<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="index.html">[UP]</a></h5>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>allocate (7)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>allocate</B>(3f) - [FORTRAN:STATEMENT] The ALLOCATE statement dynamically creates pointer targets and allocatable variables.
(LICENSE:PD)
<P>
</BLOCKQUOTE>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=7>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
<B>general</B> form:
<P>
<PRE>
    ALLOCATE ([type-spec ::] allocation-list [, alloc-opt-list])
<P>
       o      alloc-opt       is   ERRMSG = scalar_default_char_variable
                               or  MOLD = source-expr
                               or  SOURCE = source-expr
                               or  STAT = scalar_int_variable
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>USE OF DATA OBJECTS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
allocation is allocate-object [ ( allocate-shape-spec-list ) ]
[ lbracket allocate-coarray-spec rbracket ]
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
allocate-object is variable-name
or structure-component
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
allocate-shape-spec is [ lower-bound-expr : ] upper-bound-expr
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
lower-bound-expr is scalar-int-expr
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
upper-bound-expr is scalar-int-expr
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
allocate-coarray-spec is [ allocate-coshape-spec-list , ] [ lower-bound-expr : ] *
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
allocate-coshape-spec is [ lower-bound-expr : ] upper-bound-expr
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Each allocate-object shall be a nonprocedure pointer or an allocatable variable.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
If any allocate-object has a deferred type parameter, is unlimited polymorphic, or is of abstract
type, either type-spec or source-expr shall appear.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
If type-spec appears, it shall specify a type with which each allocate-object is type compatible.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
A type-param-value in a type-spec shall be an asterisk if and only if each allocate-object is a
dummy argument for which the corresponding type parameter is assumed.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
If type-spec appears, the kind type parameter values of each allocate-object shall be the same as
the corresponding type parameter values of the type-spec.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
If allocate-object is an array either allocate-shape-spec-list shall appear or source-expr shall appear
and have the same rank as allocate-object. If allocate-object is scalar, allocate-shape-spec-list shall not
appear.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
An allocate-coarray-spec shall appear if and only if the allocate-object is a coarray.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The number of allocate-shape-specs in an allocate-shape-spec-list shall be the same as the rank
of the allocate-object. The number of allocate-coshape-specs in an allocate-coarray-spec shall be one less
than the corank of the allocate-object.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
No alloc-opt shall appear more than once in a given alloc-opt-list.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
At most one of source-expr and type-spec shall appear.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Each allocate-object shall be type compatible (4.3.1.3) with source-expr . If SOURCE= appears,
source-expr shall be a scalar or have the same rank as each allocate-object.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Corresponding kind type parameters of allocate-object and source-expr shall have the same values.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
type-spec shall not specify a type that has a coarray ultimate component.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
type-spec shall not specify the type C PTR or C FUNPTR if an allocate-object is a coarray.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The declared type of source-expr shall not be C PTR or C FUNPTR if an allocate-object is a
coarray.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The declared type of source-expr shall not have a coarray ultimate component.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
An allocate-object shall not be a coindexed object.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        NOTE:
        If a coarray is of a derived type that has an allocatable component, the component shall be allocated by its
        own image:
<P>
        TYPE(SOMETHING), ALLOCATABLE :: T[:]
        &#46;&#46;&#46;
        ALLOCATE(T[*])          ! Allowed - implies synchronization
        ALLOCATE(T%AAC(N))      ! Allowed - allocated by its own image
        ALLOCATE(T[Q]%AAC(N))   ! Not allowed, because it is not
                                ! necessarily executed on image Q.
</PRE>
</BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
An allocate-object or a bound or type parameter of an allocate-object
shall not depend on the value of stat-variable, the value of
errmsg-variable, or on the value, bounds, length type parameters,
allocation status, or association status of any allocate-object in
the same ALLOCATE statement.
<P>
source-expr shall not be allocated within the ALLOCATE statement in
which it appears; nor shall it depend on the value, bounds, deferred
type parameters, allocation status, or association status of any
allocate-object in that statement.
<P>
If type-spec is specified, each allocate-object is allocated with the
specified dynamic type and type parameter values; if source-expr is
specified, each allocate-object is allocated with the dynamic type and
type parameter values of source-expr ; otherwise, each allocate-object
is allocated with its dynamic type the same as its declared type.
<P>
If type-spec appears and the value of a type parameter it specifies
differs from the value of the corresponding nondeferred type parameter
specified in the declaration of any allocate-object, an error condition
occurs. If the value of a nondeferred length type parameter of an
allocate-object differs from the value of the corresponding type
parameter of source-expr , an error condition occurs.
<P>
If a type-param-value in a type-spec in an ALLOCATE statement is
an asterisk, it denotes the current value of that assumed type
parameter. If it is an expression, subsequent redefinition or
undefinition of any entity in the expression does not affect the type
parameter value.
<P>
<PRE>
        NOTE:
        An example of an ALLOCATE statement is:
<P>
        ALLOCATE (X (N), B (-3 : M, 0:9), STAT = IERR_ALLOC)
<P>
</PRE>
</BLOCKQUOTE>
<A name=4>

     <H3>EXECUTION OF AN ALLOCATE STATEMENT</H3>

</A>
<BLOCKQUOTE>
<P>
When an ALLOCATE statement is executed for an array for which
allocate-shape-spec-list is specified, the values of the lower bound and
upper bound expressions determine the bounds of the array. Subsequent
redefinition or undefinition of any entities in the bound expressions
do not affect the array bounds. If the lower bound is omitted, the
default value is 1. If the upper bound is less than the lower bound,
the extent in that dimension is zero and the array has zero size.
<P>
When an ALLOCATE statement is executed for a coarray, the values of the
lower cobound and upper cobound expressions determine the cobounds of
the coarray. Subsequent redefinition or undefinition of any entities
in the cobound expressions do not affect the cobounds. If the lower
cobound is omitted, the default value is 1. The upper cobound shall
not be less than the lower cobound.
<P>
If an allocation specifies a coarray, its dynamic type and the values
of corresponding type parameters shall be the same on each image. The
values of corresponding bounds and corresponding cobounds shall be the
same on each image. If the coarray is a dummy argument, its ultimate
argument (12.5.2.3) shall be the same coarray on every image.
<P>
There is implicit synchronization of all images in association with
each ALLOCATE statement that allocates one or more coarrays. On each
image, execution of the segment (8.5.1) following the statement is
delayed until all other images have executed the same statement the
same number of times.
<P>
<PRE>
         NOTE:
<P>
         When an image executes an ALLOCATE statement, communication
         is not necessarily involved apart from any required for
         synchronization. The image allocates its coarray and records
         how the corresponding coarrays on other images are to be
         addressed. The processor is not required to detect violations
         of the rule that the bounds are the same on all images, nor
         is it responsible for detecting or resolving deadlock problems
         (such as two images waiting on different ALLOCATE statements).
<P>
</PRE>
If source-expr is a pointer, it shall be associated with a target. If
source-expr is allocatable, it shall be allocated.
<P>
When an ALLOCATE statement is executed for an array with no
allocate-shape-spec-list, the bounds of source-expr determine the
bounds of the array. Subsequent changes to the bounds of source-expr
do not affect the array bounds.
<P>
If SOURCE= appears, source-expr shall be conformable (2.5.6) with
allocation. If the value of a nondeferred length type parameter of
allocate-object is different from the value of the corresponding type
parameter of source-expr , an error condition occurs. On successful
allocation, if allocate-object and source-expr have the same rank the
value of allocate-object becomes that of source-expr , otherwise the
value of each element of allocate-object becomes that of source-expr .
<P>
If MOLD= appears and source-expr is a variable, its value need not be defined.
<P>
The STAT= specifier is described in 6.6.4.
<P>
If an error condition occurs during execution of an ALLOCATE statement
that does not contain the STAT= specifier, error termination is
initiated.
<P>
The ERRMSG= specifier is described in 6.6.5.
</BLOCKQUOTE>
<A name=5>

     <H3>ALLOCATION OF ALLOCATABLE VARIABLES</H3>

</A>
<BLOCKQUOTE>
<P>
The allocation status of an allocatable entity is one of the following
at any time. The status of an allocatable variable becomes allocated
if it is allocated by an ALLOCATE statement, if it is allocated during
assignment, or if it is given that status by the intrinsic subroutine
MOVE <B>ALLOC</B>(13.7.117). An allocatable variable with this status may be
referenced, defined, or deallocated; allocating it causes an error
condition in the ALLOCATE statement. The intrinsic function ALLOCATED
(13.7.11) returns true for such a variable.
<P>
<PRE>
</PRE>
allocated. The status of an allocatable variable becomes unallocated
if it is deallocated (6.6.3) or if it is given that status by the
allocation transfer procedure. An allocatable variable with this
status shall not be referenced or defined. It shall not be supplied as
an actual argument corresponding to a nonallocatable dummy argument,
except to certain intrinsic inquiry functions. It may be allocated with
the ALLOCATE statement. Deallocating it causes an error condition in
the DEALLOCATE statement. The intrinsic function ALLOCATED (13.7.11)
returns false for such a variable.
<P>
At the beginning of execution of a program, allocatable variables
are unallocated.
<P>
When the allocation status of an allocatable variable changes, the
allocation status of any associated allocatable variable changes
accordingly. Allocation of an allocatable variable establishes
values for the deferred type parameters of all associated allocatable
variables.
<P>
An unsaved allocatable local variable of a procedure has a status of
unallocated at the beginning of each invocation of the procedure. An
unsaved local variable of a construct has a status of unallocated at
the beginning of each execution of the construct.
<P>
When an object of derived type is created by an ALLOCATE statement,
any allocatable ultimate components have an allocation status of
unallocated.
</BLOCKQUOTE>
<A name=6>

     <H3>ALLOCATION OF POINTER TARGETS</H3>

</A>
<BLOCKQUOTE>
<P>
Allocation of a pointer creates an object that implicitly has the TARGET
attribute. Following successful execution of an ALLOCATE statement for
a pointer, the pointer is associated with the target and may be used
to reference or define the target. Additional pointers may become
associated with the pointer target or a part of the pointer target
by pointer assignment. It is not an error to allocate a pointer that
is already associated with a target. In this case, a new pointer
target is created as required by the attributes of the pointer and
any array bounds, type, and type parameters specified by the ALLOCATE
statement. The pointer is then associated with this new target. Any
previous association of the pointer with a target is broken. If the
previous target had been created by allocation, it becomes inaccessible
unless other pointers are associated with it. The intrinsic function
ASSOCIATED (13.7.16) may be used to determine whether a pointer that
does not have undefined association status is associated.
<P>
At the beginning of execution of a function whose result is a pointer,
the association status of the result pointer is undefined. Before such
a function returns, it shall either associate a target with this pointer
or cause the association status of this pointer to become disassociated.
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>allocate (7)</TD> <TD align=right width=33%><I>March 22, 2021</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from b5dcdb47-220d-4ba0-9900-0781dfdc02ed using man macros.</FONT>
<br><br><center><img src="images/allocate.7fortran.gif"></center>
</div>
</div>
</body>
</HTML>
Binary file (standard input) matches
