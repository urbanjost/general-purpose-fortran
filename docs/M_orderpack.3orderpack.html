<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:0.1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 0.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="index.html">[UP]</a></h5>
<button type="button" onclick="javascript:history.back()">Back</button>
-->
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>C Library Functions &nbsp;-&nbsp;</I><NOBR>M_orderpack (3)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>M_orderpack</B>(3f) - [orderpack::INTRO]General and Specialized Ranking
and Sorting Routines
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Description</A><BR>
<A HREF=#3>Sorting</A><BR>
<A HREF=#4>Ranking</A><BR>
<A HREF=#5>Unique</A><BR>
<A HREF=#6>Multiplicity</A><BR>
<A HREF=#7>Permutation</A><BR>
<A HREF=#8>Rationale</A><BR>
<A HREF=#9>Introduction</A><BR>
<A HREF=#10>Ranking Versus Sorting</A><BR>
<A HREF=#11>Ranking</A><BR>
<A HREF=#12>Optimization Choices</A><BR>
<A HREF=#13>Interface</A><BR>
<A HREF=#14>A Word Of Apology</A><BR>
<A HREF=#15>Authors</A><BR>
<A HREF=#16>Maintainers</A><BR>
<A HREF=#17>License</A><BR>
</BLOCKQUOTE>
<A name=18>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<B>Procedure</B> <I>names</I> <I>and</I> syntax:
<P>
<PRE>
    use M_orderpack, only : &
     Sort,             & ! Subroutine Sort             (INOUTVALS)
     Sort_Special,     & ! Subroutine Sort_Special     (INOUTVALS)
     Psort,            & ! Subroutine Psort            (INOUTVALS, nord)
<P>
     Rank,             & ! Subroutine Rank             (INVALS, imult)
     Rank_Basic,       & ! Subroutine Rank_Basic       (INVALS, irngt)
     Rank_Decreasing,  & ! Subroutine Rank_Decreasing  (INVALS, igoest)
     Rank_Unique,      & ! Subroutine Rank_Unique      (INVALS, irngt, nuni)
<P>
     Prank,            & ! Subroutine Prank            (INVALS, irngt, nord)
     Prank_Basic,      & ! Subroutine Prank_Basic      (INVALS, irngt, nord)
     Prank_Decreasing, & ! Subroutine Prank_Decreasing (INVALS, irngt, nord)
     Prank_Special,    & ! Subroutine Prank_Special,   (INVALS, irngt, nord)
     Prank_Unique,     & ! Subroutine Prank_Unique     (INVALS, irngt, nord)
<P>
     Median,           & ! Function Median             (INVALS)
     MedianVal,        & ! Function MedianVal          (INVALS)
     MedianLoc,        & ! Subroutine MedianLoc        (INVALS, indm)
<P>
     Orderval,         & ! Function OrderVal           (INVALS, nord)
     OrderLoc,         & ! Integer Function OrderLoc   (INVALS, nord)
     Orderval_Special, & ! Function OrderVal_Special   (INVALS, nord)
<P>
     Occurrences,      & ! Subroutine Occurrences      (INVALS, imult)
     Unique,           & ! Subroutine Unique           (INOUTVALS, nuni)
     Perturb             ! Subroutine Perturb          (INOUTVALS, CLOSENESS)
<P>
</PRE>
<B>The</B> <I>procedures</I> <I>may</I> <I>be</I> <I>accessed</I> <I>via</I> <I>their</I> <I>original</I> <I>names</I> <I>in</I> ORDERPACK2.0
<B>as</B> well, <I>one</I> <I>per</I> module:
<P>
<PRE>
    ! previous ORDERPACK2.0 name ! ORDERPACK 2.1 name
    use M_refsor, only : refsor  ! Sort
    use M_inssor, only : inssor  ! Sort_special
    use M_inspar, only : inspar  ! psort
    use M_mrgrnk, only : mrgrnk  ! rank
    use M_mrgref, only : mrgref  ! rank_basic
    use M_uniinv, only : uniinv  ! rank_decreasing
    use M_unirnk, only : unirnk  ! rank_unique
    use M_rnkpar, only : rnkpar  ! prank
    use M_refpar, only : refpar  ! prank_basic
    use M_rapknr, only : rapknr  ! prank_decreasing
    use M_rinpar, only : rinpar  ! prank_special
    use M_unipar, only : unipar  ! prank_unique
    use M_median, only : median  ! median
    use M_valmed, only : valmed  ! medianval
    use M_indmed, only : indmed  ! medianloc
    use M_valnth, only : valnth  ! orderval
    use M_indnth, only : indnth  ! orderloc
    use M_fndnth, only : fndnth  ! orderval_special
    use M_mulcnt, only : mulcnt  ! occurrences
    use M_unista, only : unista  ! unique
    use M_ctrper, only : ctrper  ! perturb
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
ORDERPACK 2.1 - Unconditional, Unique <I>and</I> Partial Ranking, Sorting,
<I>and</I> Permutation
<P>
ORDERPACK 2.1 performs both conventional sorting <I>and</I> ranking <B>as</B> well <B>as</B>
the rarer specialized ordering tasks such <B>as</B> partial sorting, partial
ranking, unique sorting, unique ranking, inverse unique ranking, <I>and</I>
more. These partial sort <I>and</I> ranking routines can greatly accelerate
many computations when users need only the M largest or smallest
elements out of a N-element vector.
<P>
All the specialized <I>procedures</I> have a range over which they far
outperform a basic sort, <I>and</I> most have a range where they dramatically
underperform. If you are not limited by memory requirements or have no
issues with runtimes the simplest solution <I>may</I> <I>be</I> just to use <B>SORT</B>(3f)
<I>and</I> <B>RANK</B>(3f).
<P>
Otherwise, your solution method <I>may</I> very well depend on the size of
the input arrays, whether the data is already close to the required
order, or how costly it is to create work arrays or an index array.
<P>
So, if you want the smallest value <I>in</I> an array call the intrinsic
<B>MINVAL</B>(3f), not <B>ORDERVAL</B>(3f).
</BLOCKQUOTE>
<A name=3>

     <H3>SORTING</H3>

</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; FULL SORTING</H4>
</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>Sort</B> </TD><TD valign=bottom>
Sorts array into ascending order (Quicksort)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Sort_Special</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Sorts array into ascending order (Insertion sort,
generally for small or nearly sorted arrays)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PARTIAL SORTING</H4>
</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>Psort</B> </TD><TD valign=bottom>
partially sorts an array
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Orderval</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Return VALUE of Nth lowest value of array
(QuickSort)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Orderval_Special</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Return Nth lowest value of an array
(Insert-sort, generally for small or nearly
sorted arrays))
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MedianVal</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
finds the median of an array
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>Median</B> </TD><TD valign=bottom>
Return median value of array. If number of elements
is even, return average of the two "medians"
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=11>

     <H3>RANKING</H3>

</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; UNCONDITIONAL RANKING</H4>
</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>Rank</B> </TD><TD valign=bottom>
ranks array (optimized merge-sort)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Rank_Basic</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ranks array (basic merge-sort)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PARTIAL RANKING</H4>
</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>Prank</B> </TD><TD valign=bottom>
partially ranks array (Optimized QuickSort)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Prank_Basic</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
partially ranks array
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Prank_Decreasing</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
partially ranks array <I>in</I> DECREASING order
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Prank_Special</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
partially ranks array (Basic Insert-Sort)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Orderloc</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Return INDEX of Nth value of array (QuickSort-like)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MedianLoc</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Returns INDEX of median value of an array.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; UNIQUE RANKING</H4>
</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Rank_Unique</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
performs a MergeSort ranking of an array,
with removal of duplicate entries.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Rank_Decreasing</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
an inverse ranking of an array,
with duplicate entries assigned the same rank.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Prank_Unique</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
partially rank an array removing duplicates
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>UNIQUE</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B><A HREF=#5>Unique</A></B> </TD><TD valign=bottom>
Removes duplicates from an array
otherwise retaining <I>original</I> order
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=6>

     <H3>MULTIPLICITY</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Occurrences</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Give the multiplicity for each array value
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=7>

     <H3>PERMUTATION</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Perturb</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
a random permutation of an array, optionally leaving
elements close to initial locations
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=8>

     <H3>RATIONALE</H3>

</A>
<BLOCKQUOTE>
<P>
While Fortran 90 <I>and</I> later variants have made life much easier for
scientific programmers than Fortran 77, the language still lacks
depth <I>in</I> public domain utilities. <B>The</B> following package, ORDERPACK
2.1, provides important but uncommon routines needed to complete the
Fortran programming environment.
</BLOCKQUOTE>
<A name=9>

     <H3>INTRODUCTION</H3>

</A>
<BLOCKQUOTE>
<P>
<B>The</B> existing fortran code base provides many conventional ranking
or sorting routines, but very few specialized ranking or sorting
routines. Specifically, we know of no other Fortran code which sorts
or ranks only a small proportion of an array (partial ordering). Such
partial ranking routines have applications <I>in</I> statistics for rapidly
computing extreme order statistics, finding nearest neighbors, <I>and</I>
other clustering operations. In addition, many applications need to
work with only the unique values <I>in</I> an array (unique ordering). Such
unique ranking routines allow users to isolate individual cases out
of a mass of discrete data. Many times the frequency of the unique
values proves interesting (e.g., empirical distributions).
<P>
ORDERPACK handles all of these ordering needs.
<P>
Also, ORDERPACK contains a partial unique ranking routine. Such a
routine would prove useful <I>in</I> finding a limited number of unique
values <I>in</I> an array.
<P>
Inversion of orderings becomes difficult when duplicates exist (not
a <I>one</I>-to-<I>one</I> relation). <B>The</B> ORDERPACK inverse ranking routine handles
this difficult case.
<P>
As an added bonus ORDERPACK provides an unusual routine which allows
user controllable partial random permutation of arrays.
<P>
ORDERPACK of course contains conventional or unconditional sorting
routines <B>as</B> well.
<P>
Finally, many Fortran sorting or ranking routines do not take advantage
of available memory <I>and</I> cache to maximize performance. <B>The</B> routines
<I>in</I> ORDERPACK have been designed to take advantage of modern machines.
</BLOCKQUOTE>
<A name=10>

     <H3>RANKING VERSUS SORTING</H3>

</A>
<BLOCKQUOTE>
<P>
Ranking consists <I>in</I> finding, for each element of a set, its order
(rank) <I>in</I> the sorted set, without effectively changing the initial
order (or disorder! ) of the set. In many instances, it better suits
the actual need of the user than sorting, <B>as</B> the ranks can then <I>be</I>
used to order other related sets or components of a user type.
<P>
Ranking is especially needed when the sizes of the elements are large,
<I>and</I> therefore moving them around is resource-consuming.
</BLOCKQUOTE>
<A name=11>

     <H3>RANKING</H3>

</A>
<BLOCKQUOTE>
<P>
In some instances, <I>one</I> is not actually interested <I>in</I> modifying the
order of the elements <I>in</I> a set, but only <I>in</I> knowing how to access them
<I>in</I> increasing -- or decreasing -- order. Ranking, <B>as</B> it is called,
provides the index array <B>I</B>(:) such <B>as</B> the set <B>S</B>(<B>I</B>(:)) is ordered. One
of the advantages of carrying out ranking rather than sorting is that
the index array can <I>be</I> computed without the performance penalty of
moving the elements around when they are of large sizes. A similar
point is that the index array can <I>be</I> used to index other data.
</BLOCKQUOTE>
<A name=12>

     <H3>OPTIMIZATION CHOICES</H3>

</A>
<BLOCKQUOTE>
<P>
We tried to take into account the recent trends <I>in</I> computing to make
our compromise choices. Of course, no two problems are the same, <I>and</I>
for some of them the following decisions <I>may</I> happen to <I>be</I> wrong. We
just hope that for most cases, they will <I>be</I> right.
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: We tried to take into account the recent trends <I>in</I> computing to make
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Make extensive use of work arrays: Memory can <I>be</I> extended,
time cannot.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Try to reduce the number of operations <I>in</I> the inner loops, even
if it increases code size.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Assume that cache size is relatively small, <I>and</I> try to maximize
cache hits.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<A name=13>

     <H3>INTERFACE</H3>

</A>
<BLOCKQUOTE>
<P>
Robust routines make <I>their</I> interface known to the calling
program. There are three main ways to implement this <I>in</I> Fortran:
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: Robust routines make <I>their</I> interface known to the calling
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Explicit interfaces, either included <I>in</I> the body of the calling
routine, or gathered <I>in</I> an &#146;interface module&#146;. An example of
including an interface block <I>in</I> the calling program can <I>be</I> found
<I>in</I> the sample program sort7.f90.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Embedding the routine of interest <B>as</B> a "contained routine" into
the calling procedure. An example of such way can <I>be</I> found <I>in</I>
the follow.f90 program, that rebuilds a curve from a set of X,
Y coordinates.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
Embedding the routine of interest into a MODULE, <I>and</I> USEing that
module <I>in</I> the procedure that calls the routine. This creates
order dependencies when compiling code, generally resulting <I>in</I>
requiring such tools <B>as</B> Makefiles but has many other benefits,
such <B>as</B> most easily allowing for generic versions of the routines,
This is the way we used here. An example of use is provided <B>as</B>
the test program tstvalnth.f90.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<A name=14>

     <H3>A WORD OF APOLOGY</H3>

</A>
<BLOCKQUOTE>
<P>
When <I>one</I> looks at the description of a sorting algorithm, the
process seems pretty simple, <I>and</I> can usually <I>be</I> held <I>in</I> 10 to 20
lines of pseudo-code. But if <I>one</I> wants an optimized program, <I>one</I>
takes this simple implementation, <I>and</I> looks for redundant operations,
investigates runs with sample data sets with a profiling tool, <I>and</I>
is led to duplicate code with slight modifications rather than use
tests <I>in</I> inner loops, to process differently the first <I>and</I> the last
iterations, or to take into account some special cases that are only
special <I>in</I> that they can <I>be</I> done faster.
<P>
In the end, the number of lines of source code <I>may</I> <I>be</I>
multiplied tenfold, <I>and</I> the readability decreased <I>in</I> a similar
proportion. Unfortunately, this is the price to pay for speed of
execution. It was that way when I started programming more than 20
years ago, <I>and</I> I have forsaken any hope that it might become otherwise
before I return to dust. So please accept my apologies that this code
is often complex <I>and</I> difficult to read.
</BLOCKQUOTE>
<A name=15>

     <H3>AUTHORS</H3>

</A>
<BLOCKQUOTE>
Michel Olagnon IFREMER Brest / <A HREF="mailto:Michel.Olagnon@ifremer.fr">Michel.Olagnon@ifremer.fr</A>
<P>
2000- 2013/11/06
</BLOCKQUOTE>
<A name=16>

     <H3>MAINTAINERS</H3>

</A>
<BLOCKQUOTE>
John S. Urban, 2022-04-16
</BLOCKQUOTE>
<A name=17>

     <H3>LICENSE</H3>

</A>
<BLOCKQUOTE>
CC0-1.0
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I>Nemo Release 3.1</I></TD> <TD width=33% align=center>M_orderpack (3)</TD> <TD align=right width=33%><I>November 11, 2022</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from 604d7b81-d304-4143-a041-29618381e031 using man macros.</FONT>
<br><br><center><img src="images/M_orderpack.3orderpack.gif"></center>
</div>
</div>
</body>
</HTML>
