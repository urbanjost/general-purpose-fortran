<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="index.html">[UP]</a></h5>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>M_strings_oop (3)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>M_strings_oop</B>(3f) - [M_strings:INTRO] OOP Fortran string module
<P>
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Description</A><BR>
<A HREF=#3>See Also</A><BR>
<A HREF=#4>Examples</A><BR>
<A HREF=#5>Author</A><BR>
<A HREF=#6>License</A><BR>
</BLOCKQUOTE>
<A name=7>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<B>use</B> <I>M_strings_oop</I>
</BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
The <B>M_strings</B>(3fm) module is a collection of Fortran procedures
that supplement the built-in intrinsic string routines. Routines
for parsing, tokenizing, changing case, substituting new strings for
substrings, locating strings with simple wildcard expressions, removing
tabs and line terminators and other string manipulations are included.
<P>
<I>M_strings_oop</I>(3fm) is a companion module that provides an OOP interface
to the M_strings module.
</BLOCKQUOTE>
<P>
<P>
<A name=3>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
There are additional routines in other GPF modules for working with
expressions (M_calculator), time strings (M_time), random strings
(M_random, M_uuid), lists (M_list), and interfacing with the C regular
expression library (M_regex).
</BLOCKQUOTE>
<A name=4>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
Each of the procedural functions in <B>M_strings</B>(3fm) includes an example
program in the corresponding <B>man</B>(1) page for the function. The
object-oriented interface does not have individual <B>man</B>(1) pages,
but is instead demonstrated using the following example program:
<P>
<PRE>
    program demo_M_strings_oop
    !
    ! This is an example using the object-oriented class/type model
    ! defined in M_strings_oop
    ! This is essentially the same functionality as the procedures
    ! combined with several Fortran intrinsics and overloaded operators
    !
    use M_strings_oop,only : string, p
    implicit none
    TYPE(string) :: str1
    TYPE(string) :: str2
    TYPE(string) :: str3
    TYPE(string) :: str4
    !==============================================================================
      write(*,*)&#146;exercise the M_STRING_OOP module interface&#146;
      ! draw a break line in the output
      write(*,*)repeat(&#146;=&#146;,78)
      write(*,*)&#146;Call methods of type(STRING)&#146;
      ! define TYPE(STRING) with constructor
      str2=string(&#146;   This  is  a  String!       &#146;)
      str4=string(&#146; a  String &#146;)
      write(*,*)repeat(&#146;=&#146;,78)
      ! print members of type
      write(*,101)&#146;str2%str is &#46;&#46;&#46;............. &#146;,str2%str
      ! same as intrinsic LEN()
      write(*,202)&#146;len &#46;&#46;&#46;..................... &#146;,str2%len()
      ! same as intrinsic INDEX()
      write(*,202)&#146;len_trim &#46;&#46;&#46;................ &#146;,str2%len_trim()
      ! same as intrinsic INDEX()
      write(*,202)&#146;index("is")&#46;&#46;&#46;.............. &#146;,str2%index("is")
      ! same as intrinsic INDEX()
      write(*,202)&#146;index("is",back=.T.) &#46;&#46;&#46;.... &#146;,str2%index("is",back=.TRUE.)
      ! output TYPE(STRING) with %str all uppercase
      write(*,101)&#146;upper &#46;&#46;&#46;................... &#146;,p(str2%upper())
      ! output TYPE(STRING) with %str all miniscule
      write(*,101)&#146;lower &#46;&#46;&#46;................... &#146;,p(str2%lower())
      ! output TYPE(STRING) with %str reversed
      write(*,101)&#146;reverse &#46;&#46;&#46;................. &#146;,p(str2%reverse())
      ! same as intrinsic ADJUSTL()
      write(*,101)&#146;adjustl &#46;&#46;&#46;................. &#146;,p(str2%adjustl())
      ! same as intrinsic ADJUSTR()
      write(*,101)&#146;adjustr &#46;&#46;&#46;................. &#146;,p(str2%adjustr())
      ! center string in current string length
      write(*,101)&#146;adjustc &#46;&#46;&#46;................. &#146;,p(str2%adjustc())
      ! center string in string length of NN
      write(*,101)&#146;adjustc(49) &#46;&#46;&#46;............. &#146;,p(str2%adjustc(49))
      ! force %str to be NN characters long
      write(*,101)&#146;lenset(49) &#46;&#46;&#46;.............. &#146;,p(str2%lenset(49))
      ! same as intrinsic TRIM()
      write(*,101)&#146;trim &#46;&#46;&#46;.................... &#146;,p(str2%trim())
      ! trim leading and trailing spaces
      write(*,101)&#146;crop &#46;&#46;&#46;.................... &#146;,p(str2%crop())
      ! calls M_strings procedure SUBSTITUTE()
      write(*,101)&#146;substitute("This","Here") .. &#146;,p(str2%substitute("This","Here"))
      ! calls M_strings procedure COMPACT()
      write(*,101)&#146;compact &#46;&#46;&#46;................. &#146;,p(str2%compact())
      write(*,101)&#146;compact("") &#46;&#46;&#46;............. &#146;,p(str2%compact(""))
      write(*,101)&#146;compact(":") &#46;&#46;&#46;............ &#146;,p(str2%compact(":"))
      ! calls M_strings procedure TRANSLITERATE()
      write(*,101)&#146;transliterate("aei","VWX") . &#146;,p(str2%transliterate("aei","VWX"))
      write(*,101)&#146;transliterate("aeiou"," ") . &#146;,p(str2%transliterate("aeiou"," "))
      write(*,101)&#146;transliterate("aeiou","") .. &#146;,p(str2%transliterate("aeiou",""))
      write(*,101)&#146;transliterate(" aeiou","") . &#146;,p(str2%transliterate(" aeiou",""))
      ! calls M_strings procedure SWITCH()
      write(*,404)&#146;chars &#46;&#46;&#46;................. . &#146;,str4%chars()
<P>
      write(*,*)repeat(&#146;=&#146;,78)
      str2%str=&#146;\t\tSome tabs\t   x\bX &#146;
      write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
      write(*,101)&#146;expand &#46;&#46;&#46;.................. &#146;,p(str2%expand())
      str2=str2%expand()
      ! calls M_strings procedure NOTABS()
      write(*,101)&#146;notabs &#46;&#46;&#46;.................. &#146;,p(str2%notabs())
      ! calls M_strings procedure NOESC()
      write(*,101)&#146;noesc &#46;&#46;&#46;................... &#146;,p(str2%noesc())
<P>
      write(*,*)repeat(&#146;=&#146;,78)
      write(*,*)&#146;Casting to numeric variables&#146;
      str3=string(&#146;   12.345678901234567e1        &#146;)
      write(*,101)&#146;str3%str &#46;&#46;&#46;................ &#146;,str3%str
      ! calls M_strings procedure STRING_TO_VALUE()
      write(*,*)&#146;int  &#46;&#46;&#46;.................... &#146;, str3%int()
      ! calls M_strings procedure STRING_TO_VALUE()
      write(*,*)&#146;real &#46;&#46;&#46;.................... &#146;, str3%real()
      ! calls M_strings procedure STRING_TO_VALUE()
      write(*,*)&#146;dble &#46;&#46;&#46;.................... &#146;, str3%dble()
<P>
      write(*,*)repeat(&#146;=&#146;,78)
      write(*,*)&#146;Matching simple globbing patterns&#146;
      str3=string(&#146;   12.345678901234567e1        &#146;)
      str3=string(&#146;Four score and seven years ago&#146;)
      write(*,101)&#146;str3%str &#46;&#46;&#46;................ &#146;,str3%str
      ! calls M_strings procedure MATCHW
      write(*,*)&#146;match("Fo*") &#46;&#46;&#46;............ &#146;, str3%match("Fo*")
      ! calls M_strings procedure MATCHW
      write(*,*)&#146;match("and") &#46;&#46;&#46;............ &#146;, str3%match("and")
      ! calls M_strings procedure MATCHW
      write(*,*)&#146;match("*and*") &#46;&#46;&#46;.......... &#146;, str3%match("*and*")
<P>
      101 format(1x,a,"[",a,"]")
      202 format(1x,a,i0)
      303 format(1x,*(l3))
      404 format(1x,a,*("[",a1,"]":))
<P>
      write(*,*)repeat(&#146;=&#146;,78)
      write(*,*)&#146;OVERLOADED OPERATORS (add and subtract,return TYPE(STRING))&#146;
      str1%str=&#146;123.456&#146;
      str2%str=&#146;AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj&#146;
      write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
      write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
      write(*,*)&#146;str1 + str2 &#46;&#46;&#46;............. &#146;,p(str1 + str2)
      ! a string that looks like a numeric value can have a value added
      write(*,*)&#146;str1 + 20000 &#46;&#46;&#46;............ &#146;,p(str1 +20000)
      write(*,*)&#146;str1 - 20.0 &#46;&#46;&#46;............. &#146;,p(str1 -20.0)
      write(*,*)&#146;str2 - "Aa" (removes ALL) .. &#146;,p(str2 - &#146;Aa&#146;)
<P>
      write(*,*)repeat(&#146;=&#146;,78)
      write(*,*)&#146;OVERLOADED OPERATORS (multiply,return TYPE(STRING))&#146;
      str1%str=&#146;AaBbCcDdEeFfGgHhIiJj&#146;
      write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
      write(*,*)&#146;str1 * 3 &#46;&#46;&#46;................ &#146;,p(str1 * 3)
<P>
      write(*,*)repeat(&#146;=&#146;,78)
      write(*,*)&#146;OVERLOADED OPERATORS (//,return TYPE(STRING))&#146;
      str1%str=&#146;String one:&#146;
      str2%str=&#146;String two:&#146;
      write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
      write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
      write(*,*)&#146;str1 // str2 &#46;&#46;&#46;............. &#146;,p(str1 // str2)
      ! numeric values are converted to strings
      write(*,*)&#146;str1 // 20000 &#46;&#46;&#46;............ &#146;,p(str1 // 20000)
      write(*,*)&#146;str1 // 20.0 &#46;&#46;&#46;............. &#146;,p(str1 // 20.0)
<P>
      write(*,*)repeat(&#146;=&#146;,78)
      write(*,*)&#146;OVERLOADED OPERATORS (logical comparisons,return logical)&#146;
      ! NOTE: comparisons are performed on the character variable members
      !       of the type(string)
      str1%str=&#146;abcdefghij&#146;
      str2%str=&#146;klmnopqrst&#146;
      write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
      write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
      write(*,*)&#146;: EQ LT GT LE GE NE&#146;
      write(*,*)&#146;compare str1 to str1&#146;
      write(*,303)str1.eq.str1  ,str1.lt.str1  ,str1.gt.str1  ,str1.le.str1 &
                 & ,str1.ge.str1  ,str1.ne.str1
      write(*,*)&#146;compare str1 to str2&#146;
      write(*,303)str1.eq.str2  ,str1.lt.str2  ,str1.gt.str2  ,str1.le.str2 &
                 & ,str1.ge.str2  ,str1.ne.str2
      write(*,*)&#146;compare str2 to str1&#146;
      write(*,303)str2.eq.str1  ,str2.lt.str1  ,str2.gt.str1  ,str2.le.str1 &
                 & ,str2.ge.str1  ,str2.ne.str1
<P>
      write(*,*)repeat(&#146;=&#146;,78)
<P>
    end program demo_M_strings_oop
<P>
</PRE>
</BLOCKQUOTE>
Expected output
<P>
<PRE>
     exercise the M_STRING_OOP module interface
     =============================================================================
     Call methods of type(STRING)
     =============================================================================
     str2%str is &#46;&#46;&#46;............. [   This  is  a  String!             ]
     len &#46;&#46;&#46;..................... 36
     len_trim &#46;&#46;&#46;................ 23
     index("is")&#46;&#46;&#46;.............. 6
     index("is",back=.T.) &#46;&#46;&#46;.... 10
     upper &#46;&#46;&#46;................... [   THIS  IS  A  STRING!             ]
     lower &#46;&#46;&#46;................... [   this  is  a  string!             ]
     reverse &#46;&#46;&#46;................. [             !gnirtS  a  si  sihT   ]
     adjustl &#46;&#46;&#46;................. [This  is  a  String!                ]
     adjustr &#46;&#46;&#46;................. [                This  is  a  String!]
     adjustc &#46;&#46;&#46;................. [        This  is  a  String!        ]
     adjustc(49) &#46;&#46;&#46;............. [              This  is  a  String!               ]
     lenset(49) &#46;&#46;&#46;.............. [   This  is  a  String!                          ]
     trim &#46;&#46;&#46;.................... [   This  is  a  String!]
     crop &#46;&#46;&#46;.................... [This  is  a  String!]
     substitute("This","Here") .. [   Here  is  a  String!             ]
     compact &#46;&#46;&#46;................. [This is a String!]
     compact("") &#46;&#46;&#46;............. [ThisisaString!]
     compact(":") &#46;&#46;&#46;............ [This:is:a:String!]
     transliterate("aei","VWX") . [   ThXs  Xs  V  StrXng!             ]
     transliterate("aeiou"," ") . [   Th s   s     Str ng!             ]
     transliterate("aeiou","") .. [   Ths  s    Strng!                 ]
     transliterate(" aeiou","") . [ThssStrng!                          ]
     chars &#46;&#46;&#46;................. . [ ][a][ ][s][t][r][i][n][g][ ]
     =============================================================================
     str2%str &#46;&#46;&#46;................ [\t\tSome tabs\t   x\bX ]
     expand &#46;&#46;&#46;.................. [         Some tabs          x   X]
     notabs &#46;&#46;&#46;.................. [                Some tabs          x    X]
     noesc &#46;&#46;&#46;................... [  Some tabs    x X]
     =============================================================================
     Casting to numeric variables
     str3%str &#46;&#46;&#46;................ [   12.345678901234567e1        ]
     int  &#46;&#46;&#46;....................          123
     real &#46;&#46;&#46;....................    123.456787
     dble &#46;&#46;&#46;....................    123.45678901234567
     =============================================================================
     Matching simple globbing patterns
     str3%str &#46;&#46;&#46;................ [Four score and seven years ago]
     match("Fo*") &#46;&#46;&#46;............  T
     match("and") &#46;&#46;&#46;............  F
     match("*and*") &#46;&#46;&#46;..........  T
     ==============================================================================
     OVERLOADED OPERATORS (add and subtract, return TYPE(STRING))
     str1%str &#46;&#46;&#46;................ [123.456]
     str2%str &#46;&#46;&#46;................ [AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj]
     str1 + str2 &#46;&#46;&#46;............. 123.456 AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj
     str1 + 20000 &#46;&#46;&#46;............ 20123.455999999998
     str1 - 20.0 &#46;&#46;&#46;............. -103.456
     str2 - "Aa" (removes ALL) .. BbCcDdEeFfGgHhIiJj BbCcDdEeFfGgHhIiJj
     =============================================================================
     OVERLOADED OPERATORS (multiply, return TYPE(STRING))
     str1%str &#46;&#46;&#46;................ [AaBbCcDdEeFfGgHhIiJj]
     str1 * 3 &#46;&#46;&#46;................ AaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJj
     =============================================================================
     OVERLOADED OPERATORS (//, return TYPE(STRING))
     str1%str &#46;&#46;&#46;................ [String one:]
     str2%str &#46;&#46;&#46;................ [String two:]
     str1 // str2 &#46;&#46;&#46;............. String one:String two:
     str1 // 20000 &#46;&#46;&#46;............ String one:20000
     str1 // 20.0 &#46;&#46;&#46;............. String one:20.0
     =============================================================================
     OVERLOADED OPERATORS (logical comparisons, return logical)
     str1%str &#46;&#46;&#46;................ [abcdefghij]
     str2%str &#46;&#46;&#46;................ [klmnopqrst]
     : EQ LT GT LE GE NE
     compare str1 to str1
     :  T  F  F  T  T  F
     compare str1 to str2
     :  F  T  F  T  F  T
     compare str2 to str1
     :  F  F  T  F  T  T
     =============================================================================
<P>
</PRE>
<BLOCKQUOTE>
Expected output
</BLOCKQUOTE>
<A name=5>

     <H3>AUTHOR</H3>

</A>
<BLOCKQUOTE>
John S. Urban
</BLOCKQUOTE>
<A name=6>

     <H3>LICENSE</H3>

</A>
<BLOCKQUOTE>
Public Domain
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>M_strings_oop (3)</TD> <TD align=right width=33%><I>March 14, 2021</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from deab1e56-e618-4780-a8e1-25dd1acaece0 using man macros.</FONT>
<br><br><center><img src="images/M_strings_oop.3m_strings.gif"></center>
</div>
</div>
</body>
</HTML>
