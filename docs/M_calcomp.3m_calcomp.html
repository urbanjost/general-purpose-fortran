<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="index.html">[UP]</a></h5>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>M_calcomp (3)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>M_calcomp</B>(3fm) - [M_calcomp::INTRO] emulate old Calcomp graphics library
(LICENSE:PD)
<P>
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Table Of Contents</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#3>Introduction</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#4>Calcomp Basic Software</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#5>Calcomp General Functional Software</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#6>Calcomp Scientific Functional Software</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#7>Applications Routines</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#8>Calcomp Code Migration Supplement</A><BR>
<A HREF=#9>Introduction</A><BR>
<A HREF=#10>Calcomp Basic Software</A><BR>
<A HREF=#11>Example</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#12>A Sample Plotting Program</A><BR>
<A HREF=#13>Calcomp General Functional Software</A><BR>
<A HREF=#14>Calcomp Scientific Functional Software</A><BR>
<A HREF=#15>Application Routines</A><BR>
<A HREF=#16>Calcomp Manpages</A><BR>
<A HREF=#17>Calcomp Setup</A><BR>
<A HREF=#18>Calcomp Supplement</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#19>Moving Existing Calcomp Code</A><BR>
<A HREF=#20>Record Of Revisions</A><BR>
<A HREF=#21>Example</A><BR>
<A HREF=#22>License</A><BR>
</BLOCKQUOTE>
<A name=23>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; THE CALCOMP GRAPHICS LIBRARY USER GUIDE</H4>
</A>
<BLOCKQUOTE>
<P>
This is an interface that closely emulates a very early de-facto
graphics standard called the "CALCOMP-compatible library" and is
generally used to interface to older utilities that support CALCOMP
interfaces, or to quickly resurrect codes that have CALCOMP calls
in them. It is not recommended for new large code development.
<P>
The CALCOMP library is a simple set of FORTRAN callable graphic routines
that allows users to quickly construct plots. It was historically
used principally to interface to purchased vendor software that often
supplied a "CALCOMP library interface", and for quick development of
codes that generated XY plots (that is right -- products often could not
produce graphics without being hooked up to the customer custom plotting
interfaces!).
<P>
Consult the supplement at the end of this guide for specific guidelines
on how to convert existing user and vendor CALCOMP code.
<P>
Revision 1.0.0: 07/01/91
</BLOCKQUOTE>
<A name=2>

     <H3>TABLE OF CONTENTS</H3>

</A>
<BLOCKQUOTE>
<P>
The following sections are available &#46;&#46;&#46;.
</BLOCKQUOTE>
<A name=9>

    <H4>&nbsp; &nbsp; INTRODUCTION</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=10>

    <H4>&nbsp; &nbsp; CALCOMP BASIC SOFTWARE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>PLOT</B> </TD><TD valign=bottom>
- Move or draw to specified point,
establish plot origin, update pen position
and terminate plotting
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PLOTS</B> </TD><TD valign=bottom>
- Initialization, specify output file unit number
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>FACTOR</B> </TD><TD valign=bottom>
- Adjusts the overall size of the plot
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>WHERE</B> </TD><TD valign=bottom>
- Returns current pen location
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NFRAME</B> </TD><TD valign=bottom>
- Ends current frame and re-origins pen position
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SYMBOL</B> </TD><TD valign=bottom>
- Plots annotation (text) and special symbols
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NUMBER</B> </TD><TD valign=bottom>
- Plot decimal equivalent of a floating point number
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SCALE</B> </TD><TD valign=bottom>
- Determine starting value and scale for an array
to be plotted on a graph
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>AXIS</B> </TD><TD valign=bottom>
- Draws an annotated linear graph axis
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LINE</B> </TD><TD valign=bottom>
- Scale and plot a set of X,Y values
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NEWPEN</B> </TD><TD valign=bottom>
- Select new pen color
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>WIDTH</B> </TD><TD valign=bottom>
- Set line thickness
</TD></TR>
<TR></TR></TABLE>Sample Plotting Program
</BLOCKQUOTE>
<A name=13>

    <H4>&nbsp; &nbsp; CALCOMP GENERAL FUNCTIONAL SOFTWARE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>CIRCL</B> </TD><TD valign=bottom>
- Draws a circle, arc, or spiral
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ELIPS</B> </TD><TD valign=bottom>
- Draws an ellipse or elliptical (or circular) arc
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>DASHL</B> </TD><TD valign=bottom>
- Draws dashed line connecting a series of data points
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>DASHP</B> </TD><TD valign=bottom>
- Draws a dashed line to a specified point
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>FIT</B> </TD><TD valign=bottom>
- Draws a curve through three points
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>GRID</B> </TD><TD valign=bottom>
- Draws a linear grid
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>POLY</B> </TD><TD valign=bottom>
- Draws an equilateral polygon
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RECT</B> </TD><TD valign=bottom>
- Draws a rectangle
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=14>

    <H4>&nbsp; &nbsp; CALCOMP SCIENTIFIC FUNCTIONAL SOFTWARE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>CURVX</B> </TD><TD valign=bottom>
- Draws a function of X over a given range
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CURVY</B> </TD><TD valign=bottom>
- Draws a function of Y over a given range
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>FLINE</B> </TD><TD valign=bottom>
- Draws a smooth curve through a set of data points
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SMOOT</B> </TD><TD valign=bottom>
- Draws a smooth curve through sequential data points
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SCALG</B> </TD><TD valign=bottom>
- Performs scaling for logarithmic plotting
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LGAXS</B> </TD><TD valign=bottom>
- Plots an annotated logarithmic axis
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LGLIN</B> </TD><TD valign=bottom>
- Draws data in either log-log or semi-log mode
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>POLAR</B> </TD><TD valign=bottom>
- Draws data points using polar coordinates
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=7>

    <H4>&nbsp; &nbsp; APPLICATIONS ROUTINES</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>CNTOUR</B> </TD><TD valign=bottom>
- Makes a contour plot
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=8>

    <H4>&nbsp; &nbsp; CALCOMP CODE MIGRATION SUPPLEMENT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=9>

     <H3>INTRODUCTION</H3>

</A>
<BLOCKQUOTE>
<P>
This user guide describes the calling sequences and arguments for the
FORTRAN-callable CALCOMP software subroutines. The routines do not
produce a device dependent CALCOMP file but rather call the <B>M_draw</B>(3f)
graphics module.
<P>
CALCOMP divides their routines into three categories:
<P>
<PRE>
    Basic, General Function, and Scientific Function.
<P>
    Differences between the implemented routines and the standard CALCOMP
    routines are:
<P>
     o All coordinate values should be greater than or equal to zero, and
       less than 100 inches. Values outside this range may result in
       unpredictable results (Negative values are possible if the
       frame coordinate origin is set first using the PLOT call).
<P>
     o The metalanguage output filename is "pdf", and uses FORTRAN
       unit 50 unless an appropriate alternate value is specified
       in the PLOTS routine call. The output filename may be specified
       using the environment variable CALCOMP_PDF.
<P>
     o A routine NFRAME is available for creating multiple frames for
       graphic devices other than pen plotters.
<P>
     o Color is supported via the NEWPEN routine
<P>
     o Line thickness is supported via the WIDTH routine
<P>
     o Frames will not plot to true inches unless specific steps are
       taken in the generation and post-processing of the plot file.
<P>
</PRE>
</BLOCKQUOTE>
Other changes may be needed in existing CALCOMP code from vendors as
CALCOMP has produced several versions of CALCOMP routines that vary in
such ways as use of CHARACTER variables versus Hollerith, the number
of parameters on SYMBOL calls, and the current pen position after a
call to SYMBOL.
<BLOCKQUOTE>
<P>
The CALCOMP subroutines were written for use with CALCOMP pen plotters
and originally worked in units of inches for the mapping of the
plot directly to the output device. There are two classes of CALCOMP
subroutines-<B>-those</B> that accept user units and scale them to inches and
those that require data to be directly in units of inches.
<P>
Table 1 lists the CALCOMP subroutines that fall into each class.
<P>
The main difference CALCOMP users will notice when using this CALCOMP
library is that when the CALCOMP subroutines were incorporated into
<B>M_DRAW</B>(3fm) the meaning of CALCOMP inches was altered to no longer mean
a physical inch but just a unit-less measure (since <B>M_DRAW</B>(3fm) uses
device-independent space and the graphics post processing procedures
produce output for a number of graphics devices, some of which have a
limited device space unlike pen plotters). THIS DIFFERENCE IS USUALLY
ONLY OF SIGNIFICANCE TO USERS TRYING TO PRODUCE PLOTS USING TRUE INCHES.
<P>
The graphics post processing procedures use the CALCOMP inches to
determine the aspect ratio of the plot, and the plot is made as large as
possible for a given device while maintaining the aspect ratio specified
by the user CALCOMP calls. A parameter called SIZE is included with
most graphics post-processor procedures which facilitates the scaling
of plots to a specific size in inches. An example program shows how to
use these parameters to get consistent frames in as close as possible
to true inches.
</BLOCKQUOTE>
<P>
TABLE 1
<P>
<PRE>
 Scaling versus Device units
<P>
  &gt;    Routines Which                    Routines Which Require
  &gt;    Perform Scaling                           Inches
  &gt; of User Data to Inches         (Data Must be Scaled to Inches)
  &gt; ______________________          _______________________________
  &gt;
  &gt;         SCALE                               PLOT
  &gt;         AXIS                                WHERE
  &gt;         LINE                                SYMBOL
  &gt;         DASHL                               NUMBER
  &gt;         FLINE                               CIRCL
  &gt;         SCALG                               ELIPS
  &gt;         LGAXS                               DASHP
  &gt;         LGLIN                               FIT
  &gt;         POLAR                               GRID
  &gt;                                             POLY
  &gt;                                             RECT
  &gt;                                             CURVX
  &gt;                                             CURVY
  &gt;                                             SMOOT
<P>
</PRE>
<A name=10>

     <H3>CALCOMP BASIC SOFTWARE</H3>

</A>
<BLOCKQUOTE>
<P>
The routines included in the CALCOMP Basic Software category are
PLOT, PLOTS, FACTOR, WHERE, SYMBOL, NUMBER, SCALE, AXIS, LINE,
WIDTH and NEWPEN. NFRAME, an enhancement, is included here because
it performs a basic function.
<P>
Usually when examining existing CALCOMP code you will find it breaks
down into two categories - that which produces XY plots and that
which does almost everything in its own high-level routines and uses
CALCOMP mostly just to draw lines with the PLOT command. Therefore
you are likely not to need to be familiar with many of the CALCOMP
routines described here.
<P>
The majority of graphic applications are intended to produce an
XY-plot. Usually the production of these graphs requires only a
combination of the routines PLOTS (initialize), SCALE, AXIS, LINE,
NFRAME and PLOT (terminate). Additional text can be added with SYMBOL,
and options such as frame borders and general line drawing might be
added with PLOT calls.
<P>
When plotting requirements cannot be satisfied by using these
subroutines, the code often calls the PLOT routine almost exclusively
( which basically draws a line or moves the pen directly in units
of inches). This is often done by vendors so that it is very easy
for them to interface to virtually any graphics library.
<P>
Two other routines are often found in programs that do not call the
higher level routines (such as the axis and contour plot routines):
follows:
<TABLE cellpadding=3><!-- tsb: Two other routines are often found in programs that do not call the
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>FACTOR</B> </TD><TD valign=bottom>
Adjusts the overall size of a plot.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>WHERE</B> </TD><TD valign=bottom>
Returns the current pen location.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=21>

     <H3>EXAMPLE</H3>

</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=12>

    <H4>&nbsp; &nbsp; A SAMPLE PLOTTING PROGRAM</H4>
</A>
<BLOCKQUOTE>
<P>
To illustrate the use of the CALCOMP routines, a sample program is
provided which will produce the graph shown below. The only assumption
made is that the 24 pairs of TIME and VOLTAGE data values are contained
in a file of 24 records.
<P>
<PRE>
   program sample
   use M_calcomp
   !  Reserve space for 24 data values plus two additional locations
   !  required by the SCALE, AXIS, and LINE subroutines.
   dimension xarray(26),yarray(26)
   !  Perform initialization.
   call plots(0.0,10.0,0.0,10.0)
   !  Read 24 pairs of TIME and VOLTAGE from an input file into two arrays
   !  with names XARRAY and YARRAY.
   read (5,25)(xarray(i),yarray(i),i=1,24)
   25    format(2f6.2)
   !  Establish a new origin one-half inch higher than the point where the
   !  pen was initially placed so that the annotation of the TIME axis will
   !  fit between the axis and the edge of the plotting surface.
   call plot(0.0,0.5,-3)
   !  Compute scale factors for use in plotting the TIME values within a
   !  five-inch plotting area.
   call scale(xarray,5.0,24,1)
   !  Compute scale factors for use in plotting the VOLTAGE data values
   !  within a six-inch plotting area (i.e., the data pairs of TIME,
   !  VOLTAGE will plot within a five-by-six inch area).
   call scale(yarray,6.0,24,1)
   !  Draw the TIME axis (5 inches long), using the scale factors computed
   !  in statement 40 to determine the milliseconds at each inch along the
   !  TIME axis.
   call axis(0.0,0.0,&#146;time in milliseconds&#146;,-20,5.0,0.0,xarray(25),xarray(26))
   !  Draw the VOLTAGE axis (6 inches long) using the scale factors
   !  computed in statement 50 to determine the voltage at each inch along
   !  the VOLTAGE axis.
   call axis(0.0,0.0,&#146;voltage&#146;,7,6.0,90.0,yarray(25),yarray(26))
   !  Plot VOLTAGE vs TIME, drawing a line between each of the 24 scaled
   !  points and a symbol X at every other point.
   call line(xarray,yarray,24,1,2,4)
   !  Plot the first line of the graph title.
   call symbol(0.5,5.6,0.21,&#146;performance test&#146;,inteq,0.0,16)
   !  Plot the second line of the graph title.
   call symbol(0.5,5.2,0.14,&#146;ref. no. 1623-46&#146;,inteq,0.0,16)
   !  Terminate the plot.
   call nframe()
   !  Close the plot file.
   CALL PLOT(0.0,00.0,999)
   !  Terminate Program execution.
   end program sample
<P>
</PRE>
</BLOCKQUOTE>
<A name=13>

     <H3>CALCOMP GENERAL FUNCTIONAL SOFTWARE</H3>

</A>
<BLOCKQUOTE>
<P>
The routines included in the CALCOMP General Functional software category
are CIRCL, DASHL, DASHP, ELIPS, FIT, GRID, POLY and
RECT. These routines call the Basic routines and should be viewed
as an extension of the Basic library rather than as a separate entity.
</BLOCKQUOTE>
<A name=14>

     <H3>CALCOMP SCIENTIFIC FUNCTIONAL SOFTWARE</H3>

</A>
<BLOCKQUOTE>
<P>
The routines included in the CALCOMP Scientific Functional software
category are CURVX, CURVY, FLINE, LGAXS, LGLIN, POLAR,
SCALG, and SMOOT. These routines call the Basic routines and
should be viewed as an extension of the Basic library.
</BLOCKQUOTE>
<A name=15>

     <H3>APPLICATION ROUTINES</H3>

</A>
<BLOCKQUOTE>
<P>
The routines included in this category draw, on a single call, complete
plots of types useful to engineers. They are not part of the software
from CALCOMP, but they do use the Basic CALCOMP subroutines.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CNTOUR</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=16>

     <H3>CALCOMP MANPAGES</H3>

</A>
<BLOCKQUOTE>
<P>
If the manpages have been installed properly, you should be able to
list all the CALCOMP-related pages by entering
<P>
<PRE>
   man -s 3m_calcomp -k .
<P>
</PRE>
There should be a directory in the source for the GPF (General Purpose
Fortran) collection that contains a collection of example CALCOMP
programs in
<P>
<PRE>
   PROGRAMS/CALCOMP
<P>
</PRE>
You can list all the manpages sorted by section using
<P>
<PRE>
   #!/bin/bash
   export MANWIDTH=80
   for NAME in $(man -s 3m_calcomp -k . |sort -k 4|awk &#146;{print $1}&#146;)
   do
      man -s 3m_calcomp $NAME |col -b
   done
<P>
</PRE>
</BLOCKQUOTE>
<A name=17>

     <H3>CALCOMP SETUP</H3>

</A>
<BLOCKQUOTE>
<P>
Since this version of a CALCOMP-compatible library uses the <B>M_draw</B>(3f)
graphic primitives, the same environment variables can be used to
select the type and size of output. For example:
<P>
<PRE>
   # where the M_draw(3f) font files are located
   export M_DRAW_FONTLIB=/usr/share/hershey
<P>
   # X11
   # set output to Poskanzer pixel map format at specified size
   export M_DRAW_DEVICE=&#146;x11&#146;
   # run a program
   demo_general
<P>
   # There are many output formats available (Adobe PDF, PostScript, SVG, &#46;&#46;&#46;)
<P>
   # POSKANZER ASCII FILES (one of the harder ones to use in this case)
   # set output to Poskanzer pixel map format at specified size
   export M_DRAW_DEVICE=&#146;p3 850 1100&#146;
   # the name of the output file
   export M_DRAW_OUTPUT=calcomp.p3
<P>
   # optionally set up the virtual size in inches of the calcomp drawing surface
   export CALCOMP_XMIN CALCOMP_XMAX CALCOMP_YMIN CALCOMP_YMAX
   CALCOMP_XMIN=0
   CALCOMP_XMAX=8.5
   CALCOMP_YMIN=0
   CALCOMP_YMAX=11
<P>
   # run a program
   demo_general
   # split pixmap file into individual drawings
    csplit -f P3. -k calcomp.p3 &#146;%^P3%&#146; &#146;/^P3/&#146; &#146;{999}&#146; 2&gt;&1 &gt;/dev/null
<P>
</PRE>
</BLOCKQUOTE>
<A name=18>

     <H3>CALCOMP SUPPLEMENT</H3>

</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=19>

    <H4>&nbsp; &nbsp; MOVING EXISTING CALCOMP CODE</H4>
</A>
<BLOCKQUOTE>
<P>
The CALCOMP plot library emulates the interface originally leased
from California Computer Products, Inc; and had been available in
a very similar form on the old CDC 7600 Super Computers. Of course,
this similarity is intentional. This library is trying to provide a
consistent programming environment wherever possible.
<P>
All of the subroutines from the 7600 version of the CALCOMP library
have been included in this version; although plots generated will
not always look exactly the same as those produced on the 7600s.
<P>
The CALCOMP library is interfaced to locally developed routines (called
primitives) which produce plots using the <B>M_DRAW</B>(3fm) module. This
allows CALCOMP-based code to generate output which can be sent to any
supported <B>M_DRAW</B>(3fm) output device.
<P>
CALCOMP is not the recommended graphics package for major new program
development.
<P>
CALCOMP is being provided to meet certain special requirements:
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: CALCOMP is being provided to meet certain special requirements:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=4%>
1.
</TD><TD>
To facilitate the migration of user code that already uses a
CALCOMP-like package to new machines.
</TD></TR>
<TR valign=top><TD width=4%>
2.
</TD><TD>
To support interfaces to non-inhouse code. Such code may
often already support a set of CALCOMP-like calls.
</TD></TR>
<TR valign=top><TD width=4%>
3.
</TD><TD>
Applications where a simple portable interface is more important
than powerful graphics capabilities.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
There are no plans to provide local enhancements to CALCOMP, and
capabilities such as high-level charting routines will
not be made available with CALCOMP. Those involved in program
conversions and development are urged to consider long-term graphics
requirements in deciding which package to use (CALCOMP or an alternative).
<P>
The CALCOMP software was initially developed to drive only CALCOMP
plotters. In general, the calls produced plots directly in inches
(A call to draw a line one unit long produced a one-inch line on
the plotter).
<P>
With the interfacing of CALCOMP to the <B>M_DRAW</B>(3f) module graphics
system (which provides the ability to obtain output on a wide range of
devices), the meaning of units in the CALCOMP library has undergone
a change. CALCOMP Inches, therefore, may not translate directly
into physical inches on a pen plotter.
<P>
Important differences exist between this CALCOMP and "standard" CALCOMP
interfaces third-party software often provides interfaces to. The format
of the following primary example program can be used as a guide as to
how to nullify the affects of these differences.
<P>
<PRE>
  DIFFERENCES FROM 7600 CALCOMP LIBRARIES
<P>
  1. For subroutines SYMBOL, AXIS, and LGAXS, the parameter used to
     specify text or title information (IBCD) has been changed to be
     type CHARACTER to be consistent with ANSI 77 FORTRAN. Data for these
     arguments should be changed to be type CHARACTER (although use of
     a Hollerith string or INTEGER array may currently work, their use is
     not recommended, and there are no plans to support this usage).
<P>
  2. For subroutine SYMBOL on the 7600s, there is a "STANDARD" call
     (used to plot a text string) and a "SPECIAL" call (used to plot a
     single symbol). To Accommodate CHARACTER data and both versions of
     the call to SYMBOL, the calling sequence was modified to have 7
     arguments. All programs being converted from the 7600
     -MUST- make this change to the call to SYMBOL.
<P>
     The new calling sequence is
<P>
           CALL SYMBOL(XPAGE,YPAGE,HEIGHT,IBCD,INTEQ,ANGLE,NCHAR)
<P>
</PRE>
<BLOCKQUOTE>
Where XPAGE, YPAGE, HEIGHT, and ANGLE are defined as on the 7600s, and the
user guide can be consulted for details of their use.
<P>
The last parameter NCHAR is used as a flag to specify whether a text string
or a single symbol is being plotted. If NCHAR is less that zero, a single
symbol is plotted regardless of the contents of IBCD. If NCHAR is equal to
or greater than zero the string in IBCD is used (FAILURE TO SPECIFY THE
PROPER VALUE FOR NCHAR, INTEQ OR IBCD WILL CAUSE ERRONEOUS RESULTS).
<P>
To use SYMBOL to plot text for titles, captions, or legends--
<P>
<PRE>
        IBCD--Contains the text string as CHARACTER data.
<P>
        INTEQ--Should be set to 999 .
               (THE ACTUAL VALUE IS NOT USED FOR ANYTHING.)
<P>
        NCHAR--Is the number of characters in IBCD.
<P>
</PRE>
For example, the following call to SYMBOL will result in the characters
<P>
<PRE>
         CHARACTER GRLBL*8
         GRLBL = &#146;TITLE 10&#146;
         CALL SYMBOL(1.0,1.0,0.14,GRLBL,999,0.0,8)
<P>
</PRE>
To use SYMBOL to plot a single symbol or character--
<P>
<PRE>
        IBCD--  A dummy CHARACTER variable or string should be used
                THE ACTUAL VALUE IS NOT USED FOR ANYTHING.)
<P>
        INTEQ--Contains the INTEGER EQUIVALENT of the desired symbol.
               If INTEQ has a value of 0 (zero) through 14, a centered
               symbol (where XPAGE and YPAGE specify the center of
               the symbol) is produced. The symbol table is unchanged
               from that on the 7600s, so the table on page 2-10 of the
               7600 CALCOMP guide is still applicable.
<P>
        NCHAR--Determines whether the pen is up or down during the move
               to XPAGE and YPAGE. (IT MUST BE NEGATIVE.)
<P>
               When NCHAR is--
<P>
                -1, the pen is UP during the move.
                -2 or less, the pen is DOWN during the move.
<P>
</PRE>
For example, the following call to SYMBOL will result in special symbol
number 5 being output with its center at XY coordinates of (1.0,1.0).
<P>
<PRE>
        CALL SYMBOL(1.0,1.0,0.14,DUMMY,5,0.0,-1)
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=4%>
3.
</TD><TD>
Because of interfacing the CALCOMP routines to the device
dependent <B>M_DRAW</B>(3fm)<B>-based</B> post-processing procedures, some limit for
the maximum plot size had to be established. For the CALCOMP
library, a plot frame is limited to a maximum size in either the
X or Y direction of 100 "CALCOMP inches". (The actual frame size
on a particular output medium is dependent on the method of post-
processing and the device selected.)
<P>
Each plot frame is usually initialized by a call to subroutine PLOT with
the third argument (IPEN) equal to <B>-2</B> or <B>-3</B>. For example,
<P>
<PRE>
          CALL PLOT(0.5,1.0,-3)
<P>
</PRE>
Says to move 0.5 inches in the X-direction and 1.0 inch in the Y-direction
before establishing a new origin. When establishing a new origin, all
offsets are included inside the frame boundary, and therefore, they are part
of the plot frame size. If any X or Y coordinate value (Plus the appropriate
offset) exceeds the 100 inch limit, results are unpredictable. In programs
where X and Y coordinate values exceed the scaling limit, a call to the
CALCOMP routine FACTOR may be used to scale down the plot size appropriately.
Each plot frame is terminated by a call to subroutine NFRAME; no additional
offset is added here.
<P>
Knowledge of the plot frame size in the X and Y directions will be needed to
scale pen plots to actual inches when the device dependent post processing
procedures are available. The following example is provided to assist in
understanding how the frame size is determined.
<P>
<PRE>
      &gt;   PROGRAM CALTEST
      &gt;   USE M_calcomp
      &gt;   CALL PLOTS()           ! perform initialization
      &gt;   CALL BORDER(8.5,11.0)  ! establish a consistent frame size
      &gt;!  Calls to generate first plot go here
      &gt;!  where all calls stay inside area established by border
      &gt;!    .
      &gt;!    .
      &gt;   CALL NFRAME()          ! terminate first plot
      &gt;   CALL BORDER(8.5,11.0)  ! establish a consistent frame size
      &gt;!  In next plot negative values up to (-1,-2) are needed
      &gt;   CALL PLOT(1.0,2.0,-3) ! establish origin for second plot
      &gt;!  To stay in the border no numbers greater than XBORDER-1 in X
      &gt;!  or YBORDER-2 can be used
      &gt;!  Calls to generate second plot go here
      &gt;!    .
      &gt;!    .
      &gt;   CALL NFRAME()          ! terminate second plot
      &gt;   CALL PLOT(0.0,0.0,999)! close the plot file
      &gt;   END PROGRAM CALTEST
      &gt;   SUBROUTINE BORDER(XBORDER,YBORDER)
      &gt;!  Must be called with same values throughout entire program
      &gt;!  or not all frames will plot to same scale.
      &gt;!  Draw a box inside of which all frames can appear
      &gt;   CALL PLOT(XBORDER,0.0,    2)
      &gt;   CALL PLOT(XBORDER,YBORDER,2)
      &gt;   CALL PLOT(0.0,    YBORDER,2)
      &gt;   CALL PLOT(0.0,    0.0,    2)
      &gt;   END SUBROUTINE BORDER
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=4%>
4.
</TD><TD>
All coordinate values (XPAGE, YPAGE for example) should be greater
than or equal to zero relative to the original frame origin.
Negative values will be clipped or might cause post-processor errors.
(Although this was not a requirement on the 7600s, it is necessary
because metafiles must contain only positive values and it would
be very inefficient to store each frame&#146;s data and then translate
all the values to positive numbers once the frame was finished and
the largest negative numbers in the frame could be identified.
<TABLE width=100% cellpadding=3><!-- tsb: All coordinate values (XPAGE, YPAGE for example) should be greater
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=4%>
6.
</TD><TD>
Subroutine PLOTS must still be the first CALCOMP subroutine called.
It performs various initialization functions and should be called
only one time per program execution. Although some of the values
are not used, they are maintained for compatibility purposes.
</TD></TR>
<TR valign=top><TD width=4%>
7.
</TD><TD>
Subroutine CNTOUR (Which was developed at the Westinghouse Research
Laboratories) is available in the CALCOMP library. The plot
produced by CNTOUR will look different from that produced on the
7600s since the legend is placed at the top of the plot. If more
that 20 contours are used, the legend could overwrite the plot.
A limit of 6.5 inches must be observed for the height parameter
(HGT).
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=20>

     <H3>RECORD OF REVISIONS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>06/24/85</B> </TD></TR><TR valign=top><TD width=4%>&nbsp;</TD><TD>
Preliminary release was made for COS.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>07/11/89</B> </TD></TR><TR valign=top><TD width=4%>&nbsp;</TD><TD>
The routine NEWPEN may be used to select color.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
    07/01/91   The first release of the documentation on UNICOS.
<P>
</PRE>
</BLOCKQUOTE>
<A name=21>

     <H3>EXAMPLE</H3>

</A>
<BLOCKQUOTE>
Sample program:
<P>
<PRE>
   program demo_M_calcomp
   use M_calcomp
   ! 07/30/69
   real              :: x(104), y(104)
   character(len=40) :: msg
   integer,parameter :: kin = 50
   equivalence(x(1),xl),(y(1),yl)
   9007 format(7(1X,F9.3),F7.1)
      call make_c_qa4()   ! create datafile
      f = 1.0
      ipn = 2
      call plots(0.0,10.0,0.0,10.0)
   !-----------------------------------------------------------------------
      open(unit=kin,file=&#146;qa4.dat&#146;,action="read")
      NEXTREAD: do
         read(kin,9001) nrec, msg
         9001 format(1X,I2,7X,A40)
         write(*,*)&#146;NREC=&#146;,nrec,&#146;MSG=&#146;,trim(msg)
         select case(adjustl(msg))
   !-----------------------------------------------------------------------
          case(&#146;DATA&#146;)
            do i = 1,nrec
               read(kin,9007) x(1),y(1),x(2),y(2),x(3),y(3),x(4),y(4)
               do j = 1,4
                  if(x(j).eq.0)then
                     if(y(j).eq.0)then
                        ipn = 3
                        cycle
                     endif
                  endif
                  call plot(x(j),y(j),ipn)
                  ipn = 2
               enddo
            enddo
   !-----------------------------------------------------------------------
          case(&#146;CIRCL&#146;)
            do i = 1,nrec
               read(kin,9007) xl,yl,tho,thf,ro,rf,di
               call circl(xl,yl,tho,thf,ro,rf,di)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;DASHL&#146;)
            do i = 1,nrec
               read(kin,9009) x(1),y(1),npts,inc
               9009 format(2(1X,F9.3),1X,I3,7X,I1)
               j1 = inc+1
               j2 = inc*npts+1-inc
               do j = j1,j2,inc
                  read(kin,9007) x(j),y(j)
               enddo
               j = j2+inc
               x(j) = 0.
               y(j) = 0.
               j = j+inc
               x(j) = 1.
               y(j) = 1.
               call dashl(x,y,npts,inc)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;DASHP&#146;)
            do i = 1,nrec
               read(kin,9007) xl,yl,d
               call dashp(xl,yl,d)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;ELIPS&#146;)
            do i = 1,nrec
               read(kin,9012) xl,yl,rma,rmi,a,th0,thf,ipen
               9012 format(7(1X,F9.3),1X,I1)
               call elips(xl,yl,rma,rmi,a,tho,thf,ipen)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;FIT&#146;)
            do i = 1,nrec
               read(kin,9007) x(1),y(1),x(2),y(2),x(3),y(3)
               call fit(x(1),y(1),x(2),y(2),x(3),y(3))
            enddo
   !-----------------------------------------------------------------------
          case(&#146;GRID&#146;)
            do i = 1,nrec
               read(kin,9014) xl,yl,dx,dy,nx,ny
               9014 format(4(1X,F9.3),2(1X,I2,7X))
               call grid(xl,yl,dx,dy,nx,ny)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;POLY&#146;)
            do i = 1,nrec
               read(kin,9007) xl,yl,sl,sn,a
               call poly(xl,yl,sl,sn,a)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;RECT&#146;)
            do i = 1,nrec
               read(kin,9021) xl,yl,h,w,a,ipen
               9021 format(5(1X,F9.3),1X,I2)
               call rect(xl,yl,h,w,a,ipen)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;SYMBOL&#146;)
            do i = 1,nrec
               read(kin,9016) xl,yl,h,msg,inc
               9016 format(3(1X,F9.3), A40,1X,I3)
               read(kin,9017) a,nc
               9017 format(1X,F9.3,1X,I2)
               if(inc.lt.0)cycle NEXTREAD
               call symbol(xl,yl,h,msg,inc,a,nc)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;1100&#146;)
            do i = 1,nrec
               read(kin,9007) xl,yl
               call plot(xl,yl,-3)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;FACTOR&#146;)
            do i = 1,nrec
               read(kin,9007) f
               call factor(f)
            enddo
   !-----------------------------------------------------------------------
          case(&#146;END&#146;)
            call factor(1.)
            call plot(20.,0.,999)
            exit NEXTREAD
   !-----------------------------------------------------------------------
          case default
            write(*,*)&#146;unknown keyword &#146;,trim(msg)
   !-----------------------------------------------------------------------
         end select
   !-----------------------------------------------------------------------
      enddo NEXTREAD
      close(unit=kin,status=&#146;delete&#146;)
   !-----------------------------------------------------------------------
   contains
<P>
   subroutine make_c_qa4()
   integer,parameter :: io=40
   open(unit=io,file=&#146;qa4.dat&#146;,action="write")
   write(io,&#146;(a)&#146;)&#146;  1                RECT&#146;
   write(io,&#146;(a)&#146;)&#146; 1.        1.        9.         7.       0.         3&#146;
   write(io,&#146;(a)&#146;)&#146;  7                SYMBOL&#146;
   write(io,&#146;(a)&#146;)&#146; 1.5       9.5       .14      SAMPLE OF GENERAL SUBROUTINES PACKAGE    999&#146;
   write(io,&#146;(a)&#146;)&#146; 0.        37&#146;
   write(io,&#146;(a)&#146;)&#146; 2.25      9.        .105     CIRCL                                    999&#146;
   write(io,&#146;(a)&#146;)&#146; 0.         6&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      9.        .105     ELIPS                                    999&#146;
   write(io,&#146;(a)&#146;)&#146; 0.         5&#146;
   write(io,&#146;(a)&#146;)&#146; 2.25      6.5       .105     FIT, DASHP                               999&#146;
   write(io,&#146;(a)&#146;)&#146; 0.        11&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      6.5       .105     POLY                                     999&#146;
   write(io,&#146;(a)&#146;)&#146; 0.         4&#146;
   write(io,&#146;(a)&#146;)&#146; 3.75      4.25      .105     GRID, DASHL                              999&#146;
   write(io,&#146;(a)&#146;)&#146; 0.        12&#146;
   write(io,&#146;(a)&#146;)&#146; 2.        1.1       .07      THE BORDER IS DRAWN WITH RECT            999&#146;
   write(io,&#146;(a)&#146;)&#146; 0.        29&#146;
   write(io,&#146;(a)&#146;)&#146;  3                CIRCL&#146;
   write(io,&#146;(a)&#146;)&#146; 3.25      8.        0.        720.      .75       .25       0.&#146;
   write(io,&#146;(a)&#146;)&#146; 3.25      8.        0.        360.      .75       .25       1.&#146;
   write(io,&#146;(a)&#146;)&#146; 3.35      8.        0.        360.      .85       .85       0.&#146;
   write(io,&#146;(a)&#146;)&#146;  6                ELIPS&#146;
   write(io,&#146;(a)&#146;)&#146; 6.5       8.        .5        .7        0.        0.        360.      3&#146;
   write(io,&#146;(a)&#146;)&#146; 6.6       8.        .6        .6        0.        0.        360.      3&#146;
   write(io,&#146;(a)&#146;)&#146; 6.7       8.        .7        .5        0.        0.        360.      3&#146;
   write(io,&#146;(a)&#146;)&#146; 6.8       8.        .8        .4        0.        0.        360.      3&#146;
   write(io,&#146;(a)&#146;)&#146; 6.9       8.        .9        .3        0.        0.        360.      3&#146;
   write(io,&#146;(a)&#146;)&#146; 7.        8.        1.        .2        0.        0.        360.      3&#146;
   write(io,&#146;(a)&#146;)&#146;  3                DATA&#146;
   write(io,&#146;(a)&#146;)&#146; 0.        0.        1.5       5.        1.5       5.5       2.375     6.&#146;
   write(io,&#146;(a)&#146;)&#146; 3.5       6.125     2.625     5.5       1.5       5.5       0.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 1.5       5.        2.625     5.        3.5       5.625     0.        0.&#146;
   write(io,&#146;(a)&#146;)&#146;  1                  DASHP&#146;
   write(io,&#146;(a)&#146;)&#146; 2.375     5.625     .1&#146;
   write(io,&#146;(a)&#146;)&#146;  1                  DATA&#146;
   write(io,&#146;(a)&#146;)&#146; 1.5       5.        1.5       5.        1.5       5.        0.       0&#146;
   write(io,&#146;(a)&#146;)&#146;  2                  DASHP&#146;
   write(io,&#146;(a)&#146;)&#146; 2.375     5.625     .1&#146;
   write(io,&#146;(a)&#146;)&#146; 2.375     6.125     .1&#146;
   write(io,&#146;(a)&#146;)&#146;  2                FIT&#146;
   write(io,&#146;(a)&#146;)&#146; 2.625     5.        2.5       5.25      2.625     5.5&#146;
   write(io,&#146;(a)&#146;)&#146; 3.5       5.625     3.375     5.875     3.5       6.125&#146;
   write(io,&#146;(a)&#146;)&#146; 10                  POLY&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       3.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       4.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       5.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       6.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       7.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       8.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       9.        0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       10.       0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       11.       0.&#146;
   write(io,&#146;(a)&#146;)&#146; 5.75      5.        .35       12.       0.&#146;
   write(io,&#146;(a)&#146;)&#146;  2                GRID&#146;
   write(io,&#146;(a)&#146;)&#146; 1.5       2.        .25       .25       24         8&#146;
   write(io,&#146;(a)&#146;)&#146; 1.51      1.99      1.5       1.         4         2&#146;
   write(io,&#146;(a)&#146;)&#146;  1                DASHL&#146;
   write(io,&#146;(a)&#146;)&#146; 1.75      2.25       11       1&#146;
   write(io,&#146;(a)&#146;)&#146; 2.5       3.75&#146;
   write(io,&#146;(a)&#146;)&#146; 2.75      3.25&#146;
   write(io,&#146;(a)&#146;)&#146; 3.        3.5&#146;
   write(io,&#146;(a)&#146;)&#146; 3.5       2.75&#146;
   write(io,&#146;(a)&#146;)&#146; 4.        2.5&#146;
   write(io,&#146;(a)&#146;)&#146; 4.25      3.25&#146;
   write(io,&#146;(a)&#146;)&#146; 5.25      2.75&#146;
   write(io,&#146;(a)&#146;)&#146; 5.5       3.75&#146;
   write(io,&#146;(a)&#146;)&#146; 6.5       2.5&#146;
   write(io,&#146;(a)&#146;)&#146; 7.25      3.5&#146;
   write(io,&#146;(a)&#146;)&#146;                    END&#146;
   close(unit=io)
   end subroutine make_c_qa4
<P>
   end program demo_M_calcomp
</PRE>
</BLOCKQUOTE>
<A name=22>

     <H3>LICENSE</H3>

</A>
<BLOCKQUOTE>
Public Domain
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>M_calcomp (3)</TD> <TD align=right width=33%><I>March 27, 2021</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from 9709b32e-80d3-47a8-b7d4-22343ceee402 using man macros.</FONT>
<br><br><center><img src="images/M_calcomp.3m_calcomp.gif"></center>
</div>
</div>
</body>
</HTML>
