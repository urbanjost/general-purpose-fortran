<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="index.html">[UP]</a></h5>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>lala (3)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>LALA</B>(3f) - [M_matrix] initialize and/or pass commands to matrix
laboratory interpreter
<B>LICENSE</B>(MIT)
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Description</A><BR>
<A HREF=#3>Options</A><BR>
<A HREF=#4>Example</A><BR>
</BLOCKQUOTE>
<A name=5>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
<B>subroutine</B> <B>lala</B>(init,cmd)
<P>
<PRE>
     integer,intent(in),optional :: init
     character(len=*),intent(in),optional :: cmd
        or
     character(len=*),intent(in),optional :: cmd(:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<B>LALA</B>(3f) is modeled on <B>MATLAB</B>(3f) (MATrix LABoratory), a FORTRAN
package developed by Argonne National Laboratories for in-house use.
It provides comprehensive vector and tensor operations in a package
which may be programmed, either through a macro language or through
execution of script files.
<P>
<B>LALA</B>(3f) Functions supported include (but are not by any means limited
to) sin, cos, tan, arcfunctions, upper triangular, lower triangular,
determinants, matrix multiplication, identity, Hilbert matrices,
eigenvalues and eigenvectors, matrix roots and products, inversion
and so on and so forth.
<P>
<B>LALA</B>() can be used
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <B>LALA</B>() can be used
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
as a stand-alone utility for working with <B>lala</B>() files and
for basic computations.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
embedded in a Fortran program, passing variables back and forth
between the calling program and the utility.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
to read configuration and data files that contain expressions
and conditionally selected values.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
for interactively inspecting data generated by the calling program.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
for creating unit tests that allow for further interactive examination.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
The HELP command describes using the interpreter.
</BLOCKQUOTE>
<A name=3>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>INIT</B> </TD><TD valign=bottom>
indicate size of scratch space to allocate and (re)initialize
LALA.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CMD</B> </TD><TD valign=bottom>
LALA <B>command</B>(s) to perform. May be CHARACTER scalar or vector
</TD></TR>
<TR></TR></TABLE>INIT and CMD cannot be combined on a single call.
<P>
The first call may be an initialization declaring the number of
doubleprecision complex values to allocate for the combined scratch
and variable storage area. This form may be repeated and reinitializes
the utility at each call. A size of zero will deallocate any allocated
storage (after which the routine cannot be called with commands until
reallocated by another call to <B>lala</B>()).
<P>
If no parameters are supplied interactive mode is entered.
<P>
If a CMD is passed and no previous initialization call was made the
scratch space will be allocated to 200000.
</BLOCKQUOTE>
<A name=4>

     <H3>EXAMPLE</H3>

</A>
<BLOCKQUOTE>
<P>
Example 1:
<P>
<PRE>
      program demo_LALA
      use M_matrix, only : lala
<P>
         write(*,&#146;(a)&#146;)&#146;optionally initialize scratch area size&#146;
         call LALA(20000)
<P>
         write(*,&#146;(a)&#146;)&#146;do some commands&#146;
         call LALA([character(len=80) :: &
         & &#146;semi;                         &#146;,&
         & &#146;a=magic(4),b=-a               &#146;,&
         & &#146;a+b;a;b                       &#146;,&
         & "display(&#146;That is all Folks!&#146;) "])
<P>
         write(*,&#146;(a)&#146;)&#146;do a single command&#146;
         call LALA(&#146;who&#146;)
<P>
         write(*,&#146;(a)&#146;)&#146;enter interactive mode&#146;
         call LALA()
<P>
         write(*,&#146;(a)&#146;)&#146;ending program&#146;
</PRE>
end program demo_LALA
<P>
Example 2:
<P>
<PRE>
   program bigmat
   use M_matrix, only : lala
      ! pass strings to LALA but do not enter interactive mode
      call lala(20000)                  ! initialize silently
      call lala( &#146;a=[1 2 3 4; 5 6 7 8]&#146;)
      call lala( [character(len=80) :: &
       & &#146;semi;lines(999999)                                    &#146;,&
       & &#146;// create a magic square and add 100 to all the values&#146;,&
       & &#146;A=magic(4),&lt;X,Y&gt;=shape(A)                             &#146;,&
       & &#146;B=A+ones(X,Y)*100                                     &#146;,&
       & &#146;// save all current values to a file                  &#146;,&
       & "save(&#146;sample.laf&#146;)                                    ",&
       & &#146;// clear all user values                              &#146;,&
       & &#146;clear                                                 &#146;,&
       & &#146;// show variable names, load values from file         &#146;,&
       & &#146;// and show again to show the variables are restored  &#146;,&
       & "who;load(&#146;sample.laf&#146;);who                            "])
   end program bigmat
<P>
</PRE>
Example 3: Sample program with custom user function
<P>
<PRE>
      program custom_user
      use M_matrix
      implicit none
      call set_usersub(lala_user)
      call lala()
      contains
      !-------------------------------------------------------------
      subroutine lala_user(a,m,n,s,t)  ! sample user routine
      ! Allows personal  Fortran  subroutines  to  be  linked  into
      ! LALA. The subroutine should have the heading
      !
      !    subroutine name(a,m,n,s,t)
      !    integer :: m,n
      !    doubleprecision a(:),s,t
      !
      ! The LALA statement Y = USER(X,s,t) results in a call to
      ! the subroutine with a copy of the matrix X stored in the
      ! argument A, its column and row dimensions in M and N,
      ! and the scalar parameters S and T stored in S and T.
      ! If S and T are omitted, they are set to 0.0. After
      ! the return, A is stored in Y. The dimensions M and
      ! N may be reset within the subroutine. The statement Y =
      ! USER(K) results in a call with M = 1, N = 1 and A(1,1) =
      ! FLOAT(K). After the subroutine has been written, it must
      ! be compiled and linked to the LALA object code within the
      ! local programming environment.
      !
      implicit none
      integer                    :: m,n
      doubleprecision            :: a(:)
      doubleprecision            :: s,t
      integer                    :: i, j, k
         write(*,*)&#146;MY ROUTINE&#146;
         write(*,*)&#146;M=&#146;,m
         write(*,*)&#146;N=&#146;,n
         write(*,*)&#146;S=&#146;,s
         write(*,*)&#146;T=&#146;,t
         k=0
         do i = 1, m
            do j = 1, n
               k=k+1
               write(*,*)i,j,a(k)
            enddo
         enddo
         k=0
         if(s.eq.0)s=1
         do i = 1, m
            do j = 1, n
               k=k+1
               a(k)=a(k)*s+t
            enddo
         enddo
      end subroutine lala_user
      end program custom_user
<P>
</PRE>
</BLOCKQUOTE>
Example inputs
<P>
<PRE>
     &gt;:avg:
<P>
     &gt;for i = 2:2:n, for j = 2:2:n, t = (a(i-1,j-1)+a(i-1,j)+a(i,j-1)+a(i,j))/4; &#46;&#46;&#46;
     &gt;a(i-1,j-1) = t; a(i,j-1) = t; a(i-1,j) = t; a(i,j) = t;
<P>
     &gt;:cdiv:
<P>
     &gt;// ======================================================
     &gt;// cdiv
     &gt;a=sqrt(random(8))
     &gt;ar = real(a); ai = imag(a); br = real(b); bi = imag(b);
     &gt;p = bi/br;
     &gt;t = (ai - p*ar)/(br + p*bi);
     &gt;cr = p*t + ar/br;
     &gt;ci = t;
     &gt;p2 = br/bi;
     &gt;t2 = (ai + p2*ar)/(bi + p2*br);
     &gt;ci2 = p2*t2 - ar/bi;
     &gt;cr2 = t2;
     &gt;s = abs(br) + abs(bi);
     &gt;ars = ar/s;
     &gt;ais = ai/s;
     &gt;brs = br/s;
     &gt;bis = bi/s;
     &gt;s = brs**2 + bis**2;
     &gt;cr3 = (ars*brs + ais*bis)/s;
     &gt;ci3 = (ais*brs - ars*bis)/s;
     &gt;[cr ci; cr2 ci2; cr3 ci3]
     &gt;// ======================================================
<P>
     &gt;:exp:
<P>
     &gt;t = 0*x + eye; s = 0*eye(x); n = 1;
     &gt;while abs(s+t-s) &gt; 0, s = s+t, t = x*t/n, n = n + 1
<P>
     &gt;:four:
     &gt; n
     &gt; pi = 4*atan(1);
     &gt; i = sqrt(-1);
     &gt; w = exp(2*pi*i/n);
     &gt; F = [];
     &gt; for k = 1:n, for j = 1:n, F(k,j) = w**((j-1)*(k-1));
     &gt; F = F/sqrt(n);
     &gt; alpha = r*pi;
     &gt; rho = exp(i*alpha);
     &gt; S = log(rho*F)/i - alpha*eye;
     &gt; serr = norm(imag(S),1);
     &gt; S = real(S);
     &gt; serr = serr + norm(S-S&#146;,1)
     &gt; S = (S + S&#146;)/2;
     &gt; ferr = norm(F-exp(i*S),1)
<P>
     &gt; :gs:
     &gt; for k = 1:n, for j = 1:k-1, d = x(k,:)*x(j,:)&#146;; x(k,:) = x(k,:) - d*x(j,:); &#46;&#46;&#46;
     &gt; end, s = norm(x(k,:)), x(k,:) = x(k,:)/s;
<P>
     &gt; :jacobi:
     &gt; [n, n] = shape(A);
     &gt; X = eye(n);
     &gt; anorm = norm(A,&#146;fro&#146;);
     &gt; cnt = 1;
     &gt; while cnt &gt; 0, &#46;&#46;&#46;
     &gt;   cnt = 0; &#46;&#46;&#46;
     &gt;   for p = 1:n-1, &#46;&#46;&#46;
     &gt;     for q = p+1:n, &#46;&#46;&#46;
     &gt;       if anorm + abs(a(p,q)) &gt; anorm, &#46;&#46;&#46;
     &gt;         cnt = cnt + 1; &#46;&#46;&#46;
     &gt;         exec(&#146;jacstep&#146;); &#46;&#46;&#46;
     &gt;       end, &#46;&#46;&#46;
     &gt;     end, &#46;&#46;&#46;
     &gt;   end, &#46;&#46;&#46;
     &gt;   display(rat(A)), &#46;&#46;&#46;
     &gt; end
<P>
     &gt; :jacstep:
<P>
     &gt; d = (a(q,q)-a(p,p))*0.5/a(p,q);
     &gt; t = 1/(abs(d)+sqrt(d*d+1));
     &gt; if d &lt; 0, t = -t; end;
     &gt; c = 1/sqrt(1+t*t);  s = t*c;
     &gt; R = eye(n); r(p,p)=c; r(q,q)=c; r(p,q)=s; r(q,p)=-s;
     &gt; X = X*R;
     &gt; A = R&#146;*A*R;
<P>
     &gt; :kron:
<P>
     &gt; //  C = Kronecker product of A and B
     &gt; [m, n] = shape(A);
     &gt; for i = 1:m, &#46;&#46;&#46;
     &gt;    ci = a(i,1)*B; &#46;&#46;&#46;
     &gt;    for j = 2:n, ci = [ci a(i,j)*B]; end &#46;&#46;&#46;
     &gt;    if i = 1, C = ci; else, C = [C; ci];
<P>
     &gt; :lanczos:
<P>
     &gt; [n,n] = shape(A);
     &gt; q1 = rand(n,1);
     &gt; ort
     &gt; alpha = []; beta = [];
     &gt; q = q1/norm(q1); r = A*q(:,1);
     &gt; for j = 1:n, exec(&#146;lanstep&#146;,0);
<P>
     &gt; :lanstep:
<P>
     &gt; alpha(j) = q(:,j)&#146;*r;
     &gt; r = r - alpha(j)*q(:,j);
     &gt; if ort &lt;&gt; 0, for k = 1:j-1, r = r - r&#146;*q(:,k)*q(:,k);
     &gt; beta(j) = norm(r);
     &gt; q(:,j+1) = r/beta(j);
     &gt; r = A*q(:,j+1) - beta(j)*q(:,j);
     &gt; if j &gt; 1, T = diag(beta(1:j-1),1); T = diag(alpha) + T + T&#146;; eig(T)
<P>
     &gt; :mgs:
<P>
     &gt; for k = 1:n, s = norm(x(k,:)), x(k,:) = x(k,:)/s; &#46;&#46;&#46;
     &gt;    for j = k+1:n, d = x(j,:)*x(k,:)&#146;; x(j,:) = x(j,:) - d*x(k,:);
<P>
     &gt; :net:
<P>
     &gt; C = [
     &gt; 1   2   15  .   .   .
     &gt; 2   1   3   .   .   .
     &gt; 3   2   4   11  .   .
     &gt; 4   3   5   .   .   .
     &gt; 5   4   6   7   .   .
     &gt; 6   5   8   .   .   .
     &gt; 7   5   9   30  .   .
     &gt; 8   6   9   10  11  .
     &gt; 9   7   8   30  .   .
     &gt; 10  8   12  30  31  34
     &gt; 11  3   8   12  13  .
     &gt; 12  10  11  34  36  .
     &gt; 13  11  14  .   .   .
     &gt; 14  13  15  16  38  .
     &gt; 15  1   14  .   .   .
     &gt; 16  14  17  20  35  37
     &gt; 17  16  18  .   .   .
     &gt; 18  17  19  .   .   .
     &gt; 19  18  20  .   .   .
     &gt; 20  16  19  21  .   .
     &gt; 21  20  22  .   .   .
     &gt; 22  21  23  .   .   .
     &gt; 23  22  24  35  .   .
     &gt; 24  23  25  39  .   .
     &gt; 25  24  .   .   .   .
     &gt; 26  27  33  39  .   .
     &gt; 27  26  32  .   .   .
     &gt; 28  29  32  .   .   .
     &gt; 29  28  30  .   .   .
     &gt; 30  7   9   10  29  .
     &gt; 31  10  32  .   .   .
     &gt; 32  27  28  31  34  .
     &gt; 33  26  34  .   .   .
     &gt; 34  10  12  32  33  35
     &gt; 35  16  23  34  36  .
     &gt; 36  12  35  38  .   .
     &gt; 37  16  38  .   .   .
     &gt; 38  14  36  37  .   .
     &gt; 39  24  26  .   .   .
     &gt; ];
     &gt; [n, m] = shape(C);
     &gt; A = 0*ones(n,n);
     &gt; for i=1:n, for j=2:m, k=c(i,j); if k&gt;0, a(i,k)=1;
     &gt; check = norm(A-A&#146;,1), if check &gt; 0, quit
     &gt; [X,D] = eig(A+eye);
     &gt; D = diag(D);  D = D(n:-1:1)
     &gt; X = X(:,n:-1:1);
     &gt; [x(:,1)/sum(x(:,1)) x(:,2) x(:,3) x(:,19)]
<P>
     &gt; :pascal:
<P>
     &gt; //Generate next Pascal matrix
     &gt; [k,k] = shape(L);
     &gt; k = k + 1;
     &gt; L(k,1:k) = [L(k-1,:) 0] + [0 L(k-1,:)];
<P>
     &gt; :pdq:
<P>
     &gt; alpha = []; beta = 0; q = []; p = p(:,1)/norm(p(:,1));
     &gt; t = A&#146;*p(:,1);
     &gt; alpha(1) = norm(t);
     &gt; q(:,1) = t/alpha(1);
     &gt; X = p(:,1)*(alpha(1)*q(:,1))&#146;
     &gt; e(1) = norm(A-X,1)
     &gt; for j = 2:r, exec(&#146;pdqstep&#146;,ip); &#46;&#46;&#46;
     &gt;    X = X + p(:,j)*(alpha(j)*q(:,j)+beta(j)*q(:,j-1))&#146;, &#46;&#46;&#46;
     &gt;    e(j) = norm(A-X,1)
<P>
     &gt; :pdqstep:
<P>
     &gt; t = A*q(:,j-1) - alpha(j-1)*p(:,j-1);
     &gt;    if ort&gt;0, for i = 1:j-1, t = t - t&#146;*p(:,i)*p(:,i);
     &gt; beta(j) = norm(t);
     &gt; p(:,j) = t/beta(j);
     &gt; t = A&#146;*p(:,j) - beta(j)*q(:,j-1);
     &gt;    if ort&gt;0, for i = 1:j-1, t = t - t&#146;*q(:,i)*q(:,i);
     &gt; alpha(j) = norm(t);
     &gt; q(:,j) = t/alpha(j);
<P>
     &gt; :pop:
<P>
     &gt; y = [ 75.995   91.972  105.711  123.203   &#46;&#46;&#46;
     &gt;      131.669  150.697  179.323  203.212]&#146;
     &gt; t = [ 1900:10:1970 ]&#146;
     &gt; t = (t - 1940*ones(t))/40;   [t y]
     &gt; n = 8;  A(:,1) = ones(t);  for j = 2:n, A(:,j) = t .* A(:,j-1);
     &gt; A
     &gt; c = A\y
<P>
     &gt; :qr:
<P>
     &gt; scale = s(m);
     &gt; sm = s(m)/scale; smm1 = s(m-1)/scale; emm1 = e(m-1)/scale;
     &gt; sl = s(l)/scale; el = e(l)/scale;
     &gt; b = ((smm1 + sm)*(smm1 - sm) + emm1**2)/2;
     &gt; c = (sm*emm1)**2;
     &gt; shift = sqrt(b**2+c); if b &lt; 0, shift = -shift;
     &gt; shift = c/(b + shift)
     &gt; f = (sl + sm)*(sl-sm) - shift
     &gt; g = sl*el
     &gt; for k = l: m-1, exec(&#146;qrstep&#146;,ip)
     &gt; e(m-1) = f
<P>
     &gt; :qrstep:
<P>
     &gt; exec(&#146;rot&#146;);
     &gt; if k &lt;&gt; l, e(k-1) = f
     &gt; f = cs*s(k) + sn*e(k)
     &gt; e(k) = cs*e(k) - sn*s(k)
     &gt; g = sn*s(k+1)
     &gt; s(k+1) = cs*s(k+1)
     &gt; exec(&#146;rot&#146;);
     &gt; s(k) = f
     &gt; f = cs*e(k) + sn*s(k+1)
     &gt; s(k+1) = -sn*e(k) + cs*s(k+1)
     &gt; g = sn*e(k+1)
     &gt; e(k+1) = cs*e(k+1)
<P>
     &gt; :rho:
<P>
     &gt; //Conductivity example.
     &gt; //Parameters ---
     &gt;    rho       //radius of cylindrical inclusion
     &gt;    n         //number of terms in solution
     &gt;    m         //number of boundary points
     &gt; //initialize operation counter
     &gt;    flop = [0 0];
     &gt; //initialize variables
     &gt;    m1 = round(m/3);   //number of points on each straight edge
     &gt;    m2 = m - m1;       //number of points with Dirichlet conditions
     &gt;    pi = 4*atan(1);
     &gt; //generate points in Cartesian coordinates
     &gt;    //right hand edge
     &gt;    for i = 1:m1, x(i) = 1; y(i) = (1-rho)*(i-1)/(m1-1);
     &gt;    //top edge
     &gt;    for i = m2+1:m, x(i) = (1-rho)*(m-i)/(m-m2-1); y(i) = 1;
     &gt;    //circular edge
     &gt;    for i = m1+1:m2, t = pi/2*(i-m1)/(m2-m1+1); &#46;&#46;&#46;
     &gt;       x(i) = 1-rho*sin(t);  y(i) = 1-rho*cos(t);
     &gt; //convert to polar coordinates
     &gt;    for i = 1:m-1, th(i) = atan(y(i)/x(i));  &#46;&#46;&#46;
     &gt;       r(i) = sqrt(x(i)**2+y(i)**2);
     &gt;    th(m) = pi/2;  r(m) = 1;
     &gt; //generate matrix
     &gt;    //Dirichlet conditions
     &gt;    for i = 1:m2, for j = 1:n, k = 2*j-1; &#46;&#46;&#46;
     &gt;       a(i,j) = r(i)**k*cos(k*th(i));
     &gt;    //Neumann conditions
     &gt;    for i = m2+1:m, for j = 1:n, k = 2*j-1; &#46;&#46;&#46;
     &gt;       a(i,j) = k*r(i)**(k-1)*sin((k-1)*th(i));
     &gt; //generate right hand side
     &gt;    for i = 1:m2, b(i) = 1;
     &gt;    for i = m2+1:m, b(i) = 0;
     &gt; //solve for coefficients
     &gt;    c = A\b
     &gt; //compute effective conductivity
     &gt;    c(2:2:n) = -c(2:2:n)
     &gt;    sigma = sum(c)
     &gt; //output total operation count
     &gt;    ops = flop(2)
<P>
     &gt; :rogers.exec:
<P>
     &gt; exec(&#146;d.boug&#146;);                // reads data
     &gt; [g,k] = shape(p);              // p is matrix of gene frequencies
     &gt; wv = ncen/sum(ncen);           // ncen contains population sizes
     &gt; pbar = wv*p;                   // weighted average of p
     &gt; p = p - ones(g,1)*pbar;        // deviations from mean
     &gt; p = sqrt(diag(wv)) * p;        // weight rows of p by sqrt of pop size
     &gt; h = diag(pbar); h = h*(eye-h); // diagonal contains binomial variance: p*(1-p)
     &gt; r = p*inv(h)*p&#146;/k;             // normalized covariance matrix
     &gt; eig(r)&#146;
<P>
     &gt; :rosser:
<P>
     &gt; A  = [
     &gt;   611.  196. -192.  407.   -8.  -52.  -49.   29.
     &gt;   196.  899.  113. -192.  -71.  -43.   -8.  -44.
     &gt;  -192.  113.  899.  196.   61.   49.    8.   52.
     &gt;   407. -192.  196.  611.    8.   44.   59.  -23.
     &gt;    -8.  -71.   61.    8.  411. -599.  208.  208.
     &gt;   -52.  -43.   49.   44. -599.  411.  208.  208.
     &gt;   -49.   -8.    8.   59.  208.  208.   99. -911.
     &gt;    29.  -44.   52.  -23.  208.  208. -911.   99.  ];
<P>
     &gt; :rot:
<P>
     &gt; // subexec rot(f,g,cs,sn)
     &gt;    rho = g; if abs(f) &gt; abs(g), rho = f;
     &gt;    cs = 1.0; sn = 0.0; z = 1.0;
     &gt;    r = norm([f g]); if rho &lt; 0, r = -r; r
     &gt;    if r &lt;&gt; 0.0, cs = f/r
     &gt;    if r &lt;&gt; 0.0, sn = g/r
     &gt;    if abs(f) &gt; abs(g), z = sn;
     &gt;    if abs(g) &gt;= abs(f), if cs &lt;&gt; 0, z = 1/cs;
     &gt;    f = r;
     &gt;    g = z;
<P>
     &gt; :rqi:
<P>
     &gt; rho = (x&#146;*A*x)
     &gt; x = (A-rho*eye)\x;
     &gt; x = x/norm(x)
<P>
     &gt; :setup:
<P>
     &gt; diary(&#146;xxx&#146;)
     &gt; !tail -f xxx &gt; /dev/tty1 &
     &gt; !tail -f xxx &gt; /dev/tty2 &
<P>
     &gt; :sigma:
<P>
     &gt; RHO = .5  M = 20  N = 10   SIGMA =  1.488934271883534
     &gt; RHO = .5  M = 40  N = 20   SIGMA =  1.488920312974229
     &gt; RHO = .5  M = 60  N = 30   SIGMA =  1.488920697912116
<P>
     &gt; :strut.laf:
<P>
     &gt; // Structure problem, Forsythe, Malcolm and Moler, p. 62
     &gt; s =  sqrt(2)/2;
     &gt; A = [
     &gt; -s  .  .  1  s   .  .  .  .  .  .  .  .  .  .  .  .
     &gt; -s  . -1  . -s   .  .  .  .  .  .  .  .  .  .  .  .
     &gt;  . -1  .  .  .   1  .  .  .  .  .  .  .  .  .  .  .
     &gt;  .  .  1  .  .   .  .  .  .  .  .  .  .  .  .  .  .
     &gt;  .  .  . -1  .   .  .  1  .  .  .  .  .  .  .  .  .
     &gt;  .  .  .  .  .   . -1  .  .  .  .  .  .  .  .  .  .
     &gt;  .  .  .  . -s -1  .  .  s  1  .  .  .   .  .  .  .
     &gt;  .  .  .  .  s   .  1  .  s  .  .  .  .  .  .  .  .
     &gt;  .  .  .  .  .   .  . -1 -s  .  .  1  s  .  .  .  .
     &gt;  .  .  .  .  .   .  .  . -s  . -1  . -s  .  .  .  .
     &gt;  .  .  .  .  .   .  .  .  . -1  .  .  .  1  .  .  .
     &gt;  .  .  .  .  .   .  .  .  .  .  1  .  .  .  .  .  .
     &gt;  .  .  .  .  .   .  .  .  .  .  . -1  .  .  .  s  .
     &gt;  .  .  .  .  .   .  .  .  .  .  .  .  .  . -1 -s  .
     &gt;  .  .  .  .  .   .  .  .  .  .  .  . -s -1  .  .  1
     &gt;  .  .  .  .  .   .  .  .  .  .  .  .  s  .  1  .  .
     &gt;  .  .  .  .  .   .  .  .  .  .  .  .  .  .  . -s -1];
     &gt; b = [
     &gt;  .  .  . 10  .   .  . 15  .  .  .  .  .  .  . 10  .]&#146;;
<P>
     &gt; :test1:
<P>
     &gt; // -----------------------------------------------------------------
     &gt; // start a new log file
     &gt; sh rm -fv log.txt
     &gt; diary(&#146;log.txt&#146;)
     &gt; // -----------------------------------------------------------------
     &gt; titles=[&#146;GNP deflator&#146;
     &gt;  &#146;GNP         &#146;
     &gt;  &#146;Unemployment&#146;
     &gt;  &#146;Armed Force &#146;
     &gt;  &#146;Population  &#146;
     &gt;  &#146;Year        &#146;
     &gt;  &#146;Employment  &#146;];
     &gt; data = &#46;&#46;&#46;
     &gt; [ 83.0  234.289  235.6  159.0  107.608  1947  60.323
     &gt;   88.5  259.426  232.5  145.6  108.632  1948  61.122
     &gt;   88.2  258.054  368.2  161.6  109.773  1949  60.171
     &gt;   89.5  284.599  335.1  165.0  110.929  1950  61.187
     &gt;   96.2  328.975  209.9  309.9  112.075  1951  63.221
     &gt;   98.1  346.999  193.2  359.4  113.270  1952  63.639
     &gt;   99.0  365.385  187.0  354.7  115.094  1953  64.989
     &gt;  100.0  363.112  357.8  335.0  116.219  1954  63.761
     &gt;  101.2  397.469  290.4  304.8  117.388  1955  66.019
     &gt;  104.6  419.180  282.2  285.7  118.734  1956  67.857
     &gt;  108.4  442.769  293.6  279.8  120.445  1957  68.169
     &gt;  110.8  444.546  468.1  263.7  121.950  1958  66.513
     &gt;  112.6  482.704  381.3  255.2  123.366  1959  68.655
     &gt;  114.2  502.601  393.1  251.4  125.368  1960  69.564
     &gt;  115.7  518.173  480.6  257.2  127.852  1961  69.331
     &gt;  116.9  554.894  400.7  282.7  130.081  1962  70.551];
     &gt; short
     &gt; X = data;
     &gt; [n,p] = shape(X)
     &gt; mu = ones(1,n)*X/n
     &gt; X = X - ones(n,1)*mu;  X = X/diag(sqrt(diag(X&#146;*X)))
     &gt; corr = X&#146;*X
     &gt; y = data(:,p); X = [ones(y) data(:,1:p-1)];
     &gt; long e
     &gt; beta = X\y
     &gt; expected = [ &#46;&#46;&#46;
     &gt;    -3.482258634594421D+03
     &gt;     1.506187227124484D-02
     &gt;    -3.581917929257409D-02
     &gt;    -2.020229803816908D-02
     &gt;    -1.033226867173703D-02
     &gt;    -5.110410565317738D-02
     &gt;     1.829151464612817D+00
     &gt; ]
     &gt; display(&#146;EXPE and BETA should be the same&#146;)
<P>
     &gt; :tryall:
<P>
     &gt; diary(&#146;log.txt&#146;)
     &gt; a=magic(8)
     &gt; n=3
     &gt; exec(&#146;avg&#146;)
     &gt; b=random(8,8)
     &gt; exec(&#146;cdiv&#146;)
     &gt; exec(&#146;exp&#146;)
     &gt; exec(&#146;four&#146;)
     &gt; exec(&#146;gs&#146;)
     &gt; exec(&#146;jacobi&#146;)
     &gt; // jacstep
     &gt; exec(&#146;kron&#146;)
     &gt; exec(&#146;lanczos&#146;)
     &gt; // lanstep
     &gt; exec(&#146;longley&#146;)
     &gt; exec(&#146;mgs&#146;)
     &gt; exec(&#146;net&#146;)
     &gt; exec(&#146;pascal&#146;)
     &gt; exec(&#146;pdq&#146;)
     &gt; // pdqstep
     &gt; exec(&#146;pop&#146;)
     &gt; exec(&#146;qr&#146;)
     &gt; // qrstep
     &gt; exec(&#146;rho&#146;)
     &gt; exec(&#146;rosser&#146;)
     &gt; // rot
     &gt; exec(&#146;rqi&#146;)
     &gt; exec(&#146;setup&#146;)
     &gt; exec(&#146;sigma&#146;)
     &gt; exec(&#146;strut.laf&#146;)
     &gt; exec(&#146;w5&#146;)
     &gt; exec(&#146;rogers.exec
     &gt; exec(&#146;rogers.load
<P>
     &gt; :w5:
<P>
     &gt; w5 = [
     &gt;         1.     1.      0.      0.      0.
     &gt;       -10.     1.      1.      0.      0.
     &gt;        40.     0.      1.      1.      0.
     &gt;       205.     0.      0.      1.      1.
     &gt;       024.     0.      0.      0.     -4.
     &gt;      ]
</PRE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>lala (3)</TD> <TD align=right width=33%><I>August 27, 2021</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from 2f767700-fa44-4d6d-8e13-ff2baec52731 using man macros.</FONT>
<br><br><center><img src="images/lala.3m_matrix.gif"></center>
</div>
</div>
</body>
</HTML>
