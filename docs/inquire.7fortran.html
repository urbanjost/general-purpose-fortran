<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:0.1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 0.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="index.html">[UP]</a></h5>
<button type="button" onclick="javascript:history.back()">Back</button>
-->
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Environments, Tables, And Troff Macros &nbsp;-&nbsp;</I><NOBR>inquire (7)</NOBR><HR></H1>
</CENTER>
<P>
<A name=21>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<P>
inquire(7f) - [FILE_INQUIRE] File inquiry statement
<P>
</BLOCKQUOTE>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=45>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
INQUIRE([UNIT=file_unit_number]|[FILE=file_name_expr],
<P>
<PRE>
        ACCESS = scalar_default_char_variable,
        ACTION = scalar_default_char_variable,
        ASYNCHRONOUS = scalar_default_char_variable,
        DIRECT = scalar_default_char_variable,
<P>
        BLANK = scalar_default_char_variable,
        DECIMAL = scalar_default_char_variable,
        DELIM = scalar_default_char_variable,
        ENCODING = scalar_default_char_variable,
        PAD = scalar_default_char_variable,
        SIGN = scalar_default_char_variable,
<P>
        ERR = label,
        IOMSG = iomsg_variable,
        IOSTAT = scalar_int_variable,
<P>
        EXIST = scalar_logical_variable,
        FORM = scalar_default_char_variable,
        FORMATTED = scalar_default_char_variable,
        ID = scalar_int_expr,
        NAME = scalar_default_char_variable,
        NAMED = scalar_logical_variable,
        NEXTREC = scalar_int_variable,
        NUMBER = scalar_int_variable,
        OPENED = scalar_logical_variable,
        PENDING = scalar_logical_variable,
        POS = scalar_int_variable,
        POSITION = scalar_default_char_variable,
        READ = scalar_default_char_variable,
        READWRITE = scalar_default_char_variable,
        RECL = scalar_int_variable,
        ROUND = scalar_default_char_variable,
        SEQUENTIAL = scalar_default_char_variable,
        SIZE = scalar_int_variable,
        STREAM = scalar_default_char_variable,
        UNFORMATTED = scalar_default_char_variable,
        WRITE = scalar_default_char_variable )
<P>
         or
<P>
        INQUIRE(IOLENGTH=scalar_int_variable) output_item_list
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
The INQUIRE statement may be used to inquire about properties of a
particular named file or of the connection to a particular unit. There
are three forms of the INQUIRE statement:
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: The INQUIRE statement may be used to inquire about properties of a
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
inquire by file, which uses the FILE= specifier
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
inquire by unit, which uses the UNIT= specifier
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
inquire by output list, which uses only the IOLENGTH= specifier.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
All specifier value assignments are performed according to the rules for
assignment statements.
<P>
For inquiry by unit, the unit specified need not exist or be connected
to a file. If it is connected to a file, the inquiry is being made about
the connection and about the file connected.
<P>
An INQUIRE statement may be executed before, while, or after a file is
connected to a unit. All values assigned by an INQUIRE statement are
those that are current at the time the statement is executed.
</BLOCKQUOTE>
<A name=3>

     <H3>ERROR PROCESSING</H3>

</A>
<BLOCKQUOTE>
<P>
If an error condition occurs during execution of an INQUIRE statement,
all of the inquiry specifier variables become undefined, except for
variables in the IOSTAT= and IOMSG= specifiers (if any).
<P>
The IOSTAT=, ERR=, and IOMSG= specifiers are described in 9.11.
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<P>
Unless constrained, the following inquiry specifiers may be used in
either of the inquire by file or inquire by unit forms of the INQUIRE
statement.
<TABLE cellpadding=3><!-- tsb: Unless constrained, the following inquiry specifiers may be used in
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
No specifier shall appear more than once in a given inquire_spec_list.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
An inquire_spec_list shall contain one FILE= specifier or one UNIT=
specifier, but not both.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
In the inquire by unit form of the INQUIRE statement, if the optional
characters UNIT= are omitted, the file_unit-number shall be the first
item in the inquire_spec_list.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
If an ID= specifier appears in an inquire_spec_list, a PENDING=
specifier shall also appear.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The label in the ERR= specifier shall be the statement label of a
branch target statement that appears in the same scoping unit as the
INQUIRE statement.
</TD></TR>
<TR></TR></TABLE>If file_unit-number identifies an internal unit, an error condition
occurs.
<P>
When a returned value of a specifier other than the NAME= specifier is
of type character, the value returned is in upper case.
<P>
The specifier that receives the returned value is a a default scalar
variable.
</BLOCKQUOTE>
<A name=5>

     <H3>INPUTS</H3>

</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=6>

     <H3>FILE</H3>

</A>
<BLOCKQUOTE>
<P>
The value of the file_name_expr in the FILE= specifier specifies the
name of the file being inquired about. The named file need not exist or
be connected to a unit. The value of the file_name_expr shall be of a
form acceptable to the processor as a file name. Any trailing blanks are
ignored. The interpretation of case is processor dependent.
</BLOCKQUOTE>
<A name=7>

     <H3>UNIT</H3>

</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=8>

     <H3>OUTPUTS</H3>

</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=9>

     <H3>ACCESS</H3>

</A>
<BLOCKQUOTE>
<P>
SEQUENTIAL if the connection is for sequential access
<TABLE cellpadding=3><!-- tsb: SEQUENTIAL if the connection is for sequential access
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
if the connection is for direct access
</TD></TR>
<TR valign=top><TD width=6% nowrap>
if the connection is for stream access.
</TD></TR>
<TR valign=top><TD colspan=2>
If there is no connection,
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=10>

     <H3>ACTION</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
the connection is for input only,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
the connection is for output only
</TD></TR>
<TR valign=top><TD colspan=2>
the connection is for both input and output.
</TD></TR>
<TR valign=top><TD colspan=2>
if there is no connection,
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=11>

     <H3>ASYNCHRONOUS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>YES</B> </TD><TD valign=bottom>
if the connection allows asynchronous input/output
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NO</B> </TD><TD valign=bottom>
if the connection does not allow asynchronous input/output.
</TD></TR>
<TR valign=top><TD colspan=2>
If there is no connection
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=12>

     <H3>BLANK</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>ZERO</B> </TD><TD valign=bottom>
blanks are interpreted as zeros on input
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NULL</B> </TD><TD valign=bottom>
blanks are interpreted as a null on input
</TD></TR>
<TR valign=top><TD colspan=2>
no connection or the connection is not for formatted
input/output
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=13>

     <H3>DECIMAL</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>COMMA</B> </TD><TD valign=bottom>
treat a comma as the separator between mantissa and decimal
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>POINT</B> </TD><TD valign=bottom>
use a decimal point as the separator
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=14>

     <H3>DELIM</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>APOSTROPHE,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
the delimiter mode in effect for a connection for
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>QUOTE,</B> </TD><TD valign=bottom>
formatted input/output.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; NONE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
no connection or the connection is not for formatted
input/output
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=15>

     <H3>DIRECT</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>YES</B> </TD><TD valign=bottom>
if DIRECT is included in the set of allowed access methods
for the file
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NO</B> </TD><TD valign=bottom>
if DIRECT is not included in the set of allowed access
methods for the file
</TD></TR>
<TR valign=top><TD colspan=2>
<B>UNKNOWN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
if the processor is unable to determine whether DIRECT is
included in the set of allowed access methods for the file.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=16>

     <H3>ENCODING</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>UTF-8</B> </TD><TD valign=bottom>
if the connection is for formatted input/output with an
encoding form of UTF-8
</TD></TR>
<TR valign=top><TD colspan=2>
the connection is for unformatted input/output.
</TD></TR>
<TR><TD colspan=2>
If there is no connection,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>UTF-8</B> </TD><TD valign=bottom>
if the processor is able to determine that the encoding
form of the file is UTF-8
</TD></TR>
<TR valign=top><TD colspan=2>
<B>UNKNOWN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
if the processor is unable to determine the encoding
form of the file
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; NOTE</H4>
</A>
<BLOCKQUOTE>
The value assigned may be something other than UTF-8, UNDEFINED,
or UNKNOWN if the processor supports other specific encoding forms
(e.g. UTF-16BE).
</BLOCKQUOTE>
<A name=17>

     <H3>EXIST</H3>

</A>
<BLOCKQUOTE>
<P>
[char46]true. if there exists a file with the specified name if inquire is by
FILE=filename statement or if by UNIT=number and the specified unit
exists.
<P>
[char46]false. otherwise, false is assigned.
</BLOCKQUOTE>
<A name=18>

     <H3>FORM</H3>

</A>
<BLOCKQUOTE>
<P>
FORMATTED if the connection is for formatted input/output, UNFORMATTED
if the connection is for unformatted input/output. UNDEFINED If there is
no connection
</BLOCKQUOTE>
<A name=19>

     <H3>FORMATTED</H3>

</A>
<BLOCKQUOTE>
<P>
YES if FORMATTED is included in the set of allowed forms for the file NO
if FORMATTED is not included in the set of allowed forms for the file
UNKNOWN if the processor is unable to determine whether FORMATTED is
included in the set of allowed forms for the file.
</BLOCKQUOTE>
<A name=20>

     <H3>ID</H3>

</A>
<BLOCKQUOTE>
<P>
The value of the expression specified in the ID= specifier shall be the
identifier of a pending data transfer operation for the specified unit.
This specifier interacts with the PENDING= specifier.
</BLOCKQUOTE>
<A name=21>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the NAME= specifier is assigned the
value of the name of the file if the file has a name; otherwise, it
becomes undefined.
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; NOTE</H4>
</A>
<BLOCKQUOTE>
If this specifier appears in an INQUIRE by file statement, its
value is not necessarily the same as the name given in the FILE=
specifier. However, the value returned shall be suitable for
use as the value of the file_name_expr in the FILE= specifier
in an OPEN statement.
<P>
The processor may return a file name qualified by a user
identification, device, directory, or other relevant information.
</BLOCKQUOTE>
<P>
The case of the characters assigned to scalar_default_char_variable is
processor dependent.
<A name=22>

     <H3>NAMED</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_logical_variable in the NAMED= specifier is assigned the
value true if the file has a name; otherwise, it is assigned the value
false.
</BLOCKQUOTE>
<A name=23>

     <H3>NEXTREC</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_int_variable in the NEXTREC= specifier is assigned the value
n + 1, where n is the record number of the last record read from or
written to the connection for direct access. If there is a connection
but no records have been read or written since the connection, the
scalar_int_variable is assigned the value 1. If there is no connection,
the connection is not for direct access, or the position is
indeterminate because of a previous error condition, the
scalar_int_variable becomes undefined. If there are pending data
transfer operations for the specified unit, the value assigned is
computed as if all the pending data transfers had already completed.
</BLOCKQUOTE>
<A name=24>

     <H3>NUMBER</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_int_variable in the NUMBER= specifier is assigned the value
of the external unit number of the unit that is connected to the file.
If there is no unit connected to the file, the value <B>-1</B> is assigned.
</BLOCKQUOTE>
<A name=25>

     <H3>OPENED</H3>

</A>
<BLOCKQUOTE>
<P>
[char46]true. if the file specified is connected to a unit .false. otherwise
</BLOCKQUOTE>
<A name=26>

     <H3>PAD</H3>

</A>
<BLOCKQUOTE>
<P>
YES, corresponding to the pad mode in effect for a connection. NO
</BLOCKQUOTE>
<A name=27>

     <H3>UNDEFINED</H3>

</A>
<BLOCKQUOTE>
<P>
If there is no connection or if the connection is not for formatted
input/output,
</BLOCKQUOTE>
<A name=28>

     <H3>PENDING</H3>

</A>
<BLOCKQUOTE>
<P>
The PENDING= specifier is used to determine whether previously pending
asynchronous data transfers are complete. A data transfer operation is
previously pending if it is pending at the beginning of execution of the
INQUIRE statement.
<P>
If an ID= specifier appears and the specified data transfer operation is
complete, then the variable specified in the PENDING= specifier is
assigned the value false and the INQUIRE statement performs the wait
operation for the specified data transfer.
<P>
If the ID= specifier is omitted and all previously pending data transfer
operations for the specified unit are complete, then the variable
specified in the PENDING= specifier is assigned the value false and the
INQUIRE statement performs wait operations for all previously pending
data transfers for the specified unit.
<P>
In all other cases, the variable specified in the PENDING= specifier is
assigned the value true and no wait operations are performed; in this
case the previously pending data transfers remain pending after the
execution of the INQUIRE statement.
<P>
<PRE>
        NOTE:
        The processor has considerable flexibility in defining when
        it considers a transfer to be complete. Any of the following
        approaches could be used:
<P>
           o The INQUIRE statement could consider an asynchronous data
             transfer to be incomplete until after
             the corresponding wait operation. In this case PENDING=
             would always return true unless there were no previously
             pending data transfers for the unit.
<P>
           o The INQUIRE statement could wait for all specified data
             transfers to complete and then always return
             false for PENDING=.
<P>
           o The INQUIRE statement could actually test the state of the
             specified data transfer operations.
<P>
</PRE>
</BLOCKQUOTE>
<A name=29>

     <H3>POS</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_int_variable in the POS= specifier is assigned the number of
the file storage unit immediately following the current position of a
file connected for stream access. If the file is positioned at its
terminal position, the variable is assigned a value one greater than the
number of the highest-numbered file storage unit in the file. If the
file is not connected for stream access or if the position of the file
is indeterminate because of previous error conditions, the variable
becomes undefined.
</BLOCKQUOTE>
<A name=30>

     <H3>POSITION</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the POSITION= specifier is assigned
the value REWIND if the connection was opened for positioning at its
initial point, APPEND if the connection was opened for positioning
before its endfile record or at its terminal point, and ASIS if the
connection was opened without changing its position. If there is no
connection or if the file is connected for direct access, the
scalar_default_char_variable is assigned the value UNDEFINED. If the
file has been repositioned since the connection, the
scalar_default_char_variable is assigned a processor-dependent value,
which shall not be REWIND unless the file is positioned at its initial
point and shall not be APPEND unless the file is positioned so that its
endfile record is the next record or at its terminal point if it has no
endfile record.
</BLOCKQUOTE>
<A name=31>

     <H3>READ</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the READ= specifier is assigned the
value YES if READ is included in the set of allowed actions for the
file, NO if READ is not included in the set of allowed actions for the
file, and UNKNOWN if the processor is unable to determine whether READ
is included in the set of allowed actions for the file.
</BLOCKQUOTE>
<A name=32>

     <H3>READWRITE</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the READWRITE= specifier is assigned
the value YES if READWRITE is included in the set of allowed actions for
the file, NO if READWRITE is not included in the set of allowed actions
for the file, and UNKNOWN if the processor is unable to determine
whether READWRITE is included in the set of allowed actions for the
file.
</BLOCKQUOTE>
<A name=33>

     <H3>RECL</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_int_variable in the RECL= specifier is assigned the value of
the record length of a connection for direct access, or the value of the
maximum record length of a connection for sequential access. If the
connection is for formatted input/output, the length is the number of
characters for all records that contain only characters of default kind.
If the connection is for unformatted input/output, the length is
measured in file storage units. If there is no connection, or if the
connection is for stream access, the scalar_int_variable becomes
undefined.
</BLOCKQUOTE>
<A name=34>

     <H3>ROUND</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the ROUND= specifier is assigned the
value UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PROCESSOR DEFINED,
corresponding to the I/O rounding mode in effect for a connection for
formatted input/output. If there is no connection or if the connection
is not for formatted input/output, the scalar_default_char_variable is
assigned the value UNDEFINED. The processor shall return the value
PROCESSOR DEFINED only if the behavior of the current I/O rounding mode
is different from that of the UP, DOWN, ZERO, NEAREST, and COMPATIBLE
modes.
</BLOCKQUOTE>
<A name=35>

     <H3>SEQUENTIAL</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the SEQUENTIAL= specifier is
assigned the value YES if SEQUENTIAL is included in the set of allowed
access methods for the file, NO if SEQUENTIAL is not included in the set
of allowed access methods for the file, and UNKNOWN if the processor is
unable to determine whether SEQUENTIAL is included in the set of allowed
access methods for the file.
</BLOCKQUOTE>
<A name=36>

     <H3>SIGN</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the SIGN= specifier is assigned the
value PLUS, SUPPRESS, or PROCESSOR DEFINED, corresponding to the sign
mode in effect for a connection for formatted input/output. If there is
no connection, or if the connection is not for formatted input/output,
the scalar_default_char_variable is assigned the value UNDEFINED.
</BLOCKQUOTE>
<A name=37>

     <H3>SIZE</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_int_variable in the SIZE= specifier is assigned the size of
the file in file storage units. If the file size cannot be determined,
the variable is assigned the value <B>-1</B>.
<P>
For a file that may be connected for stream access, the file size is the
number of the highest-numbered file storage unit in the file.
<P>
For a file that may be connected for sequential or direct access, the
file size may be different from the number of storage units implied by
the data in the records; the exact relationship is processor-dependent.
</BLOCKQUOTE>
<A name=38>

     <H3>STREAM</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the STREAM= specifier is assigned
the value YES if STREAM is included in the set of allowed access methods
for the file, NO if STREAM is not included in the set of allowed access
methods for the file, and UNKNOWN if the processor is unable to
determine whether STREAM is included in the set of allowed access
methods for the file.
</BLOCKQUOTE>
<A name=39>

     <H3>UNFORMATTED</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the UNFORMATTED= specifier is
assigned the value YES if UNFORMATTED is included in the set of allowed
forms for the file, NO if UNFORMATTED is not included in the set of
allowed forms for the file, and UNKNOWN if the processor is unable to
determine whether UNFORMATTED is included in the set of allowed forms
for the file.
</BLOCKQUOTE>
<A name=40>

     <H3>WRITE</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_default_char_variable in the WRITE= specifier is assigned the
value YES if WRITE is included in the set of allowed actions for the
file, NO if WRITE is not included in the set of allowed actions for the
file, and UNKNOWN if the processor is unable to determine whether WRITE
is included in the set of allowed actions for the file.
</BLOCKQUOTE>
<A name=41>

     <H3>INQUIRE BY OUTPUT LIST</H3>

</A>
<BLOCKQUOTE>
<P>
The scalar_int_variable in the IOLENGTH= specifier is assigned the
processor-dependent number of file storage units that would be required
to store the data of the output list in an unformatted file. The value
shall be suitable as a RECL= specifier in an OPEN statement that
connects a file for unformatted direct access when there are
input/output statements with the same input/output list.
<P>
The output list in an INQUIRE statement shall not contain any
derived-type list items that require a defined input/output procedure as
described in subclause 9.6.3. If a derived-type list item appears in the
output list, the value returned for the IOLENGTH= specifier assumes that
no defined input/output procedure will be invoked.
</BLOCKQUOTE>
<A name=43>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Examples of INQUIRE statements are:
<P>
<PRE>
         INQUIRE (IOLENGTH = IOL) A (1:N)
         INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &
            FORM = CHAR_VAR, IOSTAT = IOS)
<P>
</PRE>
</BLOCKQUOTE>
<A name=43>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Sample program:
<P>
<PRE>
    program demo_inquire
    implicit none
    integer :: lun=40
    integer :: iostat
       write(*,*)&#146;is it open or predefined?&#146;
       call print_inquire(lun,&#146;&#146;)
       write(*,*)&#146;what are the defaults?&#146;
       open(unit=lun)
       call print_inquire(lun,&#146;&#146;)
       close(unit=lun,status=&#146;delete&#146;,iostat=iostat)
    contains
    subroutine print_inquire(lun_in,filename)
<P>
    ! @(#) print_inquire(3f) print INQUIRE of file by name/number
<P>
    integer,intent(in),optional           ::  lun_in
    character(len=*),intent(in),optional  ::  filename
    integer                               ::  iostat
    character(len=256)                    ::  message
    character(len=:),allocatable          ::  filename_
    integer                               ::  lun
    ! STATUS=NEW|REPLACE|OLD|SCRATCH|UNKNOWN
    ! SEQUENTIAL | DIRECT | STREAM | UNDEFINED
    character(len=20)  ::  access        ;  namelist/inquire/access 
    character(len=20)  ::  asynchronous  ;  namelist/inquire/asynchronous                                   
    character(len=20)  ::  blank         ;  namelist/inquire/blank                                          
    character(len=20)  ::  decimal       ;  namelist/inquire/decimal                                        
    character(len=20)  ::  delim         ;  namelist/inquire/delim                                          
    character(len=20)  ::  direct        ;  namelist/inquire/direct                                         
    character(len=20)  ::  encoding      ;  namelist/inquire/encoding                                       
    !  FORMATTED   |  UNFORMATTED    
    character(len=20)  ::  form          ;  namelist/inquire/form        
    character(len=20)  ::  formatted     ;  namelist/inquire/formatted                                      
    character(len=20)  ::  unformatted   ;  namelist/inquire/unformatted                                    
    character(len=20)  ::  name          ;  namelist/inquire/name                                           
    character(len=20)  ::  pad           ;  namelist/inquire/pad                                            
    !  ASIS        |  REWIND       |  APPEND
    character(len=20)  ::  position      ;  namelist/inquire/position
    !  READ        |  WRITE        |  READWRITE
    character(len=20)  ::  action        ;  namelist/inquire/action  
    character(len=20)  ::  read          ;  namelist/inquire/read                                           
    character(len=20)  ::  readwrite     ;  namelist/inquire/readwrite                                      
    character(len=20)  ::  write         ;  namelist/inquire/write                                          
    character(len=20)  ::  round         ;  namelist/inquire/round                                          
    character(len=20)  ::  sequential    ;  namelist/inquire/sequential                                     
    character(len=20)  ::  sign          ;  namelist/inquire/sign                                           
    character(len=20)  ::  stream        ;  namelist/inquire/stream                                         
    integer            ::  id            ;  namelist/inquire/id                                             
    integer            ::  nextrec       ;  namelist/inquire/nextrec                                        
    integer            ::  number        ;  namelist/inquire/number                                         
    integer            ::  pos           ;  namelist/inquire/pos                                            
    integer            ::  recl          ;  namelist/inquire/recl                                           
    integer            ::  size          ;  namelist/inquire/size                                           
    logical            ::  exist         ;  namelist/inquire/exist                                          
    logical            ::  named         ;  namelist/inquire/named                                          
    logical            ::  opened        ;  namelist/inquire/opened                                         
    logical            ::  pending       ;  namelist/inquire/pending                                        
<P>
       if(present(filename))then
          filename_ =filename
       else
          filename_ =&#146;&#146;
       endif
       lun=merge(lun_in,-1,present(lun_in))
       ! exist, opened, and named always become defined
       ! unless an error condition occurs.
       if(filename_  == &#146;&#146;.and.lun /= -1)then
         write(*,*)&#146;*print_inquire* checking unit&#146;,lun
         inquire(unit=lun,recl=recl,nextrec=nextrec,pos=pos,size=size,      &
         & position=position,name=name,form=form,formatted=formatted,       &
         & unformatted=unformatted,access=access,sequential=sequential,     &
         & direct=direct,stream=stream,action=action,read=read,write=write, &
         & readwrite=readwrite,sign=sign,round=round,blank=blank,           &
         & decimal=decimal,delim=delim,encoding=encoding,pad=pad,           &
         & named=named,opened=opened,exist=exist,number=number,             &
    !bug & pending=pending,                                                 &
         & asynchronous=asynchronous,                                       &
         & iostat=iostat,err=999,iomsg=message)
       elseif(filename_  /= &#146;&#146;)then
         write(*,*)&#146;*print_inquire* checking file:&#146;//filename_
         inquire(file=filename_ ,recl=recl,nextrec=nextrec,pos=pos,         &
         & size=size,position=position,name=name,                           &
         & form=form,formatted=formatted,unformatted=unformatted,           &
         & access=access,sequential=sequential,direct=direct,stream=stream, &
         & action=action,read=read,write=write,readwrite=readwrite,         &
         & sign=sign,round=round,blank=blank,decimal=decimal,delim=delim,   &
         & encoding=encoding,pad=pad,named=named,opened=opened,exist=exist, &
         & number=number,pending=pending,asynchronous=asynchronous,         &
         & iostat=iostat,err=999,iomsg=message)
       else
          write(*,*)&#146;*print_inquire* must specify either filename or unit number&#146;
       endif
       write(*,nml=inquire,delim=&#146;none&#146;)
       return
    999   continue
       write(*,*)&#146;*print_inquire* bad inquire&#146;
    !  If an error condition occurs during execution of an INQUIRE  statement,
    !  all of the inquiry identifiers except iostat become undefined.
       write(*,*) &#146;*print_inquire* inquire call failed,iostat=&#146;,iostat, &
       & &#146;message=&#146;,message
    end subroutine print_inquire
    end program demo_inquire
<P>
</PRE>
</BLOCKQUOTE>
<A name=44>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<P>
BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7),
PRINT(7), READ(7), REWIND(7), WAIT(7), WRITE(7)
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I>Nemo Release 3.1</I></TD> <TD width=33% align=center>inquire (7)</TD> <TD align=right width=33%><I>February 23, 2025</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from e60c1933-cbd7-4152-a7ed-e6b5001fcb99 using man macros.</FONT>
<br><br><center><img src="images/inquire.7fortran.gif"></center>
</div>
</div>
</body>
</HTML>
