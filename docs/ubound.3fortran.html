<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:0.1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 0.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="index.html">[UP]</a></h5>
<button type="button" onclick="javascript:history.back()">Back</button>
-->
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>C Library Functions &nbsp;-&nbsp;</I><NOBR>ubound (3)</NOBR><HR></H1>
</CENTER>
<P>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<P>
UBOUND(3) - [ARRAY:INQUIRY] Upper dimension bounds of an array
<P>
</BLOCKQUOTE>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
result = ubound(array [,dim] [,kind] )
<P>
<PRE>
         elemental TYPE(kind=KIND) function ubound(array,dim,kind)
<P>
          TYPE(kind=KIND),intent(in)           :: array
          integer(kind=**),intent(in),optional :: dim
          integer(kind=**),intent(in),optional :: kind
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>CHARACTERISTICS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
ARRAY shall be assumed-rank or an array, of any type. It cannot be
an unallocated allocatable array or a pointer that is not
associated.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
DIM shall be a scalar integer. The corresponding actual argument
shall not be an optional dummy argument, a disassociated pointer, or
an unallocated allocatable.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND an integer initialization expression indicating the kind
parameter of the result.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The return value is of type integer and of kind KIND. If KIND is
absent, the return value is of default integer kind. The result is
scalar if DIM is present; otherwise, the result is an array of rank
one and size n, where n is the rank of ARRAY.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
a kind designated as ** may be any supported kind for the type
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
UBOUND(3) returns the upper bounds of an array, or a single upper bound
along the DIM dimension.
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
ARRAY : The assumed-rank or array of any type whose upper bounds are
to be determined. If allocatable it must be allocated; if a pointer
it must be associated. If an assumed-size array, DIM must be
present.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
DIM : a specific dimension of ARRAY to determine the bounds of. If
DIM is absent, the result is an array of the upper bounds of ARRAY.
DIM is required if ARRAY is an assumed-size array, and in that case
must be less than or equal to the rank of ARRAY.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND : indicates the kind parameter of the result. If absent, an
integer of the default kind is returned.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>RESULT</H3>

</A>
<BLOCKQUOTE>
<P>
The return value is of type integer and of kind KIND. If KIND is absent,
the return value is of default integer kind.
<P>
If DIM is absent, the result is an array of the upper bounds of each
dimension of the ARRAY.
<P>
If DIM is present, the result is a scalar corresponding to the upper
bound of the array along that dimension.
<P>
If ARRAY is an expression rather than a whole array or array structure
component, or if it has a zero extent along the relevant dimension, the
upper bound is taken to be the number of elements along the relevant
dimension.
<P>
NOTE1 If ARRAY is assumed-rank and has rank zero, DIM cannot be present
since it cannot satisfy the requirement 1 &lt;= DIM &lt;= 0.
</BLOCKQUOTE>
<A name=6>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Note this function should not be used on assumed-size arrays or in any
function without an explicit interface. Errors can occur if there is no
interface defined.
<P>
Sample program
<P>
<PRE>
    ! program demo_ubound
    module m2_bounds
    implicit none
<P>
    contains
<P>
    subroutine msub(arr)
    !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array
    integer,intent(in) :: arr(:)
       write(*,*)&#146;MSUB: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
    end subroutine msub
<P>
    end module m2_bounds
    !
    program demo_ubound
    use m2_bounds, only : msub
    implicit none
    interface
       subroutine esub(arr)
       integer,intent(in) :: arr(:)
       end subroutine esub
    end interface
    integer :: arr(-10:10)
       write(*,*)&#146;MAIN: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
       call csub()
       call msub(arr)
       call esub(arr)
    contains
    subroutine csub
       write(*,*)&#146;CSUB: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
    end subroutine csub
<P>
    end
<P>
    subroutine esub(arr)
    implicit none
    integer,intent(in) :: arr(:)
       ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE
       ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)
       write(*,*)&#146;ESUB: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
    end subroutine esub
    !end program demo_ubound
<P>
</PRE>
Results:
<P>
<PRE>
     &gt;  MAIN: LOWER=         -10 UPPER=          10 SIZE=          21
     &gt;  CSUB: LOWER=         -10 UPPER=          10 SIZE=          21
     &gt;  MSUB: LOWER=           1 UPPER=          21 SIZE=          21
     &gt;  ESUB: LOWER=           1 UPPER=          21 SIZE=          21
<P>
</PRE>
</BLOCKQUOTE>
<A name=7>

     <H3>STANDARD</H3>

</A>
<BLOCKQUOTE>
<P>
Fortran 95 , with KIND argument Fortran 2003
</BLOCKQUOTE>
<A name=8>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<P>
Array inquiry:
<TABLE cellpadding=3><!-- tsb: Array inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SIZE(3) - Determine the size of an array
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
RANK(3) - Rank of a data object
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SHAPE(3) - Determine the shape of an array
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
LBOUND(3) - Lower dimension bounds of an array
</TD></TR>
<TR></TR></TABLE>CO_UBOUND(3), CO_LBOUND(3)
<P>
State Inquiry:
<TABLE cellpadding=3><!-- tsb: State Inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
ALLOCATED(3) - Status of an allocatable entity
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
IS_CONTIGUOUS(3) - Test if object is contiguous
</TD></TR>
<TR></TR></TABLE>Kind Inquiry:
<TABLE cellpadding=3><!-- tsb: Kind Inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND(3) - Kind of an entity
</TD></TR>
<TR></TR></TABLE>Bit Inquiry:
<TABLE cellpadding=3><!-- tsb: Bit Inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
STORAGE_SIZE(3) - Storage size in bits
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
BIT_SIZE(3) - Bit size inquiry function
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
BTEST(3) - Tests a bit of an integer value.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
LBOUND(3),
</TD></TR>
<TR></TR></TABLE>Fortran intrinsic descriptions (license: MIT) @urbanjost
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I>Nemo Release 3.1</I></TD> <TD width=33% align=center>ubound (3)</TD> <TD align=right width=33%><I>December 14, 2024</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from b5a732ee-adb0-466c-a9fc-46e4de904f5b using man macros.</FONT>
<br><br><center><img src="images/ubound.3fortran.gif"></center>
</div>
</div>
</body>
</HTML>
