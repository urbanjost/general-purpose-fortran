<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:0.1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 0.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="index.html">[UP]</a></h5>
<button type="button" onclick="javascript:history.back()">Back</button>
-->
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>C Library Functions &nbsp;-&nbsp;</I><NOBR>count (3)</NOBR><HR></H1>
</CENTER>
<P>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<P>
COUNT(3) - [ARRAY:REDUCTION] Count true values in an array
<P>
</BLOCKQUOTE>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
result = count(mask [,dim] [,kind] )
<P>
<PRE>
         integer(kind=KIND) function count(mask, dim, KIND )
<P>
          logical(kind=**),intent(in) :: mask(..)
          integer(kind=**),intent(in),optional :: dim
          integer(kind=**),intent(in),optional :: KIND
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>CHARACTERISTICS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
a kind designated as ** may be any supported kind for the type
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
MASK is a logical array of any shape and kind.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
If DIM is present, the result is an array with the specified rank
removed.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND is a scalar integer constant expression valid as an integer
kind
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The return value is of default integer type unless KIND is specified
to declare the kind of the result.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
COUNT(3) counts the number of .true. elements in a logical MASK, or, if
the DIM argument is supplied, counts the number of elements along each
row of the array in the DIM direction. If the array has zero size or all
of the elements of MASK are false, then the result is 0.
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
MASK : an array to count the number of .true. values in
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
DIM : specifies to remove this dimension from the result and produce
an array of counts of .true. values along the removed dimension. If
not present, the result is a scalar count of the true elements in
MASK the value must be in the range 1 &lt;= dim &lt;= n, where n is the
rank(number of dimensions) of MASK.
<P>
The corresponding actual argument shall not be an optional dummy
argument, a disassociated pointer, or an unallocated allocatable.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND : An integer initialization expression indicating the kind
parameter of the result.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>RESULT</H3>

</A>
<BLOCKQUOTE>
<P>
The return value is the number of .true. values in MASK if DIM is not
present.
<P>
If DIM is present, the result is an array with a rank one less than the
rank of the input array MASK, and a size corresponding to the shape of
ARRAY with the DIM dimension removed, with the remaining elements
containing the number of .true. elements along the removed dimension.
</BLOCKQUOTE>
<A name=6>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Sample program:
<P>
<PRE>
    program demo_count
    implicit none
    character(len=*),parameter :: ints=&#146;(*(i2,1x))&#146;
    ! two arrays and a mask all with the same shape
    integer, dimension(2,3) :: a, b
    logical, dimension(2,3) :: mymask
    integer :: i
    integer :: c(2,3,4)
<P>
    print *,&#146;the numeric arrays we will compare&#146;
    a = reshape( [ 1, 2, 3, 4, 5, 6 ], [ 2, 3 ])
    b = reshape( [ 0, 7, 3, 4, 5, 8 ], [ 2, 3 ])
    c = reshape( [( i,i=1,24)], [ 2, 3 ,4])
    print &#146;(3i3)&#146;, a(1,:)
    print &#146;(3i3)&#146;, a(2,:)
    print *
    print &#146;(3i3)&#146;, b(1,:)
    print &#146;(3i3)&#146;, b(2,:)
    !
    ! basic calls
    print *, &#146;count a few basic things creating a mask from an expression&#146;
    print *, &#146;count a&gt;b&#146;,count(a&gt;b)
    print *, &#146;count b&lt;a&#146;,count(a&lt;b)
    print *, &#146;count b==a&#146;,count(a==b)
    print *, &#146;check sum = &#146;,count(a&gt;b) + &
                          & count(a&lt;b) + &
                          & count(a==b).eq.size(a)
    !
    ! The common usage is just getting a count, but if you want
    ! to specify the DIM argument and get back reduced arrays
    ! of counts this is easier to visualize if we look at a mask.
    print *, &#146;make a mask identifying unequal elements &#46;&#46;&#46;&#146;
    mymask = a.ne.b
    print *, &#146;the mask generated from a.ne.b&#146;
    print &#146;(3l3)&#146;, mymask(1,:)
    print &#146;(3l3)&#146;, mymask(2,:)
    !
    print *,&#146;count total and along rows and columns &#46;&#46;&#46;&#146;
    !
    print &#146;(a)&#146;, &#146;number of elements not equal&#146;
    print &#146;(a)&#146;, &#146;(ie. total true elements in the mask)&#146;
    print &#146;(3i3)&#146;, count(mymask)
    !
    print &#146;(a)&#146;, &#146;count of elements not equal in each column&#146;
    print &#146;(a)&#146;, &#146;(ie. total true elements in each column)&#146;
    print &#146;(3i3)&#146;, count(mymask, dim=1)
    !
    print &#146;(a)&#146;, &#146;count of elements not equal in each row&#146;
    print &#146;(a)&#146;, &#146;(ie. total true elements in each row)&#146;
    print &#146;(3i3)&#146;, count(mymask, dim=2)
    !
    ! working with rank=3 &#46;&#46;&#46;
    print *, &#146;lets try this with c(2,3,4)&#146;
    print *,&#146;  taking the result of the modulo   &#146;
    print *,&#146;   z=1      z=2      z=3      z=4   &#146;
    print *,&#146;  1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |&#146;
    print *,&#146;  2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |&#146;
    print *,&#146;                                    &#146;
    print *,&#146;  would result in the mask ..       &#146;
    print *,&#146;  F F T || F F F || F T F || F F F |&#146;
    print *,&#146;  F F F || F T F || F F F || T F F |&#146;
    print *,&#146;                                    &#146;
    print *,&#146; the total number of .true.values is&#146;
    print ints, count(modulo(c,5).eq.0)
    call printi(&#146;counting up along a row and removing rows&#146;,&
    count(modulo(c,5).eq.0,dim=1))
    call printi(&#146;counting up along a column and removing columns&#146;,&
    count(modulo(c,5).eq.0,dim=2))
    call printi(&#146;counting up along a depth and removing depths&#146;,&
    count(modulo(c,5).eq.0,dim=3))
    !
    contains
    !
    ! CONVENIENCE ROUTINE FOR PRINTING SMALL INTEGER MATRICES
    subroutine printi(title,arr)
    implicit none
    !
    !@(#) print small 2d integer arrays in row-column format
    !
    character(len=*),parameter :: all=&#146;(*(g0,1x))&#146; ! a handy format
    character(len=*),intent(in)  :: title
    integer,intent(in)           :: arr(:,:)
    integer                      :: i
    character(len=:),allocatable :: biggest
       !
       print all
       print all, trim(title),&#146;:(&#146;,shape(arr),&#146;)&#146;  ! print title
       biggest=&#146;           &#146;  ! make buffer to write integer into
       ! find how many characters to use for integers
       write(biggest,&#146;(i0)&#146;)ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2
       ! use this format to write a row
       biggest=&#146;(" &gt; [",*(i&#146;//trim(biggest)//&#146;:,","))&#146;
       ! print one row of array at a time
       do i=1,size(arr,dim=1)
          write(*,fmt=biggest,advance=&#146;no&#146;)arr(i,:)
          write(*,&#146;(" ]")&#146;)
       enddo
       !
    end subroutine printi
    end program demo_count
<P>
</PRE>
Results:
<P>
<PRE>
     &gt;   the numeric arrays we will compare
     &gt;    1  3  5
     &gt;    2  4  6
     &gt;
     &gt;    0  3  5
     &gt;    7  4  8
     &gt;   count a few basic things creating a mask from an expression
     &gt;   count a&gt;b           1
     &gt;   count b&lt;a           2
     &gt;   count b==a           3
     &gt;   check sum =  T
     &gt;   make a mask identifying unequal elements &#46;&#46;&#46;
     &gt;   the mask generated from a.ne.b
     &gt;    T  F  F
     &gt;    T  F  T
     &gt;   count total and along rows and columns &#46;&#46;&#46;
     &gt;  number of elements not equal
     &gt;  (ie. total true elements in the mask)
     &gt;    3
     &gt;  count of elements not equal in each column
     &gt;  (ie. total true elements in each column)
     &gt;    2  0  1
     &gt;  count of elements not equal in each row
     &gt;  (ie. total true elements in each row)
     &gt;    1  2
     &gt;   lets try this with c(2,3,4)
     &gt;     taking the result of the modulo
     &gt;      z=1      z=2      z=3      z=4
     &gt;     1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |
     &gt;     2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |
     &gt;
     &gt;     would result in the mask ..
     &gt;     F F T || F F F || F T F || F F F |
     &gt;     F F F || F T F || F F F || T F F |
     &gt;
     &gt;    the total number of .true.values is
     &gt;   4
     &gt;
     &gt;  counting up along a row and removing rows :( 3 4 )
     &gt;   &gt; [ 0, 0, 0, 1 ]
     &gt;   &gt; [ 0, 1, 1, 0 ]
     &gt;   &gt; [ 1, 0, 0, 0 ]
     &gt;
     &gt;  counting up along a column and removing columns :( 2 4 )
     &gt;   &gt; [ 1, 0, 1, 0 ]
     &gt;   &gt; [ 0, 1, 0, 1 ]
     &gt;
     &gt;  counting up along a depth and removing depths :( 2 3 )
     &gt;   &gt; [ 0, 1, 1 ]
     &gt;   &gt; [ 1, 1, 0 ]
<P>
</PRE>
</BLOCKQUOTE>
<A name=7>

     <H3>STANDARD</H3>

</A>
<BLOCKQUOTE>
<P>
Fortran 95 , with KIND argument - Fortran 2003
</BLOCKQUOTE>
<A name=8>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
ANY(3)
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
ALL(3)
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SUM(3)
</TD></TR>
<TR></TR></TABLE>Fortran intrinsic descriptions (license: MIT) @urbanjost
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I>Nemo Release 3.1</I></TD> <TD width=33% align=center>count (3)</TD> <TD align=right width=33%><I>November 24, 2024</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from 4e3edbbd-5a76-4ebc-8fc7-0d72eb2bb2ae using man macros.</FONT>
<br><br><center><img src="images/count.3fortran.gif"></center>
</div>
</div>
</body>
</HTML>
