<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:0.1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 0.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="index.html">[UP]</a></h5>
<button type="button" onclick="javascript:history.back()">Back</button>
-->
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>C Library Functions &nbsp;-&nbsp;</I><NOBR>count (3)</NOBR><HR></H1>
</CENTER>
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <H1><HR><I>C Library Functions &nbsp;-&nbsp;</I><NOBR>count (3)</NOBR><HR></H1>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B></B><B>count</B>(3fortran) </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<B>count</B>(3fortran)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>COUNT(3) </B>- [ARRAY:REDUCTION] Count true values in an array
<B>
</B></BLOCKQUOTE>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<PRE>
result = <B>count</B>(mask [,<I>dim</I>] [,<I>kind</I>] )
<P>
           integer(kind=KIND) function count(mask, dim, KIND )
<P>
            logical(kind=**),intent(in) :: mask(..)
            integer(kind=**),intent(in),optional :: dim
            integer(kind=**),intent(in),optional :: KIND
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>CHARACTERISTICS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
a <I>kind</I> designated as ** may be any supported <I>kind</I> for the type
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
MASK is a logical array of any shape and <I>kind</I>.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
If DIM is present, the result is an array with the specified rank
removed.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND is a scalar integer constant expression valid as an integer <I>kind</I>
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The return value is of default integer type unless KIND is specified to
declare the <I>kind</I> of the result.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<B>COUNT</B>(3) counts the number of .true. elements in a logical MASK, or, if the
DIM argument is supplied, counts the number of elements along each row of
the array in the DIM direction. If the array has zero size or all of the
elements of MASK are false, then the result is 0.
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
MASK : an array to count the number of .true. values in
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
DIM : specifies to remove this dimension from the result and produce an
array of counts of .true. values along the removed dimension. If not
present, the result is a scalar count of the true elements in MASK the
value must be in the range 1 &lt;= <I>dim</I> &lt;= n, where n is the <B>rank</B>(number of
dimensions) of MASK.
<P>
The corresponding actual argument shall not be an optional dummy
argument, a disassociated pointer, or an unallocated allocatable.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND : An integer initialization expression indicating the <I>kind</I> parameter
of the result.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>RESULT</H3>

</A>
<BLOCKQUOTE>
The return value is the number of .true. values in MASK if DIM is not
present.
<P>
If DIM is present, the result is an array with a rank one less than the rank
of the input array MASK, and a size corresponding to the shape of ARRAY with
the DIM dimension removed, with the remaining elements containing the number
of .true. elements along the removed dimension.
</BLOCKQUOTE>
<A name=6>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
Sample program:
<P>
<PRE>
      program demo_count
      implicit none
      character(len=*),parameter :: ints=&#146;(*(i2,1x))&#146;
      ! two arrays and a mask all with the same shape
      integer, dimension(2,3) :: a, b
      logical, dimension(2,3) :: mymask
      integer :: i
      integer :: c(2,3,4)
<P>
         print *,&#146;the numeric arrays we will compare&#146;
         a = reshape( [ 1, 2, 3, 4, 5, 6 ], [ 2, 3 ])
         b = reshape( [ 0, 7, 3, 4, 5, 8 ], [ 2, 3 ])
         c = reshape( [( i,i=1,24)], [ 2, 3 ,4])
         print &#146;(3i3)&#146;, a(1,:)
         print &#146;(3i3)&#146;, a(2,:)
         print *
         print &#146;(3i3)&#146;, b(1,:)
         print &#146;(3i3)&#146;, b(2,:)
<P>
</PRE>
<BLOCKQUOTE>
! basic calls
print *, &#146;count a few basic things creating a mask from an expression&#146;
print *, &#146;count <B>a&gt;b&#146;,count</B>(a&gt;b)
print *, &#146;count <B>b&lt;a&#146;,count</B>(a&lt;b)
print *, &#146;count <B>b==a&#146;,count</B>(a==b)
print *, &#146;check sum = &#146;,<B>count</B>(a&gt;b) + &
& <B>count</B>(a&lt;b) + &
& <B>count</B>(a==b).eq.size(a)
<BLOCKQUOTE>
<P>
! The common usage is just getting a count, but if you want
! to specify the DIM argument and get back reduced arrays
! of counts this is easier to visualize if we look at a mask.
print *, &#146;make a mask identifying unequal elements &#46;&#46;&#46;&#146;
mymask = a.ne.b
print *, &#146;the mask generated from a.ne.b&#146;
print &#146;(3l3)&#146;, <B>mymask</B>(1,:)
print &#146;(3l3)&#146;, <B>mymask</B>(2,:)
<P>
print *,&#146;count total and along rows and columns &#46;&#46;&#46;&#146;
<P>
print &#146;(a)&#146;, &#146;number of elements not equal&#146;
print &#146;(a)&#146;, &#146;(ie. total true elements in the mask)&#146;
print &#146;(3i3)&#146;, <B>count</B>(mymask)
<P>
print &#146;(a)&#146;, &#146;count of elements not equal in each column&#146;
print &#146;(a)&#146;, &#146;(ie. total true elements in each column)&#146;
print &#146;(3i3)&#146;, <B>count</B>(mymask, <I>dim</I>=1)
<P>
print &#146;(a)&#146;, &#146;count of elements not equal in each row&#146;
print &#146;(a)&#146;, &#146;(ie. total true elements in each row)&#146;
print &#146;(3i3)&#146;, <B>count</B>(mymask, <I>dim</I>=2)
<P>
! working with rank=3 &#46;&#46;&#46;
print *, &#146;lets try this with <B>c</B>(2,3,4)&#146;
<TABLE cellpadding=3><!-- tsb: ! working with rank=3 &#46;&#46;&#46;
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
taking the result of the modulo   &#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
z=1      z=2      z=3      z=4   &#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |&#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |&#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> <!-- Consumed .TP -->
<BR>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
would result in the mask ..       &#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
F F T || F F F || F T F || F F F |&#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
F F F || F T F || F F F || T F F |&#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>print *,&#146;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
print *,&#146; the total number of .true.values is&#146;
print ints, <B>count</B>(modulo(c,5).eq.0)
call <B>printi</B>(&#146;counting up along a row and removing rows&#146;,&
<B>count</B>(modulo(c,5).eq.0,<I>dim</I>=1))
call <B>printi</B>(&#146;counting up along a column and removing columns&#146;,&
<B>count</B>(modulo(c,5).eq.0,<I>dim</I>=2))
call <B>printi</B>(&#146;counting up along a depth and removing depths&#146;,&
<B>count</B>(modulo(c,5).eq.0,<I>dim</I>=3))
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<P>
contains
<P>
<PRE>
         ! CONVENIENCE ROUTINE FOR PRINTING SMALL INTEGER MATRICES
         subroutine printi(title,arr)
         implicit none
<P>
         !@(#) print small 2d integer arrays in row-column format
<P>
         character(len=*),parameter :: all=&#146;(*(g0,1x))&#146; ! a handy format
         character(len=*),intent(in)  :: title
         integer,intent(in)           :: arr(:,:)
         integer                      :: i
         character(len=:),allocatable :: biggest
<P>
            print all
            print all, trim(title),&#146;:(&#146;,shape(arr),&#146;)&#146;  ! print title
            biggest=&#146;           &#146;  ! make buffer to write integer into
            ! find how many characters to use for integers
            write(biggest,&#146;(i0)&#146;)ceiling(log10(real(maxval(abs(arr)))))+2
            ! use this format to write a row
            biggest=&#146;(" &gt; [",*(i&#146;//trim(biggest)//&#146;:,","))&#146;
            ! print one row of array at a time
            do i=1,size(arr,dim=1)
               write(*,fmt=biggest,advance=&#146;no&#146;)arr(i,:)
               write(*,&#146;(" ]")&#146;)
            enddo
<P>
</PRE>
<BLOCKQUOTE>
end subroutine printi
end program demo_count
</BLOCKQUOTE>
<P>
Results:
<P>
<PRE>
       &gt;   the numeric arrays we will compare
       &gt;    1  3  5
       &gt;    2  4  6
       &gt;
       &gt;    0  3  5
       &gt;    7  4  8
       &gt;   count a few basic things creating a mask from an expression
       &gt;   count a&gt;b           1
       &gt;   count b&lt;a           2
       &gt;   count b==a           3
       &gt;   check sum =  T
       &gt;   make a mask identifying unequal elements &#46;&#46;&#46;
       &gt;   the mask generated from a.ne.b
       &gt;    T  F  F
       &gt;    T  F  T
       &gt;   count total and along rows and columns &#46;&#46;&#46;
       &gt;  number of elements not equal
       &gt;  (ie. total true elements in the mask)
       &gt;    3
       &gt;  count of elements not equal in each column
       &gt;  (ie. total true elements in each column)
       &gt;    2  0  1
       &gt;  count of elements not equal in each row
       &gt;  (ie. total true elements in each row)
       &gt;    1  2
       &gt;   lets try this with c(2,3,4)
       &gt;     taking the result of the modulo
       &gt;      z=1      z=2      z=3      z=4
       &gt;     1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |
       &gt;     2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |
       &gt;
       &gt;     would result in the mask ..
       &gt;     F F T || F F F || F T F || F F F |
       &gt;     F F F || F T F || F F F || T F F |
       &gt;
       &gt;    the total number of .true.values is
       &gt;   4
       &gt;
       &gt;  counting up along a row and removing rows :( 3 4 )
       &gt;   &gt; [ 0, 0, 0, 1 ]
       &gt;   &gt; [ 0, 1, 1, 0 ]
       &gt;   &gt; [ 1, 0, 0, 0 ]
       &gt;
       &gt;  counting up along a column and removing columns :( 2 4 )
       &gt;   &gt; [ 1, 0, 1, 0 ]
       &gt;   &gt; [ 0, 1, 0, 1 ]
       &gt;
       &gt;  counting up along a depth and removing depths :( 2 3 )
       &gt;   &gt; [ 0, 1, 1 ]
       &gt;   &gt; [ 1, 1, 0 ]
<P>
</PRE>
</BLOCKQUOTE>
<A name=7>

     <H3>STANDARD</H3>

</A>
<BLOCKQUOTE>
Fortran 95 , with KIND argument - Fortran 2003
</BLOCKQUOTE>
<A name=8>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<B>ANY</B>(3), <B>ALL</B>(3), <B>SUM</B>(3),
<P>
fortran-lang intrinsic descriptions (license: MIT) @urbanjost
<P>
<PRE>
                               November 07, 2022               count(3fortran)
</PRE>
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I>Nemo Release 3.1</I></TD> <TD width=33% align=center>count (3)</TD> <TD align=right width=33%><I>December 18, 2022</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from 4d50f2b5-ad10-4f31-a4fe-a49d8c1e6f53 using man macros.</FONT>
<br><br><center><img src="images/count.3fortran.gif"></center>
</div>
</div>
</body>
</HTML>
