<HTML><HEAD>
<TITLE>f2018.7fortran.txt</TITLE>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>untitled ()</NOBR><HR></H1>
</CENTER>
<BLOCKQUOTE>
ISO/IEC JTC 1/SC 22/WG 5/N2146
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>untitled ()</NOBR><HR></H1>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>DRAFT</B> </TD><TD valign=bottom>
INTERNATIONAL                                    ISO/IEC
<TABLE width=100% cellpadding=3><!-- tsb: INTERNATIONAL                                    ISO/IEC
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>(for ballot)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STANDARD                                                 DIS
</TD></TR>
<TR valign=top><TD colspan=2>
<B>28th December 2017</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
1539-1
</TD></TR>
<TR><TD colspan=2>
11:02
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                    Fourth edition
<P>
                                                                       2017-12-28
<P>
</PRE>
Information technology — Programming
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
languages — Fortran —
<P>
Part 1:
<P>
Base language
<P>
Technologies de l’information — Langages de programmation —
<P>
Fortran —
<P>
Partie 1: Langage de base
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                 PDF disclaimer
<P>
</PRE>
This PDF file may contain embedded typefaces. In accordance with Adobe’s licensing policy, this file may be
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
printed or viewed but shall not be edited unless the typefaces which are embedded are licensed to and installed
<P>
on the computer performing the editing. In downloading this file, parties accept therein the responsibility of not
<P>
infringing Adobe’s licensing policy. The ISO Central Secretariat accepts no liability in this area.
<P>
Adobe is a trademark of Adobe Systems Incorporated.
<P>
Details of the software products used to create this PDF file can be found in the General Info relative to the file;
<P>
the PDF-creation parameters were optimized for printing. Every care has been taken to ensure that the file is
<P>
suitable for use by ISO member bodies. In the unlikely event that a problem relating to it is found, please inform
<P>
the Central Secretariat at the address given below.
<P>
This ISO document is a Draft International Standard and is copyright-protected by ISO. Except as permitted
<P>
under the applicable laws of the user’s country, neither this ISO draft nor any extract from it may be reproduced,
<P>
stored in a retrieval system or transmitted in any form or by any means, electronic, photocopying, recording or
<P>
otherwise, without prior written permission being secured.
<P>
Requests for permission to reproduce should be addressed to either ISO at the address below or ISO’s member
<P>
body in the country of the requester.
<P>
<PRE>
      ISO copyright office
<P>
      Case postale 56 • CH-1211 Geneva 20
<P>
      Tel. + 41 22 749 01 11
<P>
      Fax + 41 22 734 10 79
<P>
      E-mail <A HREF="mailto:copyright@iso.ch">copyright@iso.ch</A>
<P>
      Web www.iso.ch
<P>
</PRE>
Reproduction may be subject to royalty payments or a licensing agreement.
<P>
Violators may be prosecuted.
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
Contents
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
<P>
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xviii
<TABLE width=100% cellpadding=3><!-- tsb: Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xviii
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>1</B> </TD><TD valign=bottom>
Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>2</B> </TD><TD valign=bottom>
Normative references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>3</B> </TD><TD valign=bottom>
Terms and definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    5
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>4</B> </TD><TD valign=bottom>
Notation, conformance, and compatibility . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</TD></TR>
<TR><TD colspan=2>
<PRE>
    4.1   Notation, symbols and abbreviated terms . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
<P>
          4.1.1     Syntax rules . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
<P>
          4.1.2     Constraints . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
<P>
          4.1.3     Assumed syntax rules . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
<P>
          4.1.4     Syntax conventions and characteristics       . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
<P>
          4.1.5     Text conventions . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
<P>
    4.2   Conformance . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
<P>
    4.3   Compatibility . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
<P>
          4.3.1     Previous Fortran standards . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
<P>
          4.3.2     New intrinsic procedures . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
<P>
          4.3.3     Fortran 2008 compatibility . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
<P>
          4.3.4     Fortran 2003 compatibility . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
<P>
          4.3.5     Fortran 95 compatibility . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
<P>
          4.3.6     Fortran 90 compatibility . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
<P>
          4.3.7     FORTRAN 77 compatibility . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
<P>
    4.4   Deleted and obsolescent features . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
<P>
          4.4.1     General . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
<P>
          4.4.2     Nature of deleted features . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
<P>
          4.4.3     Nature of obsolescent features . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>5</B> </TD><TD valign=bottom>
Fortran concepts . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
</TD></TR>
<TR><TD colspan=2>
<PRE>
    5.1   High level syntax . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
<P>
    5.2   Program unit concepts . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
<P>
          5.2.1     Program units and scoping      units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
<P>
          5.2.2     Program . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
<P>
          5.2.3     Procedure . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
<P>
          5.2.4     Module . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
<P>
          5.2.5     Submodule . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
<P>
    5.3   Execution concepts . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
<P>
          5.3.1     Statement classification . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
<P>
          5.3.2     Statement order . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
<P>
          5.3.3     The END statement . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
<P>
          5.3.4     Program execution . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
<P>
          5.3.5     Execution sequence . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
<P>
          5.3.6     Image execution states . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
iii
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
         5.3.7     Termination of execution . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>5.4</B> </TD><TD valign=bottom>
Data concepts . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
</TD></TR>
<TR><TD colspan=2>
<PRE>
         5.4.1     Type . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
<P>
         5.4.2     Data value . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
<P>
         5.4.3     Data entity . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
<P>
         5.4.4     Definition of objects and pointers     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
<P>
         5.4.5     Reference . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
<P>
         5.4.6     Array . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
<P>
         5.4.7     Coarray . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
<P>
         5.4.8     Established coarrays . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
<P>
         5.4.9     Pointer . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
<P>
         5.4.10 Allocatable variables . . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
<P>
         5.4.11 Storage . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>5.5</B> </TD><TD valign=bottom>
Fundamental concepts . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         5.5.1     Names and designators . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
<P>
         5.5.2     Statement keyword . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
<P>
         5.5.3     Other keywords . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
<P>
         5.5.4     Association . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
<P>
         5.5.5     Intrinsic . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
<P>
         5.5.6     Operator . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
<P>
         5.5.7     Companion processors . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>6</B> </TD><TD valign=bottom>
Lexical tokens and source form . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
</TD></TR>
<TR><TD colspan=2>
<PRE>
   6.1   Processor character set . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
<P>
         6.1.1     Characters . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
<P>
         6.1.2     Letters . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
<P>
         6.1.3     Digits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
<P>
         6.1.4     Underscore . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
<P>
         6.1.5     Special characters . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
<P>
         6.1.6     Other characters . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
<P>
   6.2   Low-level syntax . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
<P>
         6.2.1     Tokens . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
<P>
         6.2.2     Names . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
<P>
         6.2.3     Constants . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
<P>
         6.2.4     Operators . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
<P>
         6.2.5     Statement labels . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
<P>
         6.2.6     Delimiters . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
<P>
   6.3   Source form . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
<P>
         6.3.1     Program units, statements,     and lines   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
<P>
         6.3.2     Free source form . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
<P>
         6.3.3     Fixed source form . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
<P>
   6.4   Including source text . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7</B> </TD><TD valign=bottom>
Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</TD></TR>
<TR><TD colspan=2>
<PRE>
   7.1   Characteristics of types . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . 57
<P>
         7.1.1     The concept of type . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . 57
<P>
         7.1.2     Type classification . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . 57
<P>
         7.1.3     Set of values . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . 57
<P>
         7.1.4     Constants . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . 57
<P>
         7.1.5     Operations . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . 57
<P>
   7.2   Type parameters . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . 58
<P>
   7.3   Types, type specifiers, and values . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . 58
<P>
         7.3.1     Relationship of types and values to objects      . . . . . . . . . . . . . . . . . . . . . . . . . . 58
<P>
         7.3.2     Type specifiers and type compatibility . .       . . . . . . . . . . . . . . . . . . . . . . . . . . 59
<P>
   7.4   Intrinsic types . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . 61
<P>
         7.4.1     Classification and specification . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . 61
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>iv</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.4.2</B> </TD><TD valign=bottom>
Intrinsic operations on intrinsic types . .    . . . . . . . . . . . . . . . . . . . . . . . . . . .  61
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.4.3</B> </TD><TD valign=bottom>
Numeric intrinsic types . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . .  61
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.4.4</B> </TD><TD valign=bottom>
Character type . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . .  65
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.4.5</B> </TD><TD valign=bottom>
Logical type . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . .  68
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5</B> </TD><TD valign=bottom>
Derived types . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . .  68
</TD></TR>
<TR><TD colspan=2>
<PRE>
          7.5.1     Derived type concepts . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . .  68
<P>
          7.5.2     Derived-type definition . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . .  69
<P>
          7.5.3     Derived-type parameters . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . .  73
<P>
          7.5.4     Components . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . .  74
<P>
          7.5.5     Type-bound procedures . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . .  81
<P>
          7.5.6     Final subroutines . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . .  83
<P>
          7.5.7     Type extension . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . .  85
<P>
          7.5.8     Derived-type values . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
<P>
          7.5.9     Derived-type specifier . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
<P>
          7.5.10 Construction of derived-type values . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . .  88
<P>
          7.5.11 Derived-type operations and assignment            . . . . . . . . . . . . . . . . . . . . . . . . . . .  90
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.6</B> </TD><TD valign=bottom>
Enumerations and enumerators . . . . . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . .  90
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.7</B> </TD><TD valign=bottom>
Binary, octal, and hexadecimal literal constants .       . . . . . . . . . . . . . . . . . . . . . . . . . . .  92
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.8</B> </TD><TD valign=bottom>
Construction of array values . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . .  92
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8</B> </TD><TD valign=bottom>
Attribute declarations and specifications . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
</TD></TR>
<TR><TD colspan=2>
<PRE>
   8.1    Attributes of procedures and data objects        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
<P>
   8.2    Type declaration statement . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
<P>
   8.3    Automatic data objects . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97
<P>
   8.4    Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97
<P>
   8.5    Attributes . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97
<P>
          8.5.1     Attribute specification . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97
<P>
          8.5.2     Accessibility attribute . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  98
<P>
          8.5.3     ALLOCATABLE attribute . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  98
<P>
          8.5.4     ASYNCHRONOUS attribute . .             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  98
<P>
          8.5.5     BIND attribute for data entities .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  99
<P>
          8.5.6     CODIMENSION attribute . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  99
<P>
          8.5.7     CONTIGUOUS attribute . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
<P>
          8.5.8     DIMENSION attribute . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
<P>
          8.5.9     EXTERNAL attribute . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
<P>
          8.5.10 INTENT attribute . . . . . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
<P>
          8.5.11 INTRINSIC attribute . . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
<P>
          8.5.12 OPTIONAL attribute . . . . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
<P>
          8.5.13 PARAMETER attribute . . . . .             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
<P>
          8.5.14 POINTER attribute . . . . . . .           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
<P>
          8.5.15 PROTECTED attribute . . . . .             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
<P>
          8.5.16 SAVE attribute . . . . . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
<P>
          8.5.17 TARGET attribute . . . . . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
<P>
          8.5.18 VALUE attribute . . . . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
<P>
          8.5.19 VOLATILE attribute . . . . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
<P>
   8.6    Attribute specification statements . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
<P>
          8.6.1     Accessibility statement . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
<P>
          8.6.2     ALLOCATABLE statement . . .            . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
<P>
          8.6.3     ASYNCHRONOUS statement . .             . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
<P>
          8.6.4     BIND statement . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
<P>
          8.6.5     CODIMENSION statement . . .            . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
<P>
          8.6.6     CONTIGUOUS statement . . . .           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
<P>
          8.6.7     DATA statement . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
<P>
          8.6.8     DIMENSION statement . . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
<P>
          8.6.9     INTENT statement . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
<P>
          8.6.10 OPTIONAL statement . . . . . .            . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
         8.6.11 PARAMETER statement . .            . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
<P>
         8.6.12 POINTER statement . . . .          . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
<P>
         8.6.13 PROTECTED statement . .            . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
<P>
         8.6.14 SAVE statement . . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
<P>
         8.6.15 TARGET statement . . . .           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
<P>
         8.6.16 VALUE statement . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
<P>
         8.6.17 VOLATILE statement . . .           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.7</B> </TD><TD valign=bottom>
IMPLICIT statement . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.8</B> </TD><TD valign=bottom>
IMPORT statement . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.9</B> </TD><TD valign=bottom>
NAMELIST statement . . . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.10</B> </TD><TD valign=bottom>
Storage association of data objects .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         8.10.1 EQUIVALENCE statement              . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
<P>
         8.10.2 COMMON statement . . . .           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
<P>
         8.10.3 Restrictions on common and         equivalence   . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>9</B> </TD><TD valign=bottom>
Use of data objects . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
</TD></TR>
<TR><TD colspan=2>
<PRE>
   9.1   Designator . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
<P>
   9.2   Variable . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
<P>
   9.3   Constants . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
<P>
   9.4   Scalars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
<P>
         9.4.1    Substrings . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
<P>
         9.4.2    Structure components . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
<P>
         9.4.3    Coindexed named objects . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
<P>
         9.4.4    Complex parts . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
<P>
         9.4.5    Type parameter inquiry . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
<P>
   9.5   Arrays . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
<P>
         9.5.1    Order of reference . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
<P>
         9.5.2    Whole arrays . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
<P>
         9.5.3    Array elements and array sections .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
<P>
         9.5.4    Simply contiguous array designators      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
<P>
   9.6   Image selectors . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
<P>
   9.7   Dynamic association . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
<P>
         9.7.1    ALLOCATE statement . . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
<P>
         9.7.2    NULLIFY statement . . . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
<P>
         9.7.3    DEALLOCATE statement . . . . .           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
<P>
         9.7.4    STAT= specifier . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
<P>
         9.7.5    ERRMSG= specifier . . . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>10 Expressions and assignment . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   10.1 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . 147
<P>
         10.1.1 Expression semantics . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . 147
<P>
         10.1.2 Form of an expression . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . 147
<P>
         10.1.3 Precedence of operators . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . 151
<P>
         10.1.4 Evaluation of operations . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . 153
<P>
         10.1.5 Intrinsic operations . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . 153
<P>
         10.1.6 Defined operations . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . 160
<P>
         10.1.7 Evaluation of operands . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . 161
<P>
         10.1.8 Integrity of parentheses . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . 162
<P>
         10.1.9 Type, type parameters, and shape of an expression            . . . . . . . . . . . . . . . . . . . . . 162
<P>
         10.1.10 Conformability rules for elemental operations . . .         . . . . . . . . . . . . . . . . . . . . . 163
<P>
         10.1.11 Specification expression . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . 164
<P>
         10.1.12 Constant expression . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . 165
<P>
   10.2 Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . 167
<P>
         10.2.1 Assignment statement . . . . . . . . . . . . . . . .         . . . . . . . . . . . . . . . . . . . . . 167
<P>
         10.2.2 Pointer assignment . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . 171
<P>
         10.2.3 Masked array assignment – WHERE . . . . . . . .              . . . . . . . . . . . . . . . . . . . . . 175
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>vi</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>10.2.4</B> </TD><TD valign=bottom>
FORALL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11 Execution control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   11.1 Executable constructs containing blocks . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . 181
<P>
        11.1.1 Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . 181
<P>
        11.1.2 Rules governing blocks . . . . . . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . 181
<P>
        11.1.3 ASSOCIATE construct . . . . . . . . . . . . . . . . . . . . . . .           . . . . . . . . . . . . . . 182
<P>
        11.1.4 BLOCK construct . . . . . . . . . . . . . . . . . . . . . . . . . .         . . . . . . . . . . . . . . 183
<P>
        11.1.5 CHANGE TEAM construct . . . . . . . . . . . . . . . . . . . .               . . . . . . . . . . . . . . 185
<P>
        11.1.6 CRITICAL construct . . . . . . . . . . . . . . . . . . . . . . . .          . . . . . . . . . . . . . . 187
<P>
        11.1.7 DO construct . . . . . . . . . . . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . 188
<P>
        11.1.8 IF construct and statement . . . . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . 195
<P>
        11.1.9 SELECT CASE construct . . . . . . . . . . . . . . . . . . . . .             . . . . . . . . . . . . . . 196
<P>
        11.1.10 SELECT RANK construct . . . . . . . . . . . . . . . . . . . . .            . . . . . . . . . . . . . . 199
<P>
        11.1.11 SELECT TYPE construct . . . . . . . . . . . . . . . . . . . . .            . . . . . . . . . . . . . . 201
<P>
        11.1.12 EXIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . 204
<P>
   11.2 Branching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . 204
<P>
        11.2.1 Branch concepts . . . . . . . . . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . 204
<P>
        11.2.2 GO TO statement . . . . . . . . . . . . . . . . . . . . . . . . . .         . . . . . . . . . . . . . . 204
<P>
        11.2.3 Computed GO TO statement . . . . . . . . . . . . . . . . . . .              . . . . . . . . . . . . . . 205
<P>
   11.3 CONTINUE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . .         . . . . . . . . . . . . . . 205
<P>
   11.4 STOP and ERROR STOP statements . . . . . . . . . . . . . . . . . . .               . . . . . . . . . . . . . . 205
<P>
   11.5 FAIL IMAGE statement . . . . . . . . . . . . . . . . . . . . . . . . . . .         . . . . . . . . . . . . . . 206
<P>
   11.6 Image execution control . . . . . . . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . 206
<P>
        11.6.1 Image control statements . . . . . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . 206
<P>
        11.6.2 Segments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . 207
<P>
        11.6.3 SYNC ALL statement . . . . . . . . . . . . . . . . . . . . . . .            . . . . . . . . . . . . . . 208
<P>
        11.6.4 SYNC IMAGES statement . . . . . . . . . . . . . . . . . . . . .             . . . . . . . . . . . . . . 209
<P>
        11.6.5 SYNC MEMORY statement . . . . . . . . . . . . . . . . . . . .               . . . . . . . . . . . . . . 210
<P>
        11.6.6 SYNC TEAM statement . . . . . . . . . . . . . . . . . . . . . .             . . . . . . . . . . . . . . 211
<P>
        11.6.7 EVENT POST statement . . . . . . . . . . . . . . . . . . . . .              . . . . . . . . . . . . . . 211
<P>
        11.6.8 EVENT WAIT statement . . . . . . . . . . . . . . . . . . . . .              . . . . . . . . . . . . . . 212
<P>
        11.6.9 FORM TEAM statement . . . . . . . . . . . . . . . . . . . . . .             . . . . . . . . . . . . . . 212
<P>
        11.6.10 LOCK and UNLOCK statements . . . . . . . . . . . . . . . . .               . . . . . . . . . . . . . . 213
<P>
        11.6.11 STAT= and ERRMSG= specifiers in image control statements .                 . . . . . . . . . . . . . . 215
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12 Input/output statements . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   12.1 Input/output concepts . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
<P>
   12.2 Records . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
<P>
        12.2.1 Definition of a record . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
<P>
        12.2.2 Formatted record . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
<P>
        12.2.3 Unformatted record . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
<P>
        12.2.4 Endfile record . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
<P>
   12.3 External files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
<P>
        12.3.1 External file concepts . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
<P>
        12.3.2 File existence . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
<P>
        12.3.3 File access . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
<P>
        12.3.4 File position . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
<P>
        12.3.5 File storage units . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
<P>
   12.4 Internal files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
<P>
   12.5 File connection . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
<P>
        12.5.1 Referring to a file . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
<P>
        12.5.2 Connection modes . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
<P>
        12.5.3 Unit existence . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
<P>
        12.5.4 Connection of a file to a unit      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
<P>
        12.5.5 Preconnection . . . . . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
vii
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
          12.5.6 OPEN statement . . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . 226
<P>
          12.5.7 CLOSE statement . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . 230
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.6 Data transfer statements . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
          12.6.1 Form of input and output statements . . . . . . . . .        . . . . . . . . . . . . . . . . . . . . 231
<P>
          12.6.2 Control information list . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . 232
<P>
          12.6.3 Data transfer input/output list . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . 236
<P>
          12.6.4 Execution of a data transfer input/output statement          . . . . . . . . . . . . . . . . . . . . 239
<P>
          12.6.5 Termination of data transfer statements . . . . . . .        . . . . . . . . . . . . . . . . . . . . 249
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>12.7 Waiting on pending data transfer . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
          12.7.1 Wait operation . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . 250
<P>
          12.7.2 WAIT statement . . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . . 250
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>12.8 File positioning statements . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
          12.8.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . 251
<P>
          12.8.2 BACKSPACE statement . . . . . . . . . . . . . . . .          . . . . . . . . . . . . . . . . . . . . 251
<P>
          12.8.3 ENDFILE statement . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . . . . . . . 252
<P>
          12.8.4 REWIND statement . . . . . . . . . . . . . . . . . .         . . . . . . . . . . . . . . . . . . . . 252
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>12.9 FLUSH statement . . . . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>12.10 File inquiry statement . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
          12.10.1 Forms of the INQUIRE statement . . . . . . . . . . .        . . . . . . . . . . . . . . . . . . . . 253
<P>
          12.10.2 Inquiry specifiers . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . 254
<P>
          12.10.3 Inquire by output list . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . 260
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>12.11 Error, end-of-record, and end-of-file conditions . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
          12.11.1 Occurrence of input/output conditions . . . . . . . .       . . . . . . . . . . . . . . . . . . . . 260
<P>
          12.11.2 Error conditions and the ERR= specifier . . . . . . .       . . . . . . . . . . . . . . . . . . . . 260
<P>
          12.11.3 End-of-file condition and the END= specifier . . . . .      . . . . . . . . . . . . . . . . . . . . 261
<P>
          12.11.4 End-of-record condition and the EOR= specifier . . .        . . . . . . . . . . . . . . . . . . . . 261
<P>
          12.11.5 IOSTAT= specifier . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . 262
<P>
          12.11.6 IOMSG= specifier . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . 262
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>12.12 Restrictions on input/output statements . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13 Input/output editing . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
    13.1 Format specifications . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
<P>
    13.2 Explicit format specification methods . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
<P>
          13.2.1 FORMAT statement . . . . . . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
<P>
          13.2.2 Character format specification . . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
<P>
    13.3 Form of a format item list . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
<P>
          13.3.1 Syntax . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
<P>
          13.3.2 Edit descriptors . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
<P>
          13.3.3 Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
<P>
    13.4 Interaction between input/output list and format       . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
<P>
    13.5 Positioning by format control . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
<P>
    13.6 Decimal symbol . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
<P>
    13.7 Data edit descriptors . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
<P>
          13.7.1 Purpose of data edit descriptors . . . . .     . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
<P>
          13.7.2 Numeric editing . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
<P>
          13.7.3 Logical editing . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
<P>
          13.7.4 Character editing . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
<P>
          13.7.5 Generalized editing . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
<P>
          13.7.6 User-defined derived-type editing . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
<P>
    13.8 Control edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
<P>
          13.8.1 Position edit descriptors . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
<P>
          13.8.2 Slash editing . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
<P>
          13.8.3 Colon editing . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
<P>
          13.8.4 SS, SP, and S editing . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
<P>
          13.8.5 P editing . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
<P>
          13.8.6 BN and BZ editing . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>viii</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13.8.7 RU, RD, RZ, RN, RC, and RP editing</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>13.8.8 DC and DP editing . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>13.9 Character string edit descriptors . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13.10 List-directed formatting . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
         13.10.1 Purpose of list-directed formatting . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
<P>
         13.10.2 Values and value separators . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
<P>
         13.10.3 List-directed input . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
<P>
         13.10.4 List-directed output . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>13.11 Namelist formatting . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         13.11.1 Purpose of namelist formatting . . . .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
<P>
         13.11.2 Name-value subsequences . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
<P>
         13.11.3 Namelist input . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
<P>
         13.11.4 Namelist output . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>14 Program units . . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   14.1 Main program . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
<P>
   14.2 Modules . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
<P>
         14.2.1 Module syntax and semantics . . . . . .         . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
<P>
         14.2.2 The USE statement and use association .         . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
<P>
         14.2.3 Submodules . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
<P>
   14.3 Block data program units . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
<P>
</PRE>
15 Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
</TD></TR>
<TR><TD colspan=2>
<PRE>
   15.1 Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 299
<P>
   15.2 Procedure classifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . 299
<P>
         15.2.1 Procedure classification by reference . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . 299
<P>
         15.2.2 Procedure classification by means of definition . . . . . . . . . . . . .       . . . . . . . . . . . 299
<P>
   15.3 Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
<P>
         15.3.1 Characteristics of procedures . . . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . 300
<P>
         15.3.2 Characteristics of dummy arguments . . . . . . . . . . . . . . . . . .          . . . . . . . . . . . 300
<P>
         15.3.3 Characteristics of function results . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . 300
<P>
   15.4 Procedure interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . 301
<P>
         15.4.1 Interface and abstract interface . . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . 301
<P>
         15.4.2 Implicit and explicit interfaces . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . 301
<P>
         15.4.3 Specification of the procedure interface . . . . . . . . . . . . . . . . .      . . . . . . . . . . . 302
<P>
   15.5 Procedure reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . 311
<P>
         15.5.1 Syntax of a procedure reference . . . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . 311
<P>
         15.5.2 Actual arguments, dummy arguments, and argument association . . .               . . . . . . . . . . . 313
<P>
         15.5.3 Function reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . 324
<P>
         15.5.4 Subroutine reference . . . . . . . . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . 324
<P>
         15.5.5 Resolving named procedure references . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . 324
<P>
         15.5.6 Resolving type-bound procedure references . . . . . . . . . . . . . . .         . . . . . . . . . . . 326
<P>
   15.6 Procedure definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 327
<P>
         15.6.1 Intrinsic procedure definition . . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . 327
<P>
         15.6.2 Procedures defined by subprograms . . . . . . . . . . . . . . . . . . .         . . . . . . . . . . . 327
<P>
         15.6.3 Definition and invocation of procedures by means other than Fortran             . . . . . . . . . . . 332
<P>
         15.6.4 Statement function . . . . . . . . . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . 333
<P>
   15.7 Pure procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . 333
<P>
   15.8 Elemental procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . 335
<P>
         15.8.1 Elemental procedure declaration and interface . . . . . . . . . . . . .         . . . . . . . . . . . 335
<P>
         15.8.2 Elemental function actual arguments and results . . . . . . . . . . . .         . . . . . . . . . . . 336
<P>
         15.8.3 Elemental subroutine actual arguments . . . . . . . . . . . . . . . . .         . . . . . . . . . . . 336
<P>
</PRE>
16 Intrinsic procedures and modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
</TD></TR>
<TR><TD colspan=2>
<PRE>
   16.1 Classes of intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
<P>
   16.2 Arguments to intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ix
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
         16.2.1 General rules . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . 337
<P>
         16.2.2 The shape of array arguments . . . . . . . . .        . . . . . . . . . . . . . . . . . . . . . . . . 338
<P>
         16.2.3 Mask arguments . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . 338
<P>
         16.2.4 DIM arguments and reduction functions . . .           . . . . . . . . . . . . . . . . . . . . . . . . 338
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>16.3 Bit model . . . . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
         16.3.1 General . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . 338
<P>
         16.3.2 Bit sequence comparisons . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . 339
<P>
         16.3.3 Bit sequences as arguments to INT and REAL            . . . . . . . . . . . . . . . . . . . . . . . . 339
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>16.4 Numeric models . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>16.5 Atomic subroutines . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>16.6 Collective subroutines . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>16.7 Standard generic intrinsic procedures . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>16.8 Specific names for standard intrinsic functions . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>16.9 Specifications of the standard intrinsic procedures . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
         16.9.1 General . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . 349
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>16.10 Standard intrinsic modules . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         16.10.1 General . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . 436
<P>
         16.10.2 The ISO_FORTRAN_ENV intrinsic module                 . . . . . . . . . . . . . . . . . . . . . . . . 436
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>17 Exceptions and IEEE arithmetic . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   17.1 Overview of IEEE arithmetic support .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
<P>
   17.2 Derived types, constants, and operators     defined in  the modules     . . . . . . . . . . . . . . . . . . . 444
<P>
   17.3 The exceptions . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 444
<P>
   17.4 The rounding modes . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
<P>
   17.5 Underflow mode . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
<P>
   17.6 Halting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
<P>
   17.7 The floating-point modes and status .       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
<P>
   17.8 Exceptional values . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
<P>
   17.9 IEEE arithmetic . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 449
<P>
   17.10 Summary of the procedures . . . . . .      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450
<P>
   17.11 Specifications of the procedures . . . .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
<P>
         17.11.1 General . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
<P>
   17.12 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 476
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>18 Interoperability with C . . . . . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   18.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
<P>
   18.2 The ISO_C_BINDING intrinsic module . . . . . . . . . . . . .            . . . . . . . . . . . . . . . . . . . 479
<P>
         18.2.1 Summary of contents . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . 479
<P>
         18.2.2 Named constants and derived types in the module . . .           . . . . . . . . . . . . . . . . . . . 479
<P>
         18.2.3 Procedures in the module . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . . . . . . 480
<P>
   18.3 Interoperability between Fortran and C entities . . . . . . . . .       . . . . . . . . . . . . . . . . . . . 485
<P>
         18.3.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . 485
<P>
         18.3.2 Interoperability of intrinsic types . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . 485
<P>
         18.3.3 Interoperability with C pointer types . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . 486
<P>
         18.3.4 Interoperability of derived types and C struct types . .        . . . . . . . . . . . . . . . . . . . 486
<P>
         18.3.5 Interoperability of scalar variables . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . 488
<P>
         18.3.6 Interoperability of array variables . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . 488
<P>
         18.3.7 Interoperability of procedures and procedure interfaces         . . . . . . . . . . . . . . . . . . . 489
<P>
   18.4 C descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
<P>
   18.5 The source file ISO_Fortran_binding.h . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . 492
<P>
         18.5.1 Summary of contents . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . . . 492
<P>
         18.5.2 The CFI_dim_t structure type . . . . . . . . . . . . .          . . . . . . . . . . . . . . . . . . . 492
<P>
         18.5.3 The CFI_cdesc_t structure type . . . . . . . . . . . .          . . . . . . . . . . . . . . . . . . . 492
<P>
         18.5.4 Macros and typedefs in ISO_Fortran_binding.h . . . .            . . . . . . . . . . . . . . . . . . . 493
<P>
         18.5.5 Functions declared in ISO_Fortran_binding.h . . . . .           . . . . . . . . . . . . . . . . . . . 496
<P>
   18.6 Restrictions on C descriptors . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . 503
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>x</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>18.7</B> </TD><TD valign=bottom>
Restrictions on formal parameters . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . . . . 504
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>18.8</B> </TD><TD valign=bottom>
Restrictions on lifetimes . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . 504
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>18.9</B> </TD><TD valign=bottom>
Interoperation with C global variables . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . 505
</TD></TR>
<TR><TD colspan=2>
<PRE>
         18.9.1 General . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . . . . 505
<P>
         18.9.2 Binding labels for common blocks and variables . .          . . . . . . . . . . . . . . . . . . . . . 506
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>18.10 Interoperation with C functions . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         18.10.1 Definition and reference of interoperable procedures       . . . . . . . . . . . . . . . . . . . . . 506
<P>
         18.10.2 Binding labels for procedures . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . . . . . 506
<P>
         18.10.3 Exceptions and IEEE arithmetic procedures . . . .          . . . . . . . . . . . . . . . . . . . . . 507
<P>
         18.10.4 Asynchronous communication . . . . . . . . . . . .         . . . . . . . . . . . . . . . . . . . . . 507
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>19 Scope, association, and definition . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   19.1 Scopes, identifiers, and entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
<P>
   19.2 Global identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . 509
<P>
   19.3 Local identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
<P>
         19.3.1 Classes of local identifiers . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . 510
<P>
         19.3.2 Local identifiers that are the same as common block names           . . . . . . . . . . . . . . . . . 511
<P>
         19.3.3 Function results . . . . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . 511
<P>
         19.3.4 Components, type parameters, and bindings . . . . . . . .           . . . . . . . . . . . . . . . . . 511
<P>
         19.3.5 Argument keywords . . . . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . 511
<P>
   19.4 Statement and construct entities . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . 512
<P>
   19.5 Association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
<P>
         19.5.1 Name association . . . . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . 513
<P>
         19.5.2 Pointer association . . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 517
<P>
         19.5.3 Storage association . . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 520
<P>
         19.5.4 Inheritance association . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 522
<P>
         19.5.5 Establishing associations . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 522
<P>
   19.6 Definition and undefinition of variables . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . 523
<P>
         19.6.1 Definition of objects and subobjects . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . 523
<P>
         19.6.2 Variables that are always defined . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . 523
<P>
         19.6.3 Variables that are initially defined . . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . 523
<P>
         19.6.4 Variables that are initially undefined . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . 524
<P>
         19.6.5 Events that cause variables to become defined . . . . . . .         . . . . . . . . . . . . . . . . . 524
<P>
         19.6.6 Events that cause variables to become undefined . . . . . .         . . . . . . . . . . . . . . . . . 526
<P>
         19.6.7 Variable definition context . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 528
<P>
         19.6.8 Pointer association context . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 528
<P>
</PRE>
Annex A (informative) Processor dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
</TD></TR>
<TR><TD colspan=2>
<PRE>
   A.1 Unspecified items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
<P>
   A.2 Processor dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Annex B (informative) Deleted and obsolescent features . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
   B.1 Deleted features from Fortran 90 . . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . 539
<P>
   B.2 Deleted features from Fortran 2008 . . . . . . . . . . . . . . . . . .       . . . . . . . . . . . . . . . . . 540
<P>
   B.3 Obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . 540
<P>
         B.3.1    General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540
<P>
         B.3.2    Alternate return . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . 540
<P>
         B.3.3    Computed GO TO statement . . . . . . . . . . . . . . . .          . . . . . . . . . . . . . . . . . 541
<P>
         B.3.4    Statement functions . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . 541
<P>
         B.3.5    DATA statements among executables . . . . . . . . . . . .         . . . . . . . . . . . . . . . . . 541
<P>
         B.3.6    Assumed character length functions . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . 541
<P>
         B.3.7    Fixed form source . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . 541
<P>
         B.3.8    CHARACTER* form of CHARACTER declaration . . . .                  . . . . . . . . . . . . . . . . . 542
<P>
         B.3.9    ENTRY statements . . . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . . 542
<P>
         B.3.10 Label DO statement . . . . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . . . . . 542
<P>
         B.3.11 COMMON and EQUIVALENCE statements and the block                     data  program   unit  . . . . . . 542
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
xi
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
         B.3.12  Specific names for intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
<P>
         B.3.13  FORALL construct and statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Annex C (informative) Extended notes . . . . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR><TD colspan=2>
<PRE>
    C.1 Fortran 2008 features not mentioned in its Introduction . . . . . . . . . . .      . . . . . . . . . . . . . 543
<P>
    C.2 Clause 7 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
<P>
         C.2.1   Selection of the approximation methods (7.4.3.2) . . . . . . . . .        . . . . . . . . . . . . . 543
<P>
         C.2.2   Type extension and component accessibility (7.5.2.2, 7.5.4) . . . .       . . . . . . . . . . . . . 544
<P>
         C.2.3   Generic type-bound procedures (7.5.5) . . . . . . . . . . . . . . .       . . . . . . . . . . . . . 545
<P>
         C.2.4   Abstract types (7.5.7.1) . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 546
<P>
         C.2.5   Structure constructors and generic names (7.5.10) . . . . . . . . .       . . . . . . . . . . . . . 547
<P>
         C.2.6   Final subroutines (7.5.6, 7.5.6.2, 7.5.6.3, 7.5.6.4) . . . . . . . . . .  . . . . . . . . . . . . . 548
<P>
    C.3 Clause 8 notes: The VOLATILE attribute (8.5.19) . . . . . . . . . . . . .          . . . . . . . . . . . . . 550
<P>
    C.4 Clause 9 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551
<P>
         C.4.1   Structure components (9.4.2) . . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . 551
<P>
         C.4.2   Allocation with dynamic type (9.7.1) . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . 552
<P>
    C.5 Clause 10 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 553
<P>
         C.5.1   Evaluation of function references (10.1.7) . . . . . . . . . . . . . .    . . . . . . . . . . . . . 553
<P>
         C.5.2   Pointers in expressions (10.1.9.2) . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . 553
<P>
         C.5.3   Pointers in variable definition contexts (10.2.1.3, 19.6.7) . . . . .     . . . . . . . . . . . . . 553
<P>
    C.6 Clause 11 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 553
<P>
         C.6.1   The SELECT CASE construct (11.1.9) . . . . . . . . . . . . . . .          . . . . . . . . . . . . . 553
<P>
         C.6.2   Loop control (11.1.7) . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . 554
<P>
         C.6.3   Examples of DO constructs (11.1.7) . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . 554
<P>
         C.6.4   Examples of invalid DO constructs (11.1.7) . . . . . . . . . . . . .      . . . . . . . . . . . . . 555
<P>
         C.6.5   Simple example using events . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . 556
<P>
         C.6.6   Example using three teams . . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . 557
<P>
         C.6.7   Accessing coarrays in sibling teams . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . 557
<P>
         C.6.8   Example involving failed images . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . 558
<P>
         C.6.9   EVENT_QUERY example that tolerates image failure . . . . . .              . . . . . . . . . . . . . 560
<P>
    C.7 Clause 12 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 562
<P>
         C.7.1   External files (12.3) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
<P>
         C.7.2   Nonadvancing input/output (12.3.4.2) . . . . . . . . . . . . . . .        . . . . . . . . . . . . . 563
<P>
         C.7.3   OPEN statement (12.5.6) . . . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . 565
<P>
         C.7.4   Connection properties (12.5.4) . . . . . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . 566
<P>
         C.7.5   Asynchronous input/output (12.6.2.5) . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . 567
<P>
    C.8 Clause 13 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 568
<P>
         C.8.1   Number of records (13.4, 13.5, 13.8.2) . . . . . . . . . . . . . . . .    . . . . . . . . . . . . . 568
<P>
         C.8.2   List-directed input (13.10.3) . . . . . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . 568
<P>
    C.9 Clause 14 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 569
<P>
         C.9.1   Main program and block data program unit (14.1, 14.3) . . . . .           . . . . . . . . . . . . . 569
<P>
         C.9.2   Dependent compilation (14.2) . . . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . 569
<P>
         C.9.3   Examples of the use of modules (14.2.1) . . . . . . . . . . . . . .       . . . . . . . . . . . . . 571
<P>
         C.9.4   Modules with submodules (14.2.3) . . . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . 577
<P>
    C.10 Clause 15 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582
<P>
         C.10.1 Portability problems with external procedures (15.4.3.5) . . . . .         . . . . . . . . . . . . . 582
<P>
         C.10.2 Procedures defined by means other than Fortran (15.6.3) . . . . .          . . . . . . . . . . . . . 582
<P>
         C.10.3 Abstract interfaces and procedure pointer components (15.4, 7.5)           . . . . . . . . . . . . . 582
<P>
         C.10.4 Pointers and targets as arguments (15.5.2.4, 15.5.2.6, 15.5.2.7) . .       . . . . . . . . . . . . . 584
<P>
         C.10.5 Polymorphic Argument Association (15.5.2.9) . . . . . . . . . . .          . . . . . . . . . . . . . 586
<P>
         C.10.6 Rules ensuring unambiguous generics (15.4.3.4.5) . . . . . . . . .         . . . . . . . . . . . . . 587
<P>
    C.11 Clause 16 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 591
<P>
         C.11.1 Atomic memory consistency . . . . . . . . . . . . . . . . . . . . .        . . . . . . . . . . . . . 591
<P>
         C.11.2 EVENT_QUERY example . . . . . . . . . . . . . . . . . . . . . .            . . . . . . . . . . . . . 593
<P>
         C.11.3 Collective subroutine examples . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . 595
<P>
    C.12 Clause 18 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>xii</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>C.12.1 Runtime environments (18.1) . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.2 Example of Fortran calling C (18.3) . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.3 Example of C calling Fortran (18.3) . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.4 Example of calling C functions with noninteroperable data (18.10) .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.5 Example of opaque communication between C and Fortran (18.3) .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.6 Using assumed type to interoperate with C . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.7 Using assumed-type variables in Fortran . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.8 Simplifying interfaces for arbitrary rank procedures . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.9 Processing assumed-shape arrays in C . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.10 Creating a contiguous copy of an array . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.11 Changing the attributes of an array . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.12 Creating an array section in C using CFI_section . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.13 Use of CFI_setpointer . . . . . . . . . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.14 Mapping of MPI interfaces to Fortran . . . . . . . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.13 Clause 19 notes : Examples of host association (19.5.1.4) . . . . . . . . . . .</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 615
<TABLE width=100% cellpadding=3><!-- tsb: Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 615
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
xiii
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>xiv</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
List of Tables
</TD></TR>
<TR><TD colspan=2>
<PRE>
  4.3  Previous editions of the Fortran International Standard . . . . . . . . . . . . . . . . . . . . 30
<P>
  5.1  Requirements on statement ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
<P>
  5.2  Statements allowed in scoping units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
<P>
  6.1  Special characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
<P>
  6.2  Adjacent keywords where separating blanks are optional . . . . . . . . . . . . . . . . . . . 53
<P>
  9.1  Subscript order value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
<P>
  10.1 Categories of operations and relative precedence . . . . . . . . . . . . . . . . . . . . . . . . 151
<P>
  10.2 Type of operands and results for intrinsic operators . . . . . . . . . . . . . . . . . . . . . . 154
<P>
  10.3 Interpretation of the numeric intrinsic operators . . . . . . . . . . . . . . . . . . . . . . . . 155
<P>
  10.4 Interpretation of the character intrinsic operator // . . . . . . . . . . . . . . . . . . . . . . 157
<P>
  10.5 Interpretation of the logical intrinsic operators . . . . . . . . . . . . . . . . . . . . . . . . . 158
<P>
  10.6 The values of operations involving logical intrinsic operators . . . . . . . . . . . . . . . . . 158
<P>
  10.7 Interpretation of the relational intrinsic operators . . . . . . . . . . . . . . . . . . . . . . . 159
<P>
  10.8 Intrinsic assignment type conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
<P>
  10.9 Numeric conversion and the assignment statement . . . . . . . . . . . . . . . . . . . . . . . 169
<P>
  13.1 E and D exponent forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
<P>
  13.2 EN exponent forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
<P>
  13.3 ES exponent forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
<P>
  16.1 Standard generic intrinsic procedure summary . . . . . . . . . . . . . . . . . . . . . . . . . 342
<P>
  16.2 Unrestricted specific intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348
<P>
  16.3 Restricted specific intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
<P>
  16.4 Default BOUNDARY values for EOSHIFT . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
<P>
  16.5 Characteristics of the result of NULL ( ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
<P>
  17.1 IEEE relational operator correspondence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
<P>
  17.2 IEEE_ARITHMETIC module procedure summary . . . . . . . . . . . . . . . . . . . . . . 450
<P>
</PRE>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
xv
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
   17.3 IEEE_EXCEPTIONS module procedure summary . . . . . . . . . . . . . . . . . . . . . . . 451
<P>
   18.1 Names of C characters with special semantics . . . . . . . . . . . . . . . . . . . . . . . . . . 480
<P>
   18.2 Interoperability between Fortran and C types . . . . . . . . . . . . . . . . . . . . . . . . . . 485
<P>
   18.3 ISO_Fortran_binding.h macros for attribute codes . . . . . . . . . . . . . . . . . . . . . . 494
<P>
   18.4 ISO_Fortran_binding.h macros for type codes . . . . . . . . . . . . . . . . . . . . . . . . . 494
<P>
   18.5 ISO_Fortran_binding.h macros for error codes . . . . . . . . . . . . . . . . . . . . . . . . . 495
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>xvi</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
Foreword
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
1 ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commis-
<P>
<PRE>
  sion) form the specialized system for worldwide standardization. National bodies that are members of ISO or
<P>
  IEC participate in the development of International Standards through technical committees established by the
<P>
  respective organization to deal with particular fields of technical activity. ISO and IEC technical committees
<P>
  collaborate in fields of mutual interest. Other international organizations, governmental and nongovernmental,
<P>
  in liaison with ISO and IEC, also take part in the work. In the field of information technology, ISO and IEC have
<P>
  established a joint technical committee, ISO/IEC JTC 1.
<P>
</PRE>
2 International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.
<P>
3 The main task of the joint technical committee is to prepare International Standards. Draft International Stand-
<P>
<PRE>
  ards adopted by the joint technical committee are circulated to national bodies for voting. Publication as an
<P>
  International Standard requires approval by at least 75 % of the national bodies casting a vote.
<P>
</PRE>
4 Attention is drawn to the possibility that some of the elements of this document may be the subject of patent
<P>
<PRE>
  rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.
<P>
</PRE>
5 ISO/IEC 1539-1 was prepared by Joint Technical Committee ISO/IEC JTC 1, Information technology, Subcom-
<P>
<PRE>
  mittee SC 22, Programming languages, their environments and system software interfaces.
<P>
</PRE>
6 This fourth edition cancels and replaces the third edition (ISO/IEC 1539-1:2010), which has been technic-
<P>
<PRE>
  ally revised. It also incorporates the Technical Corrigenda ISO/IEC 1539-1:2010/Cor. 1:2012, ISO/IEC 1539-
<P>
  1:2010/Cor. 2:2013, ISO/IEC 1539-1:2010/Cor. 3:2014, and ISO/IEC 1539-1:2010/Cor. 4:2016, and the Technical
<P>
  Specifications ISO/IEC TS 29113:2012 and ISO/IEC TS 18508:2015.
<P>
</PRE>
7 ISO/IEC 1539 consists of the following parts, under the general title Information technology — Programming
<P>
<PRE>
  languages — Fortran:
<P>
</PRE>
8 — Part 1: Base language
<P>
9 — Part 2: Varying length character strings
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        xvii
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  Introduction
<P>
</PRE>
1 This document comprises the specification of the base Fortran language, informally known as Fortran 2018.
<P>
<PRE>
  With the limitations noted in 4.3.3, the syntax and semantics of Fortran 2008 are contained entirely within
<P>
  Fortran 2018. Therefore, any standard-conforming Fortran 2008 program not affected by such limitations is a
<P>
  standard-conforming Fortran 2018 program. New features of Fortran 2018 can be compatibly incorporated into
<P>
  such Fortran 2008 programs, with any exceptions indicated in the text of this document.
<P>
</PRE>
2 Fortran 2018 contains several extensions to Fortran 2008; these are listed below.
<P>
<PRE>
     • Data declaration:
<P>
        Constant properties of an object declared in its entity-decl can be used in its initialization. The EQUIVAL-
<P>
        ENCE and COMMON statements and the block data program unit have been redundant since Fortran 90
<P>
        and are now specified to be obsolescent. Diagnosis of the appearance of a PROTECTED TARGET variable
<P>
        accessed by use association as a data-target in a structure constructor is required.
<P>
     • Data usage and computation:
<P>
        The declared type of the value supplied for a polymorphic allocatable component in a structure constructor
<P>
        is no longer required to be the same as the declared type of the component. FORALL is now specified to
<P>
        be obsolescent. The type and kind of an implied DO variable in an array constructor or DATA statement
<P>
        can be specified within the constructor or statement. The SELECT RANK construct provides structured
<P>
        access to the elements of an assumed-rank array. Completing execution of a BLOCK construct can cause
<P>
        the association status of a pointer with the PROTECTED attribute to become undefined. The standard
<P>
        intrinsic operations &lt;, &lt;=, &gt;, and &gt;= (also known as .LT., .LE., .GT., and .GE.) on IEEE numbers provide
<P>
        compareSignaling{relation} operations; the = and /= operations (also known as .EQ. and .NE.) provide
<P>
        compareQuiet{relation} operations. Finalization of an allocatable subobject during intrinsic assignment
<P>
        has been clarified.
<P>
     • Input/output:
<P>
        The SIZE= specifier can be used with advancing input. It is no longer prohibited to open a file on more than
<P>
        one unit. The value assigned by the RECL= specifier in an INQUIRE statement has been standardized.
<P>
        The values assigned by the POS= and SIZE= specifiers in an INQUIRE statement for a unit that has
<P>
        pending asynchronous operations have been standardized. The G0.d edit descriptor can be used for list
<P>
        items of type Integer, Logical, and Character. The D, E, EN, and ES edit descriptors can have a field width
<P>
        of zero, analogous to the F edit descriptor. The exponent width e in a data edit descriptor can be zero,
<P>
        analogous to a field width of zero. Floating-point formatted input accepts hexadecimal-significand numbers
<P>
        that conform to ISO/IEC/IEEE 60559:2011. The EX edit descriptor provides hexadecimal-significand
<P>
        formatted output conforming to ISO/IEC/IEEE 60559:2011. An error condition occurs if unacceptable
<P>
        characters are presented for logical or numeric editing during execution of a formatted input statement.
<P>
     • Execution control:
<P>
        The arithmetic IF statement has been deleted. Labeled DO loops have been redundant since Fortran 90
<P>
        and are now specified to be obsolescent. The nonblock DO construct has been deleted. The locality of a
<P>
        variable used in a DO CONCURRENT construct can be explicitly specified. The stop code in a STOP or
<P>
        ERROR STOP statement can be nonconstant. Output of the stop code and exception summary from the
<P>
        STOP and ERROR STOP statements can be controlled.
<P>
     • Intrinsic procedures and modules:
<P>
        In a reference to the intrinsic function CMPLX with an actual argument of type complex, no keyword
<P>
        is needed for a KIND argument. In references to the intrinsic functions ALL, ANY, FINDLOC, IALL,
<P>
        IANY, IPARITY, MAXLOC, MAXVAL, MINLOC, MINVAL, NORM2, PARITY, PRODUCT, SUM, and
<P>
        THIS_IMAGE, the actual argument for DIM can be a present optional dummy argument. The new intrinsic
<P>
        function COSHAPE returns the coshape of a coarray. The new intrinsic function OUT_OF_RANGE tests
<P>
        whether a numeric value can be safely converted to a different type or kind. The new intrinsic subroutine
<P>
        RANDOM_INIT establishes the initial state of the pseudorandom number generator used by RANDOM_-
<P>
        NUMBER. The new intrinsic function REDUCE performs user-specified array reductions. A processor is re-
<P>
        quired to report use of a nonstandard intrinsic procedure, use of a nonstandard intrinsic module, and use of a
<P>
        nonstandard procedure from a standard intrinsic module. Integer and logical arguments to intrinsic proced-
<P>
        ures and intrinsic module procedures that were previously required to be of default kind no longer have that
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>xviii</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
requirement, except for RANDOM_SEED. Specific names for intrinsic functions are now deemed obsoles-
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
cent. All standard procedures in the intrinsic module ISO_C_BINDING, other than C_F_POINTER, are
<P>
now pure. The arguments to the intrinsic function SIGN can be of different kind. Nonpolymorphic pointer
<P>
arguments to the intrinsic functions EXTENDS_TYPE_OF and SAME_TYPE_AS need not have defined
<P>
pointer association status. The effects of invoking the intrinsic procedures COMMAND_ARGUMENT_-
<P>
COUNT, GET_COMMAND, and GET_COMMAND_ARGUMENT, on images other than image one, are
<P>
no longer processor dependent. Access to error messages from the intrinsic subroutines GET_COMMAND,
<P>
GET_COMMAND_ARGUMENT, and GET_ENVIRONMENT_VARIABLE is provided by an optional
<P>
ERRMSG argument. The result of NORM2 for a zero-sized array argument has been clarified.
</TD></TR>
<TR><TD colspan=2>
• Program units and procedures:
</TD></TR>
<TR><TD colspan=2>
<PRE>
    The IMPORT statement can appear in a contained subprogram or BLOCK construct, and can restrict
<P>
    access via host association; diagnosis of violation of the IMPORT restrictions is required. The GENERIC
<P>
    statement can be used to declare generic interfaces. The number of procedure arguments is used in generic
<P>
    resolution. In a module, the default accessibility of entities accessed from another module can be controlled
<P>
    separately from the default accessibility of entities declared in the using module. An IMPLICIT NONE
<P>
    statement can require explicit declaration of the EXTERNAL attribute throughout a scoping unit and
<P>
    its contained scoping units. A defined operation need not specify INTENT (IN) for a dummy argument
<P>
    with the VALUE attribute. A defined assignment need not specify INTENT (IN) for the second dummy
<P>
    argument if it has the VALUE attribute. Procedures that are not declared with an asterisk type-param-value can
<P>
    be invoked recursively by default; the RECURSIVE keyword is advisory only. The NON_RECURSIVE
<P>
    keyword specifies that a procedure is not recursive. The ERROR STOP statement can appear in a pure
<P>
    subprogram. A dummy argument of a pure function is permitted in a variable definition context, if it has
<P>
    the VALUE attribute. A coarray dummy argument can be referenced or defined by another image.
<P>
</PRE>
• Features previously described by ISO/IEC TS 29113:2012:
</TD></TR>
<TR><TD colspan=2>
<PRE>
    A dummy data object can assume its rank from its effective argument. A dummy data object can assume
<P>
    the type from its effective argument, without having the ability to perform type selection. An interoper-
<P>
    able procedure can have dummy arguments that are assumed-type and/or assumed-rank. An interoperable
<P>
    procedure can have dummy data objects that are allocatable, assumed-shape, optional, or pointers. The
<P>
    character length of a dummy data object of an interoperable procedure can be assumed. The argument
<P>
    to C_LOC can be a noninteroperable array. The FPTR argument to C_F_POINTER can be a noninter-
<P>
    operable array pointer. The argument to C_FUNLOC can be a noninteroperable procedure. The FPTR
<P>
    argument to C_F_PROCPOINTER can be a noninteroperable procedure pointer.
<P>
    Additionally to ISO/IEC TS 29113:2012, an assumed-rank dummy data object that is not associated with
<P>
    an assumed-size array can be used as the argument to the function C_SIZEOF from the intrinsic module
<P>
    ISO_C_BINDING.
<P>
</PRE>
• Changes to the intrinsic modules IEEE_ARITHMETIC, IEEE_EXCEPTIONS, and IEEE_FEATURES
</TD></TR>
<TR><TD colspan=2>
<PRE>
    for conformance with ISO/IEC/IEEE 60559:2011:
<P>
    There is a new, optional, rounding mode IEEE_AWAY. The new type IEEE_MODES_TYPE encapsu-
<P>
    lates all floating-point modes. Features associated with subnormal numbers can be accessed with func-
<P>
    tions and types named . . . SUBNORMAL. . . (the old . . . DENORMAL. . . names remain). The new function
<P>
    IEEE_FMA performs fused multiply-add operations. The function IEEE_INT performs rounded conver-
<P>
    sions to integer type. The new functions IEEE_MAX_NUM, IEEE_MAX_NUM_MAG, IEEE_MIN_-
<P>
    NUM, and IEEE_MIN_NUM_MAG calculate maximum and minimum numeric values. The new func-
<P>
    tions IEEE_NEXT_DOWN and IEEE_NEXT_UP return the adjacent machine numbers. The new func-
<P>
    tions IEEE_QUIET_EQ, IEEE_QUIET_GE, IEEE_QUIET_GT, IEEE_QUIET_LE, IEEE_QUIET_-
<P>
    LT, and IEEE_QUIET_NE perform quiet comparisons. The new functions IEEE_SIGNALING_EQ,
<P>
    IEEE_SIGNALING_GE, IEEE_SIGNALING_GT, IEEE_SIGNALING_GE, IEEE_SIGNALING_LE,
<P>
    IEEE_SIGNALING_LT, and IEEE_SIGNALING_NE perform signaling comparisons. The decimal round-
<P>
    ing mode can be inquired and set independently of the binary rounding mode, using the RADIX argument
<P>
    to IEEE_GET_ROUNDING_MODE and IEEE_SET_ROUNDING_MODE. The new function IEEE_-
<P>
    REAL performs rounded conversions to real type. The function IEEE_REM now requires its arguments to
<P>
    have the same radix. The function IEEE_RINT now has a ROUND argument to perform specific rounding.
<P>
    The new function IEEE_SIGNBIT tests the sign bit of an IEEE number.
<P>
</PRE>
• Features previously described by ISO/IEC TS 18508:2015:
</TD></TR>
<TR><TD colspan=2>
<PRE>
    The CRITICAL statement has optional ERRMSG= and STAT= specifiers. The intrinsic subroutines
<P>
</PRE>
⃝
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
xix
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        ATOMIC_DEFINE and ATOMIC_REF have an optional STAT argument. The new intrinsic subroutines
<P>
        ATOMIC_ADD, ATOMIC_AND, ATOMIC_CAS, ATOMIC_FETCH_ADD, ATOMIC_FETCH_AND,
<P>
        ATOMIC_FETCH_OR, ATOMIC_FETCH_XOR, ATOMIC_OR, and ATOMIC_XOR perform atomic
<P>
        operations. The new intrinsic functions FAILED_IMAGES and STOPPED_IMAGES return indices of im-
<P>
        ages known to have failed or stopped respectively. The new intrinsic function IMAGE_STATUS returns the
<P>
        image execution status of an image. The intrinsic subroutine MOVE_ALLOC has optional ERRMSG and
<P>
        STAT arguments. The intrinsic functions IMAGE_INDEX and NUM_IMAGES have additional forms with
<P>
        a TEAM or TEAM_NUMBER argument. The intrinsic function THIS_IMAGE has an optional TEAM
<P>
        argument. The EVENT POST and EVENT WAIT statements, the intrinsic subroutine EVENT_QUERY,
<P>
        and the type EVENT_TYPE provide an event facility for one-sided segment ordering. The CHANGE
<P>
        TEAM construct, derived type TEAM_TYPE, FORM TEAM and SYNC TEAM statements, intrinsic
<P>
        functions GET_TEAM and TEAM_NUMBER, and the TEAM= and TEAM_NUMBER= specifiers on
<P>
        image selectors, provide a team facility for a subset of the program’s images to act in concert as if it were the
<P>
        set of all images. This team facility allows an allocatable coarray to be allocated or deallocated on a sub-
<P>
        set of images. The new intrinsic subroutines CO_BROADCAST, CO_MAX, CO_MIN, CO_REDUCE,
<P>
        and CO_SUM perform collective reduction operations on the images of the current team. The concept
<P>
        of failed images, the FAIL IMAGE statement, the STAT= specifier on image selectors, and the named
<P>
        constant STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV provide support for
<P>
        fault-tolerant parallel execution.
<P>
      • Changes to features previously described by ISO/IEC TS 18508:2015:
<P>
        The CHANGE TEAM and SYNC TEAM statements, and the TEAM= specifier on image selectors, permit
<P>
        the team to be specified by an expression. The intrinsic functions FAILED_IMAGES and STOPPED_-
<P>
        IMAGES have no restriction on the kind of their result. The name of the function argument to the
<P>
        intrinsic function CO_REDUCE is OPERATION instead of OPERATOR; this argument is not required to
<P>
        be commutative. The named constant STAT_UNLOCKED_FAILED_IMAGE from the intrinsic module
<P>
        ISO_FORTRAN_ENV indicates that a lock variable was locked by an image that failed. The team number
<P>
        for the initial team can be used in image selectors, and in the intrinsic functions NUM_IMAGES and
<P>
        IMAGE_INDEX. A team variable that appears in a CHANGE TEAM statement can no longer be defined
<P>
        or become undefined during execution of the CHANGE TEAM construct. All images of the current team
<P>
        are no longer required to execute the same CHANGE TEAM statement. A variable of type TEAM_TYPE
<P>
        from the intrinsic module ISO_FORTRAN_ENV is not permitted to be a coarray. A variable of type
<P>
        TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV can have a pointer component, and a
<P>
        team variable becomes undefined if assigned a value from another image.
<P>
</PRE>
3 This document is organized in 19 clauses, dealing with 8 conceptual areas. These 8 areas, and the clauses in
</TD></TR>
<TR><TD colspan=2>
<PRE>
  which they are treated, are:
<P>
                                 High/low level concepts               Clauses 4, 5, 6
<P>
                                 Data concepts                         Clauses 7, 8, 9
<P>
                                 Computations                          Clauses 10, 16, 17
<P>
                                 Execution control                     Clause 11
<P>
                                 Input/output                          Clauses 12, 13
<P>
                                 Program units                         Clauses 14, 15
<P>
                                 Interoperability with C               Clause 18
<P>
                                 Scoping and association rules         Clause 19
<P>
</PRE>
4 It also contains the following nonnormative material:
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 Processor dependencies                Annex A
<P>
                                 Deleted and obsolescent features      Annex B
<P>
                                 Extended notes                        Annex C
<P>
                                 Index                                 Index
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>xx</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
Information technology — Programming languages —
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
Fortran —
<P>
Part 1:
<P>
Base language
<P>
1 Scope
</TD></TR>
<TR><TD colspan=2>
1 This document specifies the form and establishes the interpretation of programs expressed in the base Fortran
</TD></TR>
<TR><TD colspan=2>
<PRE>
  language. The purpose of this document is to promote portability, reliability, maintainability, and efficient
<P>
  execution of Fortran programs for use on a variety of computing systems.
<P>
</PRE>
2 This document specifies
</TD></TR>
<TR><TD colspan=2>
<PRE>
     •  the forms that a program written in the Fortran language may take,
<P>
     •  the rules for interpreting the meaning of a program and its data,
<P>
     •  the form of the input data to be processed by such a program, and
<P>
     •  the form of the output data resulting from the use of such a program.
<P>
</PRE>
3 Except where stated otherwise, requirements and prohibitions specified by this document apply to programs
</TD></TR>
<TR><TD colspan=2>
<PRE>
  rather than processors.
<P>
</PRE>
4 This document does not specify
</TD></TR>
<TR><TD colspan=2>
<PRE>
     •  the mechanism by which programs are transformed for use on computing systems,
<P>
     •  the operations required for setup and control of the use of programs on computing systems,
<P>
     •  the method of transcription of programs or their input or output data to or from a storage medium,
<P>
     •  the program and processor behavior when this document fails to establish an interpretation except for the
<P>
        processor detection and reporting requirements in items (2) to (10) of 4.2,
<P>
     •  the maximum number of images, or the size or complexity of a program and its data that will exceed the
<P>
        capacity of any particular computing system or the capability of a particular processor,
<P>
     •  the mechanism for determining the number of images of a program,
<P>
     •  the physical properties of an image or the relationship between images and the computational elements of
<P>
        a computing system,
<P>
     •  the physical properties of the representation of quantities and the method of rounding, approximating, or
<P>
        computing numeric values on a particular processor, except by reference to ISO/IEC/IEEE 60559:2011
<P>
        under conditions specified in Clause 17,
<P>
     •  the physical properties of input/output records, files, and units, or
<P>
     •  the physical properties and implementation of storage.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>2</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 Normative references
</TD></TR>
<TR><TD colspan=2>
1 The following documents are referred to in the text in such a way that some or all of their content constitutes
</TD></TR>
<TR><TD colspan=2>
<PRE>
  requirements of this document. For dated references, only the edition cited applies. For undated references, the
<P>
  latest edition of the referenced document (including any amendments) applies.
<P>
  ISO/IEC 646:1991 (International Reference Version), Information technology—ISO 7-bit coded character set for
<P>
  information interchange
<P>
  ISO/IEC 9899:2011, Programming languages—C
<P>
  ISO/IEC 10646, Information technology—Universal Multiple-Octet Coded Character Set (UCS)
<P>
  ISO/IEC/IEEE 60559:2011, Information technology — Microprocessor Systems — Floating-Point arithmetic
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          3
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
<PRE>
                            (Blank page)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>4</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Terms and definitions
</TD></TR>
<TR><TD colspan=2>
1 For the purposes of this document, the following terms and definitions apply. ISO and IEC maintain terminological
</TD></TR>
<TR><TD colspan=2>
<PRE>
  databases for use in standardization at the following addresses:
<P>
      • IEC Electropedia: available at <A HREF="http://www.electropedia.org">http://www.electropedia.org</A>/
<P>
      • ISO Online browsing platform: available at <A HREF="http://www.iso.org/obp">http://www.iso.org/obp</A>
<P>
  3.1
<P>
  actual argument
<P>
  entity (R1524) that appears in a procedure reference
<P>
  3.2
<P>
  allocatable
<P>
  having the ALLOCATABLE attribute (8.5.3)
<P>
  3.3
<P>
  array
<P>
  set of scalar data, all of the same type and type parameters, whose individual elements are arranged in a
<P>
  rectangular pattern (8.5.8, 9.5)
<P>
  3.3.1
<P>
  array element
<P>
  scalar individual element of an array
<P>
  3.3.2
<P>
  array pointer
<P>
  array with the POINTER attribute (8.5.14)
<P>
  3.3.3
<P>
  array section
<P>
  array subobject designated by array-section, and which is itself an array (9.5.3.3)
<P>
  3.3.4
<P>
  assumed-shape array
<P>
  nonallocatable nonpointer dummy argument array that takes its shape from its effective argument (8.5.8.3)
<P>
  3.3.5
<P>
  assumed-size array
<P>
  dummy argument array whose size is assumed from that of its effective argument (8.5.8.5)
<P>
  3.3.6
<P>
  deferred-shape array
<P>
  allocatable array or array pointer, declared with a deferred-shape-spec-list (8.5.8.4)
<P>
  3.3.7
<P>
  explicit-shape array
<P>
  array declared with an explicit-shape-spec-list, which specifies explicit values for the bounds in each dimension of
<P>
  the array (8.5.8.2)
<P>
  3.4
<P>
  ASCII character
<P>
  character whose representation method corresponds to ISO/IEC 646:1991 (International Reference Version)
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             5
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
3.5
</TD></TR>
<TR><TD colspan=2>
associate name
</TD></TR>
<TR><TD colspan=2>
name of construct entity associated with a selector of an ASSOCIATE, CHANGE TEAM, SELECT RANK, or
</TD></TR>
<TR><TD colspan=2>
SELECT TYPE construct (11.1.3, 11.1.5, 11.1.10, 11.1.11)
</TD></TR>
<TR><TD colspan=2>
3.6
</TD></TR>
<TR><TD colspan=2>
associating entity
</TD></TR>
<TR><TD colspan=2>
⟨in a dynamically-established association⟩ the entity that did not exist prior to the establishment of the association
</TD></TR>
<TR><TD colspan=2>
(19.5.5)
</TD></TR>
<TR><TD colspan=2>
3.7
</TD></TR>
<TR><TD colspan=2>
association
</TD></TR>
<TR><TD colspan=2>
inheritance association, name association, pointer association, or storage association.
</TD></TR>
<TR><TD colspan=2>
3.7.1
</TD></TR>
<TR><TD colspan=2>
argument association
</TD></TR>
<TR><TD colspan=2>
association between an effective argument and a dummy argument (15.5.2)
</TD></TR>
<TR><TD colspan=2>
3.7.2
</TD></TR>
<TR><TD colspan=2>
construct association
</TD></TR>
<TR><TD colspan=2>
association between a selector and an associate name in an ASSOCIATE, CHANGE TEAM, SELECT RANK,
</TD></TR>
<TR><TD colspan=2>
or SELECT TYPE <B>construct</B>(11.1.3, 11.1.5, 11.1.10, 11.1.11, 19.5.1.6)
</TD></TR>
<TR><TD colspan=2>
3.7.3
</TD></TR>
<TR><TD colspan=2>
host association
</TD></TR>
<TR><TD colspan=2>
name association, other than argument association, between entities in a submodule or contained scoping unit
</TD></TR>
<TR><TD colspan=2>
and entities in its host (19.5.1.4)
</TD></TR>
<TR><TD colspan=2>
3.7.4
</TD></TR>
<TR><TD colspan=2>
inheritance association
</TD></TR>
<TR><TD colspan=2>
association between the inherited components of an extended type and the components of its parent component
</TD></TR>
<TR><TD colspan=2>
(19.5.4)
</TD></TR>
<TR><TD colspan=2>
3.7.5
</TD></TR>
<TR><TD colspan=2>
linkage association
</TD></TR>
<TR><TD colspan=2>
association between a variable or common block with the BIND attribute and a C global variable (18.9, 19.5.1.5)
</TD></TR>
<TR><TD colspan=2>
3.7.6
</TD></TR>
<TR><TD colspan=2>
name association
</TD></TR>
<TR><TD colspan=2>
argument association, construct association, host association, linkage association, or use association (19.5.1)
</TD></TR>
<TR><TD colspan=2>
3.7.7
</TD></TR>
<TR><TD colspan=2>
pointer association
</TD></TR>
<TR><TD colspan=2>
association between a pointer and an entity with the TARGET attribute (19.5.2)
</TD></TR>
<TR><TD colspan=2>
3.7.8
</TD></TR>
<TR><TD colspan=2>
storage association
</TD></TR>
<TR><TD colspan=2>
association between storage sequences (19.5.3)
</TD></TR>
<TR><TD colspan=2>
3.7.9
</TD></TR>
<TR><TD colspan=2>
use association
</TD></TR>
<TR><TD colspan=2>
association between entities in a module and entities in a scoping unit or construct that references that module,
</TD></TR>
<TR><TD colspan=2>
as specified by a USE statement (14.2.2)
</TD></TR>
<TR><TD colspan=2>
3.8
</TD></TR>
<TR><TD colspan=2>
assumed-rank dummy data object
</TD></TR>
<TR><TD colspan=2>
dummy data object that assumes the rank, shape, and size of its effective argument (8.5.8.7)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>6</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.9
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
assumed-type
<P>
declared with a <B>TYPE</B>(*) type specifier (7.3.2)
<P>
3.10
<P>
attribute
<P>
property of an entity that determines its uses (8.1)
<P>
3.11
<P>
automatic data object
<P>
nondummy data object with a type parameter or array bound that depends on the value of a specification-expr
<P>
that is not a constant expression (8.3)
<P>
3.12
<P>
base object
<P>
⟨data-ref ⟩ object designated by the leftmost part-name (9.4.2)
<P>
3.13
<P>
binding
<P>
type-bound procedure or final subroutine (7.5.5)
<P>
3.14
<P>
binding name
<P>
name given to a specific or generic type-bound procedure in the type definition (7.5.5)
<P>
3.15
<P>
binding label
<P>
default character value specifying the name by which a global entity with the BIND attribute is known to the
<P>
companion processor (18.10.2, 18.9.2)
<P>
3.16
<P>
block
<P>
sequence of executable constructs formed by the syntactic class block and which is treated as a unit by the
<P>
executable constructs described in 11.1
<P>
3.17
<P>
bound
<P>
array bound
<P>
limit of a dimension of an array (8.5.8)
<P>
3.18
<P>
branch target statement
<P>
action-stmt, associate-stmt, end-associate-stmt, if-then-stmt, end-if-stmt, select-case-stmt, end-select-stmt, select-
<P>
rank-stmt, end-select-rank-stmt, select-type-stmt, end-select-type-stmt, do-stmt, end-do-stmt, block-stmt, end-
<P>
block-stmt, critical-stmt, end-critical-stmt, forall-construct-stmt , where-construct-stmt, end-function-stmt, end-mp-
<P>
subprogram-stmt, end-program-stmt, or end-subroutine-stmt, whose statement label appears as a label in a GO TO
<P>
statement, computed GO TO statement, alt-return-spec, END= specifier, EOR= specifier, or ERR= specifier (11.2.1)
<P>
3.19
<P>
C address
<P>
value identifying the location of a data object or procedure either defined by the companion processor or which
<P>
might be accessible to the companion processor
<P>
<PRE>
     NOTE 3.1
<P>
     This is the concept that ISO/IEC 9899:2011 calls the address.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.20
<P>
C descriptor
<P>
C structure of type CFI_cdesc_t defined in the source file ISO_Fortran_binding.h (18.4, 18.5)
<P>
3.21
<P>
character context
<P>
within a character literal constant (7.4.4) or within a character string edit descriptor (13.3.2)
<P>
3.22
<P>
characteristics
<P>
⟨dummy argument⟩ being a dummy data object, dummy procedure, or an asterisk (alternate return indicator)
<P>
3.23
<P>
characteristics
<P>
⟨dummy data object⟩ properties listed in 15.3.2.2
<P>
3.24
<P>
characteristics
<P>
⟨dummy procedure or dummy procedure pointer⟩ properties listed in 15.3.2.3
<P>
3.25
<P>
characteristics
<P>
⟨function result⟩ properties listed in 15.3.3
<P>
3.26
<P>
characteristics
<P>
⟨procedure⟩ properties listed in 15.3.1
<P>
3.27
<P>
coarray
<P>
data entity that has nonzero corank (5.4.7)
<P>
3.27.1
<P>
established coarray
<P>
coarray that is accessible using an image-selector (5.4.8)
<P>
3.28
<P>
cobound
<P>
bound (limit) of a codimension (8.5.6)
<P>
3.29
<P>
codimension
<P>
dimension of the pattern formed by a set of corresponding coarrays (8.5.6)
<P>
3.30
<P>
coindexed object
<P>
data object whose designator includes an image-selector (R924, 9.6)
<P>
3.31
<P>
collating sequence
<P>
one-to-one mapping from a character set into the nonnegative integers (7.4.4.4)
<P>
3.32
<P>
common block
<P>
block of physical storage specified by a COMMON statement (8.10.2)
<P>
3.32.1
<P>
blank common
<P>
unnamed common block
<TABLE width=100% cellpadding=3><!-- tsb: unnamed common block
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>8</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.33
</TD></TR>
<TR><TD colspan=2>
companion processor
</TD></TR>
<TR><TD colspan=2>
processor-dependent mechanism by which global data and procedures may be referenced or defined (5.5.7)
</TD></TR>
<TR><TD colspan=2>
3.34
</TD></TR>
<TR><TD colspan=2>
component
</TD></TR>
<TR><TD colspan=2>
part of a derived type, or of an object of derived type, defined by a component-def-stmt (7.5.4)
</TD></TR>
<TR><TD colspan=2>
3.34.1
</TD></TR>
<TR><TD colspan=2>
direct component
</TD></TR>
<TR><TD colspan=2>
one of the components, or one of the direct components of a nonpointer nonallocatable component (7.5.1)
</TD></TR>
<TR><TD colspan=2>
3.34.2
</TD></TR>
<TR><TD colspan=2>
parent component
</TD></TR>
<TR><TD colspan=2>
component of an extended type whose type is that of the parent type and whose components are inheritance
</TD></TR>
<TR><TD colspan=2>
associated with the inherited components of the parent type (7.5.7.2)
</TD></TR>
<TR><TD colspan=2>
3.34.3
</TD></TR>
<TR><TD colspan=2>
potential subobject component
</TD></TR>
<TR><TD colspan=2>
nonpointer component, or potential subobject component of a nonpointer component (7.5.1)
</TD></TR>
<TR><TD colspan=2>
3.34.4
</TD></TR>
<TR><TD colspan=2>
subcomponent
</TD></TR>
<TR><TD colspan=2>
⟨structure⟩ direct component that is a subobject of the structure (9.4.2)
</TD></TR>
<TR><TD colspan=2>
3.34.5
</TD></TR>
<TR><TD colspan=2>
ultimate component
</TD></TR>
<TR><TD colspan=2>
component that is of intrinsic type, a pointer, or allocatable; or an ultimate component of a nonpointer nonal-
</TD></TR>
<TR><TD colspan=2>
locatable component of derived type
</TD></TR>
<TR><TD colspan=2>
3.35
</TD></TR>
<TR><TD colspan=2>
component order
</TD></TR>
<TR><TD colspan=2>
ordering of the nonparent components of a derived type that is used for intrinsic formatted input/output and
</TD></TR>
<TR><TD colspan=2>
structure constructors (where component keywords are not used) (7.5.4.7)
</TD></TR>
<TR><TD colspan=2>
3.36
</TD></TR>
<TR><TD colspan=2>
conformable
</TD></TR>
<TR><TD colspan=2>
⟨of two data entities⟩ having the same shape, or one being an array and the other being scalar
</TD></TR>
<TR><TD colspan=2>
3.37
</TD></TR>
<TR><TD colspan=2>
connected
</TD></TR>
<TR><TD colspan=2>
relationship between a unit and a file: each is connected if and only if the unit refers to the file (12.5.4)
</TD></TR>
<TR><TD colspan=2>
3.38
</TD></TR>
<TR><TD colspan=2>
constant
</TD></TR>
<TR><TD colspan=2>
data object that has a value and which cannot be defined, redefined, or become undefined during execution of a
</TD></TR>
<TR><TD colspan=2>
program (6.2.3, 9.3)
</TD></TR>
<TR><TD colspan=2>
3.38.1
</TD></TR>
<TR><TD colspan=2>
literal constant
</TD></TR>
<TR><TD colspan=2>
constant that does not have a name (R605, 7.4)
</TD></TR>
<TR><TD colspan=2>
3.38.2
</TD></TR>
<TR><TD colspan=2>
named constant
</TD></TR>
<TR><TD colspan=2>
named data object with the PARAMETER attribute (8.5.13)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.39
<P>
construct entity
<P>
entity whose identifier has the scope of a construct (19.1, 19.4)
<P>
3.40
<P>
constant expression
<P>
expression satisfying the requirements specified in 10.1.12, thus ensuring that its value is constant
<P>
3.41
<P>
contiguous
<P>
⟨array⟩ having array elements in order that are not separated by other data objects, as specified in 8.5.7
<P>
3.42
<P>
contiguous
<P>
⟨multi-part data object⟩ that the parts in order are not separated by other data objects
<P>
3.43
<P>
corank
<P>
number of codimensions of a coarray (zero for objects that are not coarrays) (8.5.6)
<P>
3.44
<P>
cosubscript
<P>
(R925) scalar integer expression in an image-selector (R924)
<P>
3.45
<P>
data entity
<P>
data object, result of the evaluation of an expression, or the result of the execution of a function reference
<P>
3.46
<P>
data object
<P>
object
<P>
constant (7.1.4), variable (9), or subobject of a constant (5.4.3.2.3)
<P>
3.47
<P>
decimal symbol
<P>
character that separates the whole and fractional parts in the decimal representation of a real number in a file
<P>
(13.6)
<P>
3.48
<P>
declaration
<P>
specification of attributes for various program entities
<P>
<PRE>
     NOTE 3.2
<P>
     Often this involves specifying the type of a named data object or specifying the shape of a named array
<P>
     object.
<P>
</PRE>
3.49
<P>
default initialization
<P>
mechanism for automatically initializing pointer components to have a defined pointer association status, and
<P>
nonpointer components to have a particular value (7.5.4.6)
<P>
3.50
<P>
default-initialized
<P>
⟨subcomponent⟩ subject to a default initialization specified in the type definition for that component (7.5.4.6)
<P>
3.51
<P>
definable
<P>
capable of definition and permitted to become defined
<TABLE width=100% cellpadding=3><!-- tsb: capable of definition and permitted to become defined
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>10</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.52
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
defined
<P>
⟨data object⟩ has a valid value
<P>
3.53
<P>
defined
<P>
⟨pointer⟩ has a pointer association status of associated or disassociated (19.5.2.2)
<P>
3.54
<P>
defined assignment
<P>
assignment defined by a procedure (10.2.1.4, 15.4.3.4.3)
<P>
3.55
<P>
defined input/output
<P>
input/output defined by a procedure and accessed via a defined-io-generic-spec (R1509, 12.6.4.8)
<P>
3.56
<P>
defined operation
<P>
operation defined by a procedure (10.1.6.1, 15.4.3.4.2)
<P>
3.57
<P>
definition
<P>
⟨data object⟩ process by which the data object becomes defined (19.6.5)
<P>
3.58
<P>
definition
<P>
⟨derived type (7.5.2), enumeration (7.6), or procedure (15.6)⟩ specification of the type, enumeration, or procedure
<P>
3.59
<P>
descendant
<P>
⟨module or submodule⟩ submodule that extends that module or submodule or that extends another descendant
<P>
thereof (14.2.3)
<P>
3.60
<P>
designator
<P>
name followed by zero or more component selectors, complex part selectors, array section selectors, array element
<P>
selectors, image selectors, and substring selectors (9.1)
<P>
3.60.1
<P>
complex part designator
<P>
designator that designates the real or imaginary part of a complex data object, independently of the other part
<P>
(9.4.4)
<P>
3.60.2
<P>
object designator
<P>
data object designator
<P>
designator for a data object
<P>
<PRE>
     NOTE 3.3
<P>
     An object name is a special case of an object designator.
<P>
</PRE>
3.60.3
<P>
procedure designator
<P>
designator for a procedure
<TABLE width=100% cellpadding=3><!-- tsb: designator for a procedure
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
11
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.61
<P>
disassociated
<P>
⟨pointer association⟩ pointer association status of not being associated with any target and not being undefined
<P>
(19.5.2.2)
<P>
3.62
<P>
disassociated
<P>
⟨pointer⟩ has a pointer association status of disassociated
<P>
3.63
<P>
dummy argument
<P>
entity whose identifier appears in a dummy argument list (R1536) in a FUNCTION, SUBROUTINE, ENTRY, or
<P>
statement function statement, or whose name can be used as an argument keyword in a reference to an intrinsic
<P>
procedure or a procedure in an intrinsic module
<P>
3.63.1
<P>
dummy data object
<P>
dummy argument that is a data object
<P>
3.63.2
<P>
dummy function
<P>
dummy procedure that is a function
<P>
3.64
<P>
effective argument
<P>
entity that is argument-associated with a dummy argument (15.5.2.3)
<P>
3.65
<P>
effective item
<P>
scalar object resulting from the application of the rules in 12.6.3 to an input/output list
<P>
3.66
<P>
elemental
<P>
independent scalar application of an action or operation to elements of an array or corresponding elements of a
<P>
set of conformable arrays and scalars, or possessing the capability of elemental operation
<P>
<PRE>
      NOTE 3.4
<P>
</PRE>
Combination of scalar and array operands or arguments combine the scalar <B>operand</B>(s) with each element
<TABLE width=100% cellpadding=3><!-- tsb: Combination of scalar and array operands or arguments combine the scalar <B>operand</B>(s) with each element
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
of the array <B>operand</B>(s).
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
3.66.1
<P>
elemental assignment
<P>
assignment that operates elementally
<P>
3.66.2
<P>
elemental operation
<P>
operation that operates elementally
<P>
3.66.3
<P>
elemental operator
<P>
operator in an elemental operation
<P>
3.66.4
<P>
elemental procedure
<P>
elemental intrinsic procedure or procedure defined by an elemental subprogram (15.8)
<TABLE width=100% cellpadding=3><!-- tsb: elemental intrinsic procedure or procedure defined by an elemental subprogram (15.8)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>12</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.66.5
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
elemental reference
<P>
reference to an elemental procedure with at least one array actual argument
<P>
3.66.6
<P>
elemental subprogram
<P>
subprogram with the ELEMENTAL prefix (15.8.1)
<P>
3.67
<P>
END statement
<P>
<PRE>
 end-block-data-stmt, end-function-stmt, end-module-stmt, end-mp-subprogram-stmt, end-program-stmt,
<P>
</PRE>
end-submodule-stmt, or end-subroutine-stmt
<P>
3.68
<P>
explicit initialization
<P>
initialization of a data object by a specification statement (8.4, 8.6.7)
<P>
3.69
<P>
extent
<P>
number of elements in a single dimension of an array
<P>
3.70
<P>
external file
<P>
file that exists in a medium external to the program (12.3)
<P>
3.71
<P>
external unit
<P>
external input/output unit
<P>
entity that can be connected to an external file (12.5.3, 12.5.4)
<P>
3.72
<P>
file storage unit
<P>
unit of storage in a stream file or an unformatted record file (12.3.5)
<P>
3.73
<P>
final subroutine
<P>
subroutine whose name appears in a FINAL statement (7.5.6) in a type definition, and which can be automatically
<P>
invoked by the processor when an object of that type is finalized (7.5.6.2)
<P>
3.74
<P>
finalizable
<P>
⟨type⟩ has a final subroutine or a nonpointer nonallocatable component of finalizable type
<P>
3.75
<P>
finalizable
<P>
⟨nonpointer data entity⟩ of finalizable type
<P>
3.76
<P>
finalization
<P>
process of calling final subroutines when one of the events listed in 7.5.6.3 occurs
<P>
3.77
<P>
function
<P>
procedure that is invoked by an expression
<P>
3.78
<P>
function result
<P>
entity that returns the value of a function (15.6.2.2)
<TABLE width=100% cellpadding=3><!-- tsb: entity that returns the value of a function (15.6.2.2)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
13
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.79
<P>
generic identifier
<P>
lexical token sequence that identifies a generic set of procedures, intrinsic operations, and/or intrinsic assignments
<P>
(15.4.3.4)
<P>
3.80
<P>
host instance
<P>
⟨internal procedure, or dummy procedure or procedure pointer associated with an internal procedure⟩ instance
<P>
of the host procedure that supplies the host environment of the internal procedure (15.6.2.4)
<P>
3.81
<P>
host scoping unit
<P>
host
<P>
scoping unit immediately surrounding another scoping unit, or the scoping unit extended by a submodule
<P>
3.82
<P>
IEEE infinity
<P>
ISO/IEC/IEEE 60559:2011 conformant infinite floating-point value
<P>
3.83
<P>
IEEE NaN
<P>
ISO/IEC/IEEE 60559:2011 conformant floating-point datum that does not represent a number
<P>
3.84
<P>
image
<P>
instance of a Fortran program (5.3.4)
<P>
3.84.1
<P>
active image
<P>
image that has not failed or stopped (5.3.6)
<P>
3.84.2
<P>
failed image
<P>
image that has not initiated termination but which has ceased to participate in program execution (5.3.6)
<P>
3.84.3
<P>
stopped image
<P>
image that has initiated normal termination (5.3.6)
<P>
3.85
<P>
image index
<P>
integer value identifying an image within a team
<P>
3.86
<P>
image control statement
<P>
statement that affects the execution ordering between images (11.6)
<P>
3.87
<P>
inclusive scope
<P>
nonblock scoping unit plus every block scoping unit whose host is that scoping unit or that is nested within such
<P>
a block scoping unit
<P>
<PRE>
      NOTE 3.5
<P>
</PRE>
That is, inclusive scope is the scope as if BLOCK constructs were not scoping units.
<TABLE width=100% cellpadding=3><!-- tsb: That is, inclusive scope is the scope as if BLOCK constructs were not scoping units.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>14</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.88
</TD></TR>
<TR><TD colspan=2>
inherit
</TD></TR>
<TR><TD colspan=2>
⟨extended type⟩ acquire entities (components, type-bound procedures, and type parameters) through type exten-
</TD></TR>
<TR><TD colspan=2>
sion from the parent type (7.5.7.2)
</TD></TR>
<TR><TD colspan=2>
3.89
</TD></TR>
<TR><TD colspan=2>
inquiry function
</TD></TR>
<TR><TD colspan=2>
intrinsic function, or function in an intrinsic module, whose result depends on the properties of one or more of
</TD></TR>
<TR><TD colspan=2>
its arguments instead of their values
</TD></TR>
<TR><TD colspan=2>
3.90
</TD></TR>
<TR><TD colspan=2>
interface
</TD></TR>
<TR><TD colspan=2>
⟨procedure⟩ name, procedure characteristics, dummy argument names, binding label, and generic identifiers
</TD></TR>
<TR><TD colspan=2>
(15.4.1)
</TD></TR>
<TR><TD colspan=2>
3.90.1
</TD></TR>
<TR><TD colspan=2>
abstract interface
</TD></TR>
<TR><TD colspan=2>
set of procedure characteristics with dummy argument names (15.4.1)
</TD></TR>
<TR><TD colspan=2>
3.90.2
</TD></TR>
<TR><TD colspan=2>
explicit interface
</TD></TR>
<TR><TD colspan=2>
interface of a procedure that includes all the characteristics of the procedure and names for its dummy arguments
</TD></TR>
<TR><TD colspan=2>
except for asterisk dummy arguments (15.4.2)
</TD></TR>
<TR><TD colspan=2>
3.90.3
</TD></TR>
<TR><TD colspan=2>
generic interface
</TD></TR>
<TR><TD colspan=2>
set of procedure interfaces identified by a generic identifier
</TD></TR>
<TR><TD colspan=2>
3.90.4
</TD></TR>
<TR><TD colspan=2>
implicit interface
</TD></TR>
<TR><TD colspan=2>
interface of a procedure that is not an explicit interface (15.4.2, 15.4.3.8)
</TD></TR>
<TR><TD colspan=2>
3.90.5
</TD></TR>
<TR><TD colspan=2>
specific interface
</TD></TR>
<TR><TD colspan=2>
interface identified by a nongeneric name
</TD></TR>
<TR><TD colspan=2>
3.91
</TD></TR>
<TR><TD colspan=2>
interface block
</TD></TR>
<TR><TD colspan=2>
abstract interface block, generic interface block, or specific interface block (15.4.3.2)
</TD></TR>
<TR><TD colspan=2>
3.91.1
</TD></TR>
<TR><TD colspan=2>
abstract interface block
</TD></TR>
<TR><TD colspan=2>
interface block with the ABSTRACT keyword; collection of interface bodies that specify named abstract interfaces
</TD></TR>
<TR><TD colspan=2>
3.91.2
</TD></TR>
<TR><TD colspan=2>
generic interface block
</TD></TR>
<TR><TD colspan=2>
interface block with a generic-spec; collection of interface bodies and procedure statements that are to be given
</TD></TR>
<TR><TD colspan=2>
that generic identifier
</TD></TR>
<TR><TD colspan=2>
3.91.3
</TD></TR>
<TR><TD colspan=2>
specific interface block
</TD></TR>
<TR><TD colspan=2>
interface block with no generic-spec or ABSTRACT keyword; collection of interface bodies that specify the
</TD></TR>
<TR><TD colspan=2>
interfaces of procedures
</TD></TR>
<TR><TD colspan=2>
3.92
</TD></TR>
<TR><TD colspan=2>
interoperable
</TD></TR>
<TR><TD colspan=2>
⟨Fortran entity⟩ equivalent to an entity defined by or definable by the companion processor (18.3)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
15
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.93
<P>
intrinsic
<P>
type, procedure, module, assignment, operator, or input/output operation defined in this document and accessible
<P>
without further definition or specification, or a procedure or module provided by a processor but not defined in
<P>
this document
<P>
3.93.1
<P>
standard intrinsic
<P>
⟨procedure or module⟩ defined in this document (16)
<P>
3.93.2
<P>
nonstandard intrinsic
<P>
⟨procedure or module⟩ provided by a processor but not defined in this document
<P>
3.94
<P>
internal file
<P>
character variable that is connected to an internal unit (12.4)
<P>
3.95
<P>
internal unit
<P>
input/output unit that is connected to an internal file (12.5.4)
<P>
3.96
<P>
ISO 10646 character
<P>
character whose representation method corresponds to UCS-4 in ISO/IEC 10646
<P>
3.97
<P>
keyword
<P>
statement keyword, argument keyword, type parameter keyword, or component keyword
<P>
3.97.1
<P>
argument keyword
<P>
word that identifies the corresponding dummy argument in an actual argument list (15.5.2.1)
<P>
3.97.2
<P>
component keyword
<P>
word that identifies a component in a structure constructor (7.5.10)
<P>
3.97.3
<P>
statement keyword
<P>
word that is part of the syntax of a statement (5.5.2)
<P>
3.97.4
<P>
type parameter keyword
<P>
word that identifies a type parameter in a type parameter list
<P>
3.98
<P>
lexical token
<P>
keyword, name, literal constant other than a complex literal constant, operator, label, delimiter, comma, =, =&gt;,
<P>
:, ::, ;, or % (6.2)
<P>
3.99
<P>
line
<P>
sequence of zero or more characters
<P>
3.100
<P>
main program
<P>
program unit that is not a subprogram, module, submodule, or block data program unit (14.1)
<TABLE width=100% cellpadding=3><!-- tsb: program unit that is not a subprogram, module, submodule, or block data program unit (14.1)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>16</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                 c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.101
</TD></TR>
<TR><TD colspan=2>
masked array assignment
</TD></TR>
<TR><TD colspan=2>
assignment statement in a WHERE statement or WHERE construct (10.2.3)
</TD></TR>
<TR><TD colspan=2>
3.102
</TD></TR>
<TR><TD colspan=2>
module
</TD></TR>
<TR><TD colspan=2>
program unit containing (or accessing from other modules) definitions that are to be made accessible to other
</TD></TR>
<TR><TD colspan=2>
program units (14.2)
</TD></TR>
<TR><TD colspan=2>
3.103
</TD></TR>
<TR><TD colspan=2>
name
</TD></TR>
<TR><TD colspan=2>
identifier of a program constituent, formed according to the rules given in 6.2.2
</TD></TR>
<TR><TD colspan=2>
3.104
</TD></TR>
<TR><TD colspan=2>
NaN
</TD></TR>
<TR><TD colspan=2>
Not a Number, a symbolic floating-point datum (ISO/IEC/IEEE 60559:2011)
</TD></TR>
<TR><TD colspan=2>
3.105
</TD></TR>
<TR><TD colspan=2>
operand
</TD></TR>
<TR><TD colspan=2>
data value that is the subject of an operator
</TD></TR>
<TR><TD colspan=2>
3.106
</TD></TR>
<TR><TD colspan=2>
operator
</TD></TR>
<TR><TD colspan=2>
intrinsic-operator, defined-unary-op, or defined-binary-op (R608, R1003, R1023)
</TD></TR>
<TR><TD colspan=2>
3.107
</TD></TR>
<TR><TD colspan=2>
passed-object dummy argument
</TD></TR>
<TR><TD colspan=2>
dummy argument of a type-bound procedure or procedure pointer component that becomes associated with the
</TD></TR>
<TR><TD colspan=2>
object through which the procedure is invoked (7.5.4.5)
</TD></TR>
<TR><TD colspan=2>
3.108
</TD></TR>
<TR><TD colspan=2>
pointer
</TD></TR>
<TR><TD colspan=2>
data pointer or procedure pointer
</TD></TR>
<TR><TD colspan=2>
3.108.1
</TD></TR>
<TR><TD colspan=2>
data pointer
</TD></TR>
<TR><TD colspan=2>
data entity with the POINTER attribute (8.5.14)
</TD></TR>
<TR><TD colspan=2>
3.108.2
</TD></TR>
<TR><TD colspan=2>
procedure pointer
</TD></TR>
<TR><TD colspan=2>
procedure with the EXTERNAL and POINTER attributes (8.5.9, 8.5.14)
</TD></TR>
<TR><TD colspan=2>
3.108.3
</TD></TR>
<TR><TD colspan=2>
local procedure pointer
</TD></TR>
<TR><TD colspan=2>
procedure pointer that is part of a local variable, or a named procedure pointer that is not a dummy argument
</TD></TR>
<TR><TD colspan=2>
or accessed by use or host association
</TD></TR>
<TR><TD colspan=2>
3.109
</TD></TR>
<TR><TD colspan=2>
pointer assignment
</TD></TR>
<TR><TD colspan=2>
association of a pointer with a target, by execution of a pointer assignment statement (10.2.2) or an intrinsic
</TD></TR>
<TR><TD colspan=2>
assignment statement (10.2.1.2) for a derived-type object that has the pointer as a subobject
</TD></TR>
<TR><TD colspan=2>
3.110
</TD></TR>
<TR><TD colspan=2>
polymorphic
</TD></TR>
<TR><TD colspan=2>
⟨data entity⟩ able to be of differing dynamic types during program execution (7.3.2.3)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
17
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.111
<P>
preconnected
<P>
⟨file or unit⟩ connected at the beginning of execution of the program (12.5.5)
<P>
3.112
<P>
procedure
<P>
entity encapsulating an arbitrary sequence of actions that can be invoked directly during program execution
<P>
3.112.1
<P>
dummy procedure
<P>
procedure that is a dummy argument (15.2.2.3)
<P>
3.112.2
<P>
external procedure
<P>
procedure defined by an external subprogram (R503) or by means other than Fortran (15.6.3)
<P>
3.112.3
<P>
internal procedure
<P>
procedure defined by an internal subprogram (R512)
<P>
3.112.4
<P>
module procedure
<P>
procedure defined by a module subprogram, or a procedure provided by an intrinsic module (R1408)
<P>
3.112.5
<P>
pure procedure
<P>
procedure declared or defined to be pure (15.7)
<P>
3.112.6
<P>
type-bound procedure
<P>
procedure that is bound to a derived type and referenced via an object of that type (7.5.5)
<P>
3.113
<P>
processor
<P>
combination of a computing system and mechanism by which programs are transformed for use on that computing
<P>
system
<P>
3.114
<P>
processor dependent
<P>
not completely specified in this document, having methods and semantics determined by the processor
<P>
3.115
<P>
program
<P>
set of Fortran program units and entities defined by means other than Fortran that includes exactly one main
<P>
program
<P>
3.116
<P>
program unit
<P>
main program, external subprogram, module, submodule, or block data program unit (5.2.1)
<P>
3.117
<P>
rank
<P>
number of array dimensions of a data entity (zero for a scalar entity)
<P>
3.118
<P>
record
<P>
sequence of values or characters in a file (12.2)
<TABLE width=100% cellpadding=3><!-- tsb: sequence of values or characters in a file (12.2)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>18</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                  c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.119
</TD></TR>
<TR><TD colspan=2>
record file
</TD></TR>
<TR><TD colspan=2>
file composed of a sequence of records (12.1)
</TD></TR>
<TR><TD colspan=2>
3.120
</TD></TR>
<TR><TD colspan=2>
reference
</TD></TR>
<TR><TD colspan=2>
data object reference, procedure reference, or module reference
</TD></TR>
<TR><TD colspan=2>
3.120.1
</TD></TR>
<TR><TD colspan=2>
data object reference
</TD></TR>
<TR><TD colspan=2>
appearance of a data object designator (9.1) in a context requiring its value at that point during execution
</TD></TR>
<TR><TD colspan=2>
3.120.2
</TD></TR>
<TR><TD colspan=2>
function reference
</TD></TR>
<TR><TD colspan=2>
appearance of the procedure designator for a function, or operator symbol for a defined operation, in a context
</TD></TR>
<TR><TD colspan=2>
requiring execution of the function during expression evaluation (15.5.3)
</TD></TR>
<TR><TD colspan=2>
3.120.3
</TD></TR>
<TR><TD colspan=2>
module reference
</TD></TR>
<TR><TD colspan=2>
appearance of a module name in a USE statement (14.2.2)
</TD></TR>
<TR><TD colspan=2>
3.120.4
</TD></TR>
<TR><TD colspan=2>
procedure reference
</TD></TR>
<TR><TD colspan=2>
appearance of a procedure designator, operator symbol, or assignment symbol in a context requiring execution
</TD></TR>
<TR><TD colspan=2>
of the procedure at that point during execution; or occurrence of defined input/output (13.7.6) or derived-type
</TD></TR>
<TR><TD colspan=2>
finalization (7.5.6.2)
</TD></TR>
<TR><TD colspan=2>
3.121
</TD></TR>
<TR><TD colspan=2>
saved
</TD></TR>
<TR><TD colspan=2>
having the SAVE attribute (8.5.16)
</TD></TR>
<TR><TD colspan=2>
3.122
</TD></TR>
<TR><TD colspan=2>
scalar
</TD></TR>
<TR><TD colspan=2>
data entity that can be represented by a single value of the type and that is not an array (9.5)
</TD></TR>
<TR><TD colspan=2>
3.123
</TD></TR>
<TR><TD colspan=2>
scoping unit
</TD></TR>
<TR><TD colspan=2>
BLOCK construct, derived-type definition, interface body, program unit, or subprogram, excluding all nested
</TD></TR>
<TR><TD colspan=2>
scoping units in it
</TD></TR>
<TR><TD colspan=2>
3.123.1
</TD></TR>
<TR><TD colspan=2>
block scoping unit
</TD></TR>
<TR><TD colspan=2>
scoping unit of a BLOCK construct
</TD></TR>
<TR><TD colspan=2>
3.124
</TD></TR>
<TR><TD colspan=2>
sequence
</TD></TR>
<TR><TD colspan=2>
set of elements ordered by a one-to-one correspondence with the numbers 1, 2, to n
</TD></TR>
<TR><TD colspan=2>
3.125
</TD></TR>
<TR><TD colspan=2>
sequence structure
</TD></TR>
<TR><TD colspan=2>
scalar data object of a sequence type (7.5.2.3)
</TD></TR>
<TR><TD colspan=2>
3.126
</TD></TR>
<TR><TD colspan=2>
sequence type
</TD></TR>
<TR><TD colspan=2>
derived type with the SEQUENCE attribute (7.5.2.3)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
19
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.126.1
<P>
character sequence type
<P>
sequence type with no allocatable or pointer components, and whose components are all default character or of
<P>
another character sequence type
<P>
3.126.2
<P>
numeric sequence type
<P>
sequence type with no allocatable or pointer components, and whose components are all default complex, default
<P>
integer, default logical, default real, double precision real, or of another numeric sequence type
<P>
3.127
<P>
shape
<P>
array dimensionality of a data entity, represented as a rank-one array whose size is the rank of the data entity
<P>
and whose elements are the extents of the data entity
<P>
<PRE>
     NOTE 3.6
<P>
     Thus the shape of a scalar data entity is an array with rank one and size zero.
<P>
</PRE>
3.128
<P>
simply contiguous
<P>
⟨array designator or variable⟩ satisfying the conditions specified in 9.5.4
<P>
<PRE>
     NOTE 3.7
<P>
     These conditions are simple ones which make it clear that the designator or variable designates a contiguous
<P>
     array.
<P>
</PRE>
3.129
<P>
size
<P>
⟨array⟩ total number of elements in the array
<P>
3.130
<P>
specification expression
<P>
expression satisfying the requirements specified in 10.1.11, thus being suitable for use in specifications
<P>
3.131
<P>
specific name
<P>
name that is not a generic name
<P>
3.132
<P>
standard-conforming program
<P>
program that uses only those forms and relationships described in, and has an interpretation according to, this
<P>
document
<P>
3.133
<P>
statement
<P>
sequence of one or more complete or partial lines satisfying a syntax rule that ends in <B>-stmt</B> (6.3)
<P>
3.133.1
<P>
executable statement
<P>
end-function-stmt, end-mp-subprogram-stmt, end-program-stmt, end-subroutine-stmt, or statement that is a mem-
<P>
ber of the syntactic class executable-construct, excluding those in the block-specification-part of a BLOCK con-
<P>
struct
<P>
3.133.2
<P>
nonexecutable statement
<P>
statement that is not an executable statement
<TABLE width=100% cellpadding=3><!-- tsb: statement that is not an executable statement
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>20</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.134
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
statement entity
<P>
entity whose identifier has the scope of a statement or part of a statement (19.1, 19.4)
<P>
3.135
<P>
statement label
<P>
label
<P>
unsigned positive number of up to five digits that refers to an individual statement (6.2.5)
<P>
3.136
<P>
storage sequence
<P>
contiguous sequence of storage units (19.5.3.2)
<P>
3.137
<P>
storage unit
<P>
character storage unit, numeric storage unit, file storage unit, or unspecified storage unit (19.5.3.2)
<P>
3.137.1
<P>
character storage unit
<P>
unit of storage that holds a default character value (19.5.3.2)
<P>
3.137.2
<P>
numeric storage unit
<P>
unit of storage that holds a default real, default integer, or default logical value (19.5.3.2)
<P>
3.137.3
<P>
unspecified storage unit
<P>
unit of storage that holds a value that is not default character, default real, double precision real, default logical,
<P>
or default complex (19.5.3.2)
<P>
3.138
<P>
stream file
<P>
file composed of a sequence of file storage units (12.1)
<P>
3.139
<P>
structure
<P>
scalar data object of derived type (7.5)
<P>
3.139.1
<P>
structure component
<P>
component of a structure
<P>
3.139.2
<P>
structure constructor
<P>
syntax (structure-constructor, 7.5.10) that specifies a structure value or creates such a value
<P>
3.140
<P>
submodule
<P>
program unit that extends a module or another submodule (14.2.3)
<P>
3.141
<P>
subobject
<P>
portion of data object that can be referenced, and if it is a variable defined, independently of any other portion
<P>
(9.4.2)
<P>
3.142
<P>
subprogram
<P>
function-subprogram (R1529) or subroutine-subprogram (R1534)
<TABLE width=100% cellpadding=3><!-- tsb: function-subprogram (R1529) or subroutine-subprogram (R1534)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
21
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.142.1
<P>
external subprogram
<P>
subprogram that is not contained in a main program, module, submodule, or another subprogram
<P>
3.142.2
<P>
internal subprogram
<P>
subprogram that is contained in a main program or another subprogram
<P>
3.142.3
<P>
module subprogram
<P>
subprogram that is contained in a module or submodule but is not an internal subprogram
<P>
3.143
<P>
subroutine
<P>
procedure invoked by a CALL statement, by defined assignment, or by some operations on derived-type entities
<P>
3.143.1
<P>
atomic subroutine
<P>
intrinsic subroutine that performs an action on its ATOM argument atomically (16.5)
<P>
3.143.2
<P>
collective subroutine
<P>
intrinsic subroutine that performs a calculation on a team of images without requiring synchronization
<P>
3.144
<P>
target
<P>
entity that is pointer associated with a pointer (19.5.2.2), entity on the right-hand-side of a pointer assignment
<P>
statement (R1033), or entity with the TARGET attribute (8.5.17)
<P>
3.145
<P>
team
<P>
ordered set of images created by execution of a FORM TEAM statement, or the initial ordered set of all images
<P>
3.145.1
<P>
current team
<P>
team specified by the most recently executed CHANGE TEAM statement of a CHANGE TEAM construct that
<P>
has not completed execution (11.1.5), or initial team if no CHANGE TEAM construct is being executed
<P>
3.145.2
<P>
initial team
<P>
team existing at the beginning of program execution, consisting of all images
<P>
3.145.3
<P>
parent team
<P>
⟨team except for initial team⟩ current team at time of execution of the FORM TEAM statement that created the
<P>
team (11.6.9)
<P>
3.145.4
<P>
team number
<P>
−1 which identifies the initial team, or positive integer that identifies a team within its parent team
<P>
3.146
<P>
transformational function
<P>
intrinsic function, or function in an intrinsic module, that is neither elemental nor an inquiry function
<TABLE width=100% cellpadding=3><!-- tsb: intrinsic function, or function in an intrinsic module, that is neither elemental nor an inquiry function
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>22</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.147
</TD></TR>
<TR><TD colspan=2>
type
</TD></TR>
<TR><TD colspan=2>
data type
</TD></TR>
<TR><TD colspan=2>
named category of data characterized by a set of values, a syntax for denoting these values, and a set of operations
</TD></TR>
<TR><TD colspan=2>
that interpret and manipulate the values (7.1)
</TD></TR>
<TR><TD colspan=2>
3.147.1
</TD></TR>
<TR><TD colspan=2>
abstract type
</TD></TR>
<TR><TD colspan=2>
type with the ABSTRACT attribute (7.5.7.1)
</TD></TR>
<TR><TD colspan=2>
3.147.2
</TD></TR>
<TR><TD colspan=2>
declared type
</TD></TR>
<TR><TD colspan=2>
type that a data entity is declared to have, either explicitly or implicitly (7.3.2, 10.1.9)
</TD></TR>
<TR><TD colspan=2>
3.147.3
</TD></TR>
<TR><TD colspan=2>
derived type
</TD></TR>
<TR><TD colspan=2>
type defined by a type definition (7.5) or by an intrinsic module
</TD></TR>
<TR><TD colspan=2>
3.147.4
</TD></TR>
<TR><TD colspan=2>
dynamic type
</TD></TR>
<TR><TD colspan=2>
type of a data entity at a particular point during execution of a program (7.3.2.3, 10.1.9)
</TD></TR>
<TR><TD colspan=2>
3.147.5
</TD></TR>
<TR><TD colspan=2>
extended type
</TD></TR>
<TR><TD colspan=2>
type with the EXTENDS attribute (7.5.7.1)
</TD></TR>
<TR><TD colspan=2>
3.147.6
</TD></TR>
<TR><TD colspan=2>
extensible type
</TD></TR>
<TR><TD colspan=2>
type that may be extended using the EXTENDS clause (7.5.7.1)
</TD></TR>
<TR><TD colspan=2>
3.147.7
</TD></TR>
<TR><TD colspan=2>
extension type
</TD></TR>
<TR><TD colspan=2>
⟨of one type with respect to another⟩ is the same type or is an extended type whose parent type is an extension
</TD></TR>
<TR><TD colspan=2>
type of the other type
</TD></TR>
<TR><TD colspan=2>
3.147.8
</TD></TR>
<TR><TD colspan=2>
intrinsic type
</TD></TR>
<TR><TD colspan=2>
type defined by this document that is always accessible (7.4)
</TD></TR>
<TR><TD colspan=2>
3.147.9
</TD></TR>
<TR><TD colspan=2>
numeric type
</TD></TR>
<TR><TD colspan=2>
one of the types integer, real, and complex
</TD></TR>
<TR><TD colspan=2>
3.147.10
</TD></TR>
<TR><TD colspan=2>
parent type
</TD></TR>
<TR><TD colspan=2>
⟨extended type⟩ type named in the EXTENDS clause
</TD></TR>
<TR><TD colspan=2>
3.147.11
</TD></TR>
<TR><TD colspan=2>
type compatible
</TD></TR>
<TR><TD colspan=2>
compatibility of the type of one entity with respect to another for purposes such as argument association, pointer
</TD></TR>
<TR><TD colspan=2>
association, and allocation (7.3.2)
</TD></TR>
<TR><TD colspan=2>
3.147.12
</TD></TR>
<TR><TD colspan=2>
type parameter
</TD></TR>
<TR><TD colspan=2>
value used to parameterize a type (7.2)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
23
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
3.147.12.1
<P>
assumed type parameter
<P>
length type parameter that assumes the type parameter value from another entity
<P>
<PRE>
     NOTE 3.8
<P>
     The other entity is
<P>
         • the selector for an associate name,
<P>
         • the constant-expr for a named constant of type character, or
<P>
         • the effective argument for a dummy argument.
<P>
</PRE>
3.147.12.2
<P>
deferred type parameter
<P>
length type parameter whose value can change during execution of a program and whose type-param-value is a
<P>
colon
<P>
3.147.12.3
<P>
kind type parameter
<P>
type parameter whose value is required to be defaulted or given by a constant expression
<P>
3.147.12.4
<P>
length type parameter
<P>
type parameter whose value is permitted to be assumed, deferred, or given by a specification expression
<P>
3.147.12.5
<P>
type parameter inquiry
<P>
syntax (type-param-inquiry) that is used to inquire the value of a type parameter of a data object (9.4.5)
<P>
3.147.12.6
<P>
type parameter order
<P>
ordering of the type parameters of a type (7.5.3.2) used for derived-type specifiers (derived-type-spec, 7.5.9)
<P>
3.148
<P>
ultimate argument
<P>
nondummy entity with which a dummy argument is associated via a chain of argument associations (15.5.2.3)
<P>
3.149
<P>
undefined
<P>
⟨data object⟩ does not have a valid value
<P>
3.150
<P>
undefined
<P>
⟨pointer⟩ does not have a pointer association status of associated or disassociated (19.5.2.2)
<P>
3.151
<P>
unit
<P>
input/output unit
<P>
means, specified by an io-unit, for referring to a file (12.5.1)
<P>
3.152
<P>
unlimited polymorphic
<P>
able to have any dynamic type during program execution (7.3.2.3)
<P>
3.153
<P>
unsaved
<P>
not having the SAVE attribute (8.5.16)
<TABLE width=100% cellpadding=3><!-- tsb: not having the SAVE attribute (8.5.16)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>24</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3.154
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
variable
<P>
data entity that can be defined and redefined during execution of a program
<P>
3.154.1
<P>
event variable
<P>
scalar variable of type EVENT_TYPE (16.10.2.10) from the intrinsic module ISO_FORTRAN_ENV
<P>
3.154.2
<P>
local variable
<P>
variable in a scoping unit that is not a dummy argument or part thereof, is not a global entity or part thereof,
<P>
and is not an entity or part of an entity that is accessible outside that scoping unit
<P>
3.154.3
<P>
lock variable
<P>
scalar variable of type LOCK_TYPE (16.10.2.19) from the intrinsic module ISO_FORTRAN_ENV
<P>
3.154.4
<P>
team variable
<P>
scalar variable of type TEAM_TYPE (16.10.2.32) from the intrinsic module ISO_FORTRAN_ENV
<P>
3.155
<P>
vector subscript
<P>
section-subscript that is an array (9.5.3.3.2)
<P>
3.156
<P>
whole array
<P>
array component or array name without further qualification (9.5.2)
<TABLE width=100% cellpadding=3><!-- tsb: array component or array name without further qualification (9.5.2)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
25
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>26</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Notation, conformance, and compatibility
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>4.1</B> </TD><TD valign=bottom>
Notation, symbols and abbreviated terms
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>4.1.1</B> </TD><TD valign=bottom>
Syntax rules
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Syntax rules describe the forms that Fortran lexical tokens, statements, and constructs may take. These syntax
</TD></TR>
<TR><TD colspan=2>
<PRE>
  rules are expressed in a variation of Backus-Naur form (BNF) with the following conventions.
<P>
      • Characters from the Fortran character set (6.1) are interpreted literally as shown, except where otherwise
<P>
        noted.
<P>
      • Lower-case italicized letters and words (often hyphenated and abbreviated) represent general syntactic
<P>
        classes for which particular syntactic entities shall be substituted in actual statements.
<P>
        Common abbreviations used in syntactic terms are:
<P>
                                      arg       for    argument       attr   for attribute
<P>
                                      decl      for    declaration    def    for definition
<P>
                                      desc      for    descriptor     expr   for expression
<P>
                                      int       for    integer        op     for operator
<P>
                                      spec      for    specifier      stmt   for statement
<P>
      • The syntactic metasymbols used are:
<P>
                                        is        introduces a syntactic class definition
<P>
                                        or        introduces a syntactic class alternative
<P>
                                        []        encloses an optional item
<P>
                                        [ ] &#46;&#46;&#46;   encloses an optionally repeated item
<P>
                                                     that may occur zero or more times
<P>
                                                  continues a syntax rule
<P>
      • Each syntax rule is given a unique identifying number of the form Rsnn, where s is a one- or two-digit
<P>
        clause number and nn is a two-digit sequence number within that clause. The syntax rules are distributed
<P>
        as appropriate throughout the text, and are referenced by number as needed. Some rules in Clauses 5 and
<P>
        6 are more fully described in later clauses; in such cases, the clause number s is the number of the later
<P>
        clause where the rule is repeated.
<P>
      • The syntax rules are not a complete and accurate syntax description of Fortran, and cannot be used to
<P>
        generate a Fortran parser automatically; where a syntax rule is incomplete, it is restricted by corresponding
<P>
        constraints and text.
<P>
       NOTE 4.1
<P>
       An example of the use of the syntax rules is:
<P>
                digit-string                        is   digit [ digit ] &#46;&#46;&#46;
<P>
       The following are examples of forms for a digit string allowed by the above rule:
<P>
             digit
<P>
             digit digit
<P>
             digit digit digit digit
<P>
             digit digit digit digit digit digit digit digit
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           27
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 4.1 (cont.)
<P>
        If particular entities are substituted for digit, actual digit strings might be:
<P>
               4
<P>
               67
<P>
               1999
<P>
               10243852
<P>
  4.1.2      Constraints
<P>
</PRE>
1 Each constraint is given a unique identifying number of the form Csnn, where s is a one- or two-digit clause
</TD></TR>
<TR><TD colspan=2>
<PRE>
  number and nn is a two- or three-digit sequence number within that clause.
<P>
</PRE>
2 Often a constraint is associated with a particular syntax rule. Where that is the case, the constraint is annotated
</TD></TR>
<TR><TD colspan=2>
<PRE>
  with the syntax rule number in parentheses. A constraint that is associated with a syntax rule constitutes part of
<P>
  the definition of the syntax term defined by the rule. It thus applies in all places where the syntax term appears.
<P>
</PRE>
3 Some constraints are not associated with particular syntax rules. The effect of such a constraint is similar to
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that of a restriction stated in the text, except that a processor is required to have the capability to detect and
<P>
  report violations of constraints (4.2). In some cases, a broad requirement is stated in text and a subset of the
<P>
  same requirement is also stated as a constraint. This indicates that a standard-conforming program is required to
<P>
  adhere to the broad requirement, but that a standard-conforming processor is required only to have the capability
<P>
  of diagnosing violations of the constraint.
<P>
  4.1.3      Assumed syntax rules
<P>
</PRE>
1 In order to minimize the number of additional syntax rules and convey appropriate constraint information, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  following rules are assumed.
<P>
  R401      xyz-list                       is  xyz [ , xyz ] &#46;&#46;&#46;
<P>
  R402      xyz-name                       is  name
<P>
  R403      scalar-xyz                     is  xyz
<P>
  C401      (R403) scalar-xyz shall be scalar.
<P>
</PRE>
2 The letters “xyz” stand for any syntactic class phrase. An explicit syntax rule for a term overrides an assumed
</TD></TR>
<TR><TD colspan=2>
<PRE>
  rule.
<P>
  4.1.4      Syntax conventions and characteristics
<P>
</PRE>
1 Any syntactic class name ending in “<B>-stmt</B>” follows the source form statement rules: it shall be delimited by
</TD></TR>
<TR><TD colspan=2>
<PRE>
  end-of-line or semicolon, and may be labeled unless it forms part of another statement (such as an IF or WHERE
<P>
  statement). Conversely, everything considered to be a source form statement is given a “-stmt” ending in the
<P>
  syntax rules.
<P>
</PRE>
2 The rules on statement ordering are described rigorously in the definition of program-unit (R502). Expression
</TD></TR>
<TR><TD colspan=2>
<PRE>
  hierarchy is described rigorously in the definition of expr (R1022).
<P>
</PRE>
3 The suffix “<B>-spec</B>” is used consistently for specifiers, such as input/output statement specifiers. It also is used for
</TD></TR>
<TR><TD colspan=2>
<PRE>
  type declaration attribute specifications (for example, “array-spec” in R815), and in a few other cases.
<P>
</PRE>
4 Where reference is made to a type parameter, including the surrounding parentheses, the suffix “<B>-selector</B>” is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  used. See, for example, “kind-selector” (R706) and “length-selector” (R722).
<P>
  28                                                                    ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
  4.1.5     Text conventions
<P>
</PRE>
1 In descriptive text, an equivalent English word is frequently used in place of a syntactic term. Particular state-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ments and attributes are identified in the text by an upper-case keyword, e.g., “END statement”. The descriptions
<P>
  of obsolescent features appear in a smaller type size.
<P>
       NOTE 4.2
<P>
       This sentence is an example of the type size used for obsolescent features.
<P>
  4.2      Conformance
<P>
</PRE>
1 A program (5.2.2) is a standard-conforming program if it uses only those forms and relationships described herein
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and if the program has an interpretation according to this document. A program unit (5.2.1) conforms to this
<P>
  document if it can be included in a program in a manner that allows the program to be standard conforming.
<P>
</PRE>
2 A processor conforms to this document if:
</TD></TR>
<TR><TD colspan=2>
<PRE>
        (1)     it executes any standard-conforming program in a manner that fulfills the interpretations herein,
<P>
                subject to any limits that the processor may impose on the size and complexity of the program;
<P>
        (2) it contains the capability to detect and report the use within a submitted program unit of a form
<P>
                designated herein as obsolescent, insofar as such use can be detected by reference to the numbered
<P>
                syntax rules and constraints;
<P>
        (3) it contains the capability to detect and report the use within a submitted program unit of a form or
<P>
                relationship that is not permitted by the numbered syntax rules or constraints, including the deleted
<P>
                features described in Annex B;
<P>
        (4) it contains the capability to detect and report the use within a submitted program unit of an intrinsic
<P>
                type with a kind type parameter value not supported by the processor (7.4);
<P>
        (5) it contains the capability to detect and report the use within a submitted program unit of source
<P>
                form or characters not permitted by Clause 6;
<P>
        (6) it contains the capability to detect and report the use within a submitted program of name usage
<P>
                not consistent with the scope rules for names, labels, operators, and assignment symbols in Clause
<P>
                19;
<P>
        (7) it contains the capability to detect and report the use within a submitted program unit of a non-
<P>
                standard intrinsic procedure (including one with the same name as a standard intrinsic procedure
<P>
                but with different requirements);
<P>
        (8) it contains the capability to detect and report the use within a submitted program unit of a non-
<P>
                standard intrinsic module;
<P>
        (9) it contains the capability to detect and report the use within a submitted program unit of a procedure
<P>
                from a standard intrinsic module, if the procedure is not defined by this document or the procedure
<P>
                has different requirements from those specified by this document; and
<P>
        (10) it contains the capability to detect and report the reason for rejecting a submitted program.
<P>
</PRE>
3 However, in a format specification that is not part of a FORMAT statement (13.2.1), a processor need not detect
</TD></TR>
<TR><TD colspan=2>
<PRE>
  or report the use of deleted or obsolescent features, or the use of additional forms or relationships.
<P>
</PRE>
4 A standard-conforming processor may allow additional forms and relationships provided that such additions
</TD></TR>
<TR><TD colspan=2>
<PRE>
  do not conflict with the standard forms and relationships. However, a standard-conforming processor may allow
<P>
  additional intrinsic procedures even though this could cause a conflict with the name of a procedure in a standard-
<P>
  conforming program. If such a conflict occurs and involves the name of an external procedure, the processor is
<P>
  permitted to use the intrinsic procedure unless the name has the EXTERNAL attribute (8.5.9) where it is used.
<P>
  A standard-conforming program shall not use nonstandard intrinsic procedures or modules that have been added
<P>
  by the processor.
<P>
</PRE>
5 Because a standard-conforming program may place demands on a processor that are not within the scope of this
</TD></TR>
<TR><TD colspan=2>
<PRE>
  document or may include standard items that are not portable, such as external procedures defined by means
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           29
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  other than Fortran, conformance to this document does not ensure that a program will execute consistently on
<P>
  all or any standard-conforming processors.
<P>
</PRE>
6 The semantics of facilities that are identified as processor dependent are not completely specified in this document.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  They shall be provided, with methods or semantics determined by the processor.
<P>
</PRE>
7 The processor should be accompanied by documentation that specifies the limits it imposes on the size and com-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  plexity of a program and the means of reporting when these limits are exceeded, that defines the additional forms
<P>
  and relationships it allows, and that defines the means of reporting the use of additional forms and relationships
<P>
  and the use of deleted or obsolescent forms. In this context, the use of a deleted form is the use of an additional
<P>
  form.
<P>
</PRE>
8 The processor should be accompanied by documentation that specifies the methods or semantics of processor-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  dependent facilities.
<P>
  4.3      Compatibility
<P>
  4.3.1     Previous Fortran standards
<P>
</PRE>
1 Table 4.3 lists the previous editions of the Fortran International Standard, along with their informal names.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      Table 4.3: Previous editions of the Fortran International Standard
<P>
                                          Official designation     Informal name
<P>
                                          ISO R 1539-1972          Fortran 66
<P>
                                          ISO 1539-1980            Fortran 77
<P>
                                          ISO/IEC 1539:1991        Fortran 90
<P>
                                          ISO/IEC 1539-1:1997      Fortran 95
<P>
                                          ISO/IEC 1539-1:2004      Fortran 2003
<P>
                                          ISO/IEC 1539-1:2010      Fortran 2008
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>4.3.2</B> </TD><TD valign=bottom>
New intrinsic procedures
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Each Fortran International Standard since ISO 1539:1980 (Fortran 77), defines more intrinsic procedures than
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the previous one. Therefore, a Fortran program conforming to an older standard might have a different inter-
<P>
  pretation under a newer standard if it invokes an external procedure having the same name as one of the new
<P>
  standard intrinsic procedures, unless that procedure is specified to have the EXTERNAL attribute.
<P>
  4.3.3     Fortran 2008 compatibility
<P>
</PRE>
1 Except as identified in this subclause, and except for the deleted features noted in Annex B.2, this document is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  an upward compatible extension to the preceding Fortran International Standard, ISO/IEC 1539-1:2010 (Fortran
<P>
  2008). Any standard-conforming Fortran 2008 program that does not use any deleted features, and does not use
<P>
  any feature identified in this subclause as being no longer permitted, remains standard-conforming under this
<P>
  document.
<P>
</PRE>
2 Fortran 2008 specifies that the IOSTAT= variable shall be set to a processor-dependent negative value if the flush
</TD></TR>
<TR><TD colspan=2>
<PRE>
  operation is not supported for the unit specified. This document specifies that the processor-dependent negative
<P>
  integer value shall be different from the named constants IOSTAT_EOR or IOSTAT_END from the intrinsic
<P>
  module ISO_FORTRAN_ENV.
<P>
</PRE>
3 Fortran 2008 permitted a noncontiguous array that was supplied as an actual argument corresponding to a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  contiguous INTENT (INOUT) dummy argument in one iteration of a DO CONCURRENT construct, without
<P>
  being previously defined in that iteration, to be defined in another iteration; this document does not permit this.
<P>
  30                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Fortran 2008 permitted a pure statement function to reference a volatile variable, and permitted a local variable
</TD></TR>
<TR><TD colspan=2>
<PRE>
   of a pure subprogram or of a BLOCK construct within a pure subprogram to be volatile (provided it was not
<P>
   used); this document does not permit that.
<P>
</PRE>
5 Fortran 2008 permitted a pure function to have a result that has a polymorphic allocatable ultimate component;
</TD></TR>
<TR><TD colspan=2>
<PRE>
   this document does not permit that.
<P>
</PRE>
6 Fortran 2008 permitted a PROTECTED TARGET variable accessed by use association to be used as an initial-
</TD></TR>
<TR><TD colspan=2>
<PRE>
   data-target; this document does not permit that.
<P>
</PRE>
7 Fortran 2008 permitted a named constant to have declared type LOCK_TYPE, or have a noncoarray potential
</TD></TR>
<TR><TD colspan=2>
<PRE>
   subobject component with declared type LOCK_TYPE; this document does not permit that.
<P>
</PRE>
8 Fortran 2008 permitted a polymorphic object to be finalized within a DO CONCURRENT construct; this docu-
</TD></TR>
<TR><TD colspan=2>
<PRE>
   ment does not permit that.
<P>
</PRE>
9 Fortran 2008 permitted an unallocated allocatable coarray or coindexed object to be allocated by an assignment
</TD></TR>
<TR><TD colspan=2>
<PRE>
   statement, provided it was scalar, nonpolymorphic, and had no deferred type parameters; this document does
<P>
   not permit that.
<P>
   4.3.4    Fortran 2003 compatibility
<P>
</PRE>
1 Except as identified in this subclause, this document is an upward compatible extension to ISO/IEC 1539-1:2004
</TD></TR>
<TR><TD colspan=2>
<PRE>
   (Fortran 2003). Except as identified in this subclause, any standard-conforming Fortran 2003 program remains
<P>
   standard-conforming under this document.
<P>
</PRE>
2 Fortran 2003 permitted a sequence type to have type parameters; that is not permitted by this document.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 Fortran 2003 specified that array constructors and structure constructors of finalizable type are finalized. This
<P>
<PRE>
   document specifies that these constructors are not finalized.
<P>
</PRE>
4 The form produced by the G edit descriptor for some values and some input/output rounding modes differs from
<P>
<PRE>
   that specified by Fortran 2003.
<P>
</PRE>
5 Fortran 2003 required an explicit interface only for a procedure that was actually referenced in the scope, not
<P>
<PRE>
   merely passed as an actual argument. This document requires an explicit interface for a procedure under the
<P>
   conditions listed in 15.4.2.2, regardless of whether the procedure is referenced in the scope.
<P>
</PRE>
6 Fortran 2003 permitted the function result of a pure function to be a polymorphic allocatable variable, to have
<P>
<PRE>
   a polymorphic allocatable ultimate component, or to be finalizable by an impure final subroutine. These are not
<P>
   permitted by this document.
<P>
</PRE>
7 Fortran 2003 permitted an INTENT (OUT) argument of a pure subroutine to be polymorphic; that is not
<P>
<PRE>
   permitted by this document.
<P>
</PRE>
8 Fortran 2003 interpreted assignment to an allocatable variable from a nonconformable array as intrinsic assign-
<P>
<PRE>
   ment, even when an elemental defined assignment was in scope; this document does not permit assignment from
<P>
   a nonconformable array in this context.
<P>
</PRE>
9 Fortran 2003 permitted a statement function to be of parameterized derived type; this document does not permit
<P>
<PRE>
   that.
<P>
</PRE>
10 Fortran 2003 permitted a pure statement function to reference a volatile variable, and permitted a local variable
<P>
<PRE>
   of a pure subprogram to be volatile (provided it was not used); this document does not permit that.
<P>
   4.3.5    Fortran 95 compatibility
<P>
</PRE>
1 Except as identified in this subclause, this document is an upward compatible extension to ISO/IEC 1539-1:1997
<P>
<PRE>
   (Fortran 95). Except as identified in this subclause, any standard-conforming Fortran 95 program remains
<P>
   standard-conforming under this document.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                         31
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
2 Fortran 95 permitted defined assignment between character strings of the same rank and different kinds. This
</TD></TR>
<TR><TD colspan=2>
<PRE>
  document does not permit that if both of the different kinds are ASCII, ISO 10646, or default kind.
<P>
</PRE>
3 The following Fortran 95 features might have different interpretations in this document.
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • Earlier Fortran standards had the concept of printing, meaning that column one of formatted output had
<P>
        special meaning for a processor-dependent (possibly empty) set of external files. This could be neither
<P>
        detected nor specified by a standard-specified means. The interpretation of the first column is not specified
<P>
        by this document.
<P>
      • This document specifies a different output format for real zero values in list-directed and namelist output.
<P>
      • If the processor distinguishes between positive and negative real zero, this document requires different
<P>
        returned values for ATAN2(Y,X) when X &lt; 0 and Y is negative real zero and for LOG(X) and SQRT(X)
<P>
        when X is complex with X%RE &lt; 0 and X%IM is negative real zero.
<P>
      • This document has fewer restrictions on constant expressions than Fortran 95; this might affect whether a
<P>
        variable is considered to be an automatic data object.
<P>
      • The form produced by the G edit descriptor with d equal to zero differs from that specified by Fortran 95
<P>
        for some values.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>4.3.6</B> </TD><TD valign=bottom>
Fortran 90 compatibility
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Except for the deleted features noted in Annex B.1, and except as identified in this subclause, this document
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is an upward compatible extension to ISO/IEC 1539:1991 (Fortran 90). Any standard-conforming Fortran 90
<P>
  program that does not use one of the deleted features remains standard-conforming under this document.
<P>
</PRE>
2 The PAD= specifier in the INQUIRE statement in this document returns the value UNDEFINED if there is no
</TD></TR>
<TR><TD colspan=2>
<PRE>
  connection or the connection is for unformatted input/output. Fortran 90 specified YES.
<P>
</PRE>
3 Fortran 90 specified that if the second argument to MOD or MODULO was zero, the result was processor
</TD></TR>
<TR><TD colspan=2>
<PRE>
  dependent. This document specifies that the second argument shall not be zero.
<P>
</PRE>
4 Fortran 90 permitted defined assignment between character strings of the same rank and different kinds. This
</TD></TR>
<TR><TD colspan=2>
<PRE>
  document does not permit that if both of the different kinds are ASCII, ISO 10646, or default kind.
<P>
</PRE>
5 The following Fortran 90 features have different interpretations in this document:
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • if the processor distinguishes between positive and negative real zero, the result value of the intrinsic function
<P>
        SIGN when the second argument is a negative real zero;
<P>
      • formatted output of negative real values (when the output value is zero);
<P>
      • whether an expression is a constant expression (thus whether a variable is considered to be an automatic
<P>
        data object);
<P>
      • the G edit descriptor with d equal to zero for some values.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>4.3.7</B> </TD><TD valign=bottom>
FORTRAN 77 compatibility
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Except for the deleted features noted in Annex B.1, and except as identified in this subclause, this document is an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  upward compatible extension to ISO 1539:1980 (Fortran 77). Any standard-conforming Fortran 77 program
<P>
  that does not use one of the deleted features noted in Annex B.1 and that does not depend on the differences
<P>
  specified here remains standard-conforming under this document. This document restricts the behavior for some
<P>
  features that were processor dependent in Fortran 77. Therefore, a standard-conforming Fortran 77 program
<P>
  that uses one of these processor-dependent features might have a different interpretation under this document, yet
<P>
  remain a standard-conforming program. The following Fortran 77 features might have different interpretations
<P>
  in this document.
<P>
      • Fortran 77 permitted a processor to supply more precision derived from a default real constant than can
<P>
        be represented in a default real datum when the constant is used to initialize a double precision real data
<P>
        object in a DATA statement. This document does not permit a processor this option.
<P>
  32                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
      • If a named variable that was not in a common block was initialized in a DATA statement and did not have
<P>
        the SAVE attribute specified, Fortran 77 left its SAVE attribute processor dependent. This document
<P>
        specifies (8.6.7) that this named variable has the SAVE attribute.
<P>
      • Fortran 77 specified that the number of characters required by the input list was to be less than or equal
<P>
        to the number of characters in the record during formatted input. This document specifies (12.6.4.5.3) that
<P>
        the input record is logically padded with blanks if there are not enough characters in the record, unless the
<P>
        PAD= specifier with the value ’NO’ is specified in an appropriate OPEN or READ statement.
<P>
      • A value of 0 for a list item in a formatted output statement will be formatted in a different form for some
<P>
        G edit descriptors. In addition, this document specifies how rounding of values will affect the output field
<P>
        form, but Fortran 77 did not address this issue. Therefore, the form produced for certain combinations
<P>
        of values and G edit descriptors might differ from that produced by some Fortran 77 processors.
<P>
      • Fortran 77 did not permit a processor to distinguish between positive and negative real zero; if the
<P>
        processor does so distinguish, the result will differ for the intrinsic function SIGN when the second argument
<P>
        is negative real zero, and formatted output of negative real zero will be different.
<P>
  4.4      Deleted and obsolescent features
<P>
  4.4.1     General
<P>
</PRE>
1 This document protects the users’ investment in existing software by including all but six of the language elements
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of Fortran 90 that are not processor dependent. This document identifies two categories of outmoded features.
<P>
  The first category, deleted features, consists of features considered to have been redundant in Fortran 77 and
<P>
  largely unused in Fortran 90. Those in the second category, obsolescent features, are considered to have been
<P>
  redundant in Fortran 90 and Fortran 95, but are still frequently used.
<P>
  4.4.2     Nature of deleted features
<P>
</PRE>
1 There are two groups of deleted features. The first group contains features for which better methods existed in
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Fortran 77; these features were not included in Fortran 95, Fortran 2003, or Fortran 2008, and are not included
<P>
  in this document. The second group contains features for which better methods existed in Fortran 90; these
<P>
  features were included in Fortran 2008, but are not included in this document.
<P>
  4.4.3     Nature of obsolescent features
<P>
</PRE>
1 Better methods existed in Fortran 90 and Fortran 95 for each obsolescent feature. It is recommended that
</TD></TR>
<TR><TD colspan=2>
<PRE>
  programmers use these better methods in new programs and convert existing code to these methods.
<P>
</PRE>
2 The obsolescent features are identified in the text of this document by a distinguishing type font (4.1.5).
</TD></TR>
<TR><TD colspan=2>
3 A future revision of this document might delete an obsolescent feature if its use has become insignificant.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            33
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
<PRE>
                            (Blank page)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>34</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Fortran concepts
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>5.1</B> </TD><TD valign=bottom>
High level syntax
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 This subclause introduces the syntax associated with program units and other Fortran concepts above the con-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  struct, statement, and expression levels and illustrates their relationships.
<P>
       NOTE 5.1
<P>
       Constraints and other information related to the rules that do not begin with R5 appear in the appropriate
<P>
       clause.
<P>
  R501     program                     is   program-unit
<P>
                                                 [ program-unit ] &#46;&#46;&#46;
<P>
  R502     program-unit                is   main-program
<P>
                                       or   external-subprogram
<P>
                                       or   module
<P>
                                       or   submodule
<P>
                                       or   block-data
<P>
  R1401 main-program                   is   [ program-stmt ]
<P>
                                                 [ specification-part ]
<P>
                                                 [ execution-part ]
<P>
                                                 [ internal-subprogram-part ]
<P>
                                                 end-program-stmt
<P>
  R503     external-subprogram         is function-subprogram
<P>
                                       or subroutine-subprogram
<P>
  R1529 function-subprogram            is   function-stmt
<P>
                                                 [ specification-part ]
<P>
                                                 [ execution-part ]
<P>
                                                 [ internal-subprogram-part ]
<P>
                                                 end-function-stmt
<P>
  R1534 subroutine-subprogram          is   subroutine-stmt
<P>
                                                 [ specification-part ]
<P>
                                                 [ execution-part ]
<P>
                                                 [ internal-subprogram-part ]
<P>
                                                 end-subroutine-stmt
<P>
  R1404 module                         is   module-stmt
<P>
                                                 [ specification-part ]
<P>
                                                 [ module-subprogram-part ]
<P>
                                                 end-module-stmt
<P>
  R1416 submodule                      is   submodule-stmt
<P>
                                                 [ specification-part ]
<P>
                                                 [ module-subprogram-part ]
<P>
                                                 end-submodule-stmt
<P>
  R1420    block-data                  is   block-data-stmt
<P>
                                                 [ specification-part ]
<P>
                                                 end-block-data-stmt
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        35
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R504</B> </TD><TD valign=bottom>
specification-part         is [ use-stmt ] &#46;&#46;&#46;
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         [ import-stmt ] &#46;&#46;&#46;
<P>
                                         [ implicit-part ]
<P>
                                         [ declaration-construct ] &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R505</B> </TD><TD valign=bottom>
implicit-part              is [ implicit-part-stmt ] &#46;&#46;&#46;
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         implicit-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R506</B> </TD><TD valign=bottom>
implicit-part-stmt         is implicit-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 or parameter-stmt
<P>
                                 or format-stmt
<P>
                                 or entry-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R507</B> </TD><TD valign=bottom>
declaration-construct      is specification-construct
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 or data-stmt
<P>
                                 or format-stmt
<P>
                                 or entry-stmt
<P>
                                 or stmt-function-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R508</B> </TD><TD valign=bottom>
specification-construct    is derived-type-def
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 or enum-def
<P>
                                 or generic-stmt
<P>
                                 or interface-block
<P>
                                 or parameter-stmt
<P>
                                 or procedure-declaration-stmt
<P>
                                 or other-specification-stmt
<P>
                                 or type-declaration-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R509</B> </TD><TD valign=bottom>
execution-part             is executable-construct
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         [ execution-part-construct ] &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R510</B> </TD><TD valign=bottom>
execution-part-construct   is executable-construct
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 or format-stmt
<P>
                                 or entry-stmt
<P>
                                 or data-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R511</B> </TD><TD valign=bottom>
internal-subprogram-part   is contains-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         [ internal-subprogram ] &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R512</B> </TD><TD valign=bottom>
internal-subprogram        is function-subprogram
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 or subroutine-subprogram
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1407 module-subprogram-part</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is contains-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         [ module-subprogram ] &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1408 module-subprogram</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is function-subprogram
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 or subroutine-subprogram
<P>
                                 or separate-module-subprogram
<P>
</PRE>
R1538 separate-module-subprogram is mp-subprogram-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         [ specification-part ]
<P>
                                         [ execution-part ]
<P>
                                         [ internal-subprogram-part ]
<P>
                                         end-mp-subprogram-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R513</B> </TD><TD valign=bottom>
other-specification-stmt   is access-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 or allocatable-stmt
<P>
                                 or asynchronous-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>36</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                       ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
or bind-stmt
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
or codimension-stmt
<P>
or contiguous-stmt
<P>
or dimension-stmt
<P>
or external-stmt
<P>
or intent-stmt
<P>
or intrinsic-stmt
<P>
or namelist-stmt
<P>
or optional-stmt
<P>
or pointer-stmt
<P>
or protected-stmt
<P>
or save-stmt
<P>
or target-stmt
<P>
or volatile-stmt
<P>
or value-stmt
<P>
or common-stmt
<P>
or equivalence-stmt
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R514 executable-construct</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is action-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                            or associate-construct
<P>
                            or block-construct
<P>
                            or case-construct
<P>
                            or change-team-construct
<P>
                            or critical-construct
<P>
                            or do-construct
<P>
                            or if-construct
<P>
                            or select-rank-construct
<P>
                            or select-type-construct
<P>
                            or where-construct
<P>
                            or forall-construct
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>R515 action-stmt</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is allocate-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                            or assignment-stmt
<P>
                            or backspace-stmt
<P>
                            or call-stmt
<P>
                            or close-stmt
<P>
                            or continue-stmt
<P>
                            or cycle-stmt
<P>
                            or deallocate-stmt
<P>
                            or endfile-stmt
<P>
                            or error-stop-stmt
<P>
                            or event-post-stmt
<P>
                            or event-wait-stmt
<P>
                            or exit-stmt
<P>
                            or fail-image-stmt
<P>
                            or flush-stmt
<P>
                            or form-team-stmt
<P>
                            or goto-stmt
<P>
                            or if-stmt
<P>
                            or inquire-stmt
<P>
                            or lock-stmt
<P>
                            or nullify-stmt
<P>
                            or open-stmt
<P>
                            or pointer-assignment-stmt
<P>
                            or print-stmt
<P>
                            or read-stmt
<P>
</PRE>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
37
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                                         or  return-stmt
<P>
                                         or  rewind-stmt
<P>
                                         or  stop-stmt
<P>
                                         or  sync-all-stmt
<P>
                                         or  sync-images-stmt
<P>
                                         or  sync-memory-stmt
<P>
                                         or  sync-team-stmt
<P>
                                         or  unlock-stmt
<P>
                                         or  wait-stmt
<P>
                                         or  where-stmt
<P>
                                         or  write-stmt
<P>
                                         or  computed-goto-stmt
<P>
                                         or  forall-stmt
<P>
  5.2      Program unit concepts
<P>
  5.2.1     Program units and scoping units
<P>
</PRE>
1 Program units are the fundamental components of a Fortran program. A program unit is a main program, an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  external subprogram, a module, a submodule, or a block data program unit.
<P>
</PRE>
2 A subprogram is a function subprogram or a subroutine subprogram. A module contains definitions that can be
</TD></TR>
<TR><TD colspan=2>
<PRE>
  made accessible to other program units. A submodule is an extension of a module; it may contain the definitions
<P>
  of procedures declared in a module or another submodule. A block data program unit is used to specify initial values for
<P>
  data objects in named common blocks.
<P>
</PRE>
3 Each type of program unit is described in Clause 14 or 15.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
4 A program unit consists of a set of nonoverlapping scoping units.
<P>
<PRE>
        NOTE 5.2
<P>
</PRE>
The module or submodule containing a module subprogram is the host scoping unit of the module subpro-
<TABLE width=100% cellpadding=3><!-- tsb: The module or submodule containing a module subprogram is the host scoping unit of the module subpro-
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
gram. The containing main program or subprogram is the host scoping unit of an internal subprogram.
<P>
An internal procedure is local to its host in the sense that its name is accessible within the host scoping
<P>
unit and all its other internal procedures but is not accessible elsewhere.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>5.2.2</B> </TD><TD valign=bottom>
Program
</TD></TR>
<TR></TR></TABLE>1 A program shall consist of exactly one main program, any number (including zero) of other kinds of program units,
<P>
<PRE>
  any number (including zero) of external procedures, and any number (including zero) of other entities defined by
<P>
  means other than Fortran. The main program shall be defined by a Fortran main-program program-unit or by
<P>
  means other than Fortran, but not both.
<P>
  5.2.3     Procedure
<P>
</PRE>
1 A procedure is either a function or a subroutine. Invocation of a function in an expression causes a value to be
<P>
<PRE>
  computed which is then used in evaluating the expression.
<P>
</PRE>
2 A procedure that is not pure might change the program state by changing the value of accessible data objects or
<P>
<PRE>
  procedure pointers.
<P>
</PRE>
3 Procedures are described further in Clause 15.
<P>
<PRE>
  38                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  5.2.4    Module
<P>
</PRE>
1 A module contains (or accesses from other modules) definitions that can be made accessible to other program units.
<P>
<PRE>
  These definitions include data object declarations, type definitions, procedure definitions, and interface blocks.
<P>
  Modules are further described in Clause 14.
<P>
  5.2.5    Submodule
<P>
</PRE>
1 A submodule extends a module or another submodule.
<P>
2 It may provide definitions (15.6) for procedures whose interfaces are declared (15.4.3.2) in an ancestor module
<P>
<PRE>
  or submodule. It may also contain declarations and definitions of other entities, which are accessible in its
<P>
  descendants. An entity declared in a submodule is not accessible by use association unless it is a module procedure
<P>
  whose interface is declared in the ancestor module. Submodules are further described in Clause 14.
<P>
       NOTE 5.3
<P>
       A submodule has access to entities in its parent module or submodule by host association.
<P>
  5.3     Execution concepts
<P>
  5.3.1    Statement classification
<P>
</PRE>
1 Each Fortran statement is classified as either an executable statement or a nonexecutable statement.
<P>
2 An executable statement is an instruction to perform or control an action. Thus, the executable statements of a
<P>
<PRE>
  program unit determine the behavior of the program unit.
<P>
</PRE>
3 Nonexecutable statements are used to configure the program environment in which actions take place.
<P>
<PRE>
  5.3.2    Statement order
<P>
                                Table 5.1: Requirements on statement ordering
<P>
                                     PROGRAM, FUNCTION, SUBROUTINE,
<P>
                                MODULE, SUBMODULE, or BLOCK DATA statement
<P>
                                                    USE statements
<P>
                                                 IMPORT statements
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PARAMETER IMPLICIT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>statements</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statements
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                                Derived-type definitions,
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>FORMAT</B> </TD><TD valign=bottom>
interface blocks,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                and       PARAMETER           type declaration statements,
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>ENTRY</B> </TD><TD valign=bottom>
and DATA            enumeration definitions,
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>statements</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statements           procedure declarations,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                specification statements,
<P>
</PRE>
and statement function statements
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>DATA</B> </TD><TD valign=bottom>
Executable
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>statements</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
constructs
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                CONTAINS statement
<P>
                                                 Internal subprograms
<P>
                                                or module subprograms
<P>
                                                    END statement
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
39
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
1 The syntax rules of subclause 5.1 specify the statement order within program units and subprograms. These
</TD></TR>
<TR><TD colspan=2>
<PRE>
  rules are illustrated in Table 5.1 and Table 5.2. Table 5.1 shows the ordering rules for statements and applies
<P>
  to all program units, subprograms, and interface bodies. Vertical lines delineate varieties of statements that
<P>
  may be interspersed and horizontal lines delineate varieties of statements that shall not be interspersed. Internal
<P>
  or module subprograms shall follow a CONTAINS statement. Between USE and CONTAINS statements in a
<P>
  subprogram, nonexecutable statements generally precede executable statements, although the ENTRY statement,
<P>
  FORMAT statement, and DATA statement may appear among the executable statements. Table 5.2 shows which
<P>
  statements are allowed in some kinds of scoping units.
<P>
                                   Table 5.2: Statements allowed in scoping units
<P>
                                                           Kind of scoping unit
<P>
                            Main        Module or   Block     External         Module         Internal     Interface
<P>
      Statement type      program       submodule   data    subprogram      subprogram      subprogram       body
<P>
      USE                     Yes          Yes       Yes         Yes             Yes            Yes           Yes
<P>
      IMPORT                  No        Submodule    No          No              Yes            Yes           Yes
<P>
      ENTRY                   No           No        No          Yes             Yes             No            No
<P>
      FORMAT                  Yes          No        No          Yes             Yes            Yes           No
<P>
                    1
<P>
      Misc. decl.s            Yes          Yes       Yes         Yes             Yes            Yes           Yes
<P>
      DATA                    Yes          Yes       Yes         Yes             Yes            Yes           No
<P>
      Derived-type            Yes          Yes       Yes         Yes             Yes            Yes           Yes
<P>
      Interface               Yes          Yes       No          Yes             Yes            Yes           Yes
<P>
      Executable              Yes          No        No          Yes             Yes            Yes           No
<P>
      CONTAINS                Yes          Yes       No          Yes             Yes             No           No
<P>
      Statement function      Yes          No        No          Yes             Yes             Yes           No
<P>
      (1) Miscellaneous declarations are PARAMETER statements, IMPLICIT statements, type declaration
<P>
      statements, enumeration definitions, procedure declaration statements, and specification statements.
<P>
  5.3.3     The END statement
<P>
</PRE>
1 Each program unit, module subprogram, and internal subprogram shall have exactly one END statement. The
</TD></TR>
<TR><TD colspan=2>
<PRE>
  end-program-stmt, end-function-stmt, end-subroutine-stmt, and end-mp-subprogram-stmt statements are execut-
<P>
  able, and may be branch target statements (11.2). Executing an end-program-stmt initiates normal termination.
<P>
  Executing an end-function-stmt, end-subroutine-stmt, or end-mp-subprogram-stmt is equivalent to executing a
<P>
  return-stmt with no scalar-int-expr .
<P>
</PRE>
2 The end-module-stmt, end-submodule-stmt, and end-block-data-stmt statements are nonexecutable.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  5.3.4     Program execution
<P>
</PRE>
1 Execution of a program consists of the asynchronous execution of a fixed number (which may be one) of its images.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Each image has its own execution state, floating-point status (17.7), and set of data objects, input/output units,
<P>
  and procedure pointers. The image index that identifies an image is an integer value in the range one to the
<P>
  number of images in a team.
<P>
</PRE>
2 A team is an ordered set of images that is either the initial team, consisting of all images, or a subset of a parent
</TD></TR>
<TR><TD colspan=2>
<PRE>
  team formed by execution of a FORM TEAM statement. The initial team has no parent; every other team has a
<P>
  unique parent team. Within its parent team, each team is identified by its team number; this is the integer value
<P>
  that was specified in the FORM TEAM statement.
<P>
</PRE>
3 During execution, each image has a current team, which is only changed by execution of CHANGE TEAM
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and END TEAM statements. Image indices, and thus coindexing of variable names with an image-selector, are
<P>
  relative to the current team unless a different team is specified. Initially, the current team is the initial team.
<P>
  40                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 5.4
<P>
        Fortran control constructs (11.1, 11.2) control the progress of execution in each image. Image control
<P>
        statements (11.6.1) affect the relative progress of execution between images. Coarrays (5.4.7) provide a
<P>
        mechanism for accessing data on one image from another image.
<P>
        NOTE 5.5
<P>
        A processor might allow the number of images to be chosen at compile time, link time, or run time. It might
<P>
        be the same as the number of CPUs but this is not required. Compiling for a single image might permit
<P>
        the optimizer to eliminate overhead associated with parallel execution. A program that makes assumptions
<P>
        about the number of images is unlikely to be portable.
<P>
  5.3.5      Execution sequence
<P>
</PRE>
1 Following the creation of a fixed number of images, execution begins on each image. Image execution is a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  sequence, in time, of actions. Actions take place during execution of the statement that performs them (except
<P>
  when explicitly stated otherwise). Segments (11.6.2) executed by a single image are totally ordered, and segments
<P>
  executed by separate images are partially ordered by image control statements (11.6.1).
<P>
</PRE>
2 If the program contains a Fortran main program, each image begins execution with the first executable construct
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of the main program. The execution of a main program or subprogram involves execution of the executable
<P>
  constructs within its scoping unit. When a Fortran procedure is invoked, the specification expressions within
<P>
  the specification-part of the invoked procedure, if any, are evaluated in a processor dependent order. Thereafter,
<P>
  execution proceeds to the first executable construct appearing within the scoping unit of the procedure after the
<P>
  invoked entry point. With the following exceptions, the effect of execution is as if the executable constructs are
<P>
  executed in the order in which they appear in the main program or subprogram until a STOP, ERROR STOP,
<P>
  RETURN, or END statement is executed.
<P>
      • Execution of a branching statement (11.2) changes the execution sequence. These statements explicitly
<P>
         specify a new starting place for the execution sequence.
<P>
      • DO constructs, IF constructs, SELECT CASE constructs, SELECT RANK constructs, and SELECT TYPE
<P>
         constructs contain an internal statement structure and execution of these constructs involves implicit in-
<P>
         ternal transfer of control. See Clause 11 for the detailed semantics of each of these constructs.
<P>
      • A BLOCK construct may contain specification expressions; see 11.1.4 for detailed semantics of this construct.
<P>
      • An END=, ERR=, or EOR= specifier (12.11) might result in a branch.
<P>
      • An alternate return might result in a branch.
<P>
  5.3.6      Image execution states
<P>
</PRE>
1 There are three image execution states: active, stopped, and failed. An image that has initiated normal termin-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ation of execution is a stopped image. An image that has ceased participating in program execution but has not
<P>
  initiated termination is a failed image. All other images are active images.
<P>
</PRE>
2 A failed image remains failed for the remainder of the execution of the program. The conditions that cause an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  image to fail are processor dependent.
<P>
</PRE>
3 Defining a coindexed object on a failed image has no effect other than defining the stat-variable, if one appears,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  with the value STAT_FAILED_IMAGE (16.10.2.26). The value of a reference to a coindexed object on a failed
<P>
  image is processor dependent. Execution continues after such a reference.
<P>
</PRE>
4 When an image fails during the execution of a segment, a data object on a nonfailed image becomes undefined
</TD></TR>
<TR><TD colspan=2>
<PRE>
  if it is not a lock variable or event variable and it might be defined or become undefined by execution of a
<P>
  statement of the segment other than an invocation of an atomic subroutine with the object as an actual argument
<P>
  corresponding to the ATOM dummy argument.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           41
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  5.3.7      Termination of execution
<P>
</PRE>
1 Termination of execution of a program is either normal termination or error termination. Normal termination
</TD></TR>
<TR><TD colspan=2>
<PRE>
  occurs only when all images initiate normal termination and occurs in three steps: initiation, synchronization,
<P>
  and completion. In this case, all images synchronize execution at the second step so that no image starts the
<P>
  completion step until all images have finished the initiation step. Error termination occurs when any image
<P>
  initiates error termination. Once error termination has been initiated on an image, error termination is initiated
<P>
  on all images that have not already initiated error termination. Termination of execution of the program occurs
<P>
  when all images have terminated execution.
<P>
</PRE>
2 Normal termination of execution of an image is initiated when a STOP statement or end-program-stmt is executed.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Normal termination of execution of an image also may be initiated during execution of a procedure defined by a
<P>
  companion processor (ISO/IEC 9899:2011 5.1.2.2.3 and 7.22.4.4). If normal termination of execution is initiated
<P>
  within a Fortran program unit and the program incorporates procedures defined by a companion processor, the
<P>
  process of execution termination shall include the effect of executing the C exit() function (ISO/IEC 9899:2011
<P>
  7.22.4.4) during the completion step.
<P>
</PRE>
3 Error termination of execution of an image is initiated if an ERROR STOP statement is executed or as specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  elsewhere in this document. When error termination on an image has been initiated, the processor should initiate
<P>
  error termination on other images as quickly as possible.
<P>
</PRE>
4 If the processor supports the concept of a process exit status, it is recommended that error termination initiated
</TD></TR>
<TR><TD colspan=2>
<PRE>
  other than by an ERROR STOP statement supplies a processor-dependent nonzero value as the process exit
<P>
  status.
<P>
        NOTE 5.6
<P>
        As well as in the circumstances specified in this document, error termination might be initiated by means
<P>
        other than Fortran.
<P>
        NOTE 5.7
<P>
        If an image has initiated normal termination, its data remain available for possible reference or definition
<P>
        by other images that are still executing.
<P>
  5.4       Data concepts
<P>
  5.4.1      Type
<P>
</PRE>
1 A type is a named categorization of data that, together with its type parameters, determines the set of values,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  syntax for denoting these values, and the set of operations that interpret and manipulate the values. This central
<P>
  concept is described in 7.1.
<P>
</PRE>
2 A type is either an intrinsic type or a derived type.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  5.4.1.1    Intrinsic type
<P>
</PRE>
1 The intrinsic types are integer, real, complex, character, and logical. The properties of intrinsic types are described
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in 7.4.
<P>
</PRE>
2 All intrinsic types have a kind type parameter called KIND, which determines the representation method for the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specified type. The intrinsic type character also has a length type parameter called LEN, which determines the
<P>
  length of the character string.
<P>
  5.4.1.2    Derived type
<P>
</PRE>
1 Derived types may be parameterized. A scalar object of derived type is a structure; assignment of structures
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is defined intrinsically (10.2.1.3), but there are no intrinsic operations for structures. For each derived type, a
<P>
  42                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  structure constructor is available to create values (7.5.10). In addition, objects of derived type may be used as
<P>
  procedure arguments and function results, and may appear in input/output lists. If additional operations are
<P>
  needed for a derived type, they shall be defined by procedures (10.1.6).
<P>
</PRE>
2 Derived types are described further in 7.5.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  5.4.2      Data value
<P>
</PRE>
1 Each intrinsic type has associated with it a set of values that a datum of that type may take, depending on the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  values of the type parameters. The values for each intrinsic type are described in 7.4. The values that objects of
<P>
  a derived type may assume are determined by the type definition, type parameter values, and the sets of values
<P>
  of its components.
<P>
  5.4.3      Data entity
<P>
  5.4.3.1    General
<P>
</PRE>
1 A data entity has a type and type parameters; it might have a data value (an exception is an undefined variable).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Every data entity has a rank and is thus either a scalar or an array.
<P>
</PRE>
2 A data entity that is the result of the execution of a function reference is called the function result.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  5.4.3.2    Data object
<P>
</PRE>
1 A data object is either a constant, variable, or a subobject of a constant. The type and type parameters of a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  named data object may be specified explicitly (8.2) or implicitly (8.7).
<P>
</PRE>
2 Subobjects are portions of data objects that may be referenced and defined (variables only) independently of the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  other portions.
<P>
</PRE>
3 These include portions of arrays (array elements and array sections), portions of character strings (substrings),
</TD></TR>
<TR><TD colspan=2>
<PRE>
  portions of complex objects (real and imaginary parts), and portions of structures (components). Subobjects
<P>
  are themselves data objects, but subobjects are referenced only by object designators or intrinsic functions. A
<P>
  subobject of a variable is a variable. Subobjects are described in Clause 9.
<P>
</PRE>
4 The following objects are referenced by a name:
</TD></TR>
<TR><TD colspan=2>
<PRE>
        • a named scalar                 (a scalar object);
<P>
        • a named array                  (an array object).
<P>
</PRE>
5 The following subobjects are referenced by an object designator:
</TD></TR>
<TR><TD colspan=2>
<PRE>
        • an array element               (a scalar subobject);
<P>
        • an array section               (an array subobject);
<P>
        • a complex part designator      (the real or imaginary part of a complex object);
<P>
        • a structure component          (a scalar or an array subobject);
<P>
        • a substring                    (a scalar subobject).
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>5.4.3.2.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Variable
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 A variable can have a value or be undefined; during execution of a program it can be defined, redefined, or become
</TD></TR>
<TR><TD colspan=2>
<PRE>
  undefined.
<P>
</PRE>
2 A local variable of a module, submodule, main program, subprogram, or BLOCK construct is accessible only in
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that scoping unit or construct and in any contained scoping units and constructs.
<P>
        NOTE 5.8
<P>
        A subobject of a local variable is also a local variable.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           43
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 5.8 (cont.)
<P>
       A local variable cannot be in COMMON or have the BIND attribute, because common blocks and variables with
<P>
       the BIND attribute are global entities.
<P>
  5.4.3.2.2   Constant
<P>
</PRE>
1 A constant is either a named constant or a literal constant.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 Named constants are defined using the PARAMETER attribute (8.5.13, 8.6.11). The syntax of literal constants
<P>
<PRE>
  is described in 7.4.
<P>
  5.4.3.2.3   Subobject of a constant
<P>
</PRE>
1 A subobject of a constant is a portion of a constant.
<P>
2 In an object designator for a subobject of a constant, the portion referenced may depend on the value of a variable.
<P>
<PRE>
       NOTE 5.9
<P>
       For example, given:
<P>
       CHARACTER (LEN = 10), PARAMETER :: DIGITS = ’0123456789’
<P>
       CHARACTER (LEN = 1)                      :: DIGIT
<P>
       INTEGER :: I
<P>
           &#46;&#46;&#46;
<P>
       DIGIT = DIGITS (I:I)
<P>
       DIGITS is a named constant and DIGITS (I:I) designates a subobject of the constant DIGITS.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>5.4.3.3</B> </TD><TD valign=bottom>
Expression
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 An expression (10.1) produces a data entity when evaluated. An expression represents either a data object
<P>
<PRE>
  reference or a computation; it is formed from operands, operators, and parentheses. The type, type parameters,
<P>
  value, and rank of an expression result are determined by the rules in Clause 10.
<P>
  5.4.3.4   Function reference
<P>
</PRE>
1 A function reference produces a data entity when the function is executed during expression evaluation. The
<P>
<PRE>
  type, type parameters, and rank of a function result are determined by the interface of the function (15.3.3). The
<P>
  value of a function result is determined by execution of the function.
<P>
  5.4.4     Definition of objects and pointers
<P>
</PRE>
1 When an object is given a valid value during program execution, it becomes defined. This is often accomplished
<P>
<PRE>
  by execution of an assignment or input statement. When a variable does not have a predictable value, it is
<P>
  undefined.
<P>
</PRE>
2 Similarly, when a pointer is associated with a target or nullified, its pointer association status becomes defined.
<P>
<PRE>
  When the association status of a pointer is not predictable, its pointer association status is undefined.
<P>
</PRE>
3 Clause 19 describes the ways in which variables become defined and undefined and the association status of
<P>
<PRE>
  pointers becomes defined and undefined.
<P>
  5.4.5     Reference
<P>
</PRE>
1 A data object is referenced when its value is required during execution. A procedure is referenced when it is
<P>
<PRE>
  executed.
<P>
  44                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The appearance of a data object designator or procedure designator as an actual argument does not constitute
<P>
<PRE>
  a reference to that data object or procedure unless such a reference is necessary to complete the specification of
<P>
  the actual argument.
<P>
  5.4.6     Array
<P>
</PRE>
1 An array may have up to fifteen dimensions minus its corank, and any extent in any dimension. The size of an
<P>
<PRE>
  array is the total number of elements, which is equal to the product of the extents. An array may have zero
<P>
  size. The shape of an array is determined by its rank and its extent in each dimension, and is represented as
<P>
  a rank-one array whose elements are the extents. All named arrays shall be declared, and the rank of a named
<P>
  array is specified in its declaration. Except for an assumed-rank array, the rank of a named array, once declared,
<P>
  is constant; the extents may be constant or may vary during execution.
<P>
</PRE>
2 Any intrinsic operation defined for scalar objects may be applied to conformable objects. Such operations are
<P>
<PRE>
  performed elementally to produce a resultant array conformable with the array operands. If an elemental operation
<P>
  is intrinsically pure or is implemented by a pure elemental function (15.8), the element operations may be
<P>
  performed simultaneously or in any order.
<P>
</PRE>
3 A rank-one array may be constructed from scalars and other arrays and may be reshaped into any allowable array
<P>
<PRE>
  shape (7.8).
<P>
</PRE>
4 Arrays may be of any type and are described further in 9.5.
<P>
<PRE>
  5.4.7     Coarray
<P>
</PRE>
1 A coarray is a data entity that has nonzero corank; it can be directly referenced or defined by other images. It
<P>
<PRE>
  may be a scalar or an array.
<P>
</PRE>
2 For each coarray on an image, there is a corresponding coarray with the same type, type parameters, and bounds
<P>
<PRE>
  on every other image of a team in which it is established (5.4.8).
<P>
</PRE>
3 The set of corresponding coarrays on all images in a team is arranged in a rectangular pattern. The dimensions of
<P>
<PRE>
  this pattern are the codimensions; the number of codimensions is the corank. The bounds for each codimension
<P>
  are the cobounds.
<P>
        NOTE 5.10
<P>
       If the total number of images is not a multiple of the product of the sizes of each but the rightmost of the
<P>
       codimensions, the rectangular pattern will be incomplete.
<P>
</PRE>
4 A coarray on any image can be accessed directly by using cosubscripts. On its own image, a coarray can also be
<P>
<PRE>
  accessed without use of cosubscripts.
<P>
</PRE>
5 A subobject of a coarray is a coarray if it does not have any cosubscripts, vector subscripts, allocatable component
<P>
<PRE>
  selection, or pointer component selection.
<P>
</PRE>
6 For a coindexed object, its cosubscript list determines the image index (9.6) in the same way that a subscript list
<P>
<PRE>
  determines the subscript order value for an array element (9.5.3.2).
<P>
</PRE>
7 Intrinsic procedures are provided for mapping between an image index and a list of cosubscripts.
<P>
<PRE>
        NOTE 5.11
<P>
</PRE>
The mechanism for an image to reference and define a coarray on another image might vary according
<TABLE width=100% cellpadding=3><!-- tsb: The mechanism for an image to reference and define a coarray on another image might vary according
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
to the hardware. On a shared-memory machine, a coarray on an image and the corresponding coarrays
<P>
on other images could be implemented as a sequence of arrays with evenly spaced starting addresses. On
<P>
a distributed-memory machine with separate physical memory for each image, a processor might store a
<P>
coarray at the same virtual address in each physical memory.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
45
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
        NOTE 5.12
<P>
</PRE>
Except in contexts where coindexed objects are disallowed, accessing a coarray on its own image by using
<TABLE width=100% cellpadding=3><!-- tsb: Except in contexts where coindexed objects are disallowed, accessing a coarray on its own image by using
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
a set of cosubscripts that specify that image has the same effect as accessing it without cosubscripts. In
<P>
particular, the segment ordering rules (11.6.2) apply whether or not cosubscripts are used to access the
<P>
coarray.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>5.4.8</B> </TD><TD valign=bottom>
Established coarrays
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 A nonallocatable coarray with the SAVE attribute is established in the initial team.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 An allocated allocatable coarray is established in the team in which it was allocated. An unallocated allocatable
<P>
<PRE>
  coarray is not established.
<P>
</PRE>
3 A coarray that is an associating entity in a coarray-association of a CHANGE TEAM statement is established
<P>
<PRE>
  in the team of its CHANGE TEAM construct.
<P>
</PRE>
4 A nonallocatable coarray that is an associating entity in an ASSOCIATE, SELECT RANK, or SELECT TYPE
<P>
<PRE>
  construct is established in the team in which the ASSOCIATE, SELECT RANK, or SELECT TYPE statement
<P>
  is executed.
<P>
</PRE>
5 A nonallocatable coarray that is a dummy argument or host associated with a dummy argument is established
<P>
<PRE>
  in the team in which the procedure was invoked. A coarray dummy argument is not established in any ancestor
<P>
  team even if the corresponding actual argument is established in one or more of them.
<P>
  5.4.9     Pointer
<P>
</PRE>
1 A pointer has an association status which is either associated, disassociated, or undefined (19.5.2.2).
<P>
2 A pointer that is not associated shall not be referenced or defined.
<P>
3 If a data pointer is an array, the rank is declared, but the bounds are determined when it is associated with a
<P>
<PRE>
  target.
<P>
  5.4.10      Allocatable variables
<P>
</PRE>
1 The allocation status of an allocatable variable is either allocated or unallocated. An allocatable variable becomes
<P>
<PRE>
  allocated as described in 9.7.1.3. It becomes unallocated as described in 9.7.3.2.
<P>
</PRE>
2 An unallocated allocatable variable shall not be referenced or defined.
<P>
3 If an allocatable variable is an array, the rank is declared, but the bounds are determined when it is allocated. If
<P>
<PRE>
  an allocatable variable is a coarray, the corank is declared, but the cobounds are determined when it is allocated.
<P>
  5.4.11      Storage
<P>
</PRE>
1 Many of the facilities of this document make no assumptions about the physical storage characteristics of data
<P>
<PRE>
  objects. However, program units that include storage association dependent features shall observe the storage
<P>
  restrictions described in 19.5.3.
<P>
  5.5      Fundamental concepts
<P>
  5.5.1     Names and designators
<P>
</PRE>
1 A name is used to identify a program constituent, such as a program unit, named variable, named constant,
<P>
<PRE>
  dummy argument, or derived type.
<P>
  46                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 A designator is used to identify a program constituent or a part thereof.
<P>
<PRE>
  5.5.2     Statement keyword
<P>
</PRE>
1 A statement keyword is not a reserved word; that is, a name with the same spelling is allowed. In the syntax
<P>
<PRE>
  rules, such keywords appear literally. In descriptive text, this meaning is denoted by the term “keyword” without
<P>
  any modifier. Examples of statement keywords are IF, READ, UNIT, KIND, and INTEGER.
<P>
  5.5.3     Other keywords
<P>
</PRE>
1 Other keywords denote names that identify items in a list. In this case, items are identified by a preceding
<P>
<PRE>
  keyword= rather than their position within the list.
<P>
</PRE>
2 An argument keyword is the name of a dummy argument in the interface for the procedure being referenced, and
<P>
<PRE>
  may appear in an actual argument list. A type parameter keyword is the name of a type parameter in the type
<P>
  being specified, and may appear in a type parameter list. A component keyword is the name of a component in
<P>
  a structure constructor.
<P>
  R516     keyword                        is name
<P>
        NOTE 5.13
<P>
        Use of keywords rather than position to identify items in a list can make such lists more readable and allows
<P>
        them to be reordered. This facilitates specification of a list in cases where optional items are omitted.
<P>
  5.5.4     Association
<P>
</PRE>
1 Name association (19.5.1) permits an entity to be identified by different names in the same scoping unit or by
<P>
<PRE>
  the same name or different names in different scoping units.
<P>
</PRE>
2 Pointer association (19.5.2) between a pointer and a target allows the target to be denoted by the pointer.
<P>
3 Storage association (19.5.3) causes different entities to use the same storage.
<P>
4 Inheritance association (19.5.4) occurs between components of the parent component and components inherited
<P>
<PRE>
  by type extension.
<P>
  5.5.5     Intrinsic
<P>
</PRE>
1 All intrinsic types, procedures, assignments, and operators may be used in any scoping unit without further
<P>
<PRE>
  definition or specification. Intrinsic modules (16.10, 17, 18.2) may be accessed by use association.
<P>
  5.5.6     Operator
<P>
</PRE>
1 This document specifies a number of intrinsic operators (e.g., the arithmetic operators +, –, *, /, and ** with
<P>
<PRE>
  numeric operands and the logical operators .AND., .OR., etc. with logical operands). Additional operators may
<P>
  be defined within a program (7.5.5, 15.4.3.4).
<P>
  5.5.7     Companion processors
<P>
</PRE>
1 A processor has one or more companion processors. A companion processor may be a mechanism that references
<P>
<PRE>
  and defines such entities by a means other than Fortran (15.6.3), it may be the Fortran processor itself, or it may
<P>
  be another Fortran processor. If there is more than one companion processor, the means by which the Fortran
<P>
  processor selects among them are processor dependent.
<P>
</PRE>
2 If a procedure is defined by means of a companion processor that is not the Fortran processor itself, this document
<P>
<PRE>
  refers to the C function that defines the procedure, although the procedure need not be defined by means of the
<P>
  C programming language.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            47
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
   NOTE 5.14
<P>
   A companion processor might or might not be a mechanism that conforms to the requirements of ISO/IEC
<P>
   9899:2011. If it does, 5.3.7 states that a program unit that is defined by means other than Fortran and that
<P>
   initiates normal termination is required to include the effect of executing the C exit() function.
<P>
   For example, a processor might allow a procedure defined by some language other than Fortran or C to be
<P>
   invoked if it can be described by a C prototype as defined in 6.7.6.3 of ISO/IEC 9899:2011.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>48</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Lexical tokens and source form
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>6.1</B> </TD><TD valign=bottom>
Processor character set
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>6.1.1</B> </TD><TD valign=bottom>
Characters
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The processor character set is processor dependent. Each character in a processor character set is either a control
</TD></TR>
<TR><TD colspan=2>
<PRE>
  character or a graphic character. The set of graphic characters is further divided into letters (6.1.2), digits (6.1.3),
<P>
  underscore (6.1.4), special characters (6.1.5), and other characters (6.1.6).
<P>
</PRE>
2 The letters, digits, underscore, and special characters make up the Fortran character set. Together, the set of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  letters, digits, and underscore define the syntax class alphanumeric-character.
<P>
  R601     alphanumeric-character         is letter
<P>
                                          or digit
<P>
                                          or underscore
<P>
</PRE>
3 Except for the currency symbol, the graphics used for the characters shall be as given in 6.1.2, 6.1.3, 6.1.4, and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  6.1.5. However, the style of any graphic is not specified.
<P>
  6.1.2     Letters
<P>
</PRE>
1 The twenty-six letters are:
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>2</B> </TD><TD valign=bottom>
ABCDEFGHIJKLMNOPQRSTUVWXYZ
</TD></TR>
<TR><TD colspan=2>
3 The set of letters defines the syntactic class letter. The processor character set shall include lower-case and upper-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  case letters. A lower-case letter is equivalent to the corresponding upper-case letter in program units except in a
<P>
  character context (3.21).
<P>
        NOTE 6.1
<P>
        The following statements are equivalent:
<P>
        CALL BIG_COMPLEX_OPERATION (NDATE)
<P>
        call big_complex_operation (ndate)
<P>
        Call Big_Complex_Operation (NDate)
<P>
  6.1.3     Digits
<P>
</PRE>
1 The ten digits are:
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>2</B> </TD><TD valign=bottom>
0123456789
</TD></TR>
<TR><TD colspan=2>
3 The ten digits define the syntactic class digit.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  6.1.4     Underscore
<P>
  R602     underscore                     is   _
<P>
  6.1.5     Special characters
<P>
</PRE>
1 The special characters are shown in Table 6.1.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               49
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                                           Table 6.1: Special characters
<P>
                      Character  Name of character          Character Name of character
<P>
                                 Blank                            ;       Semicolon
<P>
                          =      Equals                           !       Exclamation point
<P>
                          +      Plus                            "        Quotation mark or quote
<P>
                          -      Minus                           %        Percent
<P>
                          *      Asterisk                        &        Ampersand
<P>
                          /      Slash                           ~        Tilde
<P>
                          \      Backslash                       &lt;        Less than
<P>
                          (      Left parenthesis                &gt;        Greater than
<P>
                          )      Right parenthesis               ?        Question mark
<P>
                          [      Left square bracket             ’        Apostrophe
<P>
                          ]      Right square bracket            &#145;        Grave accent
<P>
                          {      Left curly bracket              ^        Circumflex accent
<P>
                          }      Right curly bracket              |       Vertical line
<P>
                          ,      Comma                           $        Currency symbol
<P>
                          .      Decimal point or period         #        Number sign
<P>
                          :      Colon                           @        Commercial at
<P>
</PRE>
2 Some of the special characters are used for operator symbols, bracketing, and various forms of separating and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  delimiting other lexical tokens.
<P>
  6.1.6         Other characters
<P>
</PRE>
1 Additional characters may be representable in the processor, but may appear only in comments (6.3.2.3, 6.3.3.2),
</TD></TR>
<TR><TD colspan=2>
<PRE>
  character constants (7.4.4), input/output records (12.2.2), and character string edit descriptors (13.3.2).
<P>
  6.2         Low-level syntax
<P>
  6.2.1         Tokens
<P>
</PRE>
1 The low-level syntax describes the fundamental lexical tokens of a program unit. A lexical token is a keyword,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  name, literal constant other than a complex literal constant, operator, statement label, delimiter, comma, =, =&gt;,
<P>
  :, ::, ;, .., or %.
<P>
  6.2.2         Names
<P>
</PRE>
1 Names are used for various entities such as variables, program units, dummy arguments, named constants, and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  derived types.
<P>
  R603        name                      is  letter [ alphanumeric-character ] &#46;&#46;&#46;
<P>
  C601        (R603) The maximum length of a name is 63 characters.
<P>
         NOTE 6.2
<P>
         Examples of names:
<P>
           A1
<P>
           NAME_LENGTH            (single underscore)
<P>
           S_P_R_E_A_D__O_U_T     (two consecutive underscores)
<P>
           TRAILER_               (trailing underscore)
<P>
  50                                                                ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
    NOTE 6.3
<P>
    The word “name” always denotes this particular syntactic form. The word “identifier” is used where entities
<P>
    can be identified by other syntactic forms or by values; its particular meaning depends on the context in
<P>
    which it is used.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>6.2.3</B> </TD><TD valign=bottom>
Constants
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R604</B> </TD><TD valign=bottom>
constant                     is literal-constant
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                    or named-constant
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R605</B> </TD><TD valign=bottom>
literal-constant             is   int-literal-constant
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                    or   real-literal-constant
<P>
                                    or   complex-literal-constant
<P>
                                    or   logical-literal-constant
<P>
                                    or   char-literal-constant
<P>
                                    or   boz-literal-constant
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R606</B> </TD><TD valign=bottom>
named-constant               is   name
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R607</B> </TD><TD valign=bottom>
int-constant                 is   constant
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C602</B> </TD><TD valign=bottom>
(R607) int-constant shall be of type integer.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>6.2.4</B> </TD><TD valign=bottom>
Operators
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R608</B> </TD><TD valign=bottom>
intrinsic-operator           is   power-op
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                    or   mult-op
<P>
                                    or   add-op
<P>
                                    or   concat-op
<P>
                                    or   rel-op
<P>
                                    or   not-op
<P>
                                    or   and-op
<P>
                                    or   or-op
<P>
                                    or   equiv-op
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1007 power-op</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   **
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1008 mult-op</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is *
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                    or /
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1009 add-op</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is +
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                    or –
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1011 concat-op</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   //
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1013 rel-op</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   .EQ.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                    or   .NE.
<P>
                                    or   .LT.
<P>
                                    or   .LE.
<P>
                                    or   .GT.
<P>
                                    or   .GE.
<P>
                                    or   ==
<P>
                                    or   /=
<P>
                                    or   &lt;
<P>
                                    or   &lt;=
<P>
                                    or   &gt;
<P>
                                    or   &gt;=
<P>
</PRE>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
51
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1018 not-op                             is   .NOT.
<P>
  R1019 and-op                             is   .AND.
<P>
  R1020 or-op                              is   .OR.
<P>
  R1021 equiv-op                           is .EQV.
<P>
                                           or .NEQV.
<P>
  R609      defined-operator               is defined-unary-op
<P>
                                           or defined-binary-op
<P>
                                           or extended-intrinsic-op
<P>
  R1003 defined-unary-op                   is   . letter [ letter ] &#46;&#46;&#46; .
<P>
  R1023 defined-binary-op                  is   . letter [ letter ] &#46;&#46;&#46; .
<P>
  R610      extended-intrinsic-op          is   intrinsic-operator
<P>
  6.2.5      Statement labels
<P>
</PRE>
1 A statement label provides a means of referring to an individual statement.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R611      label                          is   digit [ digit [ digit [ digit [ digit ] ] ] ]
<P>
  C603      (R611) At least one digit in a label shall be nonzero.
<P>
</PRE>
2 If a statement is labeled, the statement shall contain a nonblank character. The same statement label shall not
</TD></TR>
<TR><TD colspan=2>
<PRE>
  be given to more than one statement in its scope. Leading zeros are not significant in distinguishing between
<P>
  statement labels. There are 99999 possible unique statement labels and a processor shall accept any of them as
<P>
  a statement label. However, a processor may have a limit on the total number of unique statement labels in one
<P>
  program unit.
<P>
        NOTE 6.4
<P>
        For example:
<P>
        99999
<P>
        10
<P>
          010
<P>
        are all statement labels. The last two are equivalent.
<P>
</PRE>
3 Any statement that is not part of another statement, and that is not preceded by a semicolon in fixed form, may begin
</TD></TR>
<TR><TD colspan=2>
<PRE>
  with a statement label, but the labels are used only in the following ways.
<P>
      • The label on a branch target statement (11.2) is used to identify that statement as the possible destination
<P>
         of a branch.
<P>
      • The label on a FORMAT statement (13.2.1) is used to identify that statement as the format specification
<P>
         for a data transfer statement (12.6).
<P>
      • In some forms of the DO construct (11.1.7), the terminal statement of the construct is identified by a label.
<P>
  6.2.6      Delimiters
<P>
</PRE>
1 A lexical token that is a delimiter is a (, ), /, [, ], (/, or /).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  52                                                                       ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
<P>
  6.3       Source form
<P>
  6.3.1      Program units, statements, and lines
<P>
</PRE>
1 A Fortran program unit is a sequence of one or more lines, organized as Fortran statements, comments, and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  INCLUDE lines. A line is a sequence of zero or more characters. Lines following a program unit END statement
<P>
  are not part of that program unit. A Fortran statement is a sequence of one or more complete or partial lines.
<P>
</PRE>
2 A comment may contain any character that may occur in any character context.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 There are two source forms. Subclause 6.3.2 applies only to free form source. Subclause 6.3.3 applies only to fixed source
<P>
<PRE>
  form. Free form and fixed form shall not be mixed in the same program unit. The means for specifying the source form of a program
<P>
  unit are processor dependent.
<P>
  6.3.2      Free source form
<P>
  6.3.2.1    Free form line length
<P>
</PRE>
1 In free source form there are no restrictions on where a statement (or portion of a statement) may appear within
<P>
<PRE>
  a line. A line may contain zero characters. If a line consists entirely of characters of default kind (7.4.4), it may
<P>
  contain at most 132 characters. If a line contains any character that is not of default kind, the maximum number
<P>
  of characters allowed on the line is processor dependent.
<P>
  6.3.2.2    Blank characters in free form
<P>
</PRE>
1 In free source form blank characters shall not appear within lexical tokens other than in a character context or in
<P>
<PRE>
  a format specification. Blanks may be inserted freely between tokens to improve readability; for example, blanks
<P>
  may occur between the tokens that form a complex literal constant. A sequence of blank characters outside of a
<P>
  character context is equivalent to a single blank character.
<P>
</PRE>
2 A blank shall be used to separate names, constants, or labels from adjacent keywords, names, constants, or labels.
<P>
<PRE>
        NOTE 6.5
<P>
        For example, the blanks after REAL, READ, 30, and DO are required in the following:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; REAL X</H4>
</A>
<BLOCKQUOTE>
<P>
READ 10
<P>
30 DO K=1,3
</BLOCKQUOTE>
<P>
3 One or more blanks shall be used to separate adjacent keywords except in the following cases, where blanks are
<P>
<PRE>
  optional:
<P>
                       Table 6.2: Adjacent keywords where separating blanks are optional
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; BLOCK DATA END FILE END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; DOUBLE PRECISION END FORALL END TEAM</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE IF END FUNCTION END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE WHERE END IF END WHERE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END ASSOCIATE END INTERFACE GO TO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK END MODULE IN OUT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK DATA END PROCEDURE SELECT CASE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END CRITICAL END PROGRAM SELECT TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END ENUM END SUBMODULE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
53
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>6.3.2.3</B> </TD><TD valign=bottom>
Free form commentary
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The character “!” initiates a comment except where it appears within a character context. The comment extends
<P>
<PRE>
  to the end of the line. If the first nonblank character on a line is an “!”, the line is a comment line. Lines
<P>
  containing only blanks or containing no characters are also comment lines. Comments may appear anywhere in
<P>
  a program unit and may precede the first statement of a program unit or follow the last statement of a program
<P>
  unit. Comments have no effect on the interpretation of the program unit.
<P>
        NOTE 6.6
<P>
        This document does not restrict the number of consecutive comment lines.
<P>
  6.3.2.4     Free form statement continuation
<P>
</PRE>
1 The character “&” is used to indicate that the statement is continued on the next line that is not a comment
<P>
<PRE>
  line. Comment lines cannot be continued; an “&” in a comment has no effect. Comments may occur within a
<P>
  continued statement. When used for continuation, the “&” is not part of the statement. No line shall contain
<P>
  a single “&” as the only nonblank character or as the only nonblank character before an “!” that initiates a
<P>
  comment.
<P>
</PRE>
2 If a noncharacter context is to be continued, an “&” shall be the last nonblank character on the line, or the last
<P>
<PRE>
  nonblank character before an “!”. There shall be a later line that is not a comment; the statement is continued
<P>
  on the next such line. If the first nonblank character on that line is an “&”, the statement continues at the next
<P>
  character position following that “&”; otherwise, it continues with the first character position of that line.
<P>
</PRE>
3 If a lexical token is split across the end of a line, the first nonblank character on the first following noncomment
<P>
<PRE>
  line shall be an “&” immediately followed by the successive characters of the split token.
<P>
</PRE>
4 If a character context is to be continued, an “&” shall be the last nonblank character on the line. There shall be
<P>
<PRE>
  a later line that is not a comment; an “&” shall be the first nonblank character on the next such line and the
<P>
  statement continues with the next character following that “&”.
<P>
  6.3.2.5     Free form statement termination
<P>
</PRE>
1 If a statement is not continued, a comment or the end of the line terminates the statement.
<BLOCKQUOTE>
<P>
2 A statement may alternatively be terminated by a “;” character that appears other than in a character context
<P>
<PRE>
  or in a comment. The “;” is not part of the statement. After a “;” terminator, another statement may appear
<P>
  on the same line, or begin on that line and be continued. A sequence consisting only of zero or more blanks and
<P>
  one or more “;” terminators, in any order, is equivalent to a single “;” terminator.
<P>
  6.3.2.6     Free form statements
<P>
</PRE>
1 A label may precede any statement not forming part of another statement.
<P>
<PRE>
        NOTE 6.7
<P>
        No Fortran statement begins with a digit.
<P>
</PRE>
2 A statement shall not have more than 255 continuation lines.
<P>
<PRE>
  6.3.3      Fixed source form
<P>
  6.3.3.1     General
<P>
</PRE>
1 In fixed source form, there are restrictions on where a statement may appear within a line. If a source line contains only characters
<P>
<PRE>
  of default kind, it shall contain exactly 72 characters; otherwise, its maximum number of characters is processor dependent.
<P>
</PRE>
2 Except in a character context, blanks are insignificant and may be used freely throughout the program.
<P>
<PRE>
  54                                                                            ⃝
<P>
                                                                                c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
  6.3.3.2      Fixed form commentary
<P>
</PRE>
1 The character “!” initiates a comment except where it appears within a character context or in character position 6. The comment
<P>
<PRE>
  extends to the end of the line. If the first nonblank character on a line is an “!” in any character position other than character
<P>
  position 6, the line is a comment line. Lines beginning with a “C” or “*” in character position 1 and lines containing only blanks are
<P>
  also comment lines. Comments may appear anywhere in a program unit and may precede the first statement of the program unit or
<P>
  follow the last statement of a program unit. Comments have no effect on the interpretation of the program unit.
<P>
         NOTE 6.8
<P>
         This document does not restrict the number of consecutive comment lines.
<P>
  6.3.3.3      Fixed form statement continuation
<P>
</PRE>
1 Except within commentary, character position 6 is used to indicate continuation. If character position 6 contains a blank or zero, the
<P>
<PRE>
  line is the initial line of a new statement, which begins in character position 7. If character position 6 contains any character other
<P>
  than blank or zero, character positions 7–72 of the line constitute a continuation of the preceding noncomment line.
<P>
         NOTE 6.9
<P>
         An “!” or “;” in character position 6 is interpreted as a continuation indicator unless it appears within commentary indicated
<P>
         by a “C” or “*” in character position 1 or by an “!” in character positions 1–5.
<P>
</PRE>
2 Comment lines cannot be continued. Comment lines may occur within a continued statement.
<P>
<PRE>
  6.3.3.4      Fixed form statement termination
<P>
</PRE>
1 If a statement is not continued, a comment or the end of the line terminates the statement.
<P>
2 A statement may alternatively be terminated by a “;” character that appears other than in a character context, in a comment, or in
<P>
<PRE>
  character position 6. The “;” is not part of the statement. After a “;” terminator, another statement may begin on the same line, or
<P>
  begin on that line and be continued. A “;” shall not appear as the first nonblank character on an initial line. A sequence consisting
<P>
  only of zero or more blanks and one or more “;” terminators, in any order, is equivalent to a single “;” terminator.
<P>
  6.3.3.5      Fixed form statements
<P>
</PRE>
1 A label, if it appears, shall occur in character positions 1 through 5 of the first line of a statement; otherwise, positions 1 through
<BLOCKQUOTE>
<P>
5 shall be blank. Blanks may appear anywhere within a label. A statement following a “;” on the same line shall not be labeled.
<P>
Character positions 1 through 5 of any continuation lines shall be blank. A statement shall not have more than 255 continuation
<P>
lines. The program unit END statement shall not be continued. A statement whose initial line appears to be a program unit END
<P>
statement shall not be continued.
<TABLE cellpadding=3><!-- tsb: statement shall not be continued.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>6.4</B> </TD><TD valign=bottom>
Including source text
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Additional text may be incorporated into the source text of a program unit during processing. This is accomplished
<P>
<PRE>
  with the INCLUDE line, which has the form
<P>
           INCLUDE char-literal-constant
<P>
</PRE>
2 The char-literal-constant shall not have a kind type parameter value that is a named-constant.
<P>
3 An INCLUDE line is not a Fortran statement.
<P>
4 An INCLUDE line shall appear on a single source line where a statement may appear; it shall be the only
<P>
<PRE>
  nonblank text on this line other than an optional trailing comment. Thus, a statement label is not allowed.
<P>
</PRE>
5 The effect of the INCLUDE line is as if the referenced source text physically replaced the INCLUDE line prior
<P>
<PRE>
  to program processing. Included text may contain any source text, including additional INCLUDE lines; such
<P>
  nested INCLUDE lines are similarly replaced with the specified source text. The maximum depth of nesting of
<P>
  any nested INCLUDE lines is processor dependent. Inclusion of the source text referenced by an INCLUDE line
<P>
  shall not, at any level of nesting, result in inclusion of the same source text.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                               55
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 When an INCLUDE line is resolved, the first included statement line shall not be a continuation line and the last
<P>
<PRE>
  included statement line shall not be continued.
<P>
</PRE>
7 The interpretation of char-literal-constant is processor dependent. An example of a possible valid interpretation
<P>
<PRE>
  is that char-literal-constant is the name of a file that contains the source text to be included.
<P>
       NOTE 6.10
<P>
       In some circumstances, for example where source code is maintained in an INCLUDE file for use in programs whose source
<P>
       form might be either fixed or free, observing the following rules allows the code to be used with either source form.
<P>
           • Confine statement labels to character positions 1 to 5 and statements to character positions 7 to 72.
<P>
           • Treat blanks as being significant.
<P>
           • Use only the exclamation mark (!) to indicate a comment, but do not start the comment in character position 6.
<P>
           • For continued statements, place an ampersand (&) in both character position 73 of a continued line and character
<P>
             position 6 of a continuation line.
<P>
  56                                                                           ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  7 Types
<P>
  7.1      Characteristics of types
<P>
  7.1.1     The concept of type
<P>
</PRE>
1 Fortran provides an abstract means whereby data can be categorized without relying on a particular physical
<P>
<PRE>
  representation. This abstract means is the concept of type.
<P>
</PRE>
2 A type has a name, a set of valid values, a means to denote such values (constants), and a set of operations to
<P>
<PRE>
  manipulate the values.
<P>
  7.1.2     Type classification
<P>
</PRE>
1 A type is either an intrinsic type or a derived type.
<P>
2 This document defines five intrinsic types: integer, real, complex, character, and logical.
<P>
3 A derived type is one that is defined by a derived-type definition (7.5.2) or by an intrinsic module. It shall be
<P>
<PRE>
  used only where it is accessible (7.5.2.2). An intrinsic type is always accessible.
<P>
  7.1.3     Set of values
<P>
</PRE>
1 For each type, there is a set of valid values. The set of valid values for logical is completely determined by this
<P>
<PRE>
  document. The sets of valid values for integer, character, and real are processor dependent. The set of valid
<P>
  values for complex consists of the set of all the combinations of the values of the real and imaginary parts. The
<P>
  set of valid values for a derived type is as defined in 7.5.8.
<P>
  7.1.4     Constants
<P>
</PRE>
1 The syntax for denoting a value indicates the type, type parameters, and the particular value.
<P>
2 The syntax for literal constants of each intrinsic type is specified in 7.4.
<P>
3 A structure constructor (7.5.10) that is a constant expression (10.1.12) denotes a scalar constant value of derived
<P>
<PRE>
  type. An array constructor (7.8) that is a constant expression denotes a constant array value of intrinsic or
<P>
  derived type.
<P>
</PRE>
4 A constant value can be named (8.5.13, 8.6.11).
<P>
<PRE>
  7.1.5     Operations
<P>
</PRE>
1 For each of the intrinsic types, a set of operations and corresponding operators is defined intrinsically. These are
<P>
<PRE>
  described in Clause 10. The intrinsic set can be augmented with operations and operators defined by functions
<P>
  with the OPERATOR interface (15.4.3.2). Operator definitions are described in Clauses 10 and 15.
<P>
</PRE>
2 For derived types, there are no intrinsic operations. Operations on derived types can be defined by the program
<P>
<PRE>
  (7.5.11).
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            57
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  7.2       Type parameters
<P>
</PRE>
1 A type might be parameterized. In this case, the set of values, the syntax for denoting the values, and the set of
<P>
<PRE>
  operations on the values of the type depend on the values of the parameters.
<P>
</PRE>
2 A type parameter is either a kind type parameter or a length type parameter. All type parameters are of type
<P>
<PRE>
  integer. A kind type parameter participates in generic resolution (15.5.5.2), but a length type parameter does
<P>
  not.
<P>
</PRE>
3 Each intrinsic type has a kind type parameter named KIND. The intrinsic character type has a length type
<P>
<PRE>
  parameter named LEN. A derived type can have type parameters.
<P>
</PRE>
4 A type parameter value may be specified by a type specification (7.4, 7.5.9).
<P>
<PRE>
  R701      type-param-value             is scalar-int-expr
<P>
                                         or *
<P>
                                         or :
<P>
  C701      (R701) The type-param-value for a kind type parameter shall be a constant expression.
<P>
  C702      (R701) A colon shall not be used as a type-param-value except in the declaration of an entity that has
<P>
            the POINTER or ALLOCATABLE attribute.
<P>
</PRE>
5 A colon as a type-param-value specifies a deferred type parameter.
<P>
6 The values of the deferred type parameters of an object are determined by successful execution of an ALLOCATE
<P>
<PRE>
  statement (9.7.1), execution of an intrinsic assignment statement (10.2.1.3), execution of a pointer assignment
<P>
  statement (10.2.2), or by argument association (15.5.2).
<P>
       NOTE 7.1
<P>
       Deferred type parameters of functions, including function procedure pointers, have no values. Instead, they
<P>
       indicate that those type parameters of the function result will be determined by execution of the function,
<P>
       if it returns an allocated allocatable result or an associated pointer result.
<P>
</PRE>
7 An asterisk as a type-param-value specifies that a length type parameter is an assumed type parameter. It is used
<P>
<PRE>
  for a dummy argument to assume the type parameter value from the effective argument, for an associate name
<P>
  in a SELECT TYPE construct to assume the type parameter value from the corresponding selector, and for a
<P>
  named constant of type character to assume the character length from the constant-expr.
<P>
       NOTE 7.2
<P>
       The value of a kind type parameter is always known at compile time. Some parameterizations that involve
<P>
       multiple representation forms need to be distinguished at compile time for practical implementation and
<P>
       performance. Examples include the multiple precisions of the intrinsic real type and the possible multiple
<P>
       character sets of the intrinsic character type.
<P>
       The adjective “length” is used for type parameters other than kind type parameters because they often
<P>
       specify a length, as for intrinsic character type. However, they can be used for other purposes. The
<P>
       important difference from kind type parameters is that their values need not be known at compile time and
<P>
       might change during execution.
<P>
  7.3       Types, type specifiers, and values
<P>
  7.3.1      Relationship of types and values to objects
<P>
</PRE>
1 The name of a type serves as a type specifier and may be used to declare objects of that type. A declaration
<P>
<PRE>
  specifies the type of a named object. A data object may be declared explicitly or implicitly. A data object has
<P>
  58                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
  attributes in addition to its type. Clause 8 describes the way in which a data object is declared and how its type
<P>
  and other attributes are specified.
<P>
</PRE>
2 Scalar data of any intrinsic or derived type may be shaped in a rectangular pattern to compose an array of the
<P>
<PRE>
  same type and type parameters. An array object has a type and type parameters just as a scalar object does.
<P>
</PRE>
3 A variable is a data object. The type and type parameters of a variable determine which values that variable
<P>
<PRE>
  may take. Assignment (10.2) provides one means of changing the value of a variable of any type.
<P>
</PRE>
4 The type of a variable determines the operations that may be used to manipulate the variable.
<P>
<PRE>
  7.3.2     Type specifiers and type compatibility
<P>
  7.3.2.1    Type specifier syntax
<P>
</PRE>
1 A type specifier specifies a type and type parameter values. It is either a type-spec or a declaration-type-spec.
<P>
<PRE>
  R702     type-spec                     is intrinsic-type-spec
<P>
                                         or derived-type-spec
<P>
  C703     (R702) The derived-type-spec shall not specify an abstract type (7.5.7).
<P>
  R703     declaration-type-spec         is  intrinsic-type-spec
<P>
                                         or  TYPE ( intrinsic-type-spec )
<P>
                                         or  TYPE ( derived-type-spec )
<P>
                                         or  CLASS ( derived-type-spec )
<P>
                                         or  CLASS ( * )
<P>
                                         or  TYPE ( * )
<P>
  C704     (R703) In a declaration-type-spec, every type-param-value that is not a colon or an asterisk shall be a
<P>
           specification-expr.
<P>
  C705     (R703) In a declaration-type-spec that uses the CLASS keyword, derived-type-spec shall specify an ex-
<P>
           tensible type (7.5.7).
<P>
  C706     (R703) TYPE(derived-type-spec) shall not specify an abstract type (7.5.7).
<P>
  C707     (R702) In TYPE(intrinsic-type-spec) the intrinsic-type-spec shall not end with a comma.
<P>
  C708     An entity declared with the CLASS keyword shall be a dummy argument or have the ALLOCATABLE
<P>
           or POINTER attribute.
<P>
</PRE>
2 An intrinsic-type-spec specifies the named intrinsic type and its type parameter values. A derived-type-spec
<P>
<PRE>
  specifies the named derived type and its type parameter values.
<P>
       NOTE 7.3
<P>
       A type-spec is used in an array constructor, a SELECT TYPE construct, or an ALLOCATE statement. An
<P>
       integer-type-spec is used in a DO CONCURRENT or FORALL statement. Elsewhere, a declaration-type-spec
<P>
       is used.
<P>
  7.3.2.2    TYPE type specifier
<P>
</PRE>
1 A TYPE type specifier is used to declare entities that are assumed-type, or of an intrinsic or derived type.
<P>
2 A derived-type-spec in a TYPE type specifier in a type declaration statement shall specify a previously defined
<P>
<PRE>
  derived type. If the data entity is a function result, the derived type may be specified in the FUNCTION
<P>
  statement provided the derived type is defined within the body of the function or is accessible there by use or
<P>
  host association. If the derived type is specified in the FUNCTION statement and is defined within the body
<P>
  of the function, it is as if the function result were declared with that derived type immediately following the
<P>
  derived-type-def of the specified derived type.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            59
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 An entity that is declared using the <B>TYPE</B>(*) type specifier is assumed-type and is an unlimited polymorphic
<P>
<PRE>
  entity. It is not declared to have a type, and is not considered to have the same declared type as any other entity,
<P>
  including another unlimited polymorphic entity. Its dynamic type and type parameters are assumed from its
<P>
  effective argument.
<P>
  C709      An assumed-type entity shall be a dummy data object that does not have the ALLOCATABLE, CODI-
<P>
            MENSION, INTENT (OUT), POINTER, or VALUE attribute and is not an explicit-shape array.
<P>
  C710      An assumed-type variable name shall not appear in a designator or expression except as an actual
<P>
            argument corresponding to a dummy argument that is assumed-type, or as the first argument to the
<P>
            intrinsic function IS_CONTIGUOUS, LBOUND, PRESENT, RANK, SHAPE, SIZE, or UBOUND, or
<P>
            the function C_LOC from the intrinsic module ISO_C_BINDING.
<P>
  C711      An assumed-type actual argument that corresponds to an assumed-rank dummy argument shall be
<P>
            assumed-shape or assumed-rank.
<P>
  7.3.2.3     CLASS type specifier
<P>
</PRE>
1 The CLASS type specifier is used to declare polymorphic entities. A polymorphic entity is a data entity that is
<P>
<PRE>
  able to be of differing dynamic types during program execution.
<P>
</PRE>
2 A derived-type-spec in a CLASS type specifier in a type declaration statement shall specify a previously defined
<P>
<PRE>
  derived type. If the data entity is a function result, the derived type may be specified in the FUNCTION
<P>
  statement provided the derived type is defined within the body of the function or is accessible there by use or
<P>
  host association. If the derived type is specified in the FUNCTION statement and is defined within the body
<P>
  of the function, it is as if the function result were declared with that derived type immediately following its
<P>
  derived-type-def .
<P>
</PRE>
3 The declared type of a polymorphic entity is the specified type if the CLASS type specifier contains a type name.
<P>
4 An entity declared with the <B>CLASS</B>(*) specifier is an unlimited polymorphic entity. It is not declared to have
<P>
<PRE>
  a type, and is not considered to have the same declared type as any other entity, including another unlimited
<P>
  polymorphic entity.
<P>
</PRE>
5 A nonpolymorphic entity is type compatible only with entities of the same declared type. A polymorphic entity
<P>
<PRE>
  that is not an unlimited polymorphic entity is type compatible with entities of the same declared type or any of
<P>
  its extensions. Even though an unlimited polymorphic entity is not considered to have a declared type, it is type
<P>
  compatible with all entities. An entity is type compatible with a type if it is type compatible with entities of that
<P>
  type.
<P>
        NOTE 7.4
<P>
        Given
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE TROOT</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
<B>TYPE,EXTENDS</B>(TROOT) :: TEXTENDED
<P>
&#46;&#46;&#46;
<P>
<B>CLASS</B>(TROOT) A
<P>
<B>CLASS</B>(TEXTENDED) B
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
A is type compatible with B but B is not type compatible with A.
<BLOCKQUOTE>
<P>
6 A polymorphic allocatable object may be allocated to be of any type with which it is type compatible. A
<P>
<PRE>
  polymorphic pointer or dummy argument may, during program execution, be associated with objects with which
<P>
  it is type compatible.
<P>
  60                                                                  ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
7 The dynamic type of an allocated allocatable polymorphic object is the type with which it was allocated. The
<P>
<PRE>
  dynamic type of an associated polymorphic pointer is the dynamic type of its target. The dynamic type of a
<P>
  nonallocatable nonpointer polymorphic dummy argument is the dynamic type of its effective argument. The
<P>
  dynamic type of an unallocated allocatable object or a disassociated pointer is the same as its declared type. The
<P>
  dynamic type of an entity identified by an associate name (11.1.3) is the dynamic type of the selector with which
<P>
  it is associated. The dynamic type of an object that is not polymorphic is its declared type.
<P>
  7.4       Intrinsic types
<P>
  7.4.1      Classification and specification
<P>
</PRE>
1 Each intrinsic type is classified as a numeric type or a nonnumeric type. The numeric types are integer, real, and
<P>
<PRE>
  complex. The nonnumeric intrinsic types are character and logical.
<P>
</PRE>
2 Each intrinsic type has a kind type parameter named KIND; this type parameter is of type integer with default
<P>
<PRE>
  kind.
<P>
  R704      intrinsic-type-spec           is  integer-type-spec
<P>
                                          or  REAL [ kind-selector ]
<P>
                                          or  DOUBLE PRECISION
<P>
                                          or  COMPLEX [ kind-selector ]
<P>
                                          or  CHARACTER [ char-selector ]
<P>
                                          or  LOGICAL [ kind-selector ]
<P>
  R705      integer-type-spec             is  INTEGER [ kind-selector ]
<P>
  R706      kind-selector                 is  ( [ KIND = ] scalar-int-constant-expr )
<P>
  C712      (R706) The value of scalar-int-constant-expr shall be nonnegative and shall specify a representation
<P>
            method that exists on the processor.
<P>
  7.4.2      Intrinsic operations on intrinsic types
<P>
</PRE>
1 Intrinsic numeric operations are defined as specified in 10.1.5.2.1 for the numeric intrinsic types. Relational
<P>
<PRE>
  intrinsic operations are defined as specified in 10.1.5.5 for numeric and character intrinsic types. The intrinsic
<P>
  concatenation operation is defined as specified in 10.1.5.3 for the character type. Logical intrinsic operations are
<P>
  defined as specified in 10.1.5.4 for the logical type.
<P>
  7.4.3      Numeric intrinsic types
<P>
  7.4.3.1     Integer type
<P>
</PRE>
1 The set of values for the integer type is a subset of the mathematical integers. The processor shall provide one or
<P>
<PRE>
  more representation methods that define sets of values for data of type integer. Each such method is characterized
<P>
  by a value for the kind type parameter KIND. The kind type parameter of a representation method is returned
<P>
  by the intrinsic function KIND (16.9.108). The decimal exponent range of a representation method is returned
<P>
  by the intrinsic function RANGE (16.9.158). The intrinsic function SELECTED_INT_KIND (16.9.169) returns
<P>
  a kind value based on a specified decimal exponent range requirement. The integer type includes a zero value,
<P>
  which is considered to be neither negative nor positive. The value of a signed integer zero is the same as the
<P>
  value of an unsigned integer zero.
<P>
</PRE>
2 The processor shall provide at least one representation method with a decimal exponent range greater than or
<P>
<PRE>
  equal to 18.
<P>
</PRE>
3 The type specifier for the integer type uses the keyword INTEGER.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            61
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 The keyword INTEGER with no kind-selector specifies type integer with default kind; the kind type parameter
<P>
<PRE>
  value is equal to KIND (0). The decimal exponent range of default integer shall be at least 5.
<P>
</PRE>
5 Any integer value may be represented as a signed-int-literal-constant.
<P>
<PRE>
  R707     signed-int-literal-constant   is  [ sign ] int-literal-constant
<P>
  R708     int-literal-constant          is  digit-string [ _ kind-param ]
<P>
  R709     kind-param                    is digit-string
<P>
                                         or scalar-int-constant-name
<P>
  R710     signed-digit-string           is  [ sign ] digit-string
<P>
  R711     digit-string                  is  digit [ digit ] &#46;&#46;&#46;
<P>
  R712     sign                          is +
<P>
                                         or –
<P>
  C713     (R709) A scalar-int-constant-name shall be a named constant of type integer.
<P>
  C714     (R709) The value of kind-param shall be nonnegative.
<P>
  C715     (R708) The value of kind-param shall specify a representation method that exists on the processor.
<P>
</PRE>
6 The optional kind type parameter following digit-string specifies the kind type parameter of the integer constant;
<P>
<PRE>
  if it does not appear, the constant is default integer.
<P>
</PRE>
7 An integer constant is interpreted as a decimal value.
<P>
<PRE>
        NOTE 7.5
<P>
        Examples of signed integer literal constants are:
<P>
        473
<P>
        +56
<P>
        -101
<P>
        21_2
<P>
        21_SHORT
<P>
        1976354279568241_8
<P>
        where SHORT is a scalar integer named constant. A program that uses a digit-string as a kind-param is
<P>
        unlikely to be portable.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.4.3.2</B> </TD><TD valign=bottom>
Real type
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The real type has values that approximate the mathematical real numbers. The processor shall provide two
<P>
<PRE>
  or more approximation methods that define sets of values for data of type real. Each such method has a
<P>
  representation method and is characterized by a value for the kind type parameter KIND. The kind type parameter
<P>
  of an approximation method is returned by the intrinsic function KIND (16.9.108).
<P>
</PRE>
2 The decimal precision, decimal exponent range, and radix of an approximation method are returned by the
<P>
<PRE>
  intrinsic functions PRECISION (16.9.151), RANGE (16.9.158), and RADIX (16.9.154). The intrinsic function
<P>
  SELECTED_REAL_KIND (16.9.170) returns a kind value based on specified precision, range, and radix re-
<P>
  quirements.
<P>
        NOTE 7.6
<P>
        See C.2.1 for remarks concerning selection of approximation methods.
<P>
  62                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 The real type includes a zero value. Processors that distinguish between positive and negative zeros shall treat
<P>
<PRE>
  them as mathematically equivalent
<P>
      • in all intrinsic relational operations, and
<P>
      • as actual arguments to intrinsic procedures other than those for which it is explicitly specified that negative
<P>
         zero is distinguished.
<P>
        NOTE 7.7
<P>
        On a processor that distinguishes between 0.0 and −0.0,
<P>
            ( X &gt;= 0.0 )
<P>
        evaluates to true if X = 0.0 or if X = −0.0,
<P>
            ( X &lt; 0.0 )
<P>
        evaluates to false for X = −0.0.
<P>
        In order to distinguish between 0.0 and −0.0, a program can use the intrinsic function SIGN. SIGN (1.0, X)
<P>
        will return −1.0 if X &lt; 0.0 or if the processor distinguishes between 0.0 and −0.0 and X has the value −0.0.
<P>
</PRE>
4 The type specifier for the real type uses the keyword REAL. The keyword DOUBLE PRECISION is an alternative
<P>
<PRE>
  specifier for one kind of real type.
<P>
</PRE>
5 If the type keyword REAL is used without a kind type parameter, the real type with default real kind is specified
<P>
<PRE>
  and the kind value is KIND (0.0). The type specifier DOUBLE PRECISION specifies type real with double
<P>
  precision kind; the kind value is KIND (0.0D0). The decimal precision of the double precision real approximation
<P>
  method shall be greater than that of the default real method.
<P>
</PRE>
6 The decimal precision of double precision real shall be at least 10, and its decimal exponent range shall be at
<P>
<PRE>
  least 37. It is recommended that the decimal precision of default real be at least 6, and that its decimal exponent
<P>
  range be at least 37.
<P>
  R713      signed-real-literal-constant   is  [ sign ] real-literal-constant
<P>
  R714      real-literal-constant          is significand [ exponent-letter exponent ] [ _ kind-param ]
<P>
                                           or digit-string exponent-letter exponent [ _ kind-param ]
<P>
  R715      significand                    is digit-string . [ digit-string ]
<P>
                                           or . digit-string
<P>
  R716      exponent-letter                is E
<P>
                                           or D
<P>
  R717      exponent                       is  signed-digit-string
<P>
  C716      (R714) If both kind-param and exponent-letter appear, exponent-letter shall be E.
<P>
  C717      (R714) The value of kind-param shall specify an approximation method that exists on the processor.
<P>
</PRE>
7 A real literal constant without a kind type parameter is a default real constant if it is without an exponent part
<P>
<PRE>
  or has exponent letter E, and is a double precision real constant if it has exponent letter D. A real literal constant
<P>
  written with a kind type parameter is a real constant with the specified kind type parameter.
<P>
</PRE>
8 The exponent represents the power of ten scaling to be applied to the significand or digit string. The meaning of
<P>
<PRE>
  these constants is as in decimal scientific notation.
<P>
</PRE>
9 The significand may be written with more digits than a processor will use to approximate the value of the constant.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              63
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 7.8
<P>
        Examples of signed real literal constants are:
<P>
        -12.78
<P>
        +1.6E3
<P>
        2.1
<P>
        -16.E4_8
<P>
        0.45D-4
<P>
        10.93E7_QUAD
<P>
        .123
<P>
        3E4
<P>
        where QUAD is a scalar integer named constant.
<P>
  7.4.3.3    Complex type
<P>
</PRE>
1 The complex type has values that approximate the mathematical complex numbers. The values of a complex
<P>
<PRE>
  type are ordered pairs of real values. The first real value is called the real part, and the second real value is called
<P>
  the imaginary part.
<P>
</PRE>
2 Each approximation method used to represent data entities of type real shall be available for both the real and
<P>
<PRE>
  imaginary parts of a data entity of type complex. The (default integer) kind type parameter KIND for a complex
<P>
  entity specifies for both parts the real approximation method characterized by this kind type parameter value.
<P>
  The kind type parameter of an approximation method is returned by the intrinsic function KIND (16.9.108).
<P>
</PRE>
3 The type specifier for the complex type uses the keyword COMPLEX. There is no keyword for double precision
<P>
<PRE>
  complex. If the type keyword COMPLEX is used without a kind type parameter, the complex type with default
<P>
  complex kind is specified, the kind value is KIND (0.0), and both parts are default real.
<P>
  R718     complex-literal-constant       is  ( real-part , imag-part )
<P>
  R719     real-part                      is signed-int-literal-constant
<P>
                                          or signed-real-literal-constant
<P>
                                          or named-constant
<P>
  R720     imag-part                      is signed-int-literal-constant
<P>
                                          or signed-real-literal-constant
<P>
                                          or named-constant
<P>
  C718     (R718) Each named constant in a complex literal constant shall be of type integer or real.
<P>
</PRE>
4 If the real part and the imaginary part of a complex literal constant are both real, the kind type parameter value
<P>
<PRE>
  of the complex literal constant is the kind type parameter value of the part with the greater decimal precision; if
<P>
  the precisions are the same, it is the kind type parameter value of one of the parts as determined by the processor.
<P>
  If a part has a kind type parameter value different from that of the complex literal constant, the part is converted
<P>
  to the approximation method of the complex literal constant.
<P>
</PRE>
5 If both the real and imaginary parts are integer, they are converted to the default real approximation method
<P>
<PRE>
  and the constant is default complex. If only one of the parts is an integer, it is converted to the approximation
<P>
  method selected for the part that is real and the kind type parameter value of the complex literal constant is
<P>
  that of the part that is real.
<P>
        NOTE 7.9
<P>
        Examples of complex literal constants are:
<P>
  64                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 7.9 (cont.)
<P>
        (1.0, -1.0)
<P>
        (3, 3.1E6)
<P>
        (4.0_4, 3.6E7_8)
<P>
        ( 0., PI)             ! where PI is a previously declared named real constant.
<P>
  7.4.4      Character type
<P>
  7.4.4.1    Character sets
<P>
</PRE>
1 The character type has a set of values composed of character strings. A character string is a sequence of characters,
<P>
<PRE>
  numbered from left to right 1, 2, 3, &#46;&#46;&#46; up to the number of characters in the string. The number of characters in
<P>
  the string is called the length of the string. The length is a type parameter; its kind is processor dependent and
<P>
  its value is greater than or equal to zero.
<P>
</PRE>
2 The processor shall provide one or more representation methods that define sets of values for data of type
<P>
<PRE>
  character. Each such method is characterized by a value for the (default integer) kind type parameter KIND.
<P>
  The kind type parameter of a representation method is returned by the intrinsic function KIND (16.9.108). The
<P>
  intrinsic function SELECTED_CHAR_KIND (16.9.168) returns a kind value based on the name of a character
<P>
  type. Any character of a particular representation method representable in the processor may occur in a character
<P>
  string of that representation method.
<P>
</PRE>
3 The character set specified in ISO/IEC 646:1991 (International Reference Version) is referred to as the ASCII
<P>
<PRE>
  character set and its corresponding representation method is ASCII character kind. The character set UCS-4 as
<P>
  specified in ISO/IEC 10646 is referred to as the ISO 10646 character set and its corresponding representation
<P>
  method is the ISO 10646 character kind.
<P>
  7.4.4.2    Character type specifier
<P>
</PRE>
1 The type specifier for the character type uses the keyword CHARACTER.
<P>
2 If the type keyword CHARACTER is used without a kind type parameter, the character type with default
<P>
<PRE>
  character kind is specified and the kind value is KIND (’A’).
<P>
</PRE>
3 The default character kind shall support a character set that includes the characters in the Fortran character
<P>
<PRE>
  set (6.1). By supplying nondefault character kinds, the processor may support additional character sets. The
<P>
  characters available in nondefault character kinds are not specified by this document, except that one character
<P>
  in each nondefault character set shall be designated as a blank character to be used as a padding character.
<P>
  R721     char-selector                 is length-selector
<P>
                                         or ( LEN = type-param-value ,
<P>
                                                 KIND = scalar-int-constant-expr )
<P>
                                         or ( type-param-value ,
<P>
                                                 [ KIND = ] scalar-int-constant-expr )
<P>
                                         or ( KIND = scalar-int-constant-expr
<P>
                                                 [ , LEN =type-param-value ] )
<P>
  R722     length-selector               is ( [ LEN = ] type-param-value )
<P>
                                         or * char-length [ , ]
<P>
  R723     char-length                   is ( type-param-value )
<P>
                                         or int-literal-constant
<P>
  C719     (R721) The value of scalar-int-constant-expr shall be nonnegative and shall specify a representation
<P>
           method that exists on the processor.
<P>
  C720     (R723) The int-literal-constant shall not include a kind-param.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            65
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C721      (R723) A type-param-value in a char-length shall be a colon, asterisk, or specification-expr.
<P>
  C722      (R721 R722 R723) A type-param-value of * shall be used only
<P>
              • to declare a dummy argument,
<P>
              • to declare a named constant,
<P>
              • in the type-spec of an ALLOCATE statement wherein each allocate-object is a dummy argument of
<P>
                 type CHARACTER with an assumed character length,
<P>
              • in the type-spec or derived-type-spec of a type guard statement (11.1.11), or
<P>
              • in an external function, to declare the character length parameter of the function result.
<P>
  C723      A function name shall not be declared with an asterisk type-param-value unless it is of type CHARACTER
<P>
            and is the name of a dummy function or the name of the result of an external function.
<P>
  C724      A function name declared with an asterisk type-param-value shall not be an array, a pointer, elemental, or pure. A function
<P>
            name declared with an asterisk type-param-value shall not have the RECURSIVE attribute.
<P>
  C725      (R722) The optional comma in a length-selector is permitted only in a declaration-type-spec in a type-declaration-stmt.
<P>
  C726      (R722) The optional comma in a length-selector is permitted only if no double-colon separator appears in the type-
<P>
            declaration-stmt.
<P>
  C727      (R721) The length specified for a character statement function or for a statement function dummy argument of type
<P>
            character shall be a constant expression.
<P>
</PRE>
4 The char-selector in a CHARACTER intrinsic-type-spec and the * char-length in an entity-decl or in a component-
<P>
<PRE>
  decl of a type definition specify character length. The * char-length in an entity-decl or a component-decl specifies
<P>
  an individual length and overrides the length specified in the char-selector, if any. If a * char-length is not specified
<P>
  in an entity-decl or a component-decl, the length-selector or type-param-value specified in the char-selector is the
<P>
  character length. If the length is not specified in a char-selector or a * char-length, the length is 1.
<P>
</PRE>
5 If the character length parameter value evaluates to a negative value, the length of character entities declared
<P>
<PRE>
  is zero. A character length parameter value of : indicates a deferred type parameter (7.2). A char-length type
<P>
  parameter value of * has the following meanings.
<P>
      • If used to declare a dummy argument of a procedure, the dummy argument assumes its length from its
<P>
        effective argument.
<P>
      • If used to declare a named constant, the length is that of the constant value.
<P>
      • If used in the type-spec of an ALLOCATE statement, each allocate-object assumes its length from its effective
<P>
        argument.
<P>
      • If used in the type-spec of a type guard statement, the associating entity assumes its length from the selector.
<P>
      • If used to specify the character length parameter of a function result, any scoping unit invoking the function or passing it as
<P>
        an actual argument shall declare the function name with a character length parameter value other than * or access such a
<P>
        definition by argument, host, or use association. When the function is invoked, the length of the function result is assumed
<P>
        from the value of this type parameter.
<P>
  7.4.4.3     Character literal constant
<P>
</PRE>
1 The syntax of a character literal constant is given by R724.
<P>
<PRE>
  R724      char-literal-constant             is [ kind-param _ ] ’ [ rep-char ] &#46;&#46;&#46; ’
<P>
                                              or [ kind-param _ ] " [ rep-char ] &#46;&#46;&#46; "
<P>
  C728      (R724) The value of kind-param shall specify a representation method that exists on the processor.
<P>
</PRE>
2 The optional kind type parameter preceding the leading delimiter specifies the kind type parameter of the char-
<P>
<PRE>
  acter constant; if it does not appear, the constant is default character.
<P>
  66                                                                          ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 For the type character with kind kind-param, if it appears, and for default character otherwise, a representable
<P>
<PRE>
  character, rep-char, is defined as follows.
<P>
      • In free source form, it is any graphic character in the processor-dependent character set.
<P>
      • In fixed source form, it is any character in the processor-dependent character set. A processor may restrict the occurrence of
<P>
         some or all of the control characters.
<P>
</PRE>
4 The delimiting apostrophes or quotation marks are not part of the value of the character literal constant.
<P>
5 An apostrophe character within a character constant delimited by apostrophes is represented by two consecutive
<P>
<PRE>
  apostrophes (without intervening blanks); in this case, the two apostrophes are counted as one character. Sim-
<P>
  ilarly, a quotation mark character within a character constant delimited by quotation marks is represented by
<P>
  two consecutive quotation marks (without intervening blanks) and the two quotation marks are counted as one
<P>
  character.
<P>
</PRE>
6 A zero-length character literal constant is represented by two consecutive apostrophes (without intervening blanks)
<P>
<PRE>
  or two consecutive quotation marks (without intervening blanks) outside of a character context.
<P>
        NOTE 7.10
<P>
        Examples of character literal constants are:
<P>
        "DON’T"
<P>
        ’DON’’T’
<P>
        both of which have the value DON’T and
<P>
        ’’
<P>
        which has the zero-length character string as its value.
<P>
        NOTE 7.11
<P>
        An example of a nondefault character literal constant, where the processor supports the corresponding
<P>
        character set, is:
<P>
                                                       
<P>
        NIHONGO_’                                               ’
<P>
        where NIHONGO is a named constant whose value is the kind type parameter for Nihongo (Japanese)
<P>
        characters. This means “Without her, nothing is possible”.
<P>
  7.4.4.4    Collating sequence
<P>
</PRE>
1 The processor defines a collating sequence for the character set of each kind of character. The collating sequence
<P>
<PRE>
  is an isomorphism between the character set and the set of integers {I : 0 ≤ I &lt; N }, where N is the number of
<P>
  characters in the set. The intrinsic functions CHAR (16.9.44) and ICHAR (16.9.95) provide conversions between
<P>
  the characters and the integers according to this mapping.
<P>
        NOTE 7.12
<P>
        For example:
<P>
            ICHAR ( ’X’ )
<P>
        returns the integer value of the character ’X’ according to the collating sequence of the processor.
<P>
</PRE>
2 The collating sequence of the default character kind shall satisfy the following constraints.
<P>
<PRE>
      • ICHAR (’A’) &lt; ICHAR (’B’) &lt; &#46;&#46;&#46; &lt; ICHAR (’Z’) for the twenty-six upper-case letters.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
67
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
      • ICHAR (’0’) &lt; ICHAR (’1’) &lt; &#46;&#46;&#46; &lt; ICHAR (’9’) for the ten digits.
<P>
      • ICHAR (’ ’) &lt; ICHAR (’0’) &lt; ICHAR (’9’) &lt; ICHAR (’A’) or
<P>
        ICHAR (’ ’) &lt; ICHAR (’A’) &lt; ICHAR (’Z’) &lt; ICHAR (’0’).
<P>
      • ICHAR (’a’) &lt; ICHAR (’b’) &lt; &#46;&#46;&#46; &lt; ICHAR (’z’) for the twenty-six lower-case letters.
<P>
      • ICHAR (’ ’) &lt; ICHAR (’0’) &lt; ICHAR (’9’) &lt; ICHAR (’a’) or
<P>
        ICHAR (’ ’) &lt; ICHAR (’a’) &lt; ICHAR (’z’) &lt; ICHAR (’0’).
<P>
</PRE>
3 There are no constraints on the location of any other character in the collating sequence, nor is there any specified
<P>
<PRE>
  collating sequence relationship between the upper-case and lower-case letters.
<P>
</PRE>
4 The collating sequence for the ASCII character kind is as specified in ISO/IEC 646:1991 (International Reference
<P>
<PRE>
  Version); this collating sequence is called the ASCII collating sequence in this document. The collating sequence
<P>
  for the ISO 10646 character kind is as specified in ISO/IEC 10646.
<P>
       NOTE 7.13
<P>
       The intrinsic functions ACHAR (16.9.3) and IACHAR (16.9.88) provide conversions between characters
<P>
       and corresponding integer values according to the ASCII collating sequence.
<P>
</PRE>
5 The intrinsic functions LGT, LGE, LLE, and LLT (16.9.114-16.9.117) provide comparisons between strings based
<P>
<PRE>
  on the ASCII collating sequence. International portability is guaranteed if the set of characters used is limited
<P>
  to the Fortran character set (6.1).
<P>
  7.4.5     Logical type
<P>
</PRE>
1 The logical type has two values, which represent true and false.
</BLOCKQUOTE>
<P>
2 The processor shall provide one or more representation methods for data of type logical. Each such method
<P>
<PRE>
  is characterized by a value for the (default integer) kind type parameter KIND. The kind type parameter of a
<P>
  representation method is returned by the intrinsic function KIND (16.9.108).
<P>
</PRE>
3 The type specifier for the logical type uses the keyword LOGICAL.
<BLOCKQUOTE>
<P>
4 The keyword LOGICAL with no kind-selector specifies type logical with default kind; the kind type parameter
<P>
<PRE>
  value is equal to KIND (.FALSE.).
<P>
  R725     logical-literal-constant      is .TRUE. [ _ kind-param ]
<P>
                                         or .FALSE. [ _ kind-param ]
<P>
  C729     (R725) The value of kind-param shall specify a representation method that exists on the processor.
<P>
</PRE>
5 The optional kind type parameter specifies the kind type parameter of the logical constant; if it does not appear,
<P>
<PRE>
  the constant has the default logical kind.
<P>
  7.5      Derived types
<P>
  7.5.1     Derived type concepts
<P>
</PRE>
1 Additional types can be derived from the intrinsic types and other derived types. A type definition defines the
<P>
<PRE>
  name of the type and the names and attributes of its components and type-bound procedures.
<P>
</PRE>
2 A derived type can be parameterized by one or more type parameters, each of which is defined to be either a
<P>
<PRE>
  kind or length type parameter and can have a default value.
<P>
</PRE>
3 The ultimate components of a derived type are the components that are of intrinsic type or have the ALLOC-
<P>
<PRE>
  ATABLE or POINTER attribute, plus the ultimate components of the components that are of derived type and
<P>
  have neither the ALLOCATABLE nor POINTER attribute.
<P>
  68                                                                 ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 The direct components of a derived type are the components of that type, plus the direct components of the
<P>
<PRE>
  components that are of derived type and have neither the ALLOCATABLE nor POINTER attribute.
<P>
</PRE>
5 The potential subobject components of a derived type are the nonpointer components of that type together with
<P>
<PRE>
  the potential subobject components of the nonpointer components that are of derived type. This includes all the
<P>
  components that could be a subobject of an object of the type (9.4.2).
<P>
</PRE>
6 The components, direct components, potential subobject components, and ultimate components of an object of
<P>
<PRE>
  derived type are the components, direct components, potential subobject components, and ultimate components
<P>
  of its type, respectively.
<P>
</PRE>
7 By default, no storage sequence is implied by the order of the component definitions. However, a storage sequence
<P>
<PRE>
  is implied for a sequence type (7.5.2.3). If the derived type has the BIND attribute, the storage sequence is that
<P>
  required by the companion processor (5.5.7, 18.3.4).
<P>
</PRE>
8 A scalar entity of derived type is a structure. If a derived type has the SEQUENCE attribute, a scalar entity of
<P>
<PRE>
  the type is a sequence structure.
<P>
        NOTE 7.14
<P>
        The ultimate components of an object of the derived type kids defined below are oldest_child%name,
<P>
        oldest_child%age, and other_kids. The direct components of such an object are oldest_child%name,
<P>
        oldest_child%age, other_kids, and oldest_child.
<P>
        type :: person
<P>
           character(len=20) :: name
<P>
           integer :: age
<P>
        end type person
<P>
        type :: kids
<P>
           type(person) :: oldest_child
<P>
           type(person), allocatable, dimension(:) :: other_kids
<P>
        end type kids
<P>
  7.5.2      Derived-type definition
<P>
  7.5.2.1     Syntax of a derived-type definition
<P>
  R726      derived-type-def               is derived-type-stmt
<P>
                                                   [ type-param-def-stmt ] &#46;&#46;&#46;
<P>
                                                   [ private-or-sequence ] &#46;&#46;&#46;
<P>
                                                   [ component-part ]
<P>
                                                   [ type-bound-procedure-part ]
<P>
                                                   end-type-stmt
<P>
  R727      derived-type-stmt              is TYPE [ [ , type-attr-spec-list ] :: ] type-name
<P>
                                                 [ ( type-param-name-list ) ]
<P>
  R728      type-attr-spec                 is ABSTRACT
<P>
                                           or access-spec
<P>
                                           or BIND (C)
<P>
                                           or EXTENDS ( parent-type-name )
<P>
  C730      (R727) A derived type type-name shall not be DOUBLEPRECISION or the same as the name of any
<P>
            intrinsic type defined in this document.
<P>
  C731      (R727) The same type-attr-spec shall not appear more than once in a given derived-type-stmt.
<P>
  C732      The same type-param-name shall not appear more than once in a given derived-type-stmt.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          69
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C733     (R728) A parent-type-name shall be the name of a previously defined extensible type (7.5.7).
<P>
  C734     (R726) If the type definition contains or inherits (7.5.7.2) a deferred type-bound procedure (7.5.5), AB-
<P>
           STRACT shall appear.
<P>
  C735     (R726) If ABSTRACT appears, the type shall be extensible.
<P>
  C736     (R726) If EXTENDS appears, SEQUENCE shall not appear.
<P>
  C737     (R726) If EXTENDS appears and the type being defined has a coarray ultimate component, its parent
<P>
           type shall have a coarray ultimate component.
<P>
  C738     (R726) If EXTENDS appears and the type being defined has a potential subobject component of type
<P>
           EVENT_TYPE or LOCK_TYPE from the intrinsic module ISO_FORTRAN_ENV, its parent type
<P>
           shall be EVENT_TYPE or LOCK_TYPE or have a potential subobject component of type EVENT_-
<P>
           TYPE or LOCK_TYPE.
<P>
  R729     private-or-sequence           is private-components-stmt
<P>
                                         or sequence-stmt
<P>
  C739     (R726) The same private-or-sequence shall not appear more than once in a given derived-type-def .
<P>
  R730     end-type-stmt                 is   END TYPE [ type-name ]
<P>
  C740     (R730) If END TYPE is followed by a type-name, the type-name shall be the same as that in the
<P>
           corresponding derived-type-stmt.
<P>
</PRE>
1 Derived types with the BIND attribute are subject to additional constraints as specified in 18.3.4.
<P>
<PRE>
        NOTE 7.15
<P>
        An example of a derived-type definition is:
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE PERSON</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER AGE</H4>
</A>
<BLOCKQUOTE>
<P>
CHARACTER (LEN = 50) NAME
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE PERSON</H4>
</A>
<BLOCKQUOTE>
<P>
An example of declaring a variable CHAIRMAN of type PERSON is:
<P>
TYPE (PERSON) :: CHAIRMAN
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: TYPE (PERSON) :: CHAIRMAN
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.2.2</B> </TD><TD valign=bottom>
Accessibility
<P>
1 The accessibility of a type name is determined as specified in 8.5.2. The accessibility of a type name does not
<P>
<PRE>
  affect, and is not affected by, the accessibility of its components and type-bound procedures.
<P>
</PRE>
2 If a derived type is defined in the scoping unit of a module, and its name is private in that module, then the type
<P>
<PRE>
  name, and thus the structure constructor (7.5.10) for the type, are accessible only within that module and its
<P>
  descendants.
<P>
        NOTE 7.16
<P>
        An example of a type with a private name is:
<P>
        TYPE, PRIVATE :: AUXILIARY
<P>
            LOGICAL :: DIAGNOSTIC
<P>
            CHARACTER (LEN = 20) :: MESSAGE
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END TYPE AUXILIARY</H4>
</A>
<BLOCKQUOTE>
<P>
Such a type would be accessible only within the module in which it is defined, and within its descendants.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: Such a type would be accessible only within the module in which it is defined, and within its descendants.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>70</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.5.2.3</B> </TD><TD valign=bottom>
Sequence type
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R731</B> </TD><TD valign=bottom>
sequence-stmt                is   SEQUENCE
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C741</B> </TD><TD valign=bottom>
(R726) If SEQUENCE appears, the type shall have at least one component, each data component shall
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
            be declared to be of an intrinsic type or of a sequence type, the derived type shall not have any type
<P>
            parameter, and a type-bound-procedure-part shall not appear.
<P>
</PRE>
1 If the SEQUENCE statement appears, the type has the SEQUENCE attribute and is a sequence type. The order
<P>
<PRE>
  of the component definitions in a sequence type specifies a storage sequence for objects of that type. The type
<P>
  is a numeric sequence type if there are no pointer or allocatable components, and each component is default
<P>
  integer, default real, double precision real, default complex, default logical, or of numeric sequence type. The
<P>
  type is a character sequence type if there are no pointer or allocatable components, and each component is default
<P>
  character or of character sequence type.
<P>
        NOTE 7.17
<P>
        An example of a numeric sequence type is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE NUMERIC_SEQ</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SEQUENCE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER :: INT_VAL
<TABLE cellpadding=3><!-- tsb: INTEGER :: INT_VAL
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>REAL</B> </TD><TD valign=bottom>
:: REAL_VAL
</TD></TR>
<TR></TR></TABLE>LOGICAL :: LOG_VAL
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE NUMERIC_SEQ</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 7.18
<P>
A structure resolves into a sequence of components. Unless the structure includes a SEQUENCE statement,
<P>
the use of this terminology in no way implies that these components are stored in this, or any other, order.
<P>
Nor is there any requirement that contiguous storage be used. The sequence merely refers to the fact that
<P>
in writing the definitions there will necessarily be an order in which the components appear, and this will
<P>
define a sequence of components. This order is of limited significance because a component of an object of
<P>
derived type will always be accessed by a component name except in the following contexts: the sequence of
<P>
expressions in a derived-type value constructor, intrinsic assignment, the data values in namelist input data,
<P>
and the inclusion of the structure in an input/output list of a formatted data transfer, where it is expanded
<P>
to this sequence of components. Provided the processor adheres to the defined order in these cases, it is
<P>
otherwise free to organize the storage of the components for any nonsequence structure in memory as best
<P>
suited to the particular architecture.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: suited to the particular architecture.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.2.4</B> </TD><TD valign=bottom>
Determination of derived types
<P>
1 Derived-type definitions with the same type name may appear in different scoping units, in which case they might
<P>
<PRE>
  be independent and describe different derived types or they might describe the same type.
<P>
</PRE>
2 Two data entities have the same type if they are declared with reference to the same derived-type definition. Data
<P>
<PRE>
  entities also have the same type if they are declared with reference to different derived-type definitions that specify
<P>
  the same type name, all have the SEQUENCE attribute or all have the BIND attribute, have no components
<P>
  with PRIVATE accessibility, and have components that agree in order, name, and attributes. Otherwise, they
<P>
  are of different derived types. A data entity declared using a type with the SEQUENCE attribute or with the
<P>
  BIND attribute is not of the same type as an entity of a type that has any components that are PRIVATE.
<P>
        NOTE 7.19
<P>
        An example of declaring two entities with reference to the same derived-type definition is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>REAL X,</B> </TD><TD valign=bottom>
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
71
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
   NOTE 7.19 (cont.)
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (POINT) :: X1
<P>
CALL SUB (X1)
<P>
<PRE>
       &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE SUB (A)
<P>
<PRE>
           TYPE (POINT) :: A
<P>
              &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
The definition of derived type POINT is known in subroutine SUB by host association. Because the
<P>
declarations of X1 and A both reference the same derived-type definition, X1 and A have the same type.
<P>
X1 and A also would have the same type if the derived-type definition were in a module and both SUB and
<P>
its containing program unit accessed that derived type from the module.
<P>
NOTE 7.20
<P>
An example of data entities in different scoping units having the same type is:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM PGM</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE EMPLOYEE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SEQUENCE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER ID_NUMBER</H4>
</A>
<BLOCKQUOTE>
<P>
CHARACTER (50) NAME
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE EMPLOYEE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (EMPLOYEE) PROGRAMMER
<P>
CALL SUB (PROGRAMMER)
<P>
<PRE>
           &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM PGM</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE SUB (POSITION)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE EMPLOYEE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SEQUENCE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER ID_NUMBER</H4>
</A>
<BLOCKQUOTE>
<P>
CHARACTER (50) NAME
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE EMPLOYEE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (EMPLOYEE) POSITION
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
The actual argument PROGRAMMER and the dummy argument POSITION have the same type because
<P>
they are declared with reference to a derived-type definition with the same name, the SEQUENCE attribute,
<P>
and components that agree in order, name, and attributes.
<P>
Suppose the component name ID_NUMBER was ID_NUM in the subroutine. Because all the component
<P>
names are not identical to the component names in derived type EMPLOYEE in the main program, the
<P>
actual argument PROGRAMMER would not be of the same type as the dummy argument POSITION.
<P>
Thus, the program would not be standard-conforming.
<P>
NOTE 7.21
<P>
The requirement that the two types have the same name applies to the type-names in the respective derived
<P>
type definitions, not to local names introduced via renaming in USE statements.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: type definitions, not to local names introduced via renaming in USE statements.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>72</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.5.3</B> </TD><TD valign=bottom>
Derived-type parameters
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.3.1</B> </TD><TD valign=bottom>
Type parameter definition statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R732</B> </TD><TD valign=bottom>
type-param-def-stmt          is  integer-type-spec, type-param-attr-spec ::
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                type-param-decl-list
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R733</B> </TD><TD valign=bottom>
type-param-decl              is  type-param-name [ = scalar-int-constant-expr ]
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C742</B> </TD><TD valign=bottom>
(R732) A type-param-name in a type-param-def-stmt in a derived-type-def shall be one of the type-param-
</TD></TR>
<TR><TD colspan=2>
<PRE>
            names in the derived-type-stmt of that derived-type-def .
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C743</B> </TD><TD valign=bottom>
(R732) Each type-param-name in the derived-type-stmt in a derived-type-def shall appear exactly once as
</TD></TR>
<TR><TD colspan=2>
<PRE>
            a type-param-name in a type-param-def-stmt in that derived-type-def .
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R734</B> </TD><TD valign=bottom>
type-param-attr-spec         is KIND
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                         or LEN
<P>
</PRE>
1 The derived type is parameterized if the derived-type-stmt has any type-param-names.
</TD></TR>
<TR><TD colspan=2>
2 Each type parameter is itself of type integer. If its kind selector is omitted, the kind type parameter is default
</TD></TR>
<TR><TD colspan=2>
<PRE>
  integer.
<P>
</PRE>
3 The type-param-attr-spec explicitly specifies whether a type parameter is a kind parameter or a length parameter.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
4 If a type-param-decl has a scalar-int-constant-expr, the type parameter has a default value which is specified by
<P>
<PRE>
  the expression. If necessary, the value is converted according to the rules of intrinsic assignment (10.2.1.3) to a
<P>
  value of the same kind as the type parameter.
<P>
</PRE>
5 A type parameter may be used as a primary in a specification expression (10.1.11) in the derived-type-def . A
<P>
<PRE>
  kind type parameter may also be used as a primary in a constant expression (10.1.12) in the derived-type-def .
<P>
        NOTE 7.22
<P>
        The following example uses derived-type parameters.
<P>
               TYPE humongous_matrix(k, d)
<P>
                 INTEGER, KIND :: k = KIND (0.0)
<P>
                 INTEGER (SELECTED_INT_KIND (12)), LEN :: d
<P>
                    !-- Specify a potentially nondefault kind for d.
<P>
                 REAL (k) :: element (d, d)
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
In the following example, dim is declared to be a kind parameter, allowing generic overloading of procedures
<P>
distinguished only by dim.
<P>
<PRE>
               TYPE general_point(dim)
<P>
                 INTEGER, KIND :: dim
<P>
                 REAL :: coordinates(dim)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.5.3.2</B> </TD><TD valign=bottom>
Type parameter order
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Type parameter order is an ordering of the type parameters of a derived type; it is used for derived-type specifiers.
<BLOCKQUOTE>
<P>
2 The type parameter order of a nonextended type is the order of the type parameter list in the derived-type
<P>
<PRE>
  definition. The type parameter order of an extended type (7.5.7) consists of the type parameter order of its
<P>
  parent type followed by any additional type parameters in the order of the type parameter list in the derived-type
<P>
  definition.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            73
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
     NOTE 7.23
<P>
     Given
<P>
           TYPE :: t1 (k1, k2)
<P>
              INTEGER, KIND :: k1, k2
<P>
              REAL (k1) a (k2)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE, <B>EXTENDS</B>(t1) :: t2 (k3)
<P>
<PRE>
              INTEGER, KIND :: k3
<P>
              LOGICAL (k3) flag
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
the type parameter order for type t1 is k1 then k2, and the type parameter order for type t2 is k1 then k2
<P>
then k3.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: then k3.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.4</B> </TD><TD valign=bottom>
Components
<TABLE width=100% cellpadding=3><!-- tsb: Components
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.4.1</B> </TD><TD valign=bottom>
Component definition statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R735</B> </TD><TD valign=bottom>
component-part               is  [ component-def-stmt ] &#46;&#46;&#46;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R736</B> </TD><TD valign=bottom>
component-def-stmt           is data-component-def-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                     or proc-component-def-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R737</B> </TD><TD valign=bottom>
data-component-def-stmt      is  declaration-type-spec [ [ , component-attr-spec-list ] :: ]
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                            component-decl-list
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R738</B> </TD><TD valign=bottom>
component-attr-spec          is  access-spec
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                     or  ALLOCATABLE
<P>
                                     or  CODIMENSION lbracket coarray-spec rbracket
<P>
                                     or  CONTIGUOUS
<P>
                                     or  DIMENSION ( component-array-spec )
<P>
                                     or  POINTER
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R739</B> </TD><TD valign=bottom>
component-decl               is  component-name [ ( component-array-spec ) ]
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                            [ lbracket coarray-spec rbracket ]
<P>
                                            [ * char-length ] [ component-initialization ]
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R740</B> </TD><TD valign=bottom>
component-array-spec         is explicit-shape-spec-list
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                     or deferred-shape-spec-list
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C744</B> </TD><TD valign=bottom>
(R737) No component-attr-spec shall appear more than once in a given component-def-stmt.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C745</B> </TD><TD valign=bottom>
(R737) If neither the POINTER nor the ALLOCATABLE attribute is specified, the declaration-type-spec
</TD></TR>
<TR><TD colspan=2>
<PRE>
        in the component-def-stmt shall specify an intrinsic type or a previously defined derived type.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C746</B> </TD><TD valign=bottom>
(R737) If the POINTER or ALLOCATABLE attribute is specified, each component-array-spec shall be
</TD></TR>
<TR><TD colspan=2>
<PRE>
        a deferred-shape-spec-list.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C747</B> </TD><TD valign=bottom>
(R737) If a coarray-spec appears, it shall be a deferred-coshape-spec-list and the component shall have
</TD></TR>
<TR><TD colspan=2>
<PRE>
        the ALLOCATABLE attribute.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C748</B> </TD><TD valign=bottom>
(R737) If a coarray-spec appears, the component shall not be of type C_PTR or C_FUNPTR from
</TD></TR>
<TR><TD colspan=2>
<PRE>
        the intrinsic module ISO_C_BINDING (18.2), or of type TEAM_TYPE from the intrinsic module
<P>
        ISO_FORTRAN_ENV (16.10.2).
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>74</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                  c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C749</B> </TD><TD valign=bottom>
A data component whose type has a coarray ultimate component shall be a nonpointer nonallocatable
</TD></TR>
<TR><TD colspan=2>
<PRE>
          scalar and shall not be a coarray.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C750</B> </TD><TD valign=bottom>
(R737) If neither the POINTER nor the ALLOCATABLE attribute is specified, each component-array-
</TD></TR>
<TR><TD colspan=2>
<PRE>
          spec shall be an explicit-shape-spec-list.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C751</B> </TD><TD valign=bottom>
(R740) Each bound in the explicit-shape-spec shall be a specification expression in which there are no ref-
</TD></TR>
<TR><TD colspan=2>
<PRE>
          erences to specification functions or the intrinsic functions ALLOCATED, ASSOCIATED, EXTENDS_-
<P>
          TYPE_OF, PRESENT, or SAME_TYPE_AS, every specification inquiry reference is a constant ex-
<P>
          pression, and the value does not depend on the value of a variable.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C752</B> </TD><TD valign=bottom>
(R737) A component shall not have both the ALLOCATABLE and POINTER attributes.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C753</B> </TD><TD valign=bottom>
(R737) If the CONTIGUOUS attribute is specified, the component shall be an array with the POINTER
</TD></TR>
<TR><TD colspan=2>
<PRE>
          attribute.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C754</B> </TD><TD valign=bottom>
(R739) The * char-length option is permitted only if the component is of type character.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C755</B> </TD><TD valign=bottom>
(R736) Each type-param-value within a component-def-stmt shall be a colon or a specification expres-
</TD></TR>
<TR><TD colspan=2>
<PRE>
          sion in which there are no references to specification functions or the intrinsic functions ALLOCATED,
<P>
          ASSOCIATED, EXTENDS_TYPE_OF, PRESENT, or SAME_TYPE_AS, every specification inquiry
<P>
          reference is a constant expression, and the value does not depend on the value of a variable.
<P>
</PRE>
NOTE 7.24
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
Because a type parameter is not an object, a type-param-value or a bound in an explicit-shape-spec can
<P>
contain a type-param-name.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R741</B> </TD><TD valign=bottom>
proc-component-def-stmt         is  PROCEDURE ( [ proc-interface ] ) ,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                proc-component-attr-spec-list :: proc-decl-list
<P>
</PRE>
NOTE 7.25
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
See 15.4.3.6 for definitions of proc-interface and proc-decl.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R742</B> </TD><TD valign=bottom>
proc-component-attr-spec        is  access-spec
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                          or  NOPASS
<P>
                                          or  PASS [ (arg-name) ]
<P>
                                          or  POINTER
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C756</B> </TD><TD valign=bottom>
(R741) The same proc-component-attr-spec shall not appear more than once in a given proc-component-
</TD></TR>
<TR><TD colspan=2>
<PRE>
          def-stmt.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C757</B> </TD><TD valign=bottom>
(R741) POINTER shall appear in each proc-component-attr-spec-list.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C758</B> </TD><TD valign=bottom>
(R741) If the procedure pointer component has an implicit interface or has no arguments, NOPASS shall
</TD></TR>
<TR><TD colspan=2>
<PRE>
          be specified.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C759</B> </TD><TD valign=bottom>
(R741) If PASS (arg-name) appears, the interface of the procedure pointer component shall have a dummy
</TD></TR>
<TR><TD colspan=2>
<PRE>
          argument named arg-name.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C760</B> </TD><TD valign=bottom>
(R741) PASS and NOPASS shall not both appear in the same proc-component-attr-spec-list.
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 The declaration-type-spec in the data-component-def-stmt specifies the type and type parameters of the com-
<P>
<PRE>
  ponents in the component-decl-list, except that the character length parameter may be specified or overridden
<P>
  for a component by the appearance of * char-length in its entity-decl. The component-attr-spec-list in the data-
<P>
  component-def-stmt specifies the attributes whose keywords appear for the components in the component-decl-list,
<P>
  except that the DIMENSION attribute may be specified or overridden for a component by the appearance of a
<P>
  component-array-spec in its component-decl, and the CODIMENSION attribute may be specified or overridden
<P>
  for a component by the appearance of a coarray-spec in its component-decl.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          75
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  7.5.4.2    Array components
<P>
</PRE>
1 A data component is an array if its component-decl contains a component-array-spec or its data-component-def-
<P>
<PRE>
  stmt contains a DIMENSION clause. If the component-decl contains a component-array-spec, it specifies the
<P>
  array rank, and if the array is explicit shape (8.5.8.2), the array bounds; otherwise, the component-array-spec in
<P>
  the DIMENSION clause specifies the array rank, and if the array is explicit shape, the array bounds.
<P>
       NOTE 7.26
<P>
       An example of a derived type definition with an array component is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE LINE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>REAL, DIMENSION (2, 2) :: COORD</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                       !  COORD(:,1) has the value of [X1, Y1]
<P>
                                                       !  COORD(:,2) has the value of [X2, Y2]
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>REAL</B> </TD><TD valign=bottom>
:: WIDTH       !  Line width in centimeters
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INTEGER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: PATTERN     !  1 for solid, 2 for dash, 3 for dot
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE LINE</H4>
</A>
<BLOCKQUOTE>
<P>
An example of declaring a variable LINE_SEGMENT to be of the type LINE is:
<TABLE cellpadding=3><!-- tsb: An example of declaring a variable LINE_SEGMENT to be of the type LINE is:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>TYPE (LINE)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: LINE_SEGMENT
</TD></TR>
<TR></TR></TABLE>The scalar variable LINE_SEGMENT has a component that is an array. In this case, the array is a
<P>
subobject of a scalar. The double colon in the definition for COORD is required; the double colon in the
<P>
definition for WIDTH and PATTERN is optional.
<P>
NOTE 7.27
<P>
An example of a derived type definition with an allocatable component is:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE STACK</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTEGER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: INDEX
</TD></TR>
<TR></TR></TABLE>INTEGER, ALLOCATABLE :: CONTENTS (:)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE STACK</H4>
</A>
<BLOCKQUOTE>
<P>
For each scalar variable of type STACK, the shape of the component CONTENTS is determined by execu-
<P>
tion of an ALLOCATE statement or assignment statement, or by argument association.
<P>
NOTE 7.28
<P>
Default initialization of an explicit-shape array component can be specified by a constant expression con-
<P>
sisting of an array constructor (7.8), or of a single scalar that becomes the value of each array element.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: sisting of an array constructor (7.8), or of a single scalar that becomes the value of each array element.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.4.3</B> </TD><TD valign=bottom>
Coarray components
<P>
1 A data component is a coarray if its component-decl contains a coarray-spec or its data-component-def-stmt
<P>
<PRE>
  contains a CODIMENSION clause. If the component-decl contains a coarray-spec it specifies the corank; otherwise,
<P>
  the coarray-spec in the CODIMENSION clause specifies the corank.
<P>
       NOTE 7.29
<P>
       An example of a derived type definition with a coarray component is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE GRID_TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
REAL, ALLOCATABLE, CODIMENSION [:, :, :] :: GRID (:, :, :)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE GRID_TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
An object of type grid_type cannot be an array, an allocatable object, a coarray, or a pointer.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: An object of type grid_type cannot be an array, an allocatable object, a coarray, or a pointer.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>76</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.5.4.4</B> </TD><TD valign=bottom>
Pointer components
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 A data component is a pointer (5.4.9) if its component-attr-spec-list contains the POINTER keyword. A procedure
<P>
<PRE>
  pointer component has the POINTER keyword in its proc-component-attr-spec-list.
<P>
        NOTE 7.30
<P>
        An example of a derived type definition with a pointer component is:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE REFERENCE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTEGER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
::  VOLUME, YEAR, PAGE
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CHARACTER (LEN = 50)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
::  TITLE
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PROCEDURE (printer_interface), POINTER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
::  PRINT =&gt; <B>NULL</B>()
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CHARACTER, DIMENSION (:), POINTER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
::  SYNOPSIS
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE REFERENCE</H4>
</A>
<BLOCKQUOTE>
<P>
Any object of type REFERENCE will have the four nonpointer components VOLUME, YEAR, PAGE, and
<P>
TITLE, the procedure pointer PRINT, which has an explicit interface the same as printer_interface, plus
<P>
a pointer to an array of characters holding SYNOPSIS. The size of this target array will be determined by
<P>
the length of the synopsis. The space for the target could be allocated (9.7.1) or the pointer component
<P>
could be associated with a target by a pointer assignment statement (10.2.2).
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: could be associated with a target by a pointer assignment statement (10.2.2).
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.4.5</B> </TD><TD valign=bottom>
The passed-object dummy argument
<P>
1 A passed-object dummy argument is a distinguished dummy argument of a procedure pointer component or
<P>
<PRE>
  type-bound procedure (7.5.5). It affects procedure overriding (7.5.7.3) and argument association (15.5.2.2).
<P>
</PRE>
2 If NOPASS is specified, the procedure pointer component or type-bound procedure has no passed-object dummy
<P>
<PRE>
  argument.
<P>
</PRE>
3 If neither PASS nor NOPASS is specified or PASS is specified without arg-name, the first dummy argument of a
<P>
<PRE>
  procedure pointer component or type-bound procedure is its passed-object dummy argument.
<P>
</PRE>
4 If PASS (arg-name) is specified, the dummy argument named arg-name is the passed-object dummy argument of
<P>
<PRE>
  the procedure pointer component or named type-bound procedure.
<P>
  C761      The passed-object dummy argument shall be a scalar, nonpointer, nonallocatable dummy data object
<P>
            with the same declared type as the type being defined; all of its length type parameters shall be assumed;
<P>
            it shall be polymorphic (7.3.2.3) if and only if the type being defined is extensible (7.5.7). It shall not
<P>
            have the VALUE attribute.
<P>
        NOTE 7.31
<P>
        If a procedure is bound to several types as a type-bound procedure, different dummy arguments might be
<P>
        the passed-object dummy argument in different contexts.
<P>
  7.5.4.6     Default initialization for components
<P>
</PRE>
1 Default initialization provides a means of automatically initializing pointer components to be disassociated or
<P>
<PRE>
  associated with specific targets, and nonpointer nonallocatable components to have a particular value. Allocatable
<P>
  components are always initialized to unallocated.
<P>
</PRE>
2 A pointer variable or component is data-pointer-initialization compatible with a target if the pointer is type
<P>
<PRE>
  compatible with the target, they have the same rank, all nondeferred type parameters of the pointer have the
<P>
  same values as the corresponding type parameters of the target, and the target is contiguous if the pointer has
<P>
  the CONTIGUOUS attribute.
<P>
  R743      component-initialization       is = constant-expr
<P>
                                           or =&gt; null-init
<P>
                                           or =&gt; initial-data-target
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             77
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R744      initial-data-target            is   designator
<P>
  C762      (R737) If component-initialization appears, a double-colon separator shall appear before the component-
<P>
            decl-list.
<P>
  C763      (R737) If component-initialization appears, every type parameter and array bound of the component
<P>
            shall be a colon or constant expression.
<P>
  C764      (R737) If =&gt; appears in component-initialization, POINTER shall appear in the component-attr-spec-
<P>
            list. If = appears in component-initialization, neither POINTER nor ALLOCATABLE shall appear in
<P>
            the component-attr-spec-list.
<P>
  C765      If initial-data-target appears in a component-initialization in a component-decl, component-name shall be
<P>
            data-pointer-initialization compatible with it.
<P>
  C766      A designator that is an initial-data-target shall designate a nonallocatable, noncoindexed variable that
<P>
            has the TARGET and SAVE attributes and does not have a vector subscript. Every subscript, sec-
<P>
            tion subscript, substring starting point, and substring ending point in designator shall be a constant
<P>
            expression.
<P>
</PRE>
3 If null-init appears for a pointer component, that component in any object of the type has an initial association
<P>
<PRE>
  status of disassociated (3.61) or becomes disassociated as specified in 19.5.2.4.
<P>
</PRE>
4 If initial-data-target appears for a data pointer component, that component in any object of the type is initially
<P>
<PRE>
  associated with the target or becomes associated with the target as specified in 19.5.2.3.
<P>
</PRE>
5 If initial-proc-target (15.4.3.6) appears in proc-decl for a procedure pointer component, that component in any
<P>
<PRE>
  object of the type is initially associated with the target or becomes associated with the target as specified in
<P>
  19.5.2.3.
<P>
</PRE>
6 If constant-expr appears for a nonpointer component, that component in any object of the type is initially defined
<P>
<PRE>
  (19.6.3) or becomes defined as specified in 19.6.5 with the value determined from constant-expr. If necessary,
<P>
  the value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type,
<P>
  type parameters, and shape with the component. If the component is of a type for which default initialization is
<P>
  specified for a component, the default initialization specified by constant-expr overrides the default initialization
<P>
  specified for that component. When one initialization overrides another it is as if only the overriding initialization
<P>
  were specified (see NOTE 7.33). Explicit initialization in a type declaration statement (8.2) overrides default
<P>
  initialization (see NOTE 7.32). Unlike explicit initialization, default initialization does not imply that the object
<P>
  has the SAVE attribute.
<P>
</PRE>
7 A subcomponent (9.4.2) is default-initialized if the type of the object of which it is a component specifies default
<P>
<PRE>
  initialization for that component, and the subcomponent is not a subobject of an object that is default-initialized
<P>
  or explicitly initialized.
<P>
</PRE>
8 A type has default initialization if component-initialization is specified for any direct component of the type. An
<P>
<PRE>
  object has default initialization if it is of a type that has default initialization.
<P>
        NOTE 7.32
<P>
        It is not required that initialization be specified for each component of a derived type. For example:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE DATE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER DAY</H4>
</A>
<BLOCKQUOTE>
<P>
CHARACTER (LEN = 5) MONTH
<TABLE cellpadding=3><!-- tsb: CHARACTER (LEN = 5) MONTH
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>INTEGER :: YEAR = 2008</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Partial default initialization
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE DATE</H4>
</A>
<BLOCKQUOTE>
<P>
In the following example, the default initial value for the YEAR component of TODAY is overridden by
<P>
explicit initialization in the type declaration statement:
<P>
<PRE>
                  TYPE (DATE), PARAMETER :: TODAY = DATE (21, "Feb.", 2009)
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>78</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 7.33
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
The default initial value of a component of derived type can be overridden by default initialization specified
<P>
in the definition of the type. Continuing the example of NOTE 7.32:
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE SINGLE_SCORE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(DATE) :: PLAY_DAY = TODAY
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER SCORE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(SINGLE_SCORE), POINTER :: NEXT =&gt; NULL ( )
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE SINGLE_SCORE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(SINGLE_SCORE) SETUP
</BLOCKQUOTE>
<P>
The PLAY_DAY component of SETUP receives its initial value from TODAY, overriding the initialization
<BLOCKQUOTE>
<P>
for the YEAR component.
<P>
NOTE 7.34
<P>
Arrays of structures can be declared with elements that are partially or totally initialized by default.
<P>
Continuing the example of NOTE 7.33 :
<P>
<PRE>
            TYPE MEMBER (NAME_LEN)
<P>
                 INTEGER, LEN :: NAME_LEN
<P>
                 CHARACTER (LEN = NAME_LEN) :: NAME = ’’
<P>
                 INTEGER :: TEAM_NO, HANDICAP = 0
<P>
                 TYPE (SINGLE_SCORE), POINTER :: HISTORY =&gt; NULL ( )
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE MEMBER</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>TYPE (MEMBER(9)) LEAGUE (36)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Array of partially initialized elements
</TD></TR>
<TR></TR></TABLE>TYPE (MEMBER(9)) :: ORGANIZER = MEMBER (9) ("I. Manage",1,5,NULL ( ))
</BLOCKQUOTE>
<P>
ORGANIZER is explicitly initialized, overriding the default initialization for an object of type MEMBER.
<BLOCKQUOTE>
<P>
Allocated objects can also be initialized partially or totally. For example:
<P>
<PRE>
            ALLOCATE (ORGANIZER % HISTORY)           ! A partially initialized object of type
<P>
                                                     ! SINGLE_SCORE is created.
<P>
</PRE>
NOTE 7.35
<P>
A pointer component of a derived type can have as its target an object of that derived type. The type
<P>
definition can specify that in objects declared to be of this type, such a pointer is default initialized to
<P>
disassociated. For example:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE NODE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTEGER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: VALUE = 0
</TD></TR>
<TR></TR></TABLE>TYPE (NODE), POINTER :: NEXT_NODE =&gt; NULL ( )
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
A type such as this can be used to construct linked lists of objects of type NODE. Linked lists can also be
<P>
constructed using allocatable components.
<P>
NOTE 7.36
<P>
A pointer component of a derived type can be default initialized to have an initial target.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE NODE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTEGER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: VALUE = 0
</TD></TR>
<TR></TR></TABLE>TYPE (NODE), POINTER :: NEXT_NODE =&gt; SENTINEL
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(NODE), SAVE, TARGET :: SENTINEL
</BLOCKQUOTE>
<P>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
79
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  7.5.4.7    Component order
<P>
</PRE>
1 Component order is an ordering of the nonparent components of a derived type; it is used for intrinsic format-
<P>
<PRE>
  ted input/output and structure constructors where component keywords are not used. Parent components are
<P>
  excluded from the component order of an extended type (7.5.7).
<P>
</PRE>
2 The component order of a nonextended type is the order of the declarations of the components in the derived-type
<P>
<PRE>
  definition. The component order of an extended type consists of the component order of its parent type followed
<P>
  by any additional components in the order of their declarations in the extended derived-type definition.
<P>
        NOTE 7.37
<P>
        Given the same type definitions as in NOTE 7.23, the component order of type T1 is just A (there is only
<P>
        one component), and the component order of type T2 is A then FLAG. The parent component (T1) does
<P>
        not participate in the component order.
<P>
  7.5.4.8    Component accessibility
<P>
  R745     private-components-stmt       is  PRIVATE
<P>
  C767     (R745) A private-components-stmt is permitted only if the type definition is within the specification part
<P>
           of a module.
<P>
</PRE>
1 The default accessibility for the components that are declared in a type’s component-part is private if the type
<P>
<PRE>
  definition contains a private-components-stmt, and public otherwise. The accessibility of a component may be
<P>
  explicitly declared by an access-spec; otherwise its accessibility is the default for the type definition in which it is
<P>
  declared.
<P>
</PRE>
2 If a component is private, that component name is accessible only within the module containing the definition,
<P>
<PRE>
  and within its descendants.
<P>
        NOTE 7.38
<P>
        Type parameters are not components. They are effectively always public.
<P>
        NOTE 7.39
<P>
        The accessibility of the components of a type is independent of the accessibility of the type name. It is
<P>
        possible to have all four combinations: a public type name with a public component, a private type name
<P>
        with a private component, a public type name with a private component, and a private type name with a
<P>
        public component.
<P>
        NOTE 7.40
<P>
        An example of a public type with private components is:
<P>
           TYPE, PUBLIC :: POINT
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
REAL :: X, Y
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
Such a type definition can be accessed by use association; however, the components X and Y are accessible
<P>
only within the module and its descendants.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: only within the module and its descendants.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>80</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 7.41
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
The following example illustrates the use of an individual component access-spec to override the default
<P>
accessibility:
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE MIXED</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER :: I
<P>
INTEGER, PUBLIC :: J
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE MIXED</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (MIXED) :: M
</BLOCKQUOTE>
<P>
The component M%J is accessible in any scoping unit where M is accessible; M%I is accessible only within
<BLOCKQUOTE>
<P>
the module containing the TYPE MIXED definition, and within its descendants.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: the module containing the TYPE MIXED definition, and within its descendants.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.5</B> </TD><TD valign=bottom>
Type-bound procedures
<TABLE width=100% cellpadding=3><!-- tsb: Type-bound procedures
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>R746</B> </TD><TD valign=bottom>
type-bound-procedure-part      is   contains-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                  [ binding-private-stmt ]
<P>
                                                  [ type-bound-proc-binding ] &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R747</B> </TD><TD valign=bottom>
binding-private-stmt           is   PRIVATE
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C768</B> </TD><TD valign=bottom>
(R746) A binding-private-stmt is permitted only if the type definition is within the specification part of
</TD></TR>
<TR><TD colspan=2>
<PRE>
          a module.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R748</B> </TD><TD valign=bottom>
type-bound-proc-binding        is type-bound-procedure-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         or type-bound-generic-stmt
<P>
                                         or final-procedure-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R749</B> </TD><TD valign=bottom>
type-bound-procedure-stmt      is PROCEDURE [ [ , binding-attr-list ] :: ] type-bound-proc-decl-list
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         or PROCEDURE (interface-name), binding-attr-list :: binding-name-list
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R750</B> </TD><TD valign=bottom>
type-bound-proc-decl           is   binding-name [ =&gt; procedure-name ]
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C769</B> </TD><TD valign=bottom>
(R749) If =&gt; procedure-name appears in a type-bound-proc-decl, the double-colon separator shall appear.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C770</B> </TD><TD valign=bottom>
(R750) The procedure-name shall be the name of an accessible module procedure or an external procedure
</TD></TR>
<TR><TD colspan=2>
<PRE>
          that has an explicit interface.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C771</B> </TD><TD valign=bottom>
A binding-name in a type-bound-proc-decl in a derived type definition shall not be the same as any other
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
          binding-name within that derived type definition.
<P>
</PRE>
1 If =&gt; procedure-name does not appear in a type-bound-proc-decl, it is as though =&gt; procedure-name had appeared
<P>
<PRE>
  with a procedure name the same as the binding name.
<P>
  R751    type-bound-generic-stmt        is   GENERIC [ , access-spec ] :: generic-spec =&gt; binding-name-list
<P>
  C772    (R751) Within the specification-part of a module, each type-bound-generic-stmt shall specify, either im-
<P>
          plicitly or explicitly, the same accessibility as every other type-bound-generic-stmt with that generic-spec
<P>
          in the same derived type.
<P>
  C773    (R751) Each binding-name in binding-name-list shall be the name of a specific binding of the type.
<P>
  C774    A binding-name in a type-bound GENERIC statement shall not specify a specific binding that was
<P>
          inherited or specified previously for the same generic identifier in that derived type definition.
<P>
  C775    (R751) If generic-spec is not generic-name, each of its specific bindings shall have a passed-object dummy
<P>
          argument (7.5.4.5).
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            81
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C776     (R751) If generic-spec is OPERATOR ( defined-operator ), the interface of each binding shall be as
<P>
           specified in 15.4.3.4.2.
<P>
  C777     (R751) If generic-spec is ASSIGNMENT ( = ), the interface of each binding shall be as specified in
<P>
           15.4.3.4.3.
<P>
  C778     (R751) If generic-spec is defined-io-generic-spec, the interface of each binding shall be as specified in
<P>
           12.6.4.8. The type of the dtv argument shall be type-name.
<P>
  R752     binding-attr                  is  access-spec
<P>
                                         or  DEFERRED
<P>
                                         or  NON_OVERRIDABLE
<P>
                                         or  NOPASS
<P>
                                         or  PASS [ (arg-name) ]
<P>
  C779     (R752) The same binding-attr shall not appear more than once in a given binding-attr-list.
<P>
  C780     (R749) If the interface of the binding has no dummy argument of the type being defined, NOPASS shall
<P>
           appear.
<P>
  C781     (R749) If PASS (arg-name) appears, the interface of the binding shall have a dummy argument named
<P>
           arg-name.
<P>
  C782     (R752) PASS and NOPASS shall not both appear in the same binding-attr-list.
<P>
  C783     (R752) NON_OVERRIDABLE and DEFERRED shall not both appear in the same binding-attr-list.
<P>
  C784     (R752) DEFERRED shall appear if and only if interface-name appears.
<P>
  C785     (R749) An overriding binding (7.5.7.3) shall have the DEFERRED attribute only if the binding it over-
<P>
           rides is deferred.
<P>
  C786     (R749) A binding shall not override an inherited binding (7.5.7.2) that has the NON_OVERRIDABLE
<P>
           attribute.
<P>
</PRE>
2 A type-bound procedure statement declares one or more specific type-bound procedures. A specific type-bound
<P>
<PRE>
  procedure can have a passed-object dummy argument (7.5.4.5). A type-bound procedure with the DEFERRED
<P>
  attribute is a deferred type-bound procedure. The DEFERRED keyword shall appear only in the definition of
<P>
  an abstract type.
<P>
</PRE>
3 A GENERIC statement declares a generic type-bound procedure, which is a type-bound generic interface for its
<P>
<PRE>
  specific type-bound procedures.
<P>
</PRE>
4 A binding of a type is a type-bound procedure (specific or generic), a generic type-bound interface, or a final
<P>
<PRE>
  subroutine. These are referred to as specific bindings, generic bindings, and final bindings respectively.
<P>
</PRE>
5 A type-bound procedure may be identified by a binding name in the scope of the type definition. This name is the
<P>
<PRE>
  binding-name for a specific type-bound procedure, and the generic-name for a generic binding whose generic-spec
<P>
  is generic-name. A final binding, or a generic binding whose generic-spec is not generic-name, has no binding
<P>
  name.
<P>
</PRE>
6 The interface of a specific type-bound procedure is that of the procedure specified by procedure-name or the
<P>
<PRE>
  interface specified by interface-name.
<P>
</PRE>
7 The same generic-spec may be used in several GENERIC statements within a single derived-type definition. Each
<P>
<PRE>
  additional GENERIC statement with the same generic-spec extends the generic interface.
<P>
       NOTE 7.42
<P>
       Unlike the situation with generic procedure names, a generic type-bound procedure name is not permitted
<P>
       to be the same as a specific type-bound procedure name in the same type (19.3).
<P>
  82                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 The default accessibility for the type-bound procedures of a type is private if the type definition contains a binding-
<P>
<PRE>
  private-stmt, and public otherwise. The accessibility of a type-bound procedure may be explicitly declared by an
<P>
  access-spec; otherwise its accessibility is the default for the type definition in which it is declared.
<P>
</PRE>
9 A public type-bound procedure is accessible via any accessible object of the type. A private type-bound procedure
<P>
<PRE>
  is accessible only within the module containing the type definition, and within its descendants.
<P>
        NOTE 7.43
<P>
        The accessibility of a type-bound procedure is not affected by a PRIVATE statement in the component-part;
<P>
        the accessibility of a data component is not affected by a PRIVATE statement in the type-bound-procedure-
<P>
        part.
<P>
        NOTE 7.44
<P>
        An example of a type and a type-bound procedure is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
REAL :: X, Y
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
PROCEDURE, PASS :: LENGTH =&gt; POINT_LENGTH
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
and in the module-subprogram-part of the same module:
<P>
<PRE>
                 REAL FUNCTION POINT_LENGTH (A, B)
<P>
                   CLASS (POINT), INTENT (IN) :: A, B
<P>
                   POINT_LENGTH = SQRT ( (A%X - B%X)**2 + (A%Y - B%Y)**2 )
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION POINT_LENGTH</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.5.6</B> </TD><TD valign=bottom>
Final subroutines
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.6.1</B> </TD><TD valign=bottom>
FINAL statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R753</B> </TD><TD valign=bottom>
final-procedure-stmt           is   FINAL [ :: ] final-subroutine-name-list
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C787</B> </TD><TD valign=bottom>
(R753) A final-subroutine-name shall be the name of a module procedure with exactly one dummy
</TD></TR>
<TR><TD colspan=2>
<PRE>
           argument. That argument shall be nonoptional and shall be a noncoarray, nonpointer, nonallocatable,
<P>
           nonpolymorphic variable of the derived type being defined. All length type parameters of the dummy
<P>
           argument shall be assumed. The dummy argument shall not have the INTENT (OUT) or VALUE
<P>
           attribute.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C788</B> </TD><TD valign=bottom>
(R753) A final-subroutine-name shall not be one previously specified as a final subroutine for that type.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C789</B> </TD><TD valign=bottom>
(R753) A final subroutine shall not have a dummy argument with the same kind type parameters and
</TD></TR>
<TR><TD colspan=2>
<PRE>
           rank as the dummy argument of another final subroutine of that type.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C790</B> </TD><TD valign=bottom>
(R753) If a final subroutine has an assumed-rank dummy argument, no other final subroutine of that
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
           type shall have a dummy argument with the same kind type parameters.
<P>
</PRE>
1 The FINAL statement specifies that each procedure it names is a final subroutine. A final subroutine might be
<P>
<PRE>
  executed when a data entity of that type is finalized (7.5.6.2).
<P>
</PRE>
2 A derived type is finalizable if and only if it has a final subroutine or a nonpointer, nonallocatable component of
<P>
<PRE>
  finalizable type. A nonpointer data entity is finalizable if and only if it is of finalizable type. No other entity is
<P>
  finalizable.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               83
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 7.45
<P>
        Final subroutines are effectively always “accessible”. They are called for entity finalization regardless of the
<P>
        accessibility of the type, its other type-bound procedures, or the subroutine name itself.
<P>
        NOTE 7.46
<P>
        Final subroutines are not inherited through type extension and cannot be overridden. The final subroutines
<P>
        of the parent type are called after any additional final subroutines of an extended type are called.
<P>
  7.5.6.2     The finalization process
<P>
</PRE>
1 Only finalizable entities are finalized. When an entity is finalized, the following steps are carried out in sequence.
<P>
<PRE>
          (1)   If the dynamic type of the entity has a final subroutine whose dummy argument has the same kind
<P>
                type parameters and rank as the entity being finalized, it is called with the entity as an actual
<P>
                argument. Otherwise, if there is an elemental final subroutine whose dummy argument has the same
<P>
                kind type parameters as the entity being finalized, or a final subroutine whose dummy argument is
<P>
                assumed-rank with the same kind type parameters as the entity being finalized, it is called with the
<P>
                entity as an actual argument. Otherwise, no subroutine is called at this point.
<P>
          (2)   All finalizable components that appear in the type definition are finalized in a processor-dependent
<P>
                order. If the entity being finalized is an array, each finalizable component of each element of that
<P>
                entity is finalized separately.
<P>
          (3)   If the entity is of extended type and the parent type is finalizable, the parent component is finalized.
<P>
</PRE>
2 If several entities are to be finalized as a consequence of an event specified in 7.5.6.3, the order in which they
<P>
<PRE>
  are finalized is processor dependent. During this process, execution of a final subroutine for one of these entities
<P>
  shall not reference or define any of the other entities that have already been finalized.
<P>
        NOTE 7.47
<P>
        An implementation might need to ensure that when an event causes more than one coarray to be deallocated,
<P>
        they are deallocated in the same order on all images in the current team.
<P>
  7.5.6.3     When finalization occurs
<P>
</PRE>
1 When an intrinsic assignment statement is executed (10.2.1.3), if the variable is not an unallocated allocatable
<P>
<PRE>
  variable, it is finalized after evaluation of expr and before the definition of the variable. If the variable is an
<P>
  allocated allocatable variable, or has an allocated allocatable subobject, that would be deallocated by intrinsic
<P>
  assignment, the finalization occurs before the deallocation.
<P>
</PRE>
2 When a pointer is deallocated its target is finalized. When an allocatable entity is deallocated, it is finalized
<P>
<PRE>
  unless it is the variable in an intrinsic assignment statement or a subobject thereof. If an error condition occurs
<P>
  during deallocation, it is processor dependent whether finalization occurs.
<P>
</PRE>
3 A nonpointer, nonallocatable object that is not a dummy argument or function result is finalized immediately
<P>
<PRE>
  before it would become undefined due to execution of a RETURN or END statement (19.6.6, item (3)).
<P>
</PRE>
4 A nonpointer nonallocatable local variable of a BLOCK construct is finalized immediately before it would become
<P>
<PRE>
  undefined due to termination of the BLOCK construct (19.6.6, item (23)).
<P>
</PRE>
5 If an executable construct references a nonpointer function, the result is finalized after execution of the innermost
<P>
<PRE>
  executable construct containing the reference.
<P>
</PRE>
6 If a specification expression in a scoping unit references a function, the result is finalized before execution of the
<P>
<PRE>
  executable constructs in the scoping unit.
<P>
</PRE>
7 When a procedure is invoked, a nonpointer, nonallocatable, INTENT (OUT) dummy argument of that procedure
<P>
<PRE>
  is finalized before it becomes undefined. The finalization caused by INTENT (OUT) is considered to occur within
<P>
  84                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  the invoked procedure; so for elemental procedures, an INTENT (OUT) argument will be finalized only if a scalar
<P>
  or elemental final subroutine is available, regardless of the rank of the actual argument.
<P>
</PRE>
8 If an object is allocated via pointer allocation and later becomes unreachable due to all pointers associated with
<P>
<PRE>
  that object having their pointer association status changed, it is processor dependent whether it is finalized. If it
<P>
  is finalized, it is processor dependent as to when the final subroutines are called.
<P>
        NOTE 7.48
<P>
        If finalization is used for storage management, it often needs to be combined with defined assignment.
<P>
  7.5.6.4     Entities that are not finalized
<P>
</PRE>
1 If image execution is terminated, either by an error (e.g. an allocation failure) or by execution of a stop-stmt,
<P>
<PRE>
  error-stop-stmt, or end-program-stmt, entities existing immediately prior to termination are not finalized.
<P>
        NOTE 7.49
<P>
        A nonpointer, nonallocatable object that has the SAVE attribute is never finalized as a direct consequence
<P>
        of the execution of a RETURN or END statement.
<P>
  7.5.7       Type extension
<P>
  7.5.7.1     Extensible, extended, and abstract types
<P>
</PRE>
1 A derived type, other than the type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING, that
<P>
<PRE>
  does not have the BIND attribute or the SEQUENCE attribute is an extensible type.
<P>
</PRE>
2 A type with the EXTENDS attribute is an extended type; its parent type is the type named in the EXTENDS
<P>
<PRE>
  type-attr-spec.
<P>
        NOTE 7.50
<P>
        The name of the parent type might be a local name introduced via renaming in a USE statement.
<P>
</PRE>
3 An extensible type that does not have the EXTENDS attribute is an extension type of itself only. An extended
<P>
<PRE>
  type is an extension of itself and of all types for which its parent type is an extension.
<P>
</PRE>
4 An abstract type is a type that has the ABSTRACT attribute.
<P>
<PRE>
        NOTE 7.51
<P>
        The DEFERRED attribute (7.5.5) defers the implementation of a type-bound procedure to extensions of
<P>
        the type; it can appear only in an abstract type. The dynamic type of an object cannot be abstract;
<P>
        therefore, a deferred type-bound procedure cannot be invoked. An extension of an abstract type need not
<P>
        be abstract if it has no deferred type-bound procedures. A short example of an abstract type is:
<P>
           TYPE, ABSTRACT :: FILE_HANDLE
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<B>PROCEDURE</B>(OPEN_FILE), DEFERRED, <B>PASS</B>(HANDLE) :: OPEN
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
For a more elaborate example see C.2.4.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: For a more elaborate example see C.2.4.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.7.2</B> </TD><TD valign=bottom>
Inheritance
<P>
1 An extended type includes all of the type parameters, all of the components, and the nonoverridden (7.5.7.3)
<P>
<PRE>
  type-bound procedures of its parent type. These are inherited by the extended type from the parent type. They
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            85
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  retain all of the attributes that they had in the parent type. Additional type parameters, components, and
<P>
  procedure bindings may be declared in the derived-type definition of the extended type.
<P>
        NOTE 7.52
<P>
        Inaccessible components and bindings of the parent type are also inherited, but they remain inaccessible in
<P>
        the extended type. Inaccessible entities occur if the type being extended is accessed via use association and
<P>
        has a private entity.
<P>
        NOTE 7.53
<P>
        An extensible derived type is not required to have any components, bindings, or parameters; an extended
<P>
        type is not required to have more components, bindings, or parameters than its parent type.
<P>
</PRE>
2 An extended type has a scalar, nonpointer, nonallocatable, parent component with the type and type parameters
<P>
<PRE>
  of the parent type. The name of this component is the parent type name. If the extended type is defined in a
<P>
  module, the parent component has the accessibility of the parent type in the module in which the parent type
<P>
  was defined. Components of the parent component are inheritance associated (19.5.4) with the corresponding
<P>
  components inherited from the parent type. An ancestor component of a type is the parent component of the
<P>
  type or an ancestor component of the parent component.
<P>
</PRE>
3 If a generic binding specified in a type definition has the same generic-spec as an inherited binding, it extends
<P>
<PRE>
  the generic interface and shall satisfy the requirements specified in 15.4.3.4.5.
<P>
        NOTE 7.54
<P>
        A component or type parameter declared in an extended type cannot have the same name as any accessible
<P>
        component or type parameter of its parent type.
<P>
        NOTE 7.55
<P>
        Examples:
<P>
        TYPE POINT                                     ! A base type
<P>
           REAL :: X, Y
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>TYPE, </B><B>EXTENDS</B>(POINT) :: COLOR_POINT </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! An extension of <B>TYPE</B>(POINT)
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
           ! Components X and Y, and component name POINT, inherited from parent
<P>
           INTEGER :: COLOR
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE COLOR_POINT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.5.7.3</B> </TD><TD valign=bottom>
Type-bound procedure overriding
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 If a specific type-bound procedure specified in a type definition has the same binding name as an accessible
<P>
<PRE>
  type-bound procedure from the parent type then the binding specified in the type definition overrides the one
<P>
  from the parent type.
<P>
</PRE>
2 The overriding and overridden type-bound procedures shall satisfy the following conditions.
<P>
<PRE>
      •  Either both shall have a passed-object dummy argument or neither shall.
<P>
      •  If the overridden type-bound procedure is pure then the overriding one shall also be pure.
<P>
      •  Either both shall be elemental or neither shall.
<P>
      •  They shall have the same number of dummy arguments.
<P>
      •  Passed-object dummy arguments, if any, shall correspond by name and position.
<P>
      •  Dummy arguments that correspond by position shall have the same names and characteristics, except for
<P>
         the type of the passed-object dummy arguments.
<P>
      • Either both shall be subroutines or both shall be functions having the same result characteristics (15.3.3).
<P>
      • If the overridden type-bound procedure is PUBLIC then the overriding one shall not be PRIVATE.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>86</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 A binding of a type and a binding of an extension of that type correspond if the latter binding is the same binding
<P>
<PRE>
  as the former, overrides a corresponding binding, or is an inherited corresponding binding.
<P>
       NOTE 7.56
<P>
       The following is an example of procedure overriding, expanding on the example in NOTE 7.44.
<P>
       TYPE, EXTENDS (POINT) :: POINT_3D
<P>
          REAL :: Z
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
PROCEDURE, PASS :: LENGTH =&gt; POINT_3D_LENGTH
</BLOCKQUOTE>
<P>
END TYPE POINT_3D
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
and in the module-subprogram-part of the same module:
<P>
REAL FUNCTION POINT_3D_LENGTH ( A, B )
<P>
<PRE>
          CLASS (POINT_3D), INTENT (IN) :: A
<P>
          CLASS (POINT), INTENT (IN) :: B
<P>
          SELECT TYPE(B)
<P>
             CLASS IS(POINT_3D)
<P>
               POINT_3D_LENGTH = SQRT( (A%X-B%X)**2 + (A%Y-B%Y)**2 + (A%Z-B%Z)**2 )
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; RETURN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
PRINT *, ’In POINT_3D_LENGTH, dynamic type of argument is incorrect.’
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; STOP</H4>
</A>
<BLOCKQUOTE>
<P>
END FUNCTION POINT_3D_LENGTH
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END FUNCTION POINT_3D_LENGTH
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7.5.8</B> </TD><TD valign=bottom>
Derived-type values
<P>
1 The component value of
<P>
<PRE>
      • a pointer component is its pointer association,
<P>
      • an allocatable component is its allocation status and, if it is allocated, its dynamic type and type parameters,
<P>
        bounds and value, and
<P>
      • a nonpointer nonallocatable component is its value.
<P>
</PRE>
2 The set of values of a particular derived type consists of all possible sequences of the component values of its
<P>
<PRE>
  components.
<P>
  7.5.9     Derived-type specifier
<P>
</PRE>
1 A derived-type specifier is used in several contexts to specify a particular derived type and type parameters.
<P>
<PRE>
  R754     derived-type-spec             is  type-name [ ( type-param-spec-list ) ]
<P>
  R755     type-param-spec               is  [ keyword = ] type-param-value
<P>
  C791     (R754) type-name shall be the name of an accessible derived type.
<P>
  C792     (R754) type-param-spec-list shall appear only if the type is parameterized.
<P>
  C793     (R754) There shall be at most one type-param-spec corresponding to each parameter of the type. If a
<P>
           type parameter does not have a default value, there shall be a type-param-spec corresponding to that
<P>
           type parameter.
<P>
  C794     (R755) The keyword= may be omitted from a type-param-spec only if the keyword= has been omitted
<P>
           from each preceding type-param-spec in the type-param-spec-list.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             87
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C795     (R755) Each keyword shall be the name of a parameter of the type.
<P>
  C796     (R755) An asterisk may be used as a type-param-value in a type-param-spec only in the declaration of a
<P>
           dummy argument or associate name or in the allocation of a dummy argument.
<P>
</PRE>
2 Type parameter values that do not have type parameter keywords specified correspond to type parameters in type
<P>
<PRE>
  parameter order (7.5.3.2). If a type parameter keyword appears, the value corresponds to the type parameter
<P>
  named by the keyword. If necessary, the value is converted according to the rules of intrinsic assignment (10.2.1.3)
<P>
  to a value of the same kind as the type parameter.
<P>
</PRE>
3 The value of a type parameter for which no type-param-value has been specified is its default value.
<P>
<PRE>
  7.5.10      Construction of derived-type values
<P>
</PRE>
1 A derived-type definition implicitly defines a corresponding structure constructor that allows construction of
<P>
<PRE>
  scalar values of that derived type. The type and type parameters of a constructed value are specified by a derived
<P>
  type specifier.
<P>
  R756     structure-constructor          is  derived-type-spec ( [ component-spec-list ] )
<P>
  R757     component-spec                 is  [ keyword = ] component-data-source
<P>
  R758     component-data-source          is expr
<P>
                                          or data-target
<P>
                                          or proc-target
<P>
  C797     (R756) The derived-type-spec shall not specify an abstract type (7.5.7).
<P>
  C798     (R756) At most one component-spec shall be provided for a component.
<P>
  C799     (R756) If a component-spec is provided for an ancestor component, a component-spec shall not be provided
<P>
           for any component that is inheritance associated with a subcomponent of that ancestor component.
<P>
  C7100 (R756) A component-spec shall be provided for a nonallocatable component unless it has default initializ-
<P>
           ation or is inheritance associated with a subcomponent of another component for which a component-spec
<P>
           is provided.
<P>
  C7101 (R757) The keyword= may be omitted from a component-spec only if the keyword= has been omitted
<P>
           from each preceding component-spec in the constructor.
<P>
  C7102 (R757) Each keyword shall be the name of a component of the type.
<P>
  C7103 (R756) The type name and all components of the type for which a component-spec appears shall be
<P>
           accessible in the scoping unit containing the structure constructor.
<P>
  C7104 (R756) If derived-type-spec is a type name that is the same as a generic name, the component-spec-list
<P>
           shall not be a valid actual-arg-spec-list for a function reference that is resolvable as a generic reference to
<P>
           that name (15.5.5.2).
<P>
  C7105 (R758) A data-target shall correspond to a data pointer component; a proc-target shall correspond to a
<P>
           procedure pointer component.
<P>
  C7106 (R758) A data-target shall have the same rank as its corresponding component.
<P>
       NOTE 7.57
<P>
       The form ’name(&#46;&#46;&#46;)’ is interpreted as a generic function-reference if possible; it is interpreted as a structure-
<P>
       constructor only if it cannot be interpreted as a generic function-reference.
<P>
  88                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 In the absence of a component keyword, each component-data-source is assigned to the corresponding component
<P>
<PRE>
  in component order (7.5.4.7). If a component keyword appears, the expr is assigned to the component named
<P>
  by the keyword. For a nonpointer component, the declared type and type parameters of the component and
<P>
  expr shall conform in the same way as for a variable and expr in an intrinsic assignment statement (10.2.1.2).
<P>
  If necessary, each value of intrinsic type is converted according to the rules of intrinsic assignment (10.2.1.3) to
<P>
  a value that agrees in type and type parameters with the corresponding component of the derived type. For a
<P>
  nonpointer nonallocatable component, the shape of the expression shall conform with the shape of the component.
<P>
</PRE>
3 If a component with default initialization has no corresponding component-data-source, then the default initial-
<P>
<PRE>
  ization is applied to that component. If an allocatable component has no corresponding component-data-source,
<P>
  then that component has an allocation status of unallocated.
<P>
        NOTE 7.58
<P>
        Because no parent components appear in the defined component ordering, a value for a parent component
<P>
        can be specified only with a component keyword. Examples of equivalent values using types defined in
<P>
        NOTE 7.55:
<P>
        ! Create values with components x = 1.0, y =           2.0, color = 3.
<P>
        TYPE(POINT) :: PV = POINT(1.0, 2.0)                  ! Assume components of TYPE(POINT)
<P>
                                                             ! are accessible here.
<P>
        &#46;&#46;&#46;
<P>
        COLOR_POINT( point=point(1,2), color=3)              ! Value for parent component
<P>
        COLOR_POINT( point=PV, color=3)                      ! Available even if TYPE(point)
<P>
                                                             ! has private components
<P>
        COLOR_POINT( 1, 2, 3)                                ! All components of TYPE(point)
<P>
                                                             ! need to be accessible.
<P>
</PRE>
4 A structure constructor shall not appear before the referenced type is defined.
<P>
5 For a pointer component, the corresponding component-data-source shall be an allowable data-target or proc-
<P>
<PRE>
  target for such a pointer in a pointer assignment statement (10.2.2). If the component data source is a pointer,
<P>
  the association of the component is that of the pointer; otherwise, the component is pointer associated with the
<P>
  component data source.
<P>
        NOTE 7.59
<P>
        For example, if the variable TEXT were declared (8.2) to be
<P>
                 CHARACTER, DIMENSION (1:400), TARGET :: TEXT
<P>
        and BIBLIO were declared using the derived-type definition REFERENCE in NOTE 7.30
<P>
                 TYPE (REFERENCE) :: BIBLIO
<P>
        the statement
<P>
                 BIBLIO = REFERENCE (1, 1987, 1, "This is the title of the referenced &
<P>
                                                        &paper", SYNOPSIS=TEXT)
<P>
        is valid and associates the pointer component SYNOPSIS of the object BIBLIO with the target object
<P>
        TEXT. The keyword SYNOPSIS is required because the fifth component of the type REFERENCE is a
<P>
        procedure pointer component, not a data pointer component of type character. It is not necessary to specify
<P>
        a proc-target for the procedure pointer component because it has default initialization.
<P>
</PRE>
6 If a component of a derived type is allocatable, the corresponding constructor expression shall be a reference
<P>
<PRE>
  to the intrinsic function NULL with no arguments, an allocatable entity of the same rank, or shall evaluate to
<P>
  an entity of the same rank. If the expression is a reference to the intrinsic function NULL, the corresponding
<P>
  component of the constructor has a status of unallocated.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            89
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
7 If the component is allocatable and the expression is an allocatable entity, the corresponding component of the
<P>
<PRE>
  constructor has the same allocation status as that allocatable entity. If it is allocated, it has the same bounds;
<P>
  if a length parameter of the component is deferred, its value is the same as the corresponding parameter of the
<P>
  expression. If the component is polymorphic, it has the same dynamic type and value; otherwise, it has the value
<P>
  converted, if necessary, to the declared type of the component.
<P>
</PRE>
8 If the component is allocatable and the expression is not an allocatable entity, the component has an allocation
<P>
<PRE>
  status of allocated and the same bounds as the expression; if a length parameter of the component is deferred,
<P>
  its value is the same as the corresponding parameter of the expression. If the component is polymorphic, it has
<P>
  the same dynamic type and value; otherwise, it has the value converted, if necessary, to the declared type of the
<P>
  component.
<P>
        NOTE 7.60
<P>
        This example illustrates a derived-type constant expression using a derived type defined in NOTE 7.15:
<P>
                 PERSON (21, ’JOHN SMITH’)
<P>
        This could also be written as
<P>
                 PERSON (NAME = ’JOHN SMITH’, AGE = 21)
<P>
        NOTE 7.61
<P>
        An example constructor using the derived type GENERAL_POINT defined in NOTE 7.22 is
<P>
                 general_point(dim=3) ( [ 1., 2., 3. ] )
<P>
  7.5.11      Derived-type operations and assignment
<P>
</PRE>
1 Intrinsic assignment of derived-type entities is described in 10.2.1. This document does not specify any intrinsic
<P>
<PRE>
  operations on derived-type entities. Any operation on derived-type entities or defined assignment (10.2.1.4) for
<P>
  derived-type entities shall be defined explicitly by a function or a subroutine, and a generic interface (7.5.5,
<P>
  15.4.3.2).
<P>
  7.6      Enumerations and enumerators
<P>
</PRE>
1 An enumeration is a set of enumerators. An enumerator is a named integer constant. An enumeration definition
<P>
<PRE>
  specifies the enumeration and its set of enumerators of the corresponding integer kind.
<P>
  R759     enum-def                      is  enum-def-stmt
<P>
                                                 enumerator-def-stmt
<P>
                                                 [ enumerator-def-stmt ] &#46;&#46;&#46;
<P>
                                                 end-enum-stmt
<P>
  R760     enum-def-stmt                 is  ENUM, BIND(C)
<P>
  R761     enumerator-def-stmt           is  ENUMERATOR [ :: ] enumerator-list
<P>
  R762     enumerator                    is  named-constant [ = scalar-int-constant-expr ]
<P>
  R763     end-enum-stmt                 is  END ENUM
<P>
  C7107 (R761) If = appears in an enumerator, a double-colon separator shall appear before the enumerator-list.
<P>
</PRE>
2 For an enumeration, the kind is selected such that an integer type with that kind is interoperable (18.3.2) with the
<P>
<PRE>
  corresponding C enumeration type. The corresponding C enumeration type is the type that would be declared
<P>
  by a C enumeration specifier (6.7.2.2 of ISO/IEC 9899:2011) that specified C enumeration constants with the
<P>
  same values as those specified by the enum-def , in the same order as specified by the enum-def .
<P>
  90                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 The companion processor (5.5.7) shall be one that uses the same representation for the types declared by all C
<P>
<PRE>
  enumeration specifiers that specify the same values in the same order.
<P>
       NOTE 7.62
<P>
       If a companion processor uses an unsigned type to represent a given enumeration type, the Fortran processor
<P>
       will use the signed integer type of the same width for the enumeration, even though some of the values of the
<P>
       C enumerators might not be representable in this signed integer type. The types of any such enumerators
<P>
       will be interoperable with the type declared in the C enumeration.
<P>
       NOTE 7.63
<P>
       ISO/IEC 9899:2011 guarantees the enumeration constants fit in a C int (6.7.2.2 of ISO/IEC 9899:2011).
<P>
       Therefore, the Fortran processor can evaluate all enumerator values using the integer type with kind para-
<P>
       meter C_INT, and then determine the kind parameter of the integer type that is interoperable with the
<P>
       corresponding C enumerated type.
<P>
       NOTE 7.64
<P>
       ISO/IEC 9899:2011 specifies that two enumeration types are compatible only if they specify enumeration
<P>
       constants with the same names and same values in the same order. This document further requires that
<P>
       a C processor that is to be a companion processor of a Fortran processor use the same representation for
<P>
       two enumeration types if they both specify enumeration constants with the same values in the same order,
<P>
       even if the names are different.
<P>
</PRE>
4 An enumerator is treated as if it were explicitly declared with the PARAMETER attribute. The enumerator is
<P>
<PRE>
  defined in accordance with the rules of intrinsic assignment (10.2) with the value determined as follows.
<P>
         (1)   If scalar-int-constant-expr is specified, the value of the enumerator is the result of scalar-int-constant-
<P>
               expr.
<P>
         (2)   If scalar-int-constant-expr is not specified and the enumerator is the first enumerator in enum-def ,
<P>
               the enumerator has the value 0.
<P>
         (3)   If scalar-int-constant-expr is not specified and the enumerator is not the first enumerator in enum-
<P>
               def , its value is the result of adding 1 to the value of the enumerator that immediately precedes it
<P>
               in the enum-def .
<P>
       NOTE 7.65
<P>
       Example of an enumeration definition:
<P>
       ENUM, BIND(C)
<P>
          ENUMERATOR :: RED = 4, BLUE = 9
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; ENUMERATOR YELLOW</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END ENUM</H4>
</A>
<BLOCKQUOTE>
<P>
The kind type parameter for this enumeration is processor dependent, but the processor is required to select
<P>
a kind sufficient to represent the values 4, 9, and 10, which are the values of its enumerators. The following
<P>
declaration might be equivalent to the above enumeration definition.
<P>
INTEGER (SELECTED_INT_KIND (2)), PARAMETER :: RED = 4, BLUE = 9, YELLOW = 10
<P>
An entity of the same kind type parameter value can be declared using the intrinsic function KIND with
<P>
one of the enumerators as its argument, for example
<P>
INTEGER (KIND (RED)) :: X
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: INTEGER (KIND (RED)) :: X
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
91
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
       NOTE 7.66
<P>
       There is no difference in the effect of declaring the enumerators in multiple ENUMERATOR statements or
<P>
       in a single ENUMERATOR statement. The order in which the enumerators in an enumeration definition
<P>
       are declared is significant, but the number of ENUMERATOR statements is not.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>7.7</B> </TD><TD valign=bottom>
Binary, octal, and hexadecimal literal constants
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 A binary, octal, or hexadecimal constant (boz-literal-constant) is a sequence of digits that represents an ordered
</TD></TR>
<TR><TD colspan=2>
<PRE>
  sequence of bits. Such a constant has no type.
<P>
  R764     boz-literal-constant          is binary-constant
<P>
                                         or octal-constant
<P>
                                         or hex-constant
<P>
  R765     binary-constant               is B ’ digit [ digit ] &#46;&#46;&#46; ’
<P>
                                         or B " digit [ digit ] &#46;&#46;&#46; "
<P>
  C7108 (R765) digit shall have one of the values 0 or 1.
<P>
  R766     octal-constant                is O ’ digit [ digit ] &#46;&#46;&#46; ’
<P>
                                         or O " digit [ digit ] &#46;&#46;&#46; "
<P>
  C7109 (R766) digit shall have one of the values 0 through 7.
<P>
  R767     hex-constant                  is Z ’ hex-digit [ hex-digit ] &#46;&#46;&#46; ’
<P>
                                         or Z " hex-digit [ hex-digit ] &#46;&#46;&#46; "
<P>
  R768     hex-digit                     is   digit
<P>
                                         or   A
<P>
                                         or   B
<P>
                                         or   C
<P>
                                         or   D
<P>
                                         or   E
<P>
                                         or   F
<P>
</PRE>
2 The hex-digits A through F represent the numbers ten through fifteen, respectively; they may be represented
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by their lower-case equivalents. Each digit of a boz-literal-constant represents a sequence of bits, according to
<P>
  its numerical interpretation, using the model of 16.3, with z equal to one for binary constants, three for octal
<P>
  constants or four for hexadecimal constants. A boz-literal-constant represents a sequence of bits that consists of
<P>
  the concatenation of the sequences of bits represented by its digits, in the order the digits are specified. The
<P>
  positions of bits in the sequence are numbered from right to left, with the position of the rightmost bit being zero.
<P>
  The length of a sequence of bits is the number of bits in the sequence. The processor shall allow the position
<P>
  of the leftmost nonzero bit to be at least z − 1, where z is the maximum value that could result from invoking
<P>
  the intrinsic function STORAGE_SIZE (16.9.184) with an argument that is a real or integer scalar of any kind
<P>
  supported by the processor.
<P>
  C7110 (R764) A boz-literal-constant shall appear only as a data-stmt-constant in a DATA statement, or where
<P>
           explicitly allowed in subclause 16.9 as an actual argument of an intrinsic procedure.
<P>
  7.8      Construction of array values
<P>
</PRE>
1 An array constructor constructs a rank-one array value from a sequence of scalar values, array values, and implied
</TD></TR>
<TR><TD colspan=2>
<PRE>
  DO loops.
<P>
  R769     array-constructor             is (/ ac-spec /)
<P>
                                         or lbracket ac-spec rbracket
<P>
  92                                                                  ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R770     ac-spec                        is type-spec ::
<P>
                                          or [type-spec ::] ac-value-list
<P>
  R771     lbracket                       is  [
<P>
  R772     rbracket                       is  ]
<P>
  R773     ac-value                       is expr
<P>
                                          or ac-implied-do
<P>
  R774     ac-implied-do                  is  ( ac-value-list , ac-implied-do-control )
<P>
  R775     ac-implied-do-control          is  [ integer-type-spec :: ] ac-do-variable = scalar-int-expr ,
<P>
                                                  scalar-int-expr [ , scalar-int-expr ]
<P>
  R776     ac-do-variable                 is  do-variable
<P>
  C7111 (R770) If type-spec is omitted, each ac-value expression in the array-constructor shall have the same
<P>
           declared type and kind type parameters.
<P>
  C7112 (R770) If type-spec specifies an intrinsic type, each ac-value expression in the array-constructor shall be
<P>
           of an intrinsic type that is in type conformance with a variable of type type-spec as specified in Table
<P>
           10.8.
<P>
  C7113 (R770) If type-spec specifies a derived type, the declared type of each ac-value expression in the array-
<P>
           constructor shall be that derived type and shall have the same kind type parameter values as specified
<P>
           by type-spec.
<P>
  C7114 (R773) An ac-value shall not be unlimited polymorphic.
<P>
  C7115 (R773) The declared type of an ac-value shall not be abstract.
<P>
  C7116 (R774) The ac-do-variable of an ac-implied-do that is in another ac-implied-do shall not appear as the
<P>
           ac-do-variable of the containing ac-implied-do.
<P>
</PRE>
2 If type-spec is omitted, corresponding length type parameters of the declared type of each ac-value expression
</TD></TR>
<TR><TD colspan=2>
<PRE>
  shall have the same value; in this case, the declared type and type parameters of the array constructor are those
<P>
  of the ac-value expressions.
<P>
</PRE>
3 If type-spec appears, it specifies the declared type and type parameters of the array constructor. Each ac-value
</TD></TR>
<TR><TD colspan=2>
<PRE>
  expression in the array-constructor shall be compatible with intrinsic assignment to a variable of this type and
<P>
  type parameters. Each value is converted to the type and type parameters of the array-constructor in accordance
<P>
  with the rules of intrinsic assignment (10.2.1.3).
<P>
</PRE>
4 The dynamic type of an array constructor is the same as its declared type.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
5 The character length of an ac-value in an ac-implied-do whose iteration count is zero shall not depend on the
<P>
<PRE>
  value of the ac-do-variable and shall not depend on the value of an expression that is not a constant expression.
<P>
</PRE>
6 If an ac-value is a scalar expression, its value specifies an element of the array constructor. If an ac-value is
<P>
<PRE>
  an array expression, the values of the elements of the expression, in array element order (9.5.3.2), specify the
<P>
  corresponding sequence of elements of the array constructor. If an ac-value is an ac-implied-do, it is expanded to
<P>
  form a sequence of elements under the control of the ac-do-variable, as in the DO construct (11.1.7.4).
<P>
</PRE>
7 For an ac-implied-do, the loop initialization and execution is the same as for a DO construct.
<P>
8 An empty sequence forms a zero-sized array.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          93
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
   NOTE 7.67
<P>
   A one-dimensional array can be reshaped into any allowable array shape using the intrinsic function RE-
<P>
   SHAPE (16.9.163). An example is:
<P>
   X = (/ 3.2, 4.01, 6.5 /)
<P>
   Y = RESHAPE (SOURCE = [ 2.0, [ 4.5, 4.5 ], X ], SHAPE = [ 3, 2 ])
<P>
   This results in Y having the 3 × 2 array of values:
<P>
   2.0     3.2
<P>
   4.5     4.01
<P>
   4.5     6.5
<P>
   NOTE 7.68
<P>
   Examples of array constructors containing an implied DO are:
<P>
   (/ (I, I = 1, 1075) /)
<P>
   and
<P>
   [ 3.6, (3.6 / I, I = 1, N) ]
<P>
   NOTE 7.69
<P>
   Using the type definition for PERSON in NOTE 7.15, an example of the construction of a derived-type
<P>
   array value is:
<P>
   [ PERSON (40, ’SMITH’), PERSON (20, ’JONES’) ]
<P>
   NOTE 7.70
<P>
   Using the type definition for LINE in NOTE 7.26, an example of the construction of a derived-type scalar
<P>
   value with a rank-2 array component is:
<P>
   LINE (RESHAPE ( [ 0.0, 0.0, 1.0, 2.0 ], [ 2, 2 ] ), 0.1, 1)
<P>
   The intrinsic function RESHAPE is used to construct a value that represents a solid line from (0, 0) to (1,
<P>
   2) of width 0.1 centimeters.
<P>
   NOTE 7.71
<P>
   Examples of zero-size array constructors are:
<P>
       [ INTEGER :: ]
<P>
       [ ( I, I = 1, 0) ]
<P>
   NOTE 7.72
<P>
   An example of an array constructor that specifies a length type parameter:
<P>
       [ CHARACTER(LEN=7) :: ’Takata’, ’Tanaka’, ’Hayashi’ ]
<P>
   In this constructor, without the type specification, it would have been necessary to specify all of the constants
<P>
   with the same character length.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>94</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 Attribute declarations and specifications
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.1</B> </TD><TD valign=bottom>
Attributes of procedures and data objects
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Every data object has a type and rank and may have type parameters and other properties that determine the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  uses of the object. Collectively, these properties are the attributes of the object. The declared type of a named
<P>
  data object is either specified explicitly in a type declaration statement or determined implicitly by the first letter
<P>
  of its name (8.7). All of its attributes may be specified in a type declaration statement or individually in separate
<P>
  specification statements.
<P>
</PRE>
2 A function has a type and rank and may have type parameters and other attributes that determine the uses of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the function. The type, rank, and type parameters are the same as those of the function result.
<P>
</PRE>
3 A subroutine does not have a type, rank, or type parameters, but may have other attributes that determine the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  uses of the subroutine.
<P>
  8.2      Type declaration statement
<P>
  R801     type-declaration-stmt           is  declaration-type-spec [ [ , attr-spec ] &#46;&#46;&#46; :: ] entity-decl-list
<P>
</PRE>
1 The type declaration statement specifies the declared type of the entities in the entity declaration list. The type
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and type parameters are those specified by declaration-type-spec, except that the character length type parameter
<P>
  may be overridden for an entity by the appearance of * char-length in its entity-decl.
<P>
  R802     attr-spec                       is  access-spec
<P>
                                           or  ALLOCATABLE
<P>
                                           or  ASYNCHRONOUS
<P>
                                           or  CODIMENSION lbracket coarray-spec rbracket
<P>
                                           or  CONTIGUOUS
<P>
                                           or  DIMENSION ( array-spec )
<P>
                                           or  EXTERNAL
<P>
                                           or  INTENT ( intent-spec )
<P>
                                           or  INTRINSIC
<P>
                                           or  language-binding-spec
<P>
                                           or  OPTIONAL
<P>
                                           or  PARAMETER
<P>
                                           or  POINTER
<P>
                                           or  PROTECTED
<P>
                                           or  SAVE
<P>
                                           or  TARGET
<P>
                                           or  VALUE
<P>
                                           or  VOLATILE
<P>
  C801     (R801) The same attr-spec shall not appear more than once in a given type-declaration-stmt.
<P>
  C802     (R801) If a language-binding-spec with a NAME= specifier appears, the entity-decl-list shall consist of a
<P>
           single entity-decl.
<P>
  C803     (R801) If a language-binding-spec is specified, the entity-decl-list shall not contain any procedure names.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               95
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The type declaration statement also specifies the attributes whose keywords appear in the attr-spec, except that
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the DIMENSION attribute may be specified or overridden for an entity by the appearance of array-spec in its
<P>
  entity-decl, and the CODIMENSION attribute may be specified or overridden for an entity by the appearance of
<P>
  coarray-spec in its entity-decl.
<P>
  R803      entity-decl                        is  object-name [ ( array-spec ) ]
<P>
                                                       [ lbracket coarray-spec rbracket ]
<P>
                                                       [ * char-length ] [ initialization ]
<P>
                                               or function-name [ * char-length ]
<P>
  C804      (R803) If the entity is not of type character, * char-length shall not appear.
<P>
  C805      (R801) If initialization appears, a double-colon separator shall appear before the entity-decl-list.
<P>
  C806      (R801) If the PARAMETER keyword appears, initialization shall appear in each entity-decl.
<P>
  C807      (R803) An initialization shall not appear if object-name is a dummy argument, a function result, an object
<P>
            in a named common block unless the type declaration is in a block data program unit, an object in blank common, an
<P>
            allocatable variable, or an automatic data object.
<P>
  C808      (R803) The function-name shall be the name of an external function, an intrinsic function, a dummy
<P>
            function, a procedure pointer, or a statement function.
<P>
  R804      object-name                        is  name
<P>
  C809      (R804) The object-name shall be the name of a data object.
<P>
  R805      initialization                     is = constant-expr
<P>
                                               or =&gt; null-init
<P>
                                               or =&gt; initial-data-target
<P>
  R806      null-init                          is  function-reference
<P>
  C810      (R803) If =&gt; appears in initialization, the entity shall have the POINTER attribute. If = appears in
<P>
            initialization, the entity shall not have the POINTER attribute.
<P>
  C811      (R803) If initial-data-target appears, object-name shall be data-pointer-initialization compatible with it
<P>
            (7.5.4.6).
<P>
  C812      (R806) The function-reference shall be a reference to the intrinsic function NULL with no arguments.
<P>
</PRE>
3 A name that identifies a specific intrinsic function has a type as specified in 16.8. An explicit type declaration statement is not
</TD></TR>
<TR><TD colspan=2>
<PRE>
  required; however, it is permitted.   Specifying a type for a generic intrinsic function name in a type declaration
<P>
  statement has no effect.
<P>
</PRE>
4 If initialization appears for a nonpointer entity,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • its type and type parameters shall conform as specified for intrinsic assignment (10.2.1.2);
<P>
      • if the entity has implied shape, the rank of initialization shall be the same as the rank of the entity;
<P>
      • if the entity does not have implied shape, initialization shall either be scalar or have the same shape as the
<P>
         entity.
<P>
        NOTE 8.1
<P>
        Examples of type declaration statements:
<P>
                  REAL A (10)
<P>
                  LOGICAL, DIMENSION (5, 5) :: MASK1, MASK2
<P>
                  COMPLEX :: CUBE_ROOT = (-0.5, 0.866)
<P>
                  INTEGER, PARAMETER :: SHORT = SELECTED_INT_KIND (4)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>96</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 8.1 (cont.)
</TD></TR>
<TR><TD colspan=2>
<PRE>
                 INTEGER (SHORT) K             ! Range at least -9999 to 9999.
<P>
                 REAL (KIND (0.0D0)) B1
<P>
                 REAL (KIND = 2) B2
<P>
                 COMPLEX (KIND = KIND (0.0D0)) :: C
<P>
                 CHARACTER (LEN = 10, KIND = 2) TEXT2
<P>
                 CHARACTER CHAR, STRING *20
<P>
                 TYPE (PERSON) :: CHAIRMAN
<P>
                 TYPE(NODE), POINTER :: HEAD =&gt; NULL ( )
<P>
                 TYPE (humongous_matrix (k=8, d=1000)) :: MAT
<P>
</PRE>
(The last line above uses a type definition from NOTE 7.22.)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.3</B> </TD><TD valign=bottom>
Automatic data objects
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 An automatic data object is a nondummy data object with a type parameter or array bound that depends on
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value of a specification-expr that is not a constant expression.
<P>
  C813     An automatic data object shall not have the SAVE attribute.
<P>
</PRE>
2 If a type parameter in a declaration-type-spec or in a char-length in an entity-decl for a local variable of a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  subprogram or BLOCK construct is defined by an expression that is not a constant expression, the type parameter
<P>
  value is established on entry to a procedure defined by the subprogram, or on execution of the BLOCK statement,
<P>
  and is not affected by any redefinition or undefinition of the variables in the expression during execution of the
<P>
  procedure or BLOCK construct.
<P>
  8.4      Initialization
<P>
</PRE>
1 The appearance of initialization in an entity-decl for an entity without the PARAMETER attribute specifies that
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the entity is a variable with explicit initialization. Explicit initialization alternatively may be specified in a DATA
<P>
  statement unless the variable is of a derived type for which default initialization is specified. If initialization is
<P>
  = constant-expr, the variable is initially defined with the value specified by the constant-expr; if necessary, the
<P>
  value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type, type
<P>
  parameters, and shape with the variable. A variable, or part of a variable, shall not be explicitly initialized more
<P>
  than once in a program. If the variable is an array, it shall have its shape specified in either the type declaration
<P>
  statement or a previous attribute specification statement in the same scoping unit.
<P>
</PRE>
2 If null-init appears, the initial association status of the object is disassociated. If initial-data-target appears, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  object is initially associated with the target.
<P>
</PRE>
3 Explicit initialization of a variable that is not in a common block implies the SAVE attribute, which may be confirmed
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by explicit specification.
<P>
  8.5      Attributes
<P>
  8.5.1     Attribute specification
<P>
</PRE>
1 An attribute may be explicitly specified by an attr-spec in a type declaration statement or by an attribute
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specification statement (8.6). The following constraints apply to attributes.
<P>
  C814     An entity shall not be explicitly given any attribute more than once in a scoping unit.
<P>
  C815     An array-spec for a nonallocatable nonpointer function result shall be an explicit-shape-spec-list.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                97
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  8.5.2     Accessibility attribute
<P>
</PRE>
1 The accessibility attribute specifies the accessibility of an entity via a particular identifier.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R807     access-spec                   is PUBLIC
<P>
                                         or PRIVATE
<P>
  C816     An access-spec shall appear only in the specification-part of a module.
<P>
</PRE>
2 An access-spec in a type declaration statement specifies the accessibility of the names of all the entities declared
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by that statement. An access-spec in a derived-type-stmt specifies the accessibility of the derived type name.
<P>
  Accessibility can also be specified by an access-stmt.
<P>
</PRE>
3 An identifier that is specified in a module or is accessible in a module by use association has either the PUB-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  LIC attribute or PRIVATE attribute. An identifier whose accessibility is not explicitly specified has default
<P>
  accessibility (8.6.1).
<P>
</PRE>
4 The default accessibility attribute for a module is PUBLIC unless it has been changed by a PRIVATE statement.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Only an identifier that has the PUBLIC attribute in that module is available to be accessed from that module
<P>
  by use association.
<P>
       NOTE 8.2
<P>
       An identifier can only be accessed by use association if it has the PUBLIC attribute in the module from
<P>
       which it is accessed. It can nonetheless have the PRIVATE attribute in a module in which it is accessed by
<P>
       use association, and therefore not be available by use association from that module.
<P>
       NOTE 8.3
<P>
       An example of an accessibility specification is:
<P>
       REAL, PRIVATE :: X, Y, Z
<P>
  8.5.3     ALLOCATABLE attribute
<P>
</PRE>
1 A variable with the ALLOCATABLE attribute is a variable for which space is allocated during execution.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 8.4
<P>
       Only variables and components can have the ALLOCATABLE attribute. The result of referencing a func-
<P>
       tion whose result variable has the ALLOCATABLE attribute is a value that does not itself have the
<P>
       ALLOCATABLE attribute.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.5.4</B> </TD><TD valign=bottom>
ASYNCHRONOUS attribute
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 An entity with the ASYNCHRONOUS attribute is a variable that may be subject to asynchronous input/output
</TD></TR>
<TR><TD colspan=2>
<PRE>
  or asynchronous communication.
<P>
</PRE>
2 The base object of a variable shall have the ASYNCHRONOUS attribute in a scoping unit if
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • the variable is a dummy argument or appears in an executable statement or specification expression in that
<P>
        scoping unit, and
<P>
      • any statement of the scoping unit is executed while the variable is a pending input/output storage sequence
<P>
        affector (12.6.2.5) or a pending communication affector (18.10.4).
<P>
</PRE>
3 Use of a variable in an asynchronous data transfer statement can imply the ASYNCHRONOUS attribute; see
</TD></TR>
<TR><TD colspan=2>
<PRE>
  subclause 12.6.2.5.
<P>
</PRE>
4 An object with the ASYNCHRONOUS attribute may be associated with an object that does not have the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ASYNCHRONOUS attribute, including by use (14.2.2) or host association (19.5.1.4). If an object that is not a
<P>
  98                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
<P>
  local variable of a BLOCK construct is specified to have the ASYNCHRONOUS attribute in the specification-
<P>
  part of the construct, the object has the attribute within the construct even if it does not have the attribute
<P>
  outside the construct. If an object has the ASYNCHRONOUS attribute, then all of its subobjects also have the
<P>
  ASYNCHRONOUS attribute.
<P>
       NOTE 8.5
<P>
       The ASYNCHRONOUS attribute specifies the variables that might be associated with a pending in-
<P>
       put/output storage sequence (the actual memory locations on which asynchronous input/output is being
<P>
       performed) while the scoping unit is in execution. This information could be used by the compiler to disable
<P>
       certain code motion optimizations.
<P>
  8.5.5     BIND attribute for data entities
<P>
</PRE>
1 The BIND attribute for a variable or common block specifies that it is capable of interoperating with a C variable
</TD></TR>
<TR><TD colspan=2>
<PRE>
  whose name has external linkage (18.9).
<P>
  R808     language-binding-spec           is   BIND (C [ , NAME = scalar-default-char-constant-expr ])
<P>
  C817     An entity with the BIND attribute shall be a common block, variable, type, or procedure.
<P>
  C818     A variable with the BIND attribute shall be declared in the specification part of a module.
<P>
  C819     A variable with the BIND attribute shall be interoperable (18.3).
<P>
  C820     Each variable of a common block with the BIND attribute shall be interoperable.
<P>
</PRE>
2 If the value of the scalar-default-char-constant-expr after discarding leading and trailing blanks has nonzero
</TD></TR>
<TR><TD colspan=2>
<PRE>
  length, it shall be valid as an identifier on the companion processor.
<P>
       NOTE 8.6
<P>
       ISO/IEC 9899:2011 provides a facility for creating C identifiers whose characters are not restricted to the
<P>
       C basic character set. Such a C identifier is referred to as a universal character name (6.4.3 of ISO/IEC
<P>
       9899:2011). The name of such a C identifier might include characters that are not part of the representation
<P>
       method used by the processor for default character. If so, the C entity cannot be referenced from Fortran.
<P>
</PRE>
3 The BIND attribute for a common block implies the SAVE attribute, which may be confirmed by explicit specification.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  8.5.6     CODIMENSION attribute
<P>
  8.5.6.1    General
<P>
</PRE>
1 The CODIMENSION attribute specifies that an entity is a coarray. The coarray-spec specifies its corank or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  corank and cobounds.
<P>
  R809     coarray-spec                    is deferred-coshape-spec-list
<P>
                                           or explicit-coshape-spec
<P>
  C821     The sum of the rank and corank of an entity shall not exceed fifteen.
<P>
  C822     A coarray shall be a component or a variable that is not a function result.
<P>
  C823     A coarray shall not be of type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING
<P>
           (18.3.3), or of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV (16.10.2.32).
<P>
  C824     An entity whose type has a coarray ultimate component shall be a nonpointer nonallocatable scalar, shall
<P>
           not be a coarray, and shall not be a function result.
<P>
  C825     A coarray or an object with a coarray ultimate component shall be an associate name, a dummy argument,
<P>
           or have the ALLOCATABLE or SAVE attribute.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               99
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 8.7
<P>
        A coarray is permitted to be of a derived type with pointer or allocatable components. The target of such
<P>
        a pointer component is always on the same image as the pointer.
<P>
        NOTE 8.8
<P>
        This requirement for the SAVE attribute has the effect that automatic coarrays are not permitted; for
<P>
        example, the coarray WORK in the following code fragment is not valid.
<P>
        SUBROUTINE     SOLVE3(N,A,B)
<P>
        INTEGER ::     N
<P>
        REAL       ::  A(N)[*], B(N)
<P>
        REAL       ::  WORK(N)[*]      ! Not permitted
<P>
        If this were permitted, it would require an implicit synchronization on entry to the procedure.
<P>
        Explicit-shape coarrays that are declared in a subprogram and are not dummy arguments are required to
<P>
        have the SAVE attribute because otherwise they might be implemented as if they were automatic coarrays.
<P>
        NOTE 8.9
<P>
        Examples of CODIMENSION attribute specifications are:
<P>
            REAL    W(100,100)[0:2,*]                            ! Explicit-shape coarray
<P>
            REAL,   CODIMENSION[*] :: X                          ! Scalar coarray
<P>
            REAL,   CODIMENSION[3,*] :: Y(:)                     ! Assumed-shape coarray
<P>
            REAL,   CODIMENSION[:],ALLOCATABLE :: Z(:,:)         ! Allocatable coarray
<P>
  8.5.6.2     Allocatable coarray
<P>
</PRE>
1 A coarray with the ALLOCATABLE attribute has a specified corank, but its cobounds are determined by
</TD></TR>
<TR><TD colspan=2>
<PRE>
  allocation or argument association.
<P>
  R810      deferred-coshape-spec        is  :
<P>
  C826      A coarray with the ALLOCATABLE attribute shall have a coarray-spec that is a deferred-coshape-spec-
<P>
            list.
<P>
</PRE>
2 The corank of an allocatable coarray is equal to the number of colons in its deferred-coshape-spec-list.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 The cobounds of an unallocated allocatable coarray are undefined. No part of such a coarray shall be referenced
<P>
<PRE>
  or defined; however, the coarray may appear as an argument to an intrinsic inquiry function as specified in 16.1.
<P>
</PRE>
4 The cobounds of an allocated allocatable coarray are those specified when the coarray is allocated.
<P>
5 The cobounds of an allocatable coarray are unaffected by any subsequent redefinition or undefinition of the
<P>
<PRE>
  variables on which the cobounds’ expressions depend.
<P>
  8.5.6.3     Explicit-coshape coarray
<P>
</PRE>
1 An explicit-coshape coarray is a named coarray that has its corank and cobounds declared by an explicit-coshape-
<P>
<PRE>
  spec.
<P>
  R811      explicit-coshape-spec        is  [ [ lower-cobound : ] upper-cobound, ]&#46;&#46;&#46;
<P>
                                                [ lower-cobound : ] *
<P>
  C827      A nonallocatable coarray shall have a coarray-spec that is an explicit-coshape-spec.
<P>
</PRE>
2 The corank is equal to one plus the number of upper-cobounds.
<P>
<PRE>
  100                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  R812     lower-cobound                   is  specification-expr
<P>
  R813     upper-cobound                   is  specification-expr
<P>
  C828     (R811) A lower-cobound or upper-cobound that is not a constant expression shall appear only in a sub-
<P>
           program, BLOCK construct, or interface body.
<P>
</PRE>
3 If an explicit-coshape coarray is a local variable of a subprogram or BLOCK construct and has cobounds that are
<P>
<PRE>
  not constant expressions, the cobounds are determined on entry to a procedure defined by the subprogram, or
<P>
  on execution of the BLOCK statement, by evaluating the cobounds expressions. The cobounds of such a coarray
<P>
  are unaffected by the redefinition or undefinition of any variable during execution of the procedure or BLOCK
<P>
  construct.
<P>
</PRE>
4 The values of each lower-cobound and upper-cobound determine the cobounds of the coarray along a particular
<P>
<PRE>
  codimension. The cosubscript range of the coarray in that codimension is the set of integer values between and
<P>
  including the lower and upper cobounds. If the lower cobound is omitted, the default value is 1. The upper
<P>
  cobound shall not be less than the lower cobound.
<P>
  8.5.7      CONTIGUOUS attribute
<P>
  C829     An entity with the CONTIGUOUS attribute shall be an array pointer, an assumed-shape array, or an
<P>
           assumed-rank dummy data object.
<P>
</PRE>
1 The CONTIGUOUS attribute specifies that an assumed-shape array is contiguous, that an array pointer can
<P>
<PRE>
  only be pointer associated with a contiguous target, or that an assumed-rank dummy data object is contiguous.
<P>
</PRE>
2 An object is contiguous if it is
<P>
<PRE>
         (1)    an object with the CONTIGUOUS attribute,
<P>
         (2)    a nonpointer whole array that is not assumed-shape,
<P>
         (3)    an assumed-shape array that is argument associated with an array that is contiguous,
<P>
         (4)    an assumed-rank dummy data object whose effective argument is contiguous,
<P>
         (5)    an array allocated by an ALLOCATE statement,
<P>
         (6)    a pointer associated with a contiguous target, or
<P>
         (7)    a nonzero-sized array section (9.5.3) provided that
<P>
                (a)   its base object is contiguous,
<P>
                (b)   it does not have a vector subscript,
<P>
                (c)   the array element ordering of the elements of the section is the same as the array element
<P>
                      ordering of those elements of the base object,
<P>
                (d)   in the array element ordering of the base object, every element of the base object that is not
<P>
                      an element of the section either precedes every element of the section or follows every element
<P>
                      of the section,
<P>
                (e)   if the array is of type character and a substring-range appears, the substring-range specifies all
<P>
                      of the characters of the parent-string (9.4.1),
<P>
                (f)   only its final part-ref has nonzero rank, and
<P>
                (g)   it is not the real or imaginary part (9.4.4) of an array of type complex.
<P>
</PRE>
3 An object is not contiguous if it is an array subobject, and
<P>
<PRE>
      • the object has two or more elements,
<P>
      • the elements of the object in array element order are not consecutive in the elements of the base object,
<P>
      • the object is not of type character with length zero, and
<P>
      • the object is not of a derived type that has no ultimate components other than zero-sized arrays and
<P>
        characters with length zero.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
101
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
4 It is processor dependent whether any other object is contiguous.
</TD></TR>
<TR><TD colspan=2>
<PRE>
        NOTE 8.10
<P>
        If a derived type has only one component that is not zero-sized, it is processor dependent whether a structure
<P>
        component of a contiguous array of that type is contiguous. That is, the derived type might contain padding
<P>
        on some processors.
<P>
        NOTE 8.11
<P>
        The CONTIGUOUS attribute makes it easier for a processor to enable optimizations that depend on
<P>
        the memory layout of the object occupying a contiguous block of memory. Examples of CONTIGUOUS
<P>
        attribute specifications are:
<P>
             REAL, POINTER, CONTIGUOUS               :: SPTR(:)
<P>
             REAL, CONTIGUOUS, DIMENSION(:,:) :: D
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.5.8</B> </TD><TD valign=bottom>
DIMENSION attribute
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.5.8.1</B> </TD><TD valign=bottom>
General
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The DIMENSION attribute specifies that an entity is assumed-rank or an array. An assumed-rank dummy data
</TD></TR>
<TR><TD colspan=2>
<PRE>
  object has the rank, shape, and size of its effective argument; otherwise, the rank or rank and shape is specified
<P>
  by its array-spec.
<P>
  R814      dimension-spec               is  DIMENSION ( array-spec )
<P>
  R815      array-spec                   is  explicit-shape-spec-list
<P>
                                         or  assumed-shape-spec-list
<P>
                                         or  deferred-shape-spec-list
<P>
                                         or  assumed-size-spec
<P>
                                         or  implied-shape-spec
<P>
                                         or  implied-shape-or-assumed-size-spec
<P>
                                         or  assumed-rank-spec
<P>
        NOTE 8.12
<P>
        The maximum rank of an entity is fifteen minus the corank.
<P>
        NOTE 8.13
<P>
        Examples of DIMENSION attribute specifications are:
<P>
        SUBROUTINE EX (N, A, B)
<P>
             REAL, DIMENSION (N, 10) :: W                   ! Automatic explicit-shape array
<P>
             REAL A (:), B (0:)                             ! Assumed-shape arrays
<P>
             REAL, POINTER :: D (:, :)                      ! Array pointer
<P>
             REAL, DIMENSION (:), POINTER :: P              ! Array pointer
<P>
             REAL, ALLOCATABLE, DIMENSION (:) :: E          ! Allocatable array
<P>
             REAL, PARAMETER :: V(0:*) = [0.1, 1.1]         ! Implied-shape array
<P>
  8.5.8.2     Explicit-shape array
<P>
  R816      explicit-shape-spec          is  [ lower-bound : ] upper-bound
<P>
  R817      lower-bound                  is  specification-expr
<P>
  R818      upper-bound                  is  specification-expr
<P>
  102                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
  C830       (R816) An explicit-shape-spec whose bounds are not constant expressions shall appear only in a subpro-
<P>
             gram, derived type definition, BLOCK construct, or interface body.
<P>
</PRE>
1 An explicit-shape array is an array whose shape is explicitly declared by an explicit-shape-spec-list. The rank is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  equal to the number of explicit-shape-specs.
<P>
</PRE>
2 An explicit-shape array that is a named local variable of a subprogram or BLOCK construct may have bounds
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that are not constant expressions. The bounds, and hence shape, are determined on entry to a procedure defined
<P>
  by the subprogram, or on execution of the BLOCK statement, by evaluating the bounds’ expressions. The
<P>
  bounds of such an array are unaffected by the redefinition or undefinition of any variable during execution of the
<P>
  procedure or BLOCK construct.
<P>
</PRE>
3 The values of each lower-bound and upper-bound determine the bounds of the array along a particular dimension
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and hence the extent of the array in that dimension. If lower-bound appears it specifies the lower bound; otherwise
<P>
  the lower bound is 1. The value of a lower bound or an upper bound may be positive, negative, or zero. The
<P>
  subscript range of the array in that dimension is the set of integer values between and including the lower and
<P>
  upper bounds, provided the upper bound is not less than the lower bound. If the upper bound is less than the
<P>
  lower bound, the range is empty, the extent in that dimension is zero, and the array is of zero size.
<P>
  8.5.8.3     Assumed-shape array
<P>
</PRE>
1 An assumed-shape array is a nonallocatable nonpointer dummy argument array that takes its shape from its
</TD></TR>
<TR><TD colspan=2>
<PRE>
  effective argument.
<P>
  R819       assumed-shape-spec           is  [ lower-bound ] :
<P>
</PRE>
2 The rank is equal to the number of colons in the assumed-shape-spec-list.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 The extent of a dimension of an assumed-shape array dummy argument is the extent of the corresponding
<P>
<PRE>
  dimension of its effective argument. If the lower bound value is d and the extent of the corresponding dimension
<P>
  of its effective argument is s, then the value of the upper bound is s + d − 1. If lower-bound appears it specifies
<P>
  the lower bound; otherwise the lower bound is 1.
<P>
  8.5.8.4     Deferred-shape array
<P>
</PRE>
1 A deferred-shape array is an allocatable array or an array pointer. (An allocatable array has the ALLOCATABLE
<P>
<PRE>
  attribute; an array pointer has the POINTER attribute.)
<P>
  R820       deferred-shape-spec          is  :
<P>
  C831       An array with the POINTER or ALLOCATABLE attribute shall have an array-spec that is a deferred-
<P>
             shape-spec-list.
<P>
</PRE>
2 The rank is equal to the number of colons in the deferred-shape-spec-list.
<P>
3 The size, bounds, and shape of an unallocated allocatable array or a disassociated array pointer are undefined.
<P>
<PRE>
  No part of such an array shall be referenced or defined; however, the array may appear as an argument to an
<P>
  intrinsic inquiry function as specified in 16.1.
<P>
</PRE>
4 The bounds of each dimension of an allocated allocatable array are those specified when the array is allocated
<P>
<PRE>
  or, if it is a dummy argument, when it is argument associated with an allocated effective argument.
<P>
</PRE>
5 The bounds of each dimension of an associated array pointer, and hence its shape, may be specified
<P>
<PRE>
      • in an ALLOCATE statement (9.7.1) when the target is allocated,
<P>
      • by pointer assignment (10.2.2), or
<P>
      • if it is a dummy argument, by argument association with a nonpointer actual argument or an associated
<P>
         pointer effective argument.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
103
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
6 The bounds of an array pointer or allocatable array are unaffected by any subsequent redefinition or undefinition
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of variables on which the bounds’ expressions depend.
<P>
  8.5.8.5    Assumed-size array
<P>
</PRE>
1 An assumed-size array is a dummy argument array whose size is assumed from that of its effective argument, or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the associate name of a RANK ( * ) block in a SELECT RANK construct. The rank and extents may differ for
<P>
  the effective and dummy arguments; only the size of the effective argument is assumed by the dummy argument.
<P>
  A dummy argument is declared to be an assumed-size array by an assumed-size-spec or an implied-shape-or-
<P>
  assumed-size-spec.
<P>
  R821      assumed-implied-spec          is   [ lower-bound : ] *
<P>
  R822      assumed-size-spec             is   explicit-shape-spec-list, assumed-implied-spec
<P>
  C832      An object whose array bounds are specified by an assumed-size-spec shall be a dummy data object.
<P>
  C833      An assumed-size array with the INTENT (OUT) attribute shall not be polymorphic, finalizable, of a
<P>
            type with an allocatable ultimate component, or of a type for which default initialization is specified.
<P>
  R823      implied-shape-or-assumed-size-spec      is  assumed-implied-spec
<P>
  C834      An object whose array bounds are specified by an implied-shape-or-assumed-size-spec shall be a dummy
<P>
            data object or a named constant.
<P>
</PRE>
2 The size of an assumed-size array is determined as follows.
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • If the effective argument associated with the assumed-size dummy array is an array of any type other than
<P>
         default character, the size is that of the effective argument.
<P>
      • If the actual argument corresponding to the assumed-size dummy array is an array element of any type
<P>
         other than default character with a subscript order value of r (9.5.3.2) in an array of size x, the size of the
<P>
         dummy array is x − r + 1.
<P>
      • If the actual argument is a default character array, default character array element, or a default character
<P>
         array element substring (9.4.1), and if it begins at character storage unit t of an array with c character
<P>
         storage units, the size of the dummy array is MAX (INT ((c − t + 1)/e), 0), where e is the length of an
<P>
         element in the dummy character array.
<P>
      • If the actual argument is a default character scalar that is not an array element or array element substring
<P>
         designator, the size of the dummy array is MAX (INT (l/e), 0), where e is the length of an element in the
<P>
         dummy character array and l is the length of the actual argument.
<P>
</PRE>
3 The rank is equal to one plus the number of explicit-shape-specs.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
4 An assumed-size array has no upper bound in its last dimension and therefore has no extent in its last dimension
<P>
<PRE>
  and no shape. An assumed-size array shall not appear in a context that requires its shape.
<P>
</PRE>
5 If a list of explicit-shape-specs appears, it specifies the bounds of the first rank−1 dimensions. If lower-bound
<P>
<PRE>
  appears it specifies the lower bound of the last dimension; otherwise that lower bound is 1. An assumed-size
<P>
  array can be subscripted or sectioned (9.5.3).
<P>
</PRE>
6 If an assumed-size array has bounds that are not constant expressions, the bounds are determined on entry to
<P>
<PRE>
  the procedure. The bounds of such an array are unaffected by the redefinition or undefinition of any variable
<P>
  during execution of the procedure.
<P>
  8.5.8.6    Implied-shape array
<P>
</PRE>
1 An implied-shape array is a named constant that takes its shape from the constant-expr in its declaration. A
<P>
<PRE>
  named constant is declared to be an implied-shape array with an array-spec that is an implied-shape-or-assumed-
<P>
  size-spec or an implied-shape-spec.
<P>
  104                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  R824      implied-shape-spec             is  assumed-implied-spec, assumed-implied-spec-list
<P>
  C835      An implied-shape array shall be a named constant.
<P>
</PRE>
2 The rank of an implied-shape array is the number of assumed-implied-specs in its array-spec.
<P>
3 The extent of each dimension of an implied-shape array is the same as the extent of the corresponding dimension
<P>
<PRE>
  of the constant-expr. The lower bound of each dimension is lower-bound, if it appears, and 1 otherwise; the upper
<P>
  bound is one less than the sum of the lower bound and the extent.
<P>
  8.5.8.7     Assumed-rank entity
<P>
</PRE>
1 An assumed-rank entity is a dummy data object whose rank is assumed from its effective argument, or the associate
<P>
<PRE>
  name of a RANK DEFAULT block in a SELECT RANK construct; this rank can be zero. An assumed-rank
<P>
  entity is declared with an array-spec that is an assumed-rank-spec.
<P>
  R825      assumed-rank-spec              is  ..
<P>
  C836      An assumed-rank entity shall be a dummy data object that does not have the CODIMENSION or VALUE
<P>
            attribute.
<P>
  C837      An assumed-rank variable name shall not appear in a designator or expression except as an actual
<P>
            argument that corresponds to a dummy argument that is assumed-rank, the argument of the function
<P>
            C_LOC or C_SIZEOF from the intrinsic module ISO_C_BINDING (18.2), the first dummy argument
<P>
            of an intrinsic inquiry function, or the selector of a SELECT RANK statement.
<P>
  C838      If an assumed-size or nonallocatable nonpointer assumed-rank array is an actual argument that corres-
<P>
            ponds to a dummy argument that is an INTENT (OUT) assumed-rank array, it shall not be polymorphic,
<P>
            finalizable, of a type with an allocatable ultimate component, or of a type for which default initialization
<P>
            is specified.
<P>
  8.5.9       EXTERNAL attribute
<P>
</PRE>
1 The EXTERNAL attribute specifies that an entity is an external procedure, dummy procedure, procedure pointer,
<P>
<PRE>
  or block data subprogram.
<P>
  C839      An entity shall not have both the EXTERNAL attribute and the INTRINSIC attribute.
<P>
  C840      In an external subprogram, the EXTERNAL attribute shall not be specified for a procedure defined by
<P>
            the subprogram.
<P>
  C841      In an interface body, the EXTERNAL attribute shall not be specified for the procedure declared by the
<P>
            interface body.
<P>
</PRE>
2 If an external procedure or dummy procedure is used as an actual argument or is the target of a procedure pointer
<P>
<PRE>
  assignment, it shall be declared to have the EXTERNAL attribute.
<P>
</PRE>
3 A procedure that has both the EXTERNAL and POINTER attributes is a procedure pointer.
<P>
<PRE>
        NOTE 8.14
<P>
        The EXTERNAL attribute can be specified in a type declaration statement, by an interface body (15.4.3.2),
<P>
        by an EXTERNAL statement (15.4.3.5), or by a procedure declaration statement (15.4.3.6).
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.5.10</B> </TD><TD valign=bottom>
INTENT attribute
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 The INTENT attribute specifies the intended use of a dummy argument. An INTENT (IN) dummy argument
<P>
<PRE>
  is suitable for receiving data from the invoking scoping unit, an INTENT (OUT) dummy argument is suitable
<P>
  for returning data to the invoking scoping unit, and an INTENT (INOUT) dummy argument is suitable for use
<P>
  both to receive data from and to return data to the invoking scoping unit.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            105
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R826      intent-spec                  is IN
<P>
                                         or OUT
<P>
                                         or INOUT
<P>
  C842      An entity with the INTENT attribute shall be a dummy data object or a dummy procedure pointer.
<P>
  C843      (R826) A nonpointer object with the INTENT (IN) attribute shall not appear in a variable definition
<P>
            context (19.6.7).
<P>
  C844      A pointer with the INTENT (IN) attribute shall not appear in a pointer association context (19.6.8).
<P>
  C845      An INTENT (OUT) dummy argument of a nonintrinsic procedure shall not be an allocatable coarray or
<P>
            have a subobject that is an allocatable coarray.
<P>
  C846      An entity with the INTENT (OUT) attribute shall not be of, or have a subcomponent of, type EVENT_-
<P>
            TYPE (16.10.2.10) or LOCK_TYPE (16.10.2.19) from the intrinsic module ISO_FORTRAN_ENV.
<P>
</PRE>
2 The INTENT (IN) attribute for a nonpointer dummy argument specifies that it shall neither be defined nor
<P>
<PRE>
  become undefined during the invocation and execution of the procedure. The INTENT (IN) attribute for a
<P>
  pointer dummy argument specifies that during the invocation and execution of the procedure its association shall
<P>
  not be changed except that it may become undefined if the target is deallocated other than through the pointer
<P>
  (19.5.2.5).
<P>
</PRE>
3 The INTENT (OUT) attribute for a nonpointer dummy argument specifies that the dummy argument becomes
<P>
<PRE>
  undefined on invocation of the procedure, except for any subcomponents that are default-initialized (7.5.4.6). Any
<P>
  actual argument that corresponds to such a dummy argument shall be definable. The INTENT (OUT) attribute
<P>
  for a pointer dummy argument specifies that on invocation of the procedure the pointer association status of
<P>
  the dummy argument becomes undefined. Any actual argument that corresponds to such a pointer dummy shall
<P>
  be a pointer variable or a procedure pointer that is not the result of a function reference. Any undefinition or
<P>
  definition implied by association of an actual argument with an INTENT (OUT) dummy argument shall not
<P>
  affect any other entity within the statement that invokes the procedure.
<P>
</PRE>
4 The INTENT (INOUT) attribute for a nonpointer dummy argument specifies that any actual argument that
<P>
<PRE>
  corresponds to the dummy argument shall be definable. The INTENT (INOUT) attribute for a pointer dummy
<P>
  argument specifies that any actual argument that corresponds to the dummy argument shall be a pointer variable
<P>
  or a procedure pointer that is not the result of a function reference.
<P>
        NOTE 8.15
<P>
        The INTENT attribute for an allocatable dummy argument applies to both the allocation status and the
<P>
        definition status. An actual argument that corresponds to an INTENT (OUT) allocatable dummy argument
<P>
        is deallocated on procedure invocation (9.7.3.2). To avoid this deallocation for coarrays, INTENT (OUT) is
<P>
        not allowed for a dummy argument that is an allocatable coarray or has a subobject that is an allocatable
<P>
        coarray.
<P>
</PRE>
5 If no INTENT attribute is specified for a dummy argument, its use is subject to the limitations of its effective
<P>
<PRE>
  argument (15.5.2).
<P>
</PRE>
6 If a nonpointer object has an INTENT attribute, then all of its subobjects have the same INTENT attribute.
<P>
<PRE>
        NOTE 8.16
<P>
        An example of INTENT specification is:
<P>
        SUBROUTINE MOVE (FROM, TO)
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; USE PERSON_MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (PERSON), INTENT (IN) :: FROM
<P>
TYPE (PERSON), INTENT (OUT) :: TO
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: TYPE (PERSON), INTENT (OUT) :: TO
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>106</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 8.17
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
If a dummy argument is a nonpointer derived-type object with a pointer component, then the pointer as
<P>
a pointer is a subobject of the dummy argument, but the target of the pointer is not. Therefore, the
<P>
restrictions on subobjects of the dummy argument apply to the pointer in contexts where it is used as a
<P>
pointer, but not in contexts where it is dereferenced to indicate its target. For example, if X is a nonpointer
<P>
dummy argument of derived type with an integer pointer component P, and X is INTENT (IN), then the
<P>
statement
<P>
X%P =&gt; NEW_TARGET
<P>
is prohibited, but
<P>
X%P = 0
<P>
is allowed (provided that X%P is associated with a definable target).
<P>
Similarly, the INTENT restrictions on pointer dummy arguments apply only to the association of the
<P>
dummy argument; they do not restrict the operations allowed on its target.
<P>
<PRE>
         NOTE 8.18
<P>
</PRE>
Argument intent specifications serve several purposes in addition to documenting the intended use of dummy
<P>
arguments. A processor can check whether an INTENT (IN) dummy argument is used in a way that could
<P>
redefine it. A slightly more sophisticated processor could check to see whether an INTENT (OUT) dummy
<P>
argument could possibly be referenced before it is defined. If the procedure’s interface is explicit, the
<P>
processor can also verify that actual arguments corresponding to INTENT (OUT) or INTENT (INOUT)
<P>
dummy arguments are definable. A more sophisticated processor could use this information to optimize
<P>
the translation of the referencing scoping unit by taking advantage of the fact that actual arguments
<P>
corresponding to INTENT (IN) dummy arguments will not be changed and that any prior value of an
<P>
actual argument corresponding to an INTENT (OUT) dummy argument will not be referenced and could
<P>
thus be discarded.
<P>
INTENT (OUT) means that the value of the argument after invoking the procedure is entirely the result
<P>
of executing that procedure. If an argument might not be redefined and it is desired to have the argument
<P>
retain its value in that case, INTENT (OUT) cannot be used because it would cause the argument to
<P>
become undefined; however, INTENT (INOUT) can be used, even if there is no explicit reference to the
<P>
value of the dummy argument.
<P>
INTENT (INOUT) is not equivalent to omitting the INTENT attribute. The actual argument corresponding
<P>
to an INTENT (INOUT) dummy argument is always required to be definable, while an actual argument
<P>
corresponding to a dummy argument without an INTENT attribute need be definable only if the dummy
<P>
argument is actually redefined.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.5.11</B> </TD><TD valign=bottom>
INTRINSIC attribute
<P>
1 The INTRINSIC attribute specifies that the entity is an intrinsic procedure. The procedure name may be a
<P>
<PRE>
  generic name (16.7), a specific name (16.8), or both.
<P>
</PRE>
2 If the specific name of an intrinsic procedure (16.8) is used as an actual argument, the name shall be explicitly specified to have the
<P>
<PRE>
  INTRINSIC attribute. Note that a specific intrinsic procedure listed in Table 16.3 is not permitted to be used as an actual argument
<P>
  (C1534).
<P>
  C847      If the generic name of an intrinsic procedure is explicitly declared to have the INTRINSIC attribute,
<P>
            and it is also the generic name of one or more generic interfaces (15.4.3.2) accessible in the same scoping
<P>
            unit, the procedures in the interfaces and the generic intrinsic procedure shall all be functions or all be
<P>
            subroutines.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                             107
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  8.5.12      OPTIONAL attribute
<P>
</PRE>
1 The OPTIONAL attribute specifies that the dummy argument need not have a corresponding actual argument
<P>
<PRE>
  in a reference to the procedure (15.5.2.12).
<P>
  C848     An entity with the OPTIONAL attribute shall be a dummy argument.
<P>
        NOTE 8.19
<P>
        The intrinsic function PRESENT (16.9.152) can be used to determine whether an optional dummy argument
<P>
        has a corresponding actual argument.
<P>
  8.5.13      PARAMETER attribute
<P>
</PRE>
1 The PARAMETER attribute specifies that an entity is a named constant. The entity has the value specified by
<P>
<PRE>
  its constant-expr, converted, if necessary, to the type, type parameters and shape of the entity.
<P>
  C849     An entity with the PARAMETER attribute shall not be a variable, a coarray, or a procedure.
<P>
  C850     An expression that specifies a length type parameter or array bound of a named constant shall be a
<P>
           constant expression.
<P>
</PRE>
2 A named constant shall not be referenced unless it has been defined previously; it may be defined previously in
<P>
<PRE>
  the same statement.
<P>
        NOTE 8.20
<P>
        Examples of declarations with a PARAMETER attribute are:
<P>
        REAL, PARAMETER :: ONE = 1.0, Y = 4.1 / 3.0
<P>
        INTEGER, DIMENSION (3), PARAMETER :: ORDER = (/ 1, 2, 3 /)
<P>
        TYPE(NODE), PARAMETER :: DEFAULT = NODE(0, NULL ( ))
<P>
  8.5.14      POINTER attribute
<P>
</PRE>
1 Entities with the POINTER attribute can be associated with different data objects or procedures during execution
<P>
<PRE>
  of a program. A pointer is either a data pointer or a procedure pointer.
<P>
  C851     An entity with the POINTER attribute shall not have the ALLOCATABLE, INTRINSIC, or TARGET
<P>
           attribute, and shall not be a coarray.
<P>
  C852     A procedure with the POINTER attribute shall have the EXTERNAL attribute.
<P>
</PRE>
2 A data pointer shall not be referenced unless it is pointer associated with a target object that is defined. A data
<P>
<PRE>
  pointer shall not be defined unless it is pointer associated with a target object that is definable.
<P>
</PRE>
3 If a data pointer is associated, the values of its deferred type parameters are the same as the values of the
<P>
<PRE>
  corresponding type parameters of its target.
<P>
</PRE>
4 A procedure pointer shall not be referenced unless it is pointer associated with a target procedure.
<P>
<PRE>
        NOTE 8.21
<P>
        Examples of POINTER attribute specifications are:
<P>
        TYPE (NODE), POINTER :: CURRENT, TAIL
<P>
        REAL, DIMENSION (:, :), POINTER :: IN, OUT, SWAP
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>108</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.5.15</B> </TD><TD valign=bottom>
PROTECTED attribute
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 The PROTECTED attribute imposes limitations on the usage of module entities.
<P>
<PRE>
  C853      The PROTECTED attribute shall be specified only in the specification part of a module.
<P>
  C854      An entity with the PROTECTED attribute shall be a procedure pointer or variable.
<P>
  C855      An entity with the PROTECTED attribute shall not be in a common block.
<P>
  C856      A nonpointer object that has the PROTECTED attribute and is accessed by use association shall not
<P>
            appear in a variable definition context (19.6.7) or as a data-target or initial-data-target.
<P>
  C857      A pointer that has the PROTECTED attribute and is accessed by use association shall not appear in a
<P>
            pointer association context (19.6.8).
<P>
</PRE>
2 Other than within the module in which an entity is given the PROTECTED attribute, or within any of its
<P>
<PRE>
  descendants,
<P>
      • if it is a nonpointer object, it is not definable, and
<P>
      • if it is a pointer, its association status shall not be changed except that it may become undefined if its target
<P>
        is deallocated other than through the pointer (19.5.2.5), or if its target becomes undefined by completing
<P>
        execution of a BLOCK construct or by execution of a RETURN or END statement.
<P>
</PRE>
3 If an object has the PROTECTED attribute, all of its subobjects have the PROTECTED attribute.
<P>
<PRE>
       NOTE 8.22
<P>
       An example of the PROTECTED attribute:
<P>
                MODULE temperature
<P>
                  REAL, PROTECTED :: temp_c, temp_f
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>set_temperature_c</B>(c)
<P>
<PRE>
                     REAL, INTENT(IN) :: c
<P>
                     temp_c = c
<P>
                     temp_f = temp_c*(9.0/5.0) + 32
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
The PROTECTED attribute ensures that the variables temp_c and temp_f cannot be modified other than
<P>
via the set_temperature_c procedure, thus keeping them consistent with each other.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: via the set_temperature_c procedure, thus keeping them consistent with each other.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.5.16</B> </TD><TD valign=bottom>
SAVE attribute
<P>
1 The SAVE attribute specifies that a local variable of a program unit or subprogram retains its association status,
<P>
<PRE>
  allocation status, definition status, and value after execution of a RETURN or END statement unless it is a
<P>
  pointer and its target becomes undefined (19.5.2.5(6)). If it is a local variable of a subprogram it is shared by all
<P>
  instances (15.6.2.4) of the subprogram.
<P>
</PRE>
2 The SAVE attribute specifies that a local variable of a BLOCK construct retains its association status, allocation
<P>
<PRE>
  status, definition status, and value after termination of the construct unless it is a pointer and its target becomes
<P>
  undefined (19.5.2.5(7)). If the BLOCK construct is within a subprogram the variable is shared by all instances
<P>
  (15.6.2.4) of the subprogram.
<P>
</PRE>
3 Giving a common block the SAVE attribute confers the attribute on all entities in the common block.
<P>
<PRE>
  C858      An entity with the SAVE attribute shall be a common block, variable, or procedure pointer.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             109
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C859      The SAVE attribute shall not be specified for a dummy argument, a function result, an automatic data
<P>
            object, or an object that is in a common block.
<P>
</PRE>
4 A variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or
<P>
<PRE>
  submodule implicitly has the SAVE attribute, which may be confirmed by explicit specification. If a common block
<P>
  has the SAVE attribute in any other kind of scoping unit, it shall have the SAVE attribute in every scoping unit that is not of a
<P>
  main program, module, or submodule.
<P>
  8.5.17      TARGET attribute
<P>
</PRE>
1 The TARGET attribute specifies that a data object may have a pointer associated with it (10.2.2). An object
<P>
<PRE>
  without the TARGET attribute shall not have a pointer associated with it.
<P>
  C860      An entity with the TARGET attribute shall be a variable.
<P>
  C861      An entity with the TARGET attribute shall not have the POINTER attribute.
<P>
</PRE>
2 If an object has the TARGET attribute, then all of its nonpointer subobjects also have the TARGET attribute.
<P>
<PRE>
        NOTE 8.23
<P>
        In addition to variables explicitly declared to have the TARGET attribute, the objects created by allocation
<P>
        of pointers (9.7.1.4) have the TARGET attribute.
<P>
        NOTE 8.24
<P>
        Examples of TARGET attribute specifications are:
<P>
        TYPE (NODE), TARGET :: HEAD
<P>
        REAL, DIMENSION (1000, 1000), TARGET :: A, B
<P>
        NOTE 8.25
<P>
        Every object designator that starts from an object with the TARGET attribute will have either the TARGET
<P>
        or POINTER attribute. If pointers are involved, the designator might not necessarily be a subobject of the
<P>
        original object, but because a pointer can point only to an entity with the TARGET attribute, there is no
<P>
        way to end up at a nonpointer that does not have the TARGET attribute.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.5.18</B> </TD><TD valign=bottom>
VALUE attribute
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 The VALUE attribute specifies a type of argument association (15.5.2.4) for a dummy argument.
<P>
<PRE>
  C862      An entity with the VALUE attribute shall be a dummy data object. It shall not be an assumed-size
<P>
            array, a coarray, or a variable with a coarray ultimate component.
<P>
  C863      An entity with the VALUE attribute shall not have the ALLOCATABLE, INTENT (INOUT), INTENT
<P>
            (OUT), POINTER, or VOLATILE attributes.
<P>
  C864      A dummy argument of a procedure with the BIND attribute shall not have both the OPTIONAL and
<P>
            VALUE attributes.
<P>
  8.5.19      VOLATILE attribute
<P>
</PRE>
1 The VOLATILE attribute specifies that an object may be referenced, defined, or become undefined, by means
<P>
<PRE>
  not specified by the program. A pointer with the VOLATILE attribute may additionally have its association
<P>
  status, dynamic type and type parameters, and array bounds changed by means not specified by the program.
<P>
  An allocatable object with the VOLATILE attribute may additionally have its allocation status, dynamic type
<P>
  and type parameters, and array bounds changed by means not specified by the program.
<P>
  110                                                                       ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
<P>
  C865      An entity with the VOLATILE attribute shall be a variable that is not an INTENT (IN) dummy argu-
<P>
            ment.
<P>
  C866      The VOLATILE attribute shall not be specified for a coarray, or a variable with a coarray ultimate
<P>
            component, that is accessed by use (14.2.2) or host (19.5.1.4) association.
<P>
  C867      Within a BLOCK construct (11.1.4), the VOLATILE attribute shall not be specified for a coarray, or a
<P>
            variable with a coarray ultimate component, that is not a construct entity (19.4) of that construct.
<P>
</PRE>
2 A noncoarray object that has the VOLATILE attribute may be associated with an object that does not have
<P>
<PRE>
  the VOLATILE attribute, including by use (14.2.2) or host association (19.5.1.4). If an object that is not a
<P>
  local variable of a BLOCK construct is specified to have the VOLATILE attribute in the specification-part of
<P>
  the construct, the object has the attribute within the construct even if it does not have the attribute outside the
<P>
  construct. The relationship between coarrays, the VOLATILE attribute, and argument association is described
<P>
  in 15.5.2.8. The relationship between between coarrays, the VOLATILE attribute, and pointer association is
<P>
  described in 10.2.2.3.
<P>
</PRE>
3 A pointer should have the VOLATILE attribute if its target has the VOLATILE attribute. If, by means not
<P>
<PRE>
  specified by the program, the target is referenced, defined, or becomes undefined, the pointer shall have the
<P>
  VOLATILE attribute. All members of an EQUIVALENCE group should have the VOLATILE attribute if any member has the
<P>
  VOLATILE attribute.
<P>
</PRE>
4 If an object has the VOLATILE attribute, then all of its subobjects also have the VOLATILE attribute.
<P>
5 The Fortran processor should use the most recent definition of a volatile object each time its value is required.
<P>
<PRE>
  When a volatile object is defined by means of Fortran, it should make that definition available to the non-Fortran
<P>
  parts of the program as soon as possible.
<P>
  8.6       Attribute specification statements
<P>
  8.6.1      Accessibility statement
<P>
  R827      access-stmt                    is  access-spec [ [ :: ] access-id-list ]
<P>
  R828      access-id                      is access-name
<P>
                                           or generic-spec
<P>
  C868      (R827) An access-stmt shall appear only in the specification-part of a module. Only one accessibility
<P>
            statement with an omitted access-id-list is permitted in the specification-part of a module.
<P>
  C869      (R828) Each access-name shall be the name of a module, variable, procedure, derived type, named
<P>
            constant, or namelist group.
<P>
  C870      A module whose name appears in an access-stmt shall be referenced by a USE statement in the scoping
<P>
            unit that contains the access-stmt.
<P>
  C871      The name of a module shall appear at most once in all of the access-stmts in a module.
<P>
</PRE>
1 An access-stmt with an access-id-list specifies the accessibility attribute, PUBLIC or PRIVATE, of each access-id
<P>
<PRE>
  in the list that is not a module name. An access-stmt without an access-id list specifies the default accessibility
<P>
  of the identifiers of entities declared in the module, and of entities accessed from a module whose name does
<P>
  not appear in any access-stmt in the module. If an identifier is accessed from another module and also declared
<P>
  locally, it has the default accessibility of a locally declared identifier. The statement
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; PUBLIC</H4>
</A>
<BLOCKQUOTE>
<P>
specifies a default of public accessibility. The statement
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
specifies a default of private accessibility. If no such statement appears in a module, the default is public
<P>
accessibility.
<TABLE cellpadding=3><!-- tsb: accessibility.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
111
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
</BLOCKQUOTE>
<P>
2 If an identifier is accessed by use association and not declared in the module, and the name of every module
<P>
<PRE>
  from which it is accessed appears in an access-stmt in the scoping unit, its default accessibility is PRIVATE if
<P>
  the access-spec in every such access-stmt is PRIVATE, or PUBLIC if the access-spec in any such access-stmt is
<P>
  PUBLIC.
<P>
       NOTE 8.26
<P>
       Examples of accessibility statements are:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE EX</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
PUBLIC :: A, B, C, ASSIGNMENT (=), OPERATOR (+)
</BLOCKQUOTE>
<P>
NOTE 8.27
<BLOCKQUOTE>
<P>
The following is an example of using an accessibility statement on a module name.
<P>
<PRE>
           MODULE m2
<P>
             USE m1
<P>
             ! We want to use the types and procedures in m1, but we only want to
<P>
             ! re-export m_type from m1, and export our own procedures.
<P>
             PRIVATE m1
<P>
             PUBLIC m_type
<P>
             &#46;&#46;&#46; definitions for our own entities and module procedures.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.6.2</B> </TD><TD valign=bottom>
ALLOCATABLE statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R829</B> </TD><TD valign=bottom>
allocatable-stmt              is   ALLOCATABLE [ :: ] allocatable-decl-list
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R830</B> </TD><TD valign=bottom>
allocatable-decl              is   object-name [ ( array-spec ) ]
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                [ lbracket coarray-spec rbracket ]
<P>
</PRE>
1 The ALLOCATABLE statement specifies the ALLOCATABLE attribute (8.5.3) for a list of objects.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 8.28
<P>
       An example of an ALLOCATABLE statement is:
<P>
       REAL A, B (:), SCALAR
<P>
       ALLOCATABLE :: A (:, :), B, SCALAR
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.6.3</B> </TD><TD valign=bottom>
ASYNCHRONOUS statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R831</B> </TD><TD valign=bottom>
asynchronous-stmt             is   ASYNCHRONOUS [ :: ] object-name-list
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The ASYNCHRONOUS statement specifies the ASYNCHRONOUS attribute (8.5.4) for a list of objects.
<P>
<PRE>
  8.6.4     BIND statement
<P>
  R832    bind-stmt                     is   language-binding-spec [ :: ] bind-entity-list
<P>
  R833    bind-entity                   is   entity-name
<P>
                                        or   / common-block-name /
<P>
  C872    (R832) If the language-binding-spec has a NAME= specifier, the bind-entity-list shall consist of a single
<P>
          bind-entity.
<P>
</PRE>
1 The BIND statement specifies the BIND attribute for a list of variables and common blocks.
<P>
<PRE>
  112                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
<P>
  8.6.5     CODIMENSION statement
<P>
  R834     codimension-stmt                 is   CODIMENSION [ :: ] codimension-decl-list
<P>
  R835     codimension-decl                 is   coarray-name lbracket coarray-spec rbracket
<P>
</PRE>
1 The CODIMENSION statement specifies the CODIMENSION attribute (8.5.6) for a list of objects.
<P>
<PRE>
        NOTE 8.29
<P>
        An example of a CODIMENSION statement is:
<P>
          CODIMENSION a[*], b[3,*], c[:]
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.6.6</B> </TD><TD valign=bottom>
CONTIGUOUS statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R836</B> </TD><TD valign=bottom>
contiguous-stmt                  is   CONTIGUOUS [ :: ] object-name-list
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The CONTIGUOUS statement specifies the CONTIGUOUS attribute (8.5.7) for a list of objects.
<P>
<PRE>
  8.6.7     DATA statement
<P>
  R837     data-stmt                        is   DATA data-stmt-set [ [ , ] data-stmt-set ] &#46;&#46;&#46;
<P>
</PRE>
1 The DATA statement specifies explicit initialization (8.4).
<BLOCKQUOTE>
<P>
2 If a nonpointer variable has default initialization, it shall not appear in a data-stmt-object-list.
<P>
3 A variable that appears in a DATA statement and has not been typed previously may appear in a subsequent type
<P>
<PRE>
  declaration only if that declaration confirms the implicit typing. An array name, array section, or array element
<P>
  that appears in a DATA statement shall have had its array properties established by a previous specification
<P>
  statement.
<P>
</PRE>
4 Except for variables in named common blocks, a named variable has the SAVE attribute if any part of it is initialized
<P>
<PRE>
  in a DATA statement, and this may be confirmed by explicit specification.
<P>
  R838     data-stmt-set                    is   data-stmt-object-list / data-stmt-value-list /
<P>
  R839     data-stmt-object                 is variable
<P>
                                            or data-implied-do
<P>
  R840     data-implied-do                  is   ( data-i-do-object-list , [ integer-type-spec :: ] data-i-do-variable =
<P>
                                                    scalar-int-constant-expr ,
<P>
                                                    scalar-int-constant-expr
<P>
                                                    [ , scalar-int-constant-expr ] )
<P>
  R841     data-i-do-object                 is array-element
<P>
                                            or scalar-structure-component
<P>
                                            or data-implied-do
<P>
  R842     data-i-do-variable               is   do-variable
<P>
  C873     A data-stmt-object or data-i-do-object shall not be a coindexed variable.
<P>
  C874     (R839) A data-stmt-object that is a variable shall be a designator. Each subscript, section subscript,
<P>
           substring starting point, and substring ending point in the variable shall be a constant expression.
<P>
  C875     (R839) A variable whose designator appears as a data-stmt-object or a data-i-do-object shall not be a
<P>
           dummy argument, accessed by use or host association, in a named common block unless the DATA statement is
<P>
           in a block data program unit, in blank common, a function name, a function result name, an automatic data
<P>
           object, or an allocatable variable.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                  113
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C876     (R839) A data-i-do-object or a variable that appears as a data-stmt-object shall not be an object designator
<P>
           in which a pointer appears other than as the entire rightmost part-ref .
<P>
  C877     (R841) The array-element shall be a variable.
<P>
  C878     (R841) The scalar-structure-component shall be a variable.
<P>
  C879     (R841) The scalar-structure-component shall contain at least one part-ref that contains a subscript-list.
<P>
  C880     (R841) In an array-element or scalar-structure-component that is a data-i-do-object, any subscript shall
<P>
           be a constant expression, and any primary within that subscript that is a data-i-do-variable shall be a
<P>
           DO variable of this data-implied-do or of a containing data-implied-do.
<P>
  R843     data-stmt-value                is [ data-stmt-repeat * ] data-stmt-constant
<P>
  R844     data-stmt-repeat               is scalar-int-constant
<P>
                                          or scalar-int-constant-subobject
<P>
  C881     (R844) The data-stmt-repeat shall be positive or zero. If the data-stmt-repeat is a named constant, it
<P>
           shall have been defined previously.
<P>
  R845     data-stmt-constant             is scalar-constant
<P>
                                          or scalar-constant-subobject
<P>
                                          or signed-int-literal-constant
<P>
                                          or signed-real-literal-constant
<P>
                                          or null-init
<P>
                                          or initial-data-target
<P>
                                          or structure-constructor
<P>
  C882     (R845) If a DATA statement constant value is a named constant or a structure constructor, the named
<P>
           constant or derived type shall have been defined previously.
<P>
  C883     (R845) If a data-stmt-constant is a structure-constructor, it shall be a constant expression.
<P>
  R846     int-constant-subobject         is constant-subobject
<P>
  C884     (R846) int-constant-subobject shall be of type integer.
<P>
  R847     constant-subobject             is designator
<P>
  C885     (R847) constant-subobject shall be a subobject of a constant.
<P>
  C886     (R847) Any subscript, substring starting point, or substring ending point shall be a constant expression.
<P>
</PRE>
5 The data-stmt-object-list is expanded to form a sequence of pointers and scalar variables, referred to as “sequence
<P>
<PRE>
  of variables” in subsequent text. A nonpointer array whose unqualified name appears as a data-stmt-object or
<P>
  data-i-do-object is equivalent to a complete sequence of its array elements in array element order (9.5.3.2). An
<P>
  array section is equivalent to the sequence of its array elements in array element order. A data-implied-do is
<P>
  expanded to form a sequence of array elements and structure components, under the control of the data-i-do-
<P>
  variable, as in the DO construct (11.1.7.4).
<P>
</PRE>
6 The data-stmt-value-list is expanded to form a sequence of data-stmt-constants. A data-stmt-repeat indicates the
<P>
<PRE>
  number of times the following data-stmt-constant is to be included in the sequence; omission of a data-stmt-repeat
<P>
  has the effect of a repeat factor of 1.
<P>
</PRE>
7 A zero-sized array or a data-implied-do with an iteration count of zero contributes no variables to the expanded
<P>
<PRE>
  sequence of variables, but a zero-length scalar character variable does contribute a variable to the expanded
<P>
  sequence. A data-stmt-constant with a repeat factor of zero contributes no data-stmt-constants to the expanded
<P>
  sequence of scalar data-stmt-constants.
<P>
  114                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 The expanded sequences of variables and data-stmt-constants are in one-to-one correspondence. Each data-stmt-
<P>
<PRE>
   constant specifies the initial value, initial data target, or null-init for the corresponding variable. The lengths of
<P>
   the two expanded sequences shall be the same.
<P>
</PRE>
9 A data-stmt-constant shall be null-init or initial-data-target if and only if the corresponding data-stmt-object has
<P>
<PRE>
   the POINTER attribute. If data-stmt-constant is null-init, the initial association status of the corresponding data
<P>
   statement object is disassociated. If data-stmt-constant is initial-data-target the corresponding data statement
<P>
   object shall be data-pointer-initialization compatible (7.5.4.6) with the initial data target; the data statement
<P>
   object is initially associated with the target.
<P>
</PRE>
10 A data-stmt-constant other than boz-literal-constant, null-init, or initial-data-target shall be compatible with its
<P>
<PRE>
   corresponding variable according to the rules of intrinsic assignment (10.2.1.2). The variable is initially defined
<P>
   with the value specified by the data-stmt-constant; if necessary, the value is converted according to the rules of
<P>
   intrinsic assignment (10.2.1.3) to a value that agrees in type, type parameters, and shape with the variable.
<P>
</PRE>
11 If a data-stmt-constant is a boz-literal-constant, the corresponding variable shall be of type integer. The boz-
<P>
<PRE>
   literal-constant is treated as if it were converted by the intrinsic function INT (16.9.100) to type integer with the
<P>
   kind type parameter of the variable.
<P>
         NOTE 8.30
<P>
         Examples of DATA statements are:
<P>
         CHARACTER (LEN = 10) NAME
<P>
         INTEGER, DIMENSION (0:9) :: MILES
<P>
         REAL, DIMENSION (100, 100) :: SKEW
<P>
         TYPE (NODE), POINTER :: HEAD_OF_LIST
<P>
         TYPE (PERSON) MYNAME, YOURNAME
<P>
         DATA NAME / ’JOHN DOE’ /, MILES / 10 * 0 /
<P>
         DATA ((SKEW (K, J), J = 1, K), K = 1, 100) / 5050 * 0.0 /
<P>
         DATA ((SKEW (K, J), J = K + 1, 100), K = 1, 99) / 4950 * 1.0 /
<P>
         DATA HEAD_OF_LIST / NULL() /
<P>
         DATA MYNAME / PERSON (21, ’JOHN SMITH’) /
<P>
         DATA YOURNAME % AGE, YOURNAME % NAME / 35, ’FRED BROWN’ /
<P>
         The character variable NAME is initialized with the value JOHN DOE with padding on the right because
<P>
         the length of the constant is less than the length of the variable. All ten elements of the integer array
<P>
         MILES are initialized to zero. The two-dimensional array SKEW is initialized so that the lower triangle
<P>
         of SKEW is zero and the strict upper triangle is one. The structures MYNAME and YOURNAME are
<P>
         declared using the derived type PERSON from NOTE 7.15. The pointer HEAD_OF_LIST is declared
<P>
         using the derived type NODE from NOTE 7.35; it is initially disassociated. MYNAME is initialized by a
<P>
         structure constructor. YOURNAME is initialized by supplying a separate value for each component.
<P>
   8.6.8      DIMENSION statement
<P>
   R848      dimension-stmt                 is  DIMENSION [ :: ] array-name ( array-spec )
<P>
                                                   [ , array-name ( array-spec ) ] &#46;&#46;&#46;
<P>
</PRE>
1 The DIMENSION statement specifies the DIMENSION attribute (8.5.8) for a list of objects.
<P>
<PRE>
         NOTE 8.31
<P>
         An example of a DIMENSION statement is:
<P>
         DIMENSION A (10), B (10, 70), C (:)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
115
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.6.9</B> </TD><TD valign=bottom>
INTENT statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R849</B> </TD><TD valign=bottom>
intent-stmt                 is   INTENT ( intent-spec ) [ :: ] dummy-arg-name-list
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The INTENT statement specifies the INTENT attribute (8.5.10) for the dummy arguments in the list.
<P>
<PRE>
       NOTE 8.32
<P>
       An example of an INTENT statement is:
<P>
       SUBROUTINE EX (A, B)
<P>
           INTENT (INOUT) :: A, B
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.6.10</B> </TD><TD valign=bottom>
OPTIONAL statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R850</B> </TD><TD valign=bottom>
optional-stmt               is   OPTIONAL [ :: ] dummy-arg-name-list
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The OPTIONAL statement specifies the OPTIONAL attribute (8.5.12) for the dummy arguments in the list.
<P>
<PRE>
       NOTE 8.33
<P>
       An example of an OPTIONAL statement is:
<P>
       SUBROUTINE EX (A, B)
<P>
           OPTIONAL :: B
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.6.11</B> </TD><TD valign=bottom>
PARAMETER statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The PARAMETER statement specifies the PARAMETER attribute (8.5.13) and the values for the named con-
<P>
<PRE>
  stants in the list.
<P>
  R851     parameter-stmt              is   PARAMETER ( named-constant-def-list )
<P>
  R852     named-constant-def          is   named-constant = constant-expr
<P>
</PRE>
2 If a named constant is defined by a PARAMETER statement, it shall not be subsequently declared to have a
<P>
<PRE>
  type or type parameter value that differs from the type and type parameters it would have if declared implicitly
<P>
  (8.7). A named array constant defined by a PARAMETER statement shall have its rank specified in a prior
<P>
  specification statement.
<P>
</PRE>
3 The constant expression that corresponds to a named constant shall have type and type parameters that conform
<P>
<PRE>
  with the named constant as specified for intrinsic assignment (10.2.1.2). If the named constant has implied shape,
<P>
  the expression shall have the same rank as the named constant; otherwise, the expression shall either be scalar
<P>
  or have the same shape as the named constant.
<P>
</PRE>
4 The value of each named constant is that specified by the corresponding constant expression; if necessary, the
<P>
<PRE>
  value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type, type
<P>
  parameters, and shape with the named constant.
<P>
       NOTE 8.34
<P>
       An example of a PARAMETER statement is:
<P>
       PARAMETER (MODULUS = MOD (28, 3), NUMBER_OF_SENATORS = 100)
<P>
  8.6.12      POINTER statement
<P>
  R853     pointer-stmt                is   POINTER [ :: ] pointer-decl-list
<P>
  R854     pointer-decl                is object-name [ ( deferred-shape-spec-list ) ]
<P>
                                       or proc-entity-name
<P>
  116                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  C887    A proc-entity-name shall have the EXTERNAL attribute.
<P>
</PRE>
1 The POINTER statement specifies the POINTER attribute (8.5.14) for a list of entities.
<P>
<PRE>
       NOTE 8.35
<P>
       An example of a POINTER statement is:
<P>
       TYPE (NODE) :: CURRENT
<P>
       POINTER :: CURRENT, A (:, :)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.6.13</B> </TD><TD valign=bottom>
PROTECTED statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R855</B> </TD><TD valign=bottom>
protected-stmt                is   PROTECTED [ :: ] entity-name-list
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The PROTECTED statement specifies the PROTECTED attribute (8.5.15) for a list of entities.
<P>
<PRE>
  8.6.14     SAVE statement
<P>
  R856    save-stmt                     is   SAVE [ [ :: ] saved-entity-list ]
<P>
  R857    saved-entity                  is object-name
<P>
                                        or proc-pointer-name
<P>
                                        or   / common-block-name /
<P>
  R858    proc-pointer-name             is   name
<P>
  C888    (R856) If a SAVE statement with an omitted saved entity list appears in a scoping unit, no other
<P>
          appearance of the SAVE attr-spec or SAVE statement is permitted in that scoping unit.
<P>
  C889    A proc-pointer-name shall be the name of a procedure pointer.
<P>
</PRE>
1 A SAVE statement with a saved entity list specifies the SAVE attribute (8.5.16) for a list of entities. A SAVE
<P>
<PRE>
  statement without a saved entity list is treated as though it contained the names of all allowed items in the same
<P>
  scoping unit.
<P>
       NOTE 8.36
<P>
       An example of a SAVE statement is:
<P>
       SAVE A, B, C, / BLOCKA /, D
<P>
  8.6.15     TARGET statement
<P>
  R859    target-stmt                   is   TARGET [ :: ] target-decl-list
<P>
  R860    target-decl                   is   object-name [ ( array-spec ) ]
<P>
                                                [ lbracket coarray-spec rbracket ]
<P>
</PRE>
1 The TARGET statement specifies the TARGET attribute (8.5.17) for a list of objects.
<P>
<PRE>
       NOTE 8.37
<P>
       An example of a TARGET statement is:
<P>
       TARGET :: A (1000, 1000), B
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.6.16</B> </TD><TD valign=bottom>
VALUE statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R861</B> </TD><TD valign=bottom>
value-stmt                    is   VALUE [ :: ] dummy-arg-name-list
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
117
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
</BLOCKQUOTE>
<P>
1 The VALUE statement specifies the VALUE attribute (8.5.18) for a list of dummy arguments.
<P>
<PRE>
  8.6.17      VOLATILE statement
<P>
  R862     volatile-stmt                   is  VOLATILE [ :: ] object-name-list
<P>
</PRE>
1 The VOLATILE statement specifies the VOLATILE attribute (8.5.19) for a list of objects.
<P>
<PRE>
  8.7      IMPLICIT statement
<P>
</PRE>
1 In a scoping unit, an IMPLICIT statement specifies a type, and possibly type parameters, for all implicitly
<P>
<PRE>
  typed data entities whose names begin with one of the letters specified in the statement. An IMPLICIT NONE
<P>
  statement can indicate that no implicit typing rules are to apply in a particular scoping unit, or that external
<P>
  and dummy procedures need to be explicitly given the EXTERNAL attribute.
<P>
  R863     implicit-stmt                   is IMPLICIT implicit-spec-list
<P>
                                           or IMPLICIT NONE [ ( [ implicit-none-spec-list ] ) ]
<P>
  R864     implicit-spec                   is  declaration-type-spec ( letter-spec-list )
<P>
  R865     letter-spec                     is  letter [ – letter ]
<P>
  R866     implicit-none-spec              is EXTERNAL
<P>
                                           or TYPE
<P>
  C890     (R863) If an IMPLICIT NONE statement appears in a scoping unit, it shall precede any PARAMETER
<P>
           statements that appear in the scoping unit. No more than one IMPLICIT NONE statement shall appear
<P>
           in a scoping unit.
<P>
  C891     The same implicit-none-spec shall not appear more than once in a given implicit-stmt.
<P>
  C892     If an IMPLICIT NONE statement in a scoping unit has an implicit-none-spec of TYPE or has no implicit-
<P>
           none-spec-list, there shall be no other IMPLICIT statements in the scoping unit.
<P>
  C893     (R865) If the minus and second letter appear, the second letter shall follow the first letter alphabetically.
<P>
  C894     If IMPLICIT NONE with an implicit-none-spec of EXTERNAL appears within a scoping unit, the
<P>
           name of an external or dummy procedure in that scoping unit or in a contained subprogram or BLOCK
<P>
           construct shall have an explicit interface or be explicitly declared to have the EXTERNAL attribute.
<P>
</PRE>
2 A letter-spec consisting of two letters separated by a minus is equivalent to writing a list containing all of the letters
<P>
<PRE>
  in alphabetical order in the alphabetic sequence from the first letter through the second letter. For example, A–C
<P>
  is equivalent to A, B, C. The same letter shall not appear as a single letter, or be included in a range of letters,
<P>
  more than once in all of the IMPLICIT statements in a scoping unit.
<P>
</PRE>
3 In each scoping unit, there is a mapping, which may be null, between each of the letters A, B, &#46;&#46;&#46;, Z and a
<P>
<PRE>
  type (and type parameters). An IMPLICIT statement specifies the mapping for the letters in its letter-spec-
<P>
  list. IMPLICIT NONE with an implicit-none-spec of TYPE or with no implicit-none-spec-list specifies the null
<P>
  mapping for all the letters. If a mapping is not specified for a letter, the default for a program unit or an interface
<P>
  body is default integer if the letter is I, J, &#46;&#46;&#46;, or N and default real otherwise, and the default for a BLOCK
<P>
  construct, internal subprogram, or module subprogram is the mapping in the host scoping unit.
<P>
</PRE>
4 Any data entity that is not explicitly declared by a type declaration statement, is not an intrinsic function, is
<P>
<PRE>
  not a component, and is not accessed by use or host association is declared implicitly to be of the type (and
<P>
  type parameters) mapped from the first letter of its name, provided the mapping is not null. The mapping for
<P>
  the first letter of the data entity shall either have been established by a prior IMPLICIT statement or be the
<P>
  default mapping for the letter. An explicit type specification in a FUNCTION statement overrides an IMPLICIT
<P>
  statement for the result of that function.
<P>
  118                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
   NOTE 8.38
<P>
   The following are examples of the use of IMPLICIT statements:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE EXAMPLE_MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>FUNCTION FUN (I)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
!  Not all data entities need to
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                      INTEGER FUN        !  be declared explicitly
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION FUN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>FUNCTION JFUN (J)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
!  All data entities need to
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                   INTEGER JFUN, J       !  be declared explicitly.
<P>
                   &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION JFUN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE EXAMPLE_MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
IMPLICIT COMPLEX (C)
<TABLE cellpadding=3><!-- tsb: IMPLICIT COMPLEX (C)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>C = (3.0, 2.0)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
!  C is implicitly declared COMPLEX
</TD></TR>
<TR></TR></TABLE>&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE SUB1
<P>
<PRE>
                   IMPLICIT INTEGER (A,     C)
<P>
                   C = (0.0, 0.0)        !  C is host associated and of
<P>
                                         !  type complex
<P>
                   Z = 1.0               !  Z is implicitly declared REAL
<P>
                   A = 2                 !  A is implicitly declared INTEGER
<P>
                   CC = 1                !  CC is implicitly declared INTEGER
<P>
                   &#46;&#46;&#46;
<P>
</PRE>
END SUBROUTINE SUB1
<P>
SUBROUTINE SUB2
<P>
<PRE>
                   Z = 2.0               !  Z is implicitly declared REAL and
<P>
                                         !  is different from the variable of
<P>
                                         !  the same name in SUB1
<P>
                   &#46;&#46;&#46;
<P>
</PRE>
END SUBROUTINE SUB2
<P>
SUBROUTINE SUB3
<P>
<PRE>
                   USE EXAMPLE_MODULE !     Accesses integer function FUN
<P>
                                         !  by use association
<P>
                   Q = FUN (K)           !  Q is implicitly declared REAL and
<P>
                   &#46;&#46;&#46;                   !  K is implicitly declared INTEGER
<P>
</PRE>
END SUBROUTINE SUB3
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 8.39
<P>
The following is an example of a mapping to a derived type that is inaccessible in the local scope:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM MAIN</H4>
</A>
<BLOCKQUOTE>
<P>
IMPLICIT <B>TYPE</B>(BLOB) (A)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE BLOB</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER :: I
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE BLOB</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(BLOB) :: B
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL STEVE</H4>
</A>
<BLOCKQUOTE>
<P>
⃝
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
119
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
    NOTE 8.39 (cont.)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE STEVE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER :: BLOB
<P>
&#46;&#46;&#46;
<P>
AA = B
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE STEVE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM MAIN</H4>
</A>
<BLOCKQUOTE>
<P>
In the subroutine STEVE, it is not possible to explicitly declare a variable to be of type BLOB because
<P>
BLOB has been given a different meaning, but implicit mapping for the letter A still maps to type BLOB,
<P>
so AA is of type BLOB.
<P>
NOTE 8.40
<P>
Implicit typing is not affected by BLOCK constructs. For example, in
<P>
<PRE>
          SUBROUTINE S(N)
<P>
             &#46;&#46;&#46;
<P>
             IF (N&gt;0) THEN
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
NSQP = CEILING (SQRT (DBLE (N)))
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
IF (N&gt;0) THEN
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
PRINT *,NSQP
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
even if the only two appearances of NSQP are within the BLOCK constructs, the scope of NSQP is the whole
<P>
subroutine S.
<P>
NOTE 8.41
<P>
In the subprogram
<P>
<PRE>
             SUBROUTINE EXAMPLE (X, Y)
<P>
                IMPLICIT NONE (EXTERNAL)
<P>
                REAL, EXTERNAL :: G
<P>
                REAL :: X, Y
<P>
                X = F (Y)                       ! Invalid: F lacks the EXTERNAL attribute.
<P>
                X = G (Y)                       ! Valid: G has the EXTERNAL attribute.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
the referenced function F needs to have the EXTERNAL attribute (8.5.9).
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: the referenced function F needs to have the EXTERNAL attribute (8.5.9).
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.8</B> </TD><TD valign=bottom>
IMPORT statement
<TABLE width=100% cellpadding=3><!-- tsb: IMPORT statement
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>R867</B> </TD><TD valign=bottom>
import-stmt                   is    IMPORT [[ :: ] import-name-list ]
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                      or    IMPORT, ONLY : import-name-list
<P>
                                      or    IMPORT, NONE
<P>
                                      or    IMPORT, ALL
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C895</B> </TD><TD valign=bottom>
(R867) An IMPORT statement shall not appear in the scoping unit of a main-program, external-
</TD></TR>
<TR><TD colspan=2>
<PRE>
        subprogram, module, or block-data .
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>120</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                  c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C896</B> </TD><TD valign=bottom>
(R867) Each import-name shall be the name of an entity in the host scoping unit.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C897</B> </TD><TD valign=bottom>
If any IMPORT statement in a scoping unit has an ONLY specifier, all IMPORT statements in that
</TD></TR>
<TR><TD colspan=2>
<PRE>
           scoping unit shall have an ONLY specifier.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C898</B> </TD><TD valign=bottom>
IMPORT, NONE shall not appear in the scoping unit of a submodule.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C899</B> </TD><TD valign=bottom>
If an IMPORT, NONE or IMPORT, ALL statement appears in a scoping unit, no other IMPORT
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
           statement shall appear in that scoping unit.
<P>
</PRE>
C8100 Within an interface body, an entity that is accessed by host association shall be accessible by host or use
<P>
<PRE>
           association within the host scoping unit, or explicitly declared prior to the interface body.
<P>
</PRE>
C8101 An entity whose name appears as an import-name or which is made accessible by an IMPORT, ALL
<P>
<PRE>
           statement shall not appear in any context described in 19.5.1.4 that would cause the host entity of that
<P>
           name to be inaccessible.
<P>
</PRE>
1 If the ONLY specifier appears on an IMPORT statement in a scoping unit other than a BLOCK construct,
<P>
<PRE>
  an entity is only accessible by host association if its name appears as an import-name in that scoping unit. If
<P>
  a BLOCK construct contains one or more IMPORT statements with ONLY specifiers, identifiers of local and
<P>
  construct entities in the host scoping unit that are not in the import-name-list of at least one of the IMPORT
<P>
  statements are inaccessible in the BLOCK construct.
<P>
</PRE>
2 An IMPORT, NONE statement in a scoping unit specifies that no entities in the host scoping unit are accessible
<P>
<PRE>
  by host association in that scoping unit. This is the default for an interface body for an external or dummy
<P>
  procedure. An IMPORT, NONE statement in a BLOCK construct specifies that the identifiers of local and
<P>
  construct entities in the host scoping unit are inaccessible in the BLOCK construct.
<P>
</PRE>
3 An IMPORT, ALL statement in a scoping unit specifies that all entities from the host scoping unit are accessible
<P>
<PRE>
  in that scoping unit.
<P>
</PRE>
4 If an IMPORT statement with no specifier and no import-name-list appears in a scoping unit, every entity in
<P>
<PRE>
  the host scoping unit is accessible unless its name appears in a context described in 19.5.1.4 that causes it to be
<P>
  inaccessible. This is the default for a nested scoping unit other than an interface body for an external or dummy
<P>
  procedure.
<P>
</PRE>
5 If an IMPORT statement with an import-name-list appears in a scoping unit other than a BLOCK construct,
<P>
<PRE>
  each entity named in the list is accessible.
<P>
       NOTE 8.42
<P>
       The IMPORT, NONE statement can be used to prevent accidental host association:
<P>
          SUBROUTINE s(x,n)
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
IMPORT, NONE
<P>
&#46;&#46;&#46;
<P>
DO i=1,n ! Forces I to be locally declared.
</BLOCKQUOTE>
<P>
NOTE 8.43
<BLOCKQUOTE>
<P>
The IMPORT, ALL statement can be used to confirm the default rules and prevent accidental “shadowing”
<P>
of host entities:
<P>
<PRE>
             SUBROUTINE outer
<P>
                REAL x
<P>
                &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE inner
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: SUBROUTINE inner
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
121
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
    NOTE 8.43 (cont.)
<P>
               IMPORT, ALL
<P>
               &#46;&#46;&#46;
<P>
               x = x + 1 ! X was prevented from being locally declared&#46;&#46;&#46;
<P>
                           ! so this is the host X.
<P>
    NOTE 8.44
<P>
    The IMPORT, ONLY statement can be used to document deliberate access via host association whilst
<P>
    blocking accidental access:
<P>
          SUBROUTINE sub
<P>
             IMPORT,ONLY : x, y
<P>
             &#46;&#46;&#46;
<P>
             x = y + z ! Only X and Y are imported, so Z is local.
<P>
    NOTE 8.45
<P>
    The program
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; PROGRAM MAIN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
IMPORT, NONE
<P>
!IMPORT, ONLY: X
<P>
X = 1.0
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
is not conformant. The variable X is implicitly declared in the scoping unit of the main program. The
<P>
statement IMPORT, NONE makes X inaccessible in the BLOCK construct. If the IMPORT, NONE
<P>
statement is replaced with the IMPORT statement in the comment, the program is conformant.
<P>
NOTE 8.46
<P>
The IMPORT statement can be used to allow module procedures to have dummy arguments that are
<P>
procedures with assumed-shape arguments of an opaque type. For example:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE M</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE T</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>PRIVATE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! T is an opaque type
</TD></TR>
<TR></TR></TABLE>&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>PROCESS</B>(X,Y,RESULT,MONITOR)
<P>
<PRE>
         TYPE(T),INTENT(IN) :: X(:,:),Y(:,:)
<P>
         TYPE(T),INTENT(OUT) :: RESULT(:,:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>MONITOR</B>(ITERATION_NUMBER,CURRENT_ESTIMATE)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; IMPORT T</H4>
</A>
<BLOCKQUOTE>
<P>
<B>INTEGER,INTENT</B>(IN) :: ITERATION_NUMBER
<P>
<B>TYPE</B>(T),INTENT(IN) :: <B>CURRENT_ESTIMATE</B>(:,:)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>122</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 8.46 (cont.)
<BLOCKQUOTE>
<P>
The MONITOR dummy procedure requires an explicit interface because it has an assumed-shape array
<P>
argument, but <B>TYPE</B>(T) would not be available inside the interface body without the IMPORT statement.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: argument, but <B>TYPE</B>(T) would not be available inside the interface body without the IMPORT statement.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>8.9</B> </TD><TD valign=bottom>
NAMELIST statement
<P>
1 A NAMELIST statement specifies a group of named data objects, which may be referred to by a single name for
<P>
<PRE>
  the purpose of data transfer (12.6, 13.11).
<P>
  R868      namelist-stmt                      is   NAMELIST
<P>
                                                        / namelist-group-name / namelist-group-object-list
<P>
                                                        [ [ , ] / namelist-group-name /
<P>
                                                        namelist-group-object-list ] . . .
<P>
  C8102 (R868) The namelist-group-name shall not be a name accessed by use association.
<P>
  R869      namelist-group-object              is   variable-name
<P>
  C8103 (R869) A namelist-group-object shall not be an assumed-size array.
<P>
  C8104 (R868) A namelist-group-object shall not have the PRIVATE attribute if the namelist-group-name has
<P>
            the PUBLIC attribute.
<P>
</PRE>
2 The order in which the values appear on output is the same as the order of the namelist-group-objects in the
<P>
<PRE>
  namelist group object list; if a variable appears more than once as a namelist-group-object for the same namelist
<P>
  group, its value appears once for each occurrence.
<P>
</PRE>
3 Any namelist-group-name may occur more than once in the NAMELIST statements in a scoping unit. The
<P>
<PRE>
  namelist-group-object-list following each successive appearance of the same namelist-group-name in a scoping
<P>
  unit is treated as a continuation of the list for that namelist-group-name.
<P>
</PRE>
4 A namelist group object may be a member of more than one namelist group.
<P>
5 A namelist group object shall either be accessed by use or host association or shall have its declared type, kind
<P>
<PRE>
  type parameters of the declared type, and rank specified by previous specification statements or the procedure
<P>
  heading in the same scoping unit or by the implicit typing rules in effect for the scoping unit. If a namelist group
<P>
  object is typed by the implicit typing rules, its appearance in any subsequent type declaration statement shall
<P>
  confirm the implied type and type parameters.
<P>
         NOTE 8.47
<P>
         An example of a NAMELIST statement is:
<P>
         NAMELIST /NLIST/ A, B, C
<P>
  8.10        Storage association of data objects
<P>
  8.10.1       EQUIVALENCE statement
<P>
  8.10.1.1      General
<P>
</PRE>
1 An EQUIVALENCE statement is used to specify the sharing of storage units by two or more objects in a scoping unit. This causes
<P>
<PRE>
  storage association (19.5.3) of the objects that share the storage units.
<P>
</PRE>
2 If the equivalenced objects have differing type or type parameters, the EQUIVALENCE statement does not cause type conversion or
<P>
<PRE>
  imply mathematical equivalence. If a scalar and an array are equivalenced, the scalar does not have array properties and the array
<P>
  does not have the properties of a scalar.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                        123
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R870       equivalence-stmt                   is   EQUIVALENCE equivalence-set-list
<P>
  R871       equivalence-set                    is   ( equivalence-object , equivalence-object-list )
<P>
  R872       equivalence-object                 is   variable-name
<P>
                                                or   array-element
<P>
                                                or   substring
<P>
  C8105      (R872) An equivalence-object shall not be a designator with a base object that is a dummy argument, a function result,
<P>
             a pointer, an allocatable variable, a derived-type object that has an allocatable or pointer ultimate component, an object
<P>
             of a nonsequence derived type, an automatic data object, a coarray, a variable with the BIND attribute, a variable in a
<P>
             common block that has the BIND attribute, or a named constant.
<P>
  C8106      (R872) An equivalence-object shall not be a designator that has more than one part-ref .
<P>
  C8107      (R872) An equivalence-object shall not have the TARGET attribute.
<P>
  C8108      (R872) Each subscript or substring range expression in an equivalence-object shall be an integer constant expression
<P>
             (10.1.12).
<P>
  C8109      (R871) If an equivalence-object is default integer, default real, double precision real, default complex, default logical, or of
<P>
             numeric sequence type, all of the objects in the equivalence set shall be of these types and kinds.
<P>
  C8110      (R871) If an equivalence-object is default character or of character sequence type, all of the objects in the equivalence set
<P>
             shall be of these types and kinds.
<P>
  C8111      (R871) If an equivalence-object is of a sequence type that is not a numeric sequence or character sequence type, all of the
<P>
             objects in the equivalence set shall be of that type.
<P>
  C8112      (R871) If an equivalence-object is of an intrinsic type but is not default integer, default real, double precision real, default
<P>
             complex, default logical, or default character, all of the objects in the equivalence set shall be of the same type with the
<P>
             same kind type parameter value.
<P>
  C8113      (R872) If an equivalence-object has the PROTECTED attribute, all of the objects in the equivalence set shall have the
<P>
             PROTECTED attribute.
<P>
  C8114      (R872) The name of an equivalence-object shall not be a name made accessible by use association.
<P>
  C8115      (R872) A substring shall not have length zero.
<P>
        NOTE 8.48
<P>
        The EQUIVALENCE statement allows the equivalencing of sequence structures and the equivalencing of objects of intrinsic
<P>
        type with nondefault type parameters, but there are strict rules regarding the appearance of these objects in an EQUIVAL-
<P>
        ENCE statement.
<P>
        In addition to the above constraints, further rules on the interaction of EQUIVALENCE statements and default initialization
<P>
        are given in 19.5.3.4.
<P>
  8.10.1.2      Equivalence association
<P>
</PRE>
1 An EQUIVALENCE statement specifies that the storage sequences (19.5.3.2) of the data objects specified in an equivalence-set are
<P>
<PRE>
  storage associated. All of the nonzero-sized sequences in the equivalence-set, if any, have the same first storage unit, and all of
<P>
  the zero-sized sequences in the equivalence-set, if any, are storage associated with one another and with the first storage unit of
<P>
  any nonzero-sized sequences. This causes the storage association of the data objects in the equivalence-set and may cause storage
<P>
  association of other data objects.
<P>
</PRE>
2 If any data object in an equivalence-set has the SAVE attribute, all other objects in the equivalence-set have the SAVE attribute;
<P>
<PRE>
  this may be confirmed by explicit specification.
<P>
  8.10.1.3      Equivalence of default character objects
<P>
</PRE>
1 A default character data object shall not be equivalenced to an object that is not default character and not of a character sequence
<P>
<PRE>
  type. The lengths of equivalenced default character objects need not be the same.
<P>
</PRE>
2 An EQUIVALENCE statement specifies that the storage sequences of all the default character data objects specified in an equivalence-
<P>
<PRE>
  set are storage associated. All of the nonzero-sized sequences in the equivalence-set, if any, have the same first character storage unit,
<P>
  and all of the zero-sized sequences in the equivalence-set, if any, are storage associated with one another and with the first character
<P>
  storage unit of any nonzero-sized sequences. This causes the storage association of the data objects in the equivalence-set and may
<P>
  cause storage association of other data objects.
<P>
  124                                                                             ⃝
<P>
                                                                                  c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
         NOTE 8.49
<P>
         For example, using the declarations:
<P>
                 CHARACTER (LEN = 4) :: A, B
<P>
                 CHARACTER (LEN = 3) :: C (2)
<P>
                 EQUIVALENCE (A, C (1)), (B, C (2))
<P>
         the association of A, B, and C can be illustrated graphically as:
<P>
                   1        2       3       4         5         6        7
<P>
                 |---      --- A   ---     ---|
<P>
                                          |---      --- B      ---      ---|
<P>
                 |---      C(1)    ---|   |---      C(2)       ---|
<P>
  8.10.1.4      Array names and array element designators
<P>
</PRE>
1 For a nonzero-sized array, the use of the array name unqualified by a subscript list as an equivalence-object has the same effect as
<P>
<PRE>
  using an array element designator that identifies the first element of the array.
<P>
  8.10.1.5      Restrictions on EQUIVALENCE statements
<P>
</PRE>
1 An EQUIVALENCE statement shall not specify that the same storage unit is to occur more than once in a storage sequence.
<P>
2 An EQUIVALENCE statement shall not specify that consecutive storage units are to be nonconsecutive.
<P>
<PRE>
  8.10.2        COMMON statement
<P>
  8.10.2.1      General
<P>
</PRE>
1 The COMMON statement specifies blocks of physical storage, called common blocks, that can be accessed by any of the scoping
<P>
<PRE>
  units in a program. Thus, the COMMON statement provides a global data facility based on storage association (19.5.3).
<P>
</PRE>
2 A common block that does not have a name is called blank common.
<P>
<PRE>
  R873       common-stmt                         is   COMMON
<P>
                                                          [ / [ common-block-name ] / ] common-block-object-list
<P>
                                                          [ [ , ] / [ common-block-name ] /
<P>
                                                          common-block-object-list ] &#46;&#46;&#46;
<P>
  R874       common-block-object                 is   variable-name [ ( array-spec ) ]
<P>
  C8116      (R874) An array-spec in a common-block-object shall be an explicit-shape-spec-list.
<P>
  C8117      (R874) Only one appearance of a given variable-name is permitted in all common-block-object-lists within a scoping unit.
<P>
  C8118      (R874) A common-block-object shall not be a dummy argument, a function result, an allocatable variable, a derived-type
<P>
             object with an ultimate component that is allocatable, a procedure pointer, an automatic data object, a variable with the
<P>
             BIND attribute, an unlimited polymorphic pointer, or a coarray.
<P>
  C8119      (R874) If a common-block-object is of a derived type, the type shall have the BIND attribute or the SEQUENCE attribute
<P>
             and it shall have no default initialization.
<P>
  C8120      (R874) A variable-name shall not be a name made accessible by use association.
<P>
</PRE>
3 In each COMMON statement, the data objects whose names appear in a common block object list following a common block name
<P>
<PRE>
  are declared to be in that common block. If the first common block name is omitted, all data objects whose names appear in the
<P>
  first common block object list are specified to be in blank common. Alternatively, the appearance of two slashes with no common
<P>
  block name between them declares the data objects whose names appear in the common block object list that follows to be in blank
<P>
  common.
<P>
</PRE>
4 Any common block name or an omitted common block name for blank common may occur more than once in one or more COMMON
<P>
<PRE>
  statements in a scoping unit. The common block list following each successive appearance of the same common block name in a
<P>
  scoping unit is treated as a continuation of the list for that common block name. Similarly, each blank common block object list in
<P>
  a scoping unit is treated as a continuation of blank common.
<P>
</PRE>
5 The form variable-name (array-spec) specifies the DIMENSION attribute for that variable.
<P>
6 If derived-type objects of numeric sequence type or character sequence type (7.5.2.3) appear in common, it is as if the individual
<P>
<PRE>
  components were enumerated directly in the common list.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                          125
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  8.10.2.2      Common block storage sequence
<P>
</PRE>
1 For each common block in a scoping unit, a common block storage sequence is formed as follows:
<P>
<PRE>
           (1)    A storage sequence is formed consisting of the sequence of storage units in the storage sequences (19.5.3.2) of all data
<P>
                  objects in the common block object lists for the common block. The order of the storage sequences is the same as the
<P>
                  order of the appearance of the common block object lists in the scoping unit.
<P>
           (2)    The storage sequence formed in (1) is extended to include all storage units of any storage sequence associated with it
<P>
                  by equivalence association. The sequence shall be extended only by adding storage units beyond the last storage unit.
<P>
                  Data objects associated with an entity in a common block are considered to be in that common block.
<P>
</PRE>
2 Only COMMON statements and EQUIVALENCE statements appearing in the scoping unit contribute to common block storage
<P>
<PRE>
  sequences formed in that scoping unit.
<P>
  8.10.2.3      Size of a common block
<P>
</PRE>
1 The size of a common block is the size of its common block storage sequence, including any extensions of the sequence resulting from
<P>
<PRE>
  equivalence association.
<P>
  8.10.2.4      Common association
<P>
</PRE>
1 Within a program, the common block storage sequences of all nonzero-sized common blocks with the same name have the same first
<P>
<PRE>
  storage unit, and the common block storage sequences of all zero-sized common blocks with the same name are storage associated
<P>
  with one another. Within a program, the common block storage sequences of all nonzero-sized blank common blocks have the same
<P>
  first storage unit and the storage sequences of all zero-sized blank common blocks are associated with one another and with the first
<P>
  storage unit of any nonzero-sized blank common blocks. This results in the association of objects in different scoping units. Use or
<P>
  host association may cause these associated objects to be accessible in the same scoping unit.
<P>
</PRE>
2 A nonpointer object that is default integer, default real, double precision real, default complex, default logical, or of numeric sequence
<P>
<PRE>
  type shall be associated only with nonpointer objects of these types and kinds.
<P>
</PRE>
3 A nonpointer object that is default character or of character sequence type shall be associated only with nonpointer objects of these
<P>
<PRE>
  types and kinds.
<P>
</PRE>
4 A nonpointer object of a derived type that is not a numeric sequence or character sequence type shall be associated only with
<P>
<PRE>
  nonpointer objects of the same type.
<P>
</PRE>
5 A nonpointer object of intrinsic type but which is not default integer, default real, double precision real, default complex, default
<P>
<PRE>
  logical, or default character shall be associated only with nonpointer objects of the same type and type parameters.
<P>
</PRE>
6 A data pointer shall be storage associated only with data pointers of the same type and rank. Data pointers that are storage
<P>
<PRE>
  associated shall have deferred the same type parameters; corresponding nondeferred type parameters shall have the same value.
<P>
</PRE>
7 An object with the TARGET attribute shall be storage associated only with another object that has the TARGET attribute and the
<P>
<PRE>
  same type and type parameters.
<P>
         NOTE 8.50
<P>
         A common block is permitted to contain sequences of different storage units, provided each scoping unit that accesses the
<P>
         common block specifies an identical sequence of storage units for the common block. For example, this allows a single common
<P>
         block to contain both numeric and character storage units.
<P>
         Association in different scoping units between objects of default type, objects of double precision real type, and sequence
<P>
         structures is permitted according to the rules for equivalence objects (8.10.1).
<P>
  8.10.2.5      Differences between named common and blank common
<P>
</PRE>
1 A blank common block has the same properties as a named common block, except for the following.
<P>
<PRE>
       • Execution of a RETURN or END statement might cause data objects in a named common block to become undefined unless
<P>
          the common block has the SAVE attribute, but never causes nonpointer data objects in blank common to become undefined
<P>
          (19.6.6).
<P>
       • Named common blocks of the same name shall be of the same size in all scoping units of a program in which they appear, but
<P>
          blank common blocks may be of different sizes.
<P>
       • A data object in a named common block may be initially defined by means of a DATA statement or type declaration statement
<P>
          in a block data program unit (14.3), but objects in blank common shall not be initially defined.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>8.10.3</B> </TD><TD valign=bottom>
Restrictions on common and equivalence
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 An EQUIVALENCE statement shall not cause the storage sequences of two different common blocks to be associated.
<P>
<PRE>
  126                                                                            ⃝ c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 Equivalence association shall not cause a derived-type object with default initialization to be associated with an object in a common
<P>
<PRE>
  block.
<P>
</PRE>
3 Equivalence association shall not cause a common block storage sequence to be extended by adding storage units preceding the first
<P>
<PRE>
  storage unit of the first object specified in a COMMON statement for the common block.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                            127
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>128</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
9 Use of data objects
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>9.1</B> </TD><TD valign=bottom>
Designator
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>R901</B> </TD><TD valign=bottom>
designator                    is  object-name
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                         or  array-element
<P>
                                         or  array-section
<P>
                                         or  coindexed-named-object
<P>
                                         or  complex-part-designator
<P>
                                         or  structure-component
<P>
                                         or  substring
<P>
</PRE>
1 The appearance of a data object designator in a context that requires its value is termed a reference.
<P>
<PRE>
  9.2      Variable
<P>
  R902     variable                      is designator
<P>
                                         or function-reference
<P>
  C901     (R902) designator shall not be a constant or a subobject of a constant.
<P>
  C902     (R902) function-reference shall have a data pointer result.
<P>
</PRE>
1 A variable is either the data object denoted by designator or the target of the pointer resulting from the evaluation
<P>
<PRE>
  of function-reference; this pointer shall be associated.
<P>
</PRE>
2 A reference is permitted only if the variable is defined. A reference to a data pointer is permitted only if the
<P>
<PRE>
  pointer is associated with a target object that is defined. A variable becomes defined with a value when events
<P>
  described in 19.6.5 occur.
<P>
  R903     variable-name                 is  name
<P>
  C903     (R903) variable-name shall be the name of a variable.
<P>
  R904     logical-variable              is  variable
<P>
  C904     (R904) logical-variable shall be of type logical.
<P>
  R905     char-variable                 is  variable
<P>
  C905     (R905) char-variable shall be of type character.
<P>
  R906     default-char-variable         is  variable
<P>
  C906     (R906) default-char-variable shall be default character.
<P>
  R907     int-variable                  is  variable
<P>
  C907     (R907) int-variable shall be of type integer.
<P>
       NOTE 9.1
<P>
       For example, given the declarations:
<P>
                 CHARACTER (10) A, B (10)
<P>
                 TYPE (PERSON) P                ! See NOTE 7.15
<P>
       then A, B, B (1), B (1:5), P % AGE, and A (1:1) are all variables.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           129
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  9.3      Constants
<P>
</PRE>
1 A constant (6.2.3) is a literal constant or a named constant. A literal constant is a scalar denoted by a syntactic
<P>
<PRE>
  form, which indicates its type, type parameters, and value. A named constant is a constant that has a name; the
<P>
  name has the PARAMETER attribute (8.5.13, 8.6.11). A reference to a constant is always permitted; redefinition
<P>
  of a constant is never permitted.
<P>
  9.4      Scalars
<P>
  9.4.1     Substrings
<P>
</PRE>
1 A substring is a contiguous portion of a character string (7.4.4).
<P>
<PRE>
  R908     substring                     is   parent-string ( substring-range )
<P>
  R909     parent-string                 is   scalar-variable-name
<P>
                                         or   array-element
<P>
                                         or   coindexed-named-object
<P>
                                         or   scalar-structure-component
<P>
                                         or   scalar-constant
<P>
  R910     substring-range               is   [ scalar-int-expr ] : [ scalar-int-expr ]
<P>
  C908     (R909) parent-string shall be of type character.
<P>
</PRE>
2 The value of the first scalar-int-expr in substring-range is the starting point of the substring and the value of
<P>
<PRE>
  the second one is the ending point of the substring. The length of a substring is the number of characters in the
<P>
  substring and is MAX (l − f + 1, 0), where f and l are the starting and ending points, respectively.
<P>
</PRE>
3 Let the characters in the parent string be numbered 1, 2, 3, &#46;&#46;&#46;, n, where n is the length of the parent string.
<P>
<PRE>
  Then the characters in the substring are those from the parent string from the starting point and proceeding in
<P>
  sequence up to and including the ending point. If the starting point is greater than the ending point, the substring
<P>
  has length zero; otherwise, both the starting point and the ending point shall be within the range 1, 2, &#46;&#46;&#46;, n. If
<P>
  the starting point is not specified, the default value is 1. If the ending point is not specified, the default value is
<P>
  n.
<P>
       NOTE 9.2
<P>
       Examples of character substrings are:
<P>
              B(1)(1:5)                 array element as parent string
<P>
              P%NAME(1:1)               structure component as parent string
<P>
              ID(4:9)                   scalar variable name as parent string
<P>
              ’0123456789’(N:N)         character constant as parent string
<P>
  9.4.2     Structure components
<P>
</PRE>
1 A structure component is part of an object of derived type; it may be referenced by an object designator. A
<P>
<PRE>
  structure component may be a scalar or an array.
<P>
  R911     data-ref                      is   part-ref [ % part-ref ] &#46;&#46;&#46;
<P>
  R912     part-ref                      is   part-name [ ( section-subscript-list ) ] [ image-selector ]
<P>
  C909     (R911) Each part-name except the rightmost shall be of derived type.
<P>
  C910     (R911) Each part-name except the leftmost shall be the name of a component of the declared type of the
<P>
           preceding part-name.
<P>
  130                                                                   ⃝
<P>
                                                                        c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  C911      (R911) If the rightmost part-name is of abstract type, data-ref shall be polymorphic.
<P>
  C912      (R911) The leftmost part-name shall be the name of a data object.
<P>
  C913      (R912) If a section-subscript-list appears, the number of section-subscripts shall equal the rank of part-
<P>
            name.
<P>
  C914      (R912) If image-selector appears, the number of cosubscripts shall be equal to the corank of part-name.
<P>
  C915      A data-ref shall not be of type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BIND-
<P>
            ING (18.2), or of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV (16.10.2), if one
<P>
            of its part-ref s has an image-selector.
<P>
  C916      (R912) If image-selector appears and part-name is an array, section-subscript-list shall appear.
<P>
  C917      (R911) Except as an actual argument to an intrinsic inquiry function or as the designator in a type
<P>
            parameter inquiry, a data-ref shall not be a coindexed object that has a polymorphic allocatable potential
<P>
            subobject component.
<P>
  C918      Except as an actual argument to an intrinsic inquiry function or as the designator in a type parameter
<P>
            inquiry, if the rightmost part-ref is polymorphic, no other part-ref shall be coindexed.
<P>
</PRE>
2 The rank of a part-ref of the form part-name is the rank of part-name. The rank of a part-ref that has a section
<P>
<PRE>
  subscript list is the number of subscript triplets and vector subscripts in the list.
<P>
  C919      (R911) There shall not be more than one part-ref with nonzero rank. A part-name to the right of a
<P>
            part-ref with nonzero rank shall not have the ALLOCATABLE or POINTER attribute.
<P>
</PRE>
3 The rank of a data-ref is the rank of the part-ref with nonzero rank, if any; otherwise, the rank is zero. The base
<P>
<PRE>
  object of a data-ref is the data object whose name is the leftmost part name.
<P>
</PRE>
4 The type and type parameters, if any, of a data-ref are those of the rightmost part name.
</TD></TR>
<TR><TD colspan=2>
5 A data-ref with more than one part-ref is a subobject of its base object if none of the part-names, except for
</TD></TR>
<TR><TD colspan=2>
<PRE>
  possibly the rightmost, is a pointer. If the rightmost part-name is the only pointer, then the data-ref is a subobject
<P>
  of its base object in contexts that pertain to its pointer association status but not in any other contexts.
<P>
        NOTE 9.3
<P>
        If X is an object of derived type with a pointer component P, then the pointer X%P is a subobject of X
<P>
        when considered as a pointer – that is in contexts where it is not dereferenced.
<P>
        However the target of X%P is not a subobject of X. Thus, in contexts where X%P is dereferenced to refer
<P>
        to the target, it is not a subobject of X.
<P>
  R913      structure-component            is  data-ref
<P>
  C920      (R913) There shall be more than one part-ref and the rightmost part-ref shall not have a section-subscript-
<P>
            list.
<P>
</PRE>
6 A structure component shall be neither referenced nor defined before the declaration of the base object. A
</TD></TR>
<TR><TD colspan=2>
<PRE>
  structure component is a pointer only if the rightmost part name has the POINTER attribute.
<P>
        NOTE 9.4
<P>
        Examples of structure components are:
<P>
                  SCALAR_PARENT%SCALAR_FIELD              scalar component of scalar parent
<P>
                  ARRAY_PARENT(J)%SCALAR_FIELD            component of array element parent
<P>
                  ARRAY_PARENT(1:N)%SCALAR_FIELD          component of array section parent
<P>
        For a more elaborate example see C.4.1.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            131
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 9.5
<P>
       The syntax rules are structured such that a data-ref that ends in a component name without a following
<P>
       subscript list is a structure component, even when other component names in the data-ref are followed by
<P>
       a subscript list. A data-ref that ends in a component name with a following subscript list is either an array
<P>
       element or an array section. A data-ref of nonzero rank that ends with a substring-range is an array section.
<P>
       A data-ref of zero rank that ends with a substring-range is a substring.
<P>
  9.4.3     Coindexed named objects
<P>
</PRE>
1 A coindexed-named-object is a named scalar coarray variable followed by an image selector.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R914     coindexed-named-object        is   data-ref
<P>
  C921     (R914) The data-ref shall contain exactly one part-ref . The part-ref shall contain an image-selector.
<P>
           The part-name shall be the name of a scalar coarray.
<P>
  9.4.4     Complex parts
<P>
  R915     complex-part-designator       is designator % RE
<P>
                                         or designator % IM
<P>
  C922     (R915) The designator shall be of complex type.
<P>
</PRE>
1 If complex-part-designator is designator%RE it designates the real part of designator. If it is designator%IM
</TD></TR>
<TR><TD colspan=2>
<PRE>
  it designates the imaginary part of designator. The type of a complex-part-designator is real, and its kind and
<P>
  shape are those of the designator, which can be an array or scalar.
<P>
       NOTE 9.6
<P>
       The following are examples of complex part designators:
<P>
           impedance%re           !-- Same value as REAL(impedance)
<P>
           fft%im                 !-- Same value as AIMAG(fft)
<P>
           x%im = 0.0             !-- Sets the imaginary part of X to zero
<P>
  9.4.5     Type parameter inquiry
<P>
</PRE>
1 A type parameter inquiry is used to inquire about a type parameter of a data object. It applies to both intrinsic
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and derived types.
<P>
  R916     type-param-inquiry            is   designator % type-param-name
<P>
  C923     (R916) The type-param-name shall be the name of a type parameter of the declared type of the object
<P>
           designated by the designator.
<P>
</PRE>
2 A deferred type parameter of a pointer that is not associated or of an unallocated allocatable variable shall not
</TD></TR>
<TR><TD colspan=2>
<PRE>
  be inquired about.
<P>
       NOTE 9.7
<P>
       A type-param-inquiry has a syntax like that of a structure component reference, but it does not have the
<P>
       same semantics. It is not a variable and thus can never be assigned to. It can be used only as a primary in
<P>
       an expression. It is scalar even if designator is an array.
<P>
       The intrinsic type parameters can also be inquired about by using the intrinsic functions KIND and LEN.
<P>
  132                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 9.8
<P>
       The following are examples of type parameter inquiries:
<P>
              a%kind          !--  A is real. Same value as KIND(a).
<P>
              s%len           !--  S is character. Same value as LEN(s).
<P>
              b(10)%kind      !--  Inquiry about an array element.
<P>
              p%dim           !--  P is of the derived type general_point.
<P>
       See NOTE 7.22 for the definition of the general_point type used in the last example above.
<P>
  9.5     Arrays
<P>
  9.5.1     Order of reference
<P>
</PRE>
1 No order of reference to the elements of an array is indicated by the appearance of the array designator, except
</TD></TR>
<TR><TD colspan=2>
<PRE>
  where array element ordering (9.5.3.2) is specified.
<P>
  9.5.2     Whole arrays
<P>
</PRE>
1 A whole array is a named array or a structure component whose final part-ref is an array component name; no
</TD></TR>
<TR><TD colspan=2>
<PRE>
  subscript list is appended.
<P>
</PRE>
2 The appearance of a whole array variable in an executable construct specifies all the elements of the array (5.4.6).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  The appearance of a whole array designator in a nonexecutable statement specifies the entire array except for the
<P>
  appearance of a whole array designator in an equivalence set (8.10.1.4). An assumed-size array (8.5.8.5) is permitted to
<P>
  appear as a whole array in an executable construct or specification expression only as an actual argument in a
<P>
  procedure reference that does not require the shape.
<P>
  9.5.3     Array elements and array sections
<P>
  9.5.3.1    Syntax
<P>
  R917     array-element                    is  data-ref
<P>
  C924     (R917) Every part-ref shall have rank zero and the last part-ref shall contain a subscript-list.
<P>
  R918     array-section                    is data-ref [ ( substring-range ) ]
<P>
                                            or complex-part-designator
<P>
  C925     (R918) Exactly one part-ref shall have nonzero rank, and either the final part-ref shall have a section-
<P>
           subscript-list with nonzero rank, another part-ref shall have nonzero rank, or the complex-part-designator
<P>
           shall be an array.
<P>
  C926     (R918) If a substring-range appears, the rightmost part-name shall be of type character.
<P>
  R919     subscript                        is  scalar-int-expr
<P>
  R920     section-subscript                is subscript
<P>
                                            or subscript-triplet
<P>
                                            or vector-subscript
<P>
  R921     subscript-triplet                is  [ subscript ] : [ subscript ] [ : stride ]
<P>
  R922     stride                           is  scalar-int-expr
<P>
  R923     vector-subscript                 is  int-expr
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               133
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C927     (R923) A vector-subscript shall be an integer array expression of rank one.
<P>
  C928     (R921) The second subscript shall not be omitted from a subscript-triplet in the last dimension of an
<P>
           assumed-size array.
<P>
</PRE>
1 An array element is a scalar. An array section is an array. If a substring-range appears in an array-section, each
</TD></TR>
<TR><TD colspan=2>
<PRE>
  element is the designated substring of the corresponding element of the array section.
<P>
</PRE>
2 The value of a subscript in an array element shall be within the bounds for its dimension.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 9.9
<P>
       For example, with the declarations:
<P>
       REAL A (10, 10)
<P>
       CHARACTER (LEN = 10) B (5, 5, 5)
<P>
       A (1, 2) is an array element, A (1:N:2, M) is a rank-one array section, and B (:, :, :) (2:3) is an array of
<P>
       shape (5, 5, 5) whose elements are substrings of length 2 of the corresponding elements of B.
<P>
       NOTE 9.10
<P>
       Unless otherwise specified, an array element or array section does not have an attribute of the whole array.
<P>
       In particular, an array element or an array section does not have the POINTER or ALLOCATABLE
<P>
       attribute.
<P>
       NOTE 9.11
<P>
       Examples of array elements and array sections are:
<P>
              ARRAY_A(1:N:2)%ARRAY_B(I, J)%STRING(K)(:)                        array  section
<P>
              SCALAR_PARENT%ARRAY_FIELD(J)                                     array  element
<P>
              SCALAR_PARENT%ARRAY_FIELD(1:N)                                   array  section
<P>
              SCALAR_PARENT%ARRAY_FIELD(1:N)%SCALAR_FIELD                      array  section
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>9.5.3.2</B> </TD><TD valign=bottom>
Array element order
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The elements of an array form a sequence known as the array element order. The position of an array element
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in this sequence is determined by the subscript order value of the subscript list designating the element. The
<P>
  subscript order value is computed from the formulas in Table 9.1.
<P>
                                                Table 9.1: Subscript order value
<P>
                      Rank     Subscript bounds              Subscript list        Subscript order value
<P>
                      1        j1 :k1                        s1                    1 + (s1 − j1 )
<P>
                                                                                   1 + (s1 − j1 )
<P>
                      2        j1 :k1 ,j2 :k2                s1 , s2
<P>
                                                                                   +(s2 − j2 ) × d1
<P>
                                                                                   1 + (s1 − j1 )
<P>
                      3        j1 :k1 , j2 :k2 , j3 :k3      s1 , s2 , s3          +(s2 − j2 ) × d1
<P>
                                                                                   +(s3 − j3 ) × d2 × d1
<P>
                      ·          ·                            ·                       ·
<P>
                      ·          ·                            ·                       ·
<P>
                      ·          ·                            ·                       ·
<P>
                                                                                   1 + (s1 − j1 )
<P>
                                                                                   +(s2 − j2 ) × d1
<P>
                                                                                   +(s3 − j3 ) × d2 × d1
<P>
                      15       j1 :k1 , . . . , j15 :k15     s1 , . . . , s15
<P>
                                                                                   +&#46;&#46;&#46;
<P>
                                                                                   +(s15 − j15 ) × d14
<P>
                                                                                   ×d13 × . . . × d1
<P>
  134                                                                         ⃝
<P>
                                                                              c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
                                              Subscript order value                            (cont.)
<P>
                       Rank     Subscript bounds         Subscript list        Subscript order value
<P>
                       Notes for Table 9.1:
<P>
                               1) di = max (ki − ji + 1, 0) is the size of the ith dimension.
<P>
                               2) If the size of the array is nonzero, ji ≤ si ≤ ki for all
<P>
                               i = 1, 2, &#46;&#46;&#46;, 15.
<P>
  9.5.3.3    Array sections
<P>
</PRE>
1 In an array-section having a section-subscript-list, each subscript-triplet and vector-subscript in the section sub-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  script list indicates a sequence of subscripts, which may be empty. Each subscript in such a sequence shall be
<P>
  within the bounds for its dimension unless the sequence is empty. The array section is the set of elements from
<P>
  the array determined by all possible subscript lists obtainable from the single subscripts or sequences of subscripts
<P>
  specified by each section subscript.
<P>
</PRE>
2 In an array-section with no section-subscript-list, the rank and shape of the array is the rank and shape of the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  part-ref with nonzero rank; otherwise, the rank of the array section is the number of subscript triplets and vector
<P>
  subscripts in the section subscript list. The shape is the rank-one array whose ith element is the number of
<P>
  integer values in the sequence indicated by the ith subscript triplet or vector subscript. If any of these sequences
<P>
  is empty, the array section has size zero. The subscript order of the elements of an array section is that of the
<P>
  array data object that the array section represents.
<P>
  9.5.3.3.1    Subscript triplet
<P>
</PRE>
1 A subscript triplet designates a regular sequence of subscripts consisting of zero or more subscript values. The
</TD></TR>
<TR><TD colspan=2>
<PRE>
  stride in the subscript triplet specifies the increment between the subscript values. The subscripts and stride of a
<P>
  subscript triplet are optional. An omitted first subscript in a subscript triplet is equivalent to a subscript whose
<P>
  value is the lower bound for the array and an omitted second subscript is equivalent to the upper bound. An
<P>
  omitted stride is equivalent to a stride of 1.
<P>
</PRE>
2 The stride shall not be zero.
</TD></TR>
<TR><TD colspan=2>
3 When the stride is positive, the subscripts specified by a triplet form a regularly spaced sequence of integers
</TD></TR>
<TR><TD colspan=2>
<PRE>
  beginning with the first subscript and proceeding in increments of the stride to the largest such integer not
<P>
  greater than the second subscript; the sequence is empty if the first subscript is greater than the second.
<P>
       NOTE 9.12
<P>
       For example, suppose an array is declared as A (5, 4, 3). The section A (3 : 5, 2, 1 : 2) is the array of shape
<P>
       (3, 2):
<P>
       A (3, 2, 1)          A (3, 2, 2)
<P>
       A (4, 2, 1)          A (4, 2, 2)
<P>
       A (5, 2, 1)          A (5, 2, 2)
<P>
</PRE>
4 When the stride is negative, the sequence begins with the first subscript and proceeds in increments of the stride
</TD></TR>
<TR><TD colspan=2>
<PRE>
  down to the smallest such integer equal to or greater than the second subscript; the sequence is empty if the
<P>
  second subscript is greater than the first.
<P>
       NOTE 9.13
<P>
       For example, if an array is declared B (10), the section B (9 : 1 : −2) is the array of shape (5) whose
<P>
       elements are B (9), B (7), B (5), B (3), and B (1), in that order.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            135
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 9.14
<P>
        A subscript in a subscript triplet need not be within the declared bounds for that dimension if all values
<P>
        used in selecting the array elements are within the declared bounds.
<P>
        For example, if an array is declared as B (10), the array section B (3 : 11 : 7) is the array of shape (2)
<P>
        consisting of the elements B (3) and B (10), in that order.
<P>
  9.5.3.3.2     Vector subscript
<P>
</PRE>
1 A vector subscript designates a sequence of subscripts corresponding to the values of the elements of the expression.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Each element of the expression shall be defined.
<P>
</PRE>
2 An array section with a vector subscript shall not be finalized by a nonelemental final subroutine.
</TD></TR>
<TR><TD colspan=2>
3 If a vector subscript has two or more elements with the same value, an array section with that vector subscript
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is not definable and shall not be defined or become undefined.
<P>
        NOTE 9.15
<P>
        For example, suppose Z is a two-dimensional array of shape [5, 7] and U and V are one-dimensional arrays
<P>
        of shape (3) and (4), respectively. Assume the values of U and V are:
<P>
        U = [ 1, 3, 2 ]
<P>
        V = [ 2, 1, 1, 3 ]
<P>
        Then Z (3, V) consists of elements from the third row of Z in the order:
<P>
        Z (3, 2)      Z (3, 1)      Z (3, 1)      Z (3, 3)
<P>
        and Z (U, 2) consists of the column elements:
<P>
        Z (1, 2)      Z (3, 2)      Z (2, 2)
<P>
        and Z (U, V) consists of the elements:
<P>
        Z (1, 2)      Z (1, 1)      Z (1, 1)      Z (1, 3)
<P>
        Z (3, 2)      Z (3, 1)      Z (3, 1)      Z (3, 3)
<P>
        Z (2, 2)      Z (2, 1)      Z (2, 1)      Z (2, 3)
<P>
        Because Z (3, V) and Z (U, V) contain duplicate elements from Z, the sections Z (3, V) and Z (U, V) shall
<P>
        not be redefined as sections.
<P>
  9.5.4      Simply contiguous array designators
<P>
</PRE>
1 A section-subscript-list specifies a simply contiguous section if and only if it does not have a vector subscript and
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • all but the last subscript-triplet is a colon,
<P>
      • the last subscript-triplet does not have a stride, and
<P>
      • no subscript-triplet is preceded by a section-subscript that is a subscript.
<P>
</PRE>
2 An array designator is simply contiguous if and only if it is
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • an object-name that has the CONTIGUOUS attribute,
<P>
      • an object-name that is not a pointer, not assumed-shape, and not assumed-rank,
<P>
      • a structure-component whose final part-name is an array and that either has the CONTIGUOUS attribute
<P>
         or is not a pointer, or
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>136</B> <!-- .PP -->
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
• an array section
<P>
<PRE>
           –  that is not a complex-part-designator,
<P>
           –  that does not have a substring-range,
<P>
           –  whose final part-ref has nonzero rank,
<P>
           –  whose rightmost part-name has the CONTIGUOUS attribute or is neither assumed-shape nor a pointer,
<P>
              and
<P>
           – which either does not have a section-subscript-list, or has a section-subscript-list which specifies a
<P>
              simply contiguous section.
<P>
</PRE>
3 An array variable is simply contiguous if and only if it is a simply contiguous array designator or a reference to
<P>
<PRE>
  a function that returns a pointer with the CONTIGUOUS attribute.
<P>
       NOTE 9.16
<P>
       Array sections that are simply contiguous include column, plane, cube, and hypercube subobjects of a
<P>
       simply contiguous base object, for example:
<P>
           ARRAY1 (10:20, 3)        !  passes part of the third column of ARRAY1.
<P>
           X3D (:, i:j, 2)          !  passes part of the second plane of X3D (or the whole
<P>
                                    !  plane if i==LBOUND(X3D,2) and j==UBOUND(X3D,2).
<P>
           Y5D (:, :, :, :, 7) !       passes the seventh hypercube of Y5D.
<P>
       All simply contiguous designators designate contiguous objects.
<P>
  9.6      Image selectors
<P>
</PRE>
1 An image selector determines the image index for a coindexed object.
<P>
<PRE>
  R924     image-selector                is  lbracket cosubscript-list [ , image-selector-spec-list ] rbracket
<P>
  R925     cosubscript                   is  scalar-int-expr
<P>
  R926     image-selector-spec           is STAT = stat-variable
<P>
                                         or TEAM = team-value
<P>
                                         or TEAM_NUMBER = scalar-int-expr
<P>
  C929     No specifier shall appear more than once in a given image-selector-spec-list.
<P>
  C930     TEAM and TEAM_NUMBER shall not both appear in the same image-selector-spec-list.
<P>
  C931     A stat-variable in an image-selector shall not be a coindexed object.
<P>
</PRE>
2 The number of cosubscripts shall be equal to the corank of the object. The value of a cosubscript in an image
<P>
<PRE>
  selector shall be within the cobounds for its codimension. Taking account of the cobounds, the cosubscript list in
<P>
  an image selector determines the image index in the same way that a subscript list in an array element determines
<P>
  the subscript order value (9.5.3.2), taking account of the bounds.
<P>
</PRE>
3 If a TEAM= specifier appears in an image-selector, the team of the image selector is specified by team-value,
<P>
<PRE>
  which shall identify the current or an ancestor team; the object shall be an established coarray in that team
<P>
  or an ancestor thereof. If a TEAM_NUMBER= specifier appears in an image-selector and the current team
<P>
  is not the initial team, the value of the scalar-int-expr shall be equal to the value of a team number for one of
<P>
  the teams that were formed by execution of the FORM TEAM statement for the current team and the team of
<P>
  the image selector is that team; the object shall be an established coarray in an ancestor of the current team,
<P>
  or an associating entity of the CHANGE TEAM construct. If a TEAM_NUMBER= specifier appears in an
<P>
  image-selector and the current team is the initial team, the value of scalar-int-expr shall be the team number for
<P>
  the initial team; the object shall be an established coarray in the initial team. Otherwise, the team of the image
<P>
  selector is the current team.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         137
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 An image selector shall specify an image index value that is not greater than the number of images in the team
<P>
<PRE>
  of the image selector, and identifies the image with that index in that team.
<P>
</PRE>
5 Execution of a statement containing an image-selector with a STAT= specifier causes the stat-variable to become
<P>
<PRE>
  defined. If the designator is part of an operand that is evaluated or is a variable that is being defined or partly
<P>
  defined, and the object designated is on a failed image, the stat-variable is defined with the value STAT_-
<P>
  FAILED_IMAGE (16.10.2.26) in the intrinsic module ISO_FORTRAN_ENV; otherwise, it is defined with the
<P>
  value zero.
<P>
</PRE>
6 The denotation of a stat-variable in an image-selector shall not depend on the evaluation of any entity in the
<P>
<PRE>
  same statement. The value of an expression shall not depend on the value of any stat-variable that appears in
<P>
  the same statement. The value of a stat-variable in an image-selector shall not be affected by the execution of
<P>
  any part of the statement, other than by whether the image specified by the image-selector has failed.
<P>
       NOTE 9.17
<P>
       For example, if there are 16 images and the coarray A is declared
<P>
                 REAL :: A(10)[5,*]
<P>
       A(:)[1,4] is valid because it specifies image 16, but A(:)[2,4] is invalid because it specifies image 17.
<P>
  9.7      Dynamic association
<P>
  9.7.1     ALLOCATE statement
<P>
  9.7.1.1    Form of the ALLOCATE statement
<P>
</PRE>
1 The ALLOCATE statement dynamically creates pointer targets and allocatable variables.
<P>
<PRE>
  R927     allocate-stmt                  is   ALLOCATE ( [ type-spec :: ] allocation-list
<P>
                                                   [ , alloc-opt-list ] )
<P>
  R928     alloc-opt                      is   ERRMSG = errmsg-variable
<P>
                                          or   MOLD = source-expr
<P>
                                          or   SOURCE = source-expr
<P>
                                          or   STAT = stat-variable
<P>
  R929     errmsg-variable                is   scalar-default-char-variable
<P>
  R930     source-expr                    is   expr
<P>
  R931     allocation                     is   allocate-object [ ( allocate-shape-spec-list ) ]
<P>
                                                   [ lbracket allocate-coarray-spec rbracket ]
<P>
  R932     allocate-object                is variable-name
<P>
                                          or structure-component
<P>
  R933     allocate-shape-spec            is   [ lower-bound-expr : ] upper-bound-expr
<P>
  R934     lower-bound-expr               is   scalar-int-expr
<P>
  R935     upper-bound-expr               is   scalar-int-expr
<P>
  R936     allocate-coarray-spec          is   [ allocate-coshape-spec-list , ] [ lower-bound-expr : ] *
<P>
  R937     allocate-coshape-spec          is   [ lower-bound-expr : ] upper-bound-expr
<P>
  C932     (R932) Each allocate-object shall be a data pointer or an allocatable variable.
<P>
  138                                                                     ⃝
<P>
                                                                          c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C933</B> </TD><TD valign=bottom>
(R927) If any allocate-object has a deferred type parameter, is unlimited polymorphic, or is of abstract
</TD></TR>
<TR><TD colspan=2>
<PRE>
        type, either type-spec or source-expr shall appear.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C934</B> </TD><TD valign=bottom>
(R927) If type-spec appears, it shall specify a type with which each allocate-object is type compatible.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C935</B> </TD><TD valign=bottom>
(R927) A type-param-value in a type-spec shall be an asterisk if and only if each allocate-object is a dummy
</TD></TR>
<TR><TD colspan=2>
<PRE>
        argument for which the corresponding type parameter is assumed.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C936</B> </TD><TD valign=bottom>
(R927) If type-spec appears, the kind type parameter values of each allocate-object shall be the same as
</TD></TR>
<TR><TD colspan=2>
<PRE>
        the corresponding type parameter values of the type-spec.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C937</B> </TD><TD valign=bottom>
(R927) type-spec shall not specify a type that has a coarray ultimate component.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C938</B> </TD><TD valign=bottom>
(R927) If an allocate-object is a coarray, type-spec shall not specify type C_PTR or C_FUNPTR from
</TD></TR>
<TR><TD colspan=2>
<PRE>
        the intrinsic module ISO_C_BINDING, or type TEAM_TYPE from the intrinsic module ISO_FOR-
<P>
        TRAN_ENV.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C939</B> </TD><TD valign=bottom>
(R927) If an allocate-object is an array, either allocate-shape-spec-list shall appear in its allocation, or
</TD></TR>
<TR><TD colspan=2>
<PRE>
        source-expr shall appear in the ALLOCATE statement and have the same rank as the allocate-object.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C940</B> </TD><TD valign=bottom>
(R931) If allocate-object is scalar, allocate-shape-spec-list shall not appear.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C941</B> </TD><TD valign=bottom>
(R931) An allocate-coarray-spec shall appear if and only if the allocate-object is a coarray.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C942</B> </TD><TD valign=bottom>
(R931) The number of allocate-shape-specs in an allocate-shape-spec-list shall be the same as the rank
</TD></TR>
<TR><TD colspan=2>
<PRE>
        of the allocate-object. The number of allocate-coshape-specs in an allocate-coarray-spec shall be one less
<P>
        than the corank of the allocate-object.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C943</B> </TD><TD valign=bottom>
(R928) No alloc-opt shall appear more than once in a given alloc-opt-list.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C944</B> </TD><TD valign=bottom>
(R927) At most one of source-expr and type-spec shall appear.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C945</B> </TD><TD valign=bottom>
(R927) Each allocate-object shall be type compatible (7.3.2.3) with source-expr. If SOURCE= appears,
</TD></TR>
<TR><TD colspan=2>
<PRE>
        source-expr shall be a scalar or have the same rank as each allocate-object.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C946</B> </TD><TD valign=bottom>
(R927) If source-expr appears, the kind type parameters of each allocate-object shall have the same values
</TD></TR>
<TR><TD colspan=2>
<PRE>
        as the corresponding type parameters of source-expr.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C947</B> </TD><TD valign=bottom>
(R927) The declared type of source-expr shall not be C_PTR or C_FUNPTR from the intrinsic module
</TD></TR>
<TR><TD colspan=2>
<PRE>
        ISO_C_BINDING, or TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, if an allocate-
<P>
        object is a coarray.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C948</B> </TD><TD valign=bottom>
(R927) If SOURCE= appears, the declared type of source-expr shall not be EVENT_TYPE or LOCK_-
</TD></TR>
<TR><TD colspan=2>
<PRE>
        TYPE from the intrinsic module ISO_FORTRAN_ENV, or have a potential subobject component of
<P>
        type EVENT_TYPE or LOCK_TYPE.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C949</B> </TD><TD valign=bottom>
(R930) The declared type of source-expr shall not have a coarray ultimate component.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C950</B> </TD><TD valign=bottom>
(R932) An allocate-object shall not be a coindexed object.
</TD></TR>
<TR><TD colspan=2>
<PRE>
    NOTE 9.18
<P>
    If a coarray is of a derived type that has an allocatable component, the component can only be allocated
<P>
    by its own image:
<P>
             TYPE(SOMETHING), ALLOCATABLE :: T[:]
<P>
             &#46;&#46;&#46;
<P>
             ALLOCATE(T[*])                 ! Allowed - implies synchronization
<P>
             ALLOCATE(T%AAC(N))             ! Allowed - allocated by its own image
<P>
             ALLOCATE(T[Q]%AAC(N))          ! Not allowed, because it is not
<P>
                                            ! necessarily executed on image Q.
<P>
</PRE>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
139
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 An allocate-object or a bound or type parameter of an allocate-object shall not depend on the value of stat-variable,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value of errmsg-variable, or on the value, bounds, length type parameters, allocation status, or association
<P>
  status of any allocate-object in the same ALLOCATE statement.
<P>
</PRE>
3 source-expr shall not be allocated within the ALLOCATE statement in which it appears; nor shall it depend on
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value, bounds, deferred type parameters, allocation status, or association status of any allocate-object in that
<P>
  statement.
<P>
</PRE>
4 If an ALLOCATE statement has a SOURCE= specifier and an allocate-object that is a coarray, source-expr
</TD></TR>
<TR><TD colspan=2>
<PRE>
  shall not have a dynamic type of C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING, or
<P>
  EVENT_TYPE, LOCK_TYPE, or TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, or have
<P>
  a subcomponent whose dynamic type is EVENT_TYPE, LOCK_TYPE, or TEAM_TYPE.
<P>
</PRE>
5 If type-spec is specified, each allocate-object is allocated with the specified dynamic type and type parameter
</TD></TR>
<TR><TD colspan=2>
<PRE>
  values; if source-expr is specified, each allocate-object is allocated with the dynamic type and type parameter
<P>
  values of source-expr; otherwise, each allocate-object is allocated with its dynamic type the same as its declared
<P>
  type.
<P>
</PRE>
6 If a type-param-value in a type-spec in an ALLOCATE statement is an asterisk, it denotes the current value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that assumed type parameter. If it is an expression, subsequent redefinition or undefinition of any entity in the
<P>
  expression does not affect the type parameter value.
<P>
        NOTE 9.19
<P>
        An example of an ALLOCATE statement is:
<P>
        ALLOCATE (X (N), B (-3 : M, 0:9), STAT = IERR_ALLOC)
<P>
  9.7.1.2    Execution of an ALLOCATE statement
<P>
</PRE>
1 When an ALLOCATE statement is executed for an array for which allocate-shape-spec-list is specified, the values
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of the lower bound and upper bound expressions determine the bounds of the array. Subsequent redefinition
<P>
  or undefinition of any entities in the bound expressions do not affect the array bounds. If the lower bound is
<P>
  omitted, the default value is 1. If the upper bound is less than the lower bound, the extent in that dimension is
<P>
  zero and the array has zero size.
<P>
</PRE>
2 When an ALLOCATE statement is executed for a coarray, the values of the lower cobound and upper cobound
</TD></TR>
<TR><TD colspan=2>
<PRE>
  expressions determine the cobounds of the coarray. Subsequent redefinition or undefinition of any entities in the
<P>
  cobound expressions do not affect the cobounds. If the lower cobound is omitted, the default value is 1. The
<P>
  upper cobound shall not be less than the lower cobound.
<P>
</PRE>
3 If an allocation specifies a coarray, its dynamic type and the values of corresponding type parameters shall be the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  same on every active image in the current team. The values of corresponding bounds and corresponding cobounds
<P>
  shall be the same on those images. If the coarray is a dummy argument, its ultimate argument (15.5.2.3) shall
<P>
  be the same coarray on those images.
<P>
</PRE>
4 When an ALLOCATE statement is executed for which an allocate-object is a coarray, there is an implicit syn-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  chronization of all active images in the current team. If the current team contains a stopped or failed image,
<P>
  an error condition occurs. If no other error condition occurs, execution on the active images of the segment
<P>
  (11.6.2) following the statement is delayed until all other active images in the current team have executed the
<P>
  same statement the same number of times in this team. The segments that executed before the ALLOCATE
<P>
  statement on an active image of this team precede the segments that execute after the ALLOCATE statement on
<P>
  another active image of this team. The coarray shall not become allocated on an image unless it is successfully
<P>
  allocated on all active images in this team.
<P>
        NOTE 9.20
<P>
        When an image executes an ALLOCATE statement, communication is not necessarily involved apart from
<P>
        any required for synchronization. The image allocates its coarray and records how the corresponding
<P>
  140                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
         NOTE 9.20 (cont.)
<P>
         coarrays on other images are to be addressed. The processor is not required to detect violations of the
<P>
         rule that the bounds are the same on all images of the current team, nor is it responsible for detecting or
<P>
         resolving deadlock problems (such as two images waiting on different ALLOCATE statements.).
<P>
</PRE>
5 If source-expr is a pointer, it shall be associated with a target. If source-expr is allocatable, it shall be allocated.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
6 When an ALLOCATE statement is executed for an array with no allocate-shape-spec-list, the bounds of source-
<P>
<PRE>
   expr determine the bounds of the array. Subsequent changes to the bounds of source-expr do not affect the array
<P>
   bounds.
<P>
</PRE>
7 If SOURCE= appears, source-expr shall be conformable with allocation. If an allocate-object is not polymorphic
<P>
<PRE>
   and the source-expr is polymorphic with a dynamic type that differs from its declared type, the value provided for
<P>
   that allocate-object is the ancestor component of the source-expr that has the type of the allocate-object; otherwise
<P>
   the value provided is the value of the source-expr. On successful allocation, if allocate-object and source-expr
<P>
   have the same rank the value of allocate-object becomes the value provided, otherwise the value of each element
<P>
   of allocate-object becomes the value provided. The source-expr is evaluated exactly once for each execution of an
<P>
   ALLOCATE statement.
<P>
</PRE>
8 If MOLD= appears and source-expr is a variable, its value need not be defined.
<P>
9 If type-spec appears and the value of a length type parameter it specifies differs from the value of the corresponding
<P>
<PRE>
   nondeferred type parameter specified in the declaration of any allocate-object, an error condition occurs. If the
<P>
   value of a nondeferred length type parameter of an allocate-object differs from the value of the corresponding type
<P>
   parameter of source-expr, an error condition occurs.
<P>
</PRE>
10 The set of error conditions for an ALLOCATE statement is processor dependent. If an error condition occurs
<P>
<PRE>
   during execution of an ALLOCATE statement that does not contain the STAT= specifier, error termination is
<P>
   initiated. The STAT= specifier is described in 9.7.4. The ERRMSG= specifier is described in 9.7.5.
<P>
   9.7.1.3     Allocation of allocatable variables
<P>
</PRE>
1 The allocation status of an allocatable entity is one of the following at any time.
<P>
<PRE>
        • The status of an allocatable variable becomes “allocated” if it is allocated by an ALLOCATE statement, if
<P>
          it is allocated during assignment, or if it is given that status by the intrinsic subroutine MOVE_ALLOC
<P>
          (16.9.137). An allocatable variable with this status may be referenced, defined, or deallocated; allocating it
<P>
          causes an error condition in the ALLOCATE statement. The result of the intrinsic function ALLOCATED
<P>
          (16.9.11) is true for such a variable.
<P>
        • An allocatable variable has a status of “unallocated” if it is not allocated. The status of an allocatable
<P>
          variable becomes unallocated if it is deallocated (9.7.3) or if it is given that status by the intrinsic sub-
<P>
          routine MOVE_ALLOC. An allocatable variable with this status shall not be referenced or defined. It shall
<P>
          not be supplied as an actual argument corresponding to a nonallocatable nonoptional dummy argument,
<P>
          except to certain intrinsic inquiry functions. It may be allocated with the ALLOCATE statement. Deal-
<P>
          locating it causes an error condition in the DEALLOCATE statement. The result of the intrinsic function
<P>
          ALLOCATED (16.9.11) is false for such a variable.
<P>
</PRE>
2 At the beginning of execution of a program, allocatable variables are unallocated.
<P>
3 When the allocation status of an allocatable variable changes, the allocation status of any associated allocat-
<P>
<PRE>
   able variable changes accordingly. Allocation of an allocatable variable establishes values for the deferred type
<P>
   parameters of all associated allocatable variables.
<P>
</PRE>
4 An unsaved allocatable local variable of a procedure has a status of unallocated at the beginning of each invocation
<P>
<PRE>
   of the procedure. An unsaved allocatable local variable of a construct has a status of unallocated at the beginning
<P>
   of each execution of the construct.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                              141
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
5 When an object of derived type is created by an ALLOCATE statement, any allocatable ultimate components
</TD></TR>
<TR><TD colspan=2>
<PRE>
  have an allocation status of unallocated unless the SOURCE= specifier appears and the corresponding component
<P>
  of the source-expr is allocated.
<P>
</PRE>
6 If the evaluation of a function would change the allocation status of a variable and if a reference to the function
</TD></TR>
<TR><TD colspan=2>
<PRE>
  appears in an expression in which the value of the function is not needed to determine the value of the expression,
<P>
  the allocation status of the variable after evaluation of the expression is processor dependent.
<P>
  9.7.1.4    Allocation of pointer targets
<P>
</PRE>
1 Allocation of a pointer creates an object that implicitly has the TARGET attribute. Following successful execution
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of an ALLOCATE statement for a pointer, the pointer is associated with the target and may be used to reference
<P>
  or define the target. Additional pointers may become associated with the pointer target or a part of the pointer
<P>
  target by pointer assignment. It is not an error to allocate a pointer that is already associated with a target.
<P>
  In this case, a new pointer target is created as required by the attributes of the pointer and any array bounds,
<P>
  type, and type parameters specified by the ALLOCATE statement. The pointer is then associated with this
<P>
  new target. Any previous association of the pointer with a target is broken. If the previous target had been
<P>
  created by allocation, it becomes inaccessible unless other pointers are associated with it. The intrinsic function
<P>
  ASSOCIATED (16.9.16) may be used to determine whether a pointer that does not have undefined association
<P>
  status is associated.
<P>
</PRE>
2 At the beginning of execution of a function whose result is a pointer, the association status of the result pointer
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is undefined. Before such a function returns, it shall either associate a target with this pointer or cause the
<P>
  association status of this pointer to become disassociated.
<P>
  9.7.2     NULLIFY statement
<P>
  R938     nullify-stmt                  is   NULLIFY ( pointer-object-list )
<P>
  R939     pointer-object                is variable-name
<P>
                                         or structure-component
<P>
                                         or proc-pointer-name
<P>
  C951     (R939) Each pointer-object shall have the POINTER attribute.
<P>
</PRE>
1 A pointer-object shall not depend on the value, bounds, or association status of another pointer-object in the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  same NULLIFY statement.
<P>
</PRE>
2 Execution of a NULLIFY statement causes each pointer-object to become disassociated.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 9.21
<P>
       When a NULLIFY statement is applied to a polymorphic pointer (7.3.2.3), its dynamic type becomes the
<P>
       same as its declared type.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>9.7.3</B> </TD><TD valign=bottom>
DEALLOCATE statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>9.7.3.1</B> </TD><TD valign=bottom>
Form of the DEALLOCATE statement
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 The DEALLOCATE statement causes allocatable variables to be deallocated; it causes pointer targets to be
<P>
<PRE>
  deallocated and the pointers to be disassociated.
<P>
  R940     deallocate-stmt               is   DEALLOCATE ( allocate-object-list [ , dealloc-opt-list ] )
<P>
  R941     dealloc-opt                   is STAT = stat-variable
<P>
                                         or ERRMSG = errmsg-variable
<P>
  C952     (R941) No dealloc-opt shall appear more than once in a given dealloc-opt-list.
<P>
  142                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 An allocate-object shall not depend on the value, bounds, allocation status, or association status of another
<P>
<PRE>
  allocate-object in the same DEALLOCATE statement; it also shall not depend on the value of the stat-variable
<P>
  or errmsg-variable in the same DEALLOCATE statement.
<P>
</PRE>
3 The set of error conditions for a DEALLOCATE statement is processor dependent. If an error condition occurs
<P>
<PRE>
  during execution of a DEALLOCATE statement that does not contain the STAT= specifier, error termination is
<P>
  initiated. The STAT= specifier is described in 9.7.4. The ERRMSG= specifier is described in 9.7.5.
<P>
</PRE>
4 When more than one allocated object is deallocated by execution of a DEALLOCATE statement, the order of
<P>
<PRE>
  deallocation is processor dependent.
<P>
        NOTE 9.22
<P>
        An example of a DEALLOCATE statement is:
<P>
        DEALLOCATE (X, B)
<P>
  9.7.3.2    Deallocation of allocatable variables
<P>
</PRE>
1 Deallocating an unallocated allocatable variable causes an error condition in the DEALLOCATE statement.
<P>
<PRE>
  Deallocating an allocatable variable with the TARGET attribute causes the pointer association status of any
<P>
  pointer associated with it to become undefined. An allocatable variable shall not be deallocated if it or any
<P>
  subobject of it is argument associated with a dummy argument or construct associated with an associate name.
<P>
</PRE>
2 When the execution of a procedure is terminated by execution of a RETURN or END statement, an unsaved
<P>
<PRE>
  allocatable local variable of the procedure retains its allocation and definition status if it is a function result or a
<P>
  subobject thereof; otherwise, if it is allocated it will be deallocated.
<P>
</PRE>
3 When a BLOCK construct terminates, any unsaved allocated allocatable local variable of the construct is deal-
<P>
<PRE>
  located.
<P>
</PRE>
4 If an executable construct references a function whose result is allocatable or has an allocatable subobject, and
<P>
<PRE>
  the function reference is executed, an allocatable result and any allocated allocatable subobject of the result is
<P>
  deallocated after execution of the innermost executable construct containing the reference.
<P>
</PRE>
5 If a function whose result is allocatable or has an allocatable subobject is referenced in the specification part of a
<P>
<PRE>
  scoping unit, and the function reference is executed, an allocatable result and any allocated allocatable subobject
<P>
  of the result is deallocated before execution of the executable constructs of the scoping unit.
<P>
</PRE>
6 When a procedure is invoked, any allocated allocatable object that is an actual argument corresponding to an
<P>
<PRE>
  INTENT (OUT) allocatable dummy argument is deallocated; any allocated allocatable object that is a subobject
<P>
  of an actual argument corresponding to an INTENT (OUT) dummy argument is deallocated. If a Fortran proced-
<P>
  ure that has an INTENT (OUT) allocatable dummy argument is invoked by a C function and the corresponding
<P>
  argument in the C function call is a C descriptor that describes an allocated allocatable variable, the variable
<P>
  is deallocated on entry to the Fortran procedure. If a C function is invoked from a Fortran procedure via an
<P>
  interface with an INTENT (OUT) allocatable dummy argument and the corresponding actual argument in the
<P>
  reference to the C function is an allocated allocatable variable, the variable is deallocated on invocation (before
<P>
  execution of the C function begins).
<P>
</PRE>
7 When an intrinsic assignment statement (10.2.1.3) is executed, any noncoarray allocated allocatable subobject of
<P>
<PRE>
  the variable is deallocated before the assignment takes place.
<P>
</PRE>
8 When a variable of derived type is deallocated, any allocated allocatable subobject is deallocated. If an error
<P>
<PRE>
  condition occurs during deallocation, it is processor dependent whether an allocated allocatable subobject is
<P>
  deallocated.
<P>
</PRE>
9 If an allocatable component is a subobject of a finalizable object, that object is finalized before the component is
<P>
<PRE>
  automatically deallocated.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              143
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
10 When a statement that deallocates a coarray is executed, there is an implicit synchronization of all active images
<P>
<PRE>
   in the current team. If the current team contains a stopped or failed image, an error condition occurs. If no
<P>
   other error condition occurs, execution on the active images of the segment (11.6.2) following the statement is
<P>
   delayed until all other active images in the current team have executed the same statement the same number of
<P>
   times in this team. The segments that executed before the statement on an active image of this team precede
<P>
   the segments that execute after the statement on another active image of this team. A coarray shall not become
<P>
   deallocated on an image unless it is successfully deallocated on all active images in this team.
<P>
</PRE>
11 If an allocate-object is a coarray dummy argument, its ultimate argument (15.5.2.3) shall be the same coarray on
<P>
<PRE>
   those images.
<P>
</PRE>
12 The effect of automatic deallocation is the same as that of a DEALLOCATE statement without a dealloc-opt-list.
<P>
<PRE>
         NOTE 9.23
<P>
         In the following example:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE PROCESS</H4>
</A>
<BLOCKQUOTE>
<P>
REAL, ALLOCATABLE :: <B>TEMP</B>(:)
<P>
REAL, ALLOCATABLE, SAVE :: <B>X</B>(:)
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE PROCESS</H4>
</A>
<BLOCKQUOTE>
<P>
on return from subroutine PROCESS, the allocation status of X is preserved because X has the SAVE
<P>
attribute. TEMP does not have the SAVE attribute, so it will be deallocated if it was allocated. On the
<P>
next invocation of PROCESS, TEMP will have an allocation status of unallocated.
<P>
NOTE 9.24
<P>
For example, executing a RETURN, END, or END BLOCK statement, or deallocating an object that has
<P>
an allocatable subobject, can cause deallocation of a coarray, and thus an implicit synchronization of all
<P>
active images in the current team.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: active images in the current team.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>9.7.3.3</B> </TD><TD valign=bottom>
Deallocation of pointer targets
<P>
1 If a pointer appears in a DEALLOCATE statement, its association status shall be defined. Deallocating a pointer
<P>
<PRE>
   that is disassociated or whose target was not created by an ALLOCATE statement causes an error condition
<P>
   in the DEALLOCATE statement. If a pointer is associated with an allocatable entity, the pointer shall not be
<P>
   deallocated. A pointer shall not be deallocated if its target or any subobject thereof is argument associated with
<P>
   a dummy argument or construct associated with an associate name.
<P>
</PRE>
2 If a pointer appears in a DEALLOCATE statement, it shall be associated with the whole of an object that was
<P>
<PRE>
   created by allocation. The pointer shall have the same dynamic type and type parameters as the allocated object,
<P>
   and if the allocated object is an array the pointer shall be an array whose elements are the same as those of the
<P>
   allocated object in array element order. Deallocating a pointer target causes the pointer association status of any
<P>
   other pointer that is associated with the target or a portion of the target to become undefined.
<P>
   9.7.4      STAT= specifier
<P>
   R942      stat-variable                is  scalar-int-variable
<P>
</PRE>
1 A stat-variable should have a decimal exponent range of at least four; otherwise the processor-dependent error
<P>
<PRE>
   code might not be representable in the variable.
<P>
</PRE>
2 This rest of this subclause applies where an alloc-opt or dealloc-opt that is a STAT= specifier appears in an
<P>
<PRE>
   ALLOCATE or DEALLOCATE statement.
<P>
</PRE>
3 The stat-variable shall not be allocated or deallocated within the ALLOCATE or DEALLOCATE statement
<P>
<PRE>
   in which it appears; nor shall it depend on the value, bounds, deferred type parameters, allocation status, or
<P>
   144                                                                ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
association status of any allocate-object in that statement. The stat-variable shall not depend on the value of the
<TABLE width=100% cellpadding=3><!-- tsb: association status of any allocate-object in that statement. The stat-variable shall not depend on the value of the
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
errmsg-variable.
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
4 Successful execution of the ALLOCATE or DEALLOCATE statement causes the stat-variable to become defined
</TD></TR>
<TR><TD colspan=2>
<PRE>
  with a value of zero.
<P>
</PRE>
5 If an ALLOCATE or DEALLOCATE statement with a coarray allocate-object is executed when the current team
</TD></TR>
<TR><TD colspan=2>
<PRE>
  contains a stopped image, the stat-variable becomes defined with the value STAT_STOPPED_IMAGE from the
<P>
  intrinsic module ISO_FORTRAN_ENV (16.10.2). Otherwise, if an allocate-object is a coarray, the current team
<P>
  contains a failed image, and no other error condition occurs, the stat-variable becomes defined with value STAT_-
<P>
  FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV. If any other error condition occurs during
<P>
  execution of the ALLOCATE or DEALLOCATE statement, the stat-variable becomes defined with a processor-
<P>
  dependent positive integer value different from STAT_STOPPED_IMAGE and STAT_FAILED_IMAGE.
<P>
</PRE>
6 If stat-variable became defined with the value STAT_FAILED_IMAGE, each allocate-object is successfully al-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  located or deallocated on all the active images of the current team. If any other error condition occurs, each
<P>
  allocate-object has a processor-dependent status:
<P>
      • each allocate-object that was successfully allocated shall have an allocation status of allocated or a pointer
<P>
         association status of associated;
<P>
      • each allocate-object that was successfully deallocated shall have an allocation status of unallocated or a
<P>
         pointer association status of disassociated;
<P>
      • each allocate-object that was not successfully allocated or deallocated shall retain its previous allocation
<P>
         status or pointer association status.
<P>
        NOTE 9.25
<P>
        The status of objects that were not successfully allocated or deallocated can be individually checked with
<P>
        the intrinsic functions ALLOCATED or ASSOCIATED.
<P>
  9.7.5      ERRMSG= specifier
<P>
</PRE>
1 The errmsg-variable shall not be allocated or deallocated within the ALLOCATE or DEALLOCATE statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in which it appears; nor shall it depend on the value, bounds, deferred type parameters, allocation status, or
<P>
  association status of any allocate-object in that statement. The errmsg-variable shall not depend on the value of
<P>
  the stat-variable.
<P>
</PRE>
2 If an error condition occurs during execution of an ALLOCATE or DEALLOCATE statement with an ERRMSG=
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specifier, the errmsg-variable is assigned an explanatory message, truncated or padded according to the rules of
<P>
  intrinsic assignment. If no such condition occurs, the definition status and value of errmsg-variable are unchanged.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           145
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
<PRE>
                            (Blank page)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>146</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
10 Expressions and assignment
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>10.1</B> </TD><TD valign=bottom>
Expressions
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>10.1.1</B> </TD><TD valign=bottom>
Expression semantics
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 An expression represents either a data object reference or a computation, and its value is either a scalar or an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  array. Evaluation of an expression produces a value, which has a type, type parameters (if appropriate), and a
<P>
  shape (10.1.9). The corank of an expression that is not a variable is zero.
<P>
  10.1.2     Form of an expression
<P>
  10.1.2.1   Overall expression syntax
<P>
</PRE>
1 An expression is formed from operands, operators, and parentheses. An operand is either a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  An operation is either intrinsic (10.1.5) or defined (10.1.6). More complicated expressions can be formed using
<P>
  operands which are themselves expressions.
<P>
</PRE>
2 An expression is defined in terms of several categories: primary, level-1 expression, level-2 expression, level-3
</TD></TR>
<TR><TD colspan=2>
<PRE>
  expression, level-4 expression, and level-5 expression.
<P>
</PRE>
3 These categories are related to the different operator precedence levels and, in general, are defined in terms of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  other categories. The simplest form of each expression category is a primary.
<P>
  10.1.2.2   Primary
<P>
  R1001 primary                          is  literal-constant
<P>
                                         or  designator
<P>
                                         or  array-constructor
<P>
                                         or  structure-constructor
<P>
                                         or  function-reference
<P>
                                         or  type-param-inquiry
<P>
                                         or  type-param-name
<P>
                                         or  ( expr )
<P>
  C1001 (R1001) The type-param-name shall be the name of a type parameter.
<P>
  C1002 (R1001) The designator shall not be a whole assumed-size array.
<P>
  C1003 (R1001) The expr shall not be a function reference that returns a procedure pointer.
<P>
       NOTE 10.1
<P>
       Examples of a primary are:
<P>
             Example                                           Syntactic class
<P>
             1.0                                               constant
<P>
             ’ABCDEFGHIJKLMNOPQRSTUVWXYZ’ (I:I)                designator
<P>
             [ 1.0, 2.0 ]                                      array-constructor
<P>
             PERSON (’Jones’, 12)                              structure-constructor
<P>
             F (X, Y)                                          function-reference
<P>
             X%KIND                                            type-param-inquiry
<P>
             KIND                                              type-param-name
<P>
             (S + T)                                           (expr)
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        147
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  10.1.2.3   Level-1 expressions
<P>
</PRE>
1 Defined unary operators have the highest operator precedence (Table 10.1). Level-1 expressions are primaries
</TD></TR>
<TR><TD colspan=2>
<PRE>
  optionally operated on by defined unary operators:
<P>
  R1002 level-1-expr                     is   [ defined-unary-op ] primary
<P>
  R1003 defined-unary-op                 is   . letter [ letter ] &#46;&#46;&#46; .
<P>
  C1004 (R1003) A defined-unary-op shall not contain more than 63 letters and shall not be the same as any
<P>
          intrinsic-operator or logical-literal-constant.
<P>
       NOTE 10.2
<P>
       Simple examples of a level-1 expression are:
<P>
             Example                                               Syntactic class
<P>
             A                                                     primary (R1001)
<P>
             .INVERSE. B                                           level-1-expr (R1002)
<P>
       A more complicated example of a level-1 expression is:
<P>
             .INVERSE. (A + B)
<P>
  10.1.2.4   Level-2 expressions
<P>
</PRE>
1 Level-2 expressions are level-1 expressions optionally involving the numeric operators power-op, mult-op, and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  add-op.
<P>
  R1004 mult-operand                     is   level-1-expr [ power-op mult-operand ]
<P>
  R1005 add-operand                      is   [ add-operand mult-op ] mult-operand
<P>
  R1006 level-2-expr                     is   [ [ level-2-expr ] add-op ] add-operand
<P>
  R1007 power-op                         is   **
<P>
  R1008 mult-op                          is *
<P>
                                         or /
<P>
  R1009 add-op                           is +
<P>
                                         or –
<P>
       NOTE 10.3
<P>
       Simple examples of a level-2 expression are:
<P>
             Example                Syntactic class           Remarks
<P>
             A                      level-1-expr              A is a primary. (R1002)
<P>
             B ** C                 mult-operand              B is a level-1-expr, ** is a power-op,
<P>
                                                                 and C is a mult-operand. (R1004)
<P>
             D * E                  add-operand               D is an add-operand, * is a mult-op,
<P>
                                                                 and E is a mult-operand. (R1005)
<P>
             +1                     level-2-expr              + is an add-op
<P>
                                                                 and 1 is an add-operand. (R1006)
<P>
             F - I                  level-2-expr              F is a level-2-expr, – is an add-op,
<P>
                                                                 and I is an add-operand. (R1006)
<P>
  148                                                                    ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 10.3 (cont.)
<P>
       A more complicated example of a level-2 expression is:
<P>
             - A + D * E + B ** C
<P>
  10.1.2.5   Level-3 expressions
<P>
</PRE>
1 Level-3 expressions are level-2 expressions optionally involving the character operator concat-op.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1010 level-3-expr                    is  [ level-3-expr concat-op ] level-2-expr
<P>
  R1011 concat-op                       is  //
<P>
       NOTE 10.4
<P>
       Simple examples of a level-3 expression are:
<P>
            Example                                            Syntactic class
<P>
            A                                                  level-2-expr (R1006)
<P>
            B // C                                             level-3-expr (R1010)
<P>
       A more complicated example of a level-3 expression is:
<P>
            X // Y // ’ABCD’
<P>
  10.1.2.6   Level-4 expressions
<P>
</PRE>
1 Level-4 expressions are level-3 expressions optionally involving the relational operators rel-op.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1012 level-4-expr                    is  [ level-3-expr rel-op ] level-3-expr
<P>
  R1013 rel-op                          is  .EQ.
<P>
                                        or  .NE.
<P>
                                        or  .LT.
<P>
                                        or  .LE.
<P>
                                        or  .GT.
<P>
                                        or  .GE.
<P>
                                        or  ==
<P>
                                        or  /=
<P>
                                        or  &lt;
<P>
                                        or  &lt;=
<P>
                                        or  &gt;
<P>
                                        or  &gt;=
<P>
       NOTE 10.5
<P>
       Simple examples of a level-4 expression are:
<P>
            Example                                            Syntactic class
<P>
            A                                                  level-3-expr (R1010)
<P>
            B == C                                             level-4-expr (R1012)
<P>
            D &lt; E                                              level-4-expr (R1012)
<P>
       A more complicated example of a level-4 expression is:
<P>
             (A + B) /= C
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                 149
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  10.1.2.7   Level-5 expressions
<P>
</PRE>
1 Level-5 expressions are level-4 expressions optionally involving the logical operators not-op, and-op, or-op, and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  equiv-op.
<P>
  R1014 and-operand                      is   [ not-op ] level-4-expr
<P>
  R1015 or-operand                       is   [ or-operand and-op ] and-operand
<P>
  R1016 equiv-operand                    is   [ equiv-operand or-op ] or-operand
<P>
  R1017 level-5-expr                     is   [ level-5-expr equiv-op ] equiv-operand
<P>
  R1018 not-op                           is   .NOT.
<P>
  R1019 and-op                           is   .AND.
<P>
  R1020 or-op                            is   .OR.
<P>
  R1021 equiv-op                         is .EQV.
<P>
                                         or .NEQV.
<P>
       NOTE 10.6
<P>
       Simple examples of a level-5 expression are:
<P>
             Example                                               Syntactic class
<P>
             A                                                     level-4-expr (R1012)
<P>
             .NOT. B                                               and-operand (R1014)
<P>
             C .AND. D                                             or-operand (R1015)
<P>
             E .OR. F                                              equiv-operand (R1016)
<P>
             G .EQV. H                                             level-5-expr (R1017)
<P>
             S .NEQV. T                                            level-5-expr (R1017)
<P>
       A more complicated example of a level-5 expression is:
<P>
            A .AND. B .EQV. .NOT. C
<P>
  10.1.2.8   General form of an expression
<P>
</PRE>
1 Expressions are level-5 expressions optionally involving defined binary operators. Defined binary operators have
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the lowest operator precedence (Table 10.1).
<P>
  R1022 expr                             is   [ expr defined-binary-op ] level-5-expr
<P>
  R1023 defined-binary-op                is   . letter [ letter ] &#46;&#46;&#46; .
<P>
  C1005 (R1023) A defined-binary-op shall not contain more than 63 letters and shall not be the same as any
<P>
          intrinsic-operator or logical-literal-constant.
<P>
       NOTE 10.7
<P>
       Simple examples of an expression are:
<P>
             Example                                               Syntactic class
<P>
             A                                                     level-5-expr (R1017)
<P>
             B.UNION.C                                             expr (R1022)
<P>
  150                                                                    ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 10.7 (cont.)
<P>
       More complicated examples of an expression are:
<P>
              (B .INTERSECT. C) .UNION. (X - Y)
<P>
              A + B == C * D
<P>
              .INVERSE. (A + B)
<P>
              A + B .AND. C * D
<P>
              E // G == H (1:10)
<P>
  10.1.3      Precedence of operators
<P>
</PRE>
1 There is a precedence among the intrinsic and extension operations corresponding to the form of expressions
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specified in 10.1.2, which determines the order in which the operands are combined unless the order is changed
<P>
  by the use of parentheses. This precedence order is summarized in Table 10.1.
<P>
                         Table 10.1: Categories of operations and relative precedence
<P>
                       Category of operation                 Operators               Precedence
<P>
                             Extension                   defined-unary-op              Highest
<P>
                              Numeric                             **                      .
<P>
                              Numeric                            *, /                     .
<P>
                              Numeric                       unary +, –                    .
<P>
                              Numeric                       binary +, –                   .
<P>
                             Character                            //                      .
<P>
                             Relational         .EQ., .NE., .LT., .LE., .GT., .GE.,
<P>
                                                     ==, /=, &lt;, &lt;=, &gt;, &gt;=                 .
<P>
                               Logical                         .NOT.                      .
<P>
                               Logical                         .AND.                      .
<P>
                               Logical                          .OR.                      .
<P>
                               Logical                    .EQV., .NEQV.                   .
<P>
                             Extension                   defined-binary-op             Lowest
<P>
</PRE>
2 The precedence of a defined operation is that of its operator.
</TD></TR>
<TR><TD colspan=2>
<PRE>
        NOTE 10.8
<P>
</PRE>
For example, in the expression
</TD></TR>
<TR><TD colspan=2>
<PRE>
           -A ** 2
<P>
</PRE>
the exponentiation operator (**) has precedence over the negation operator (–); therefore, the operands of
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
the exponentiation operator are combined to form an expression that is used as the operand of the negation
<P>
operator. The interpretation of the above expression is the same as the interpretation of the expression
<TABLE width=100% cellpadding=3><!-- tsb: operator. The interpretation of the above expression is the same as the interpretation of the expression
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
(A ** 2)
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
3 The general form of an expression (10.1.2) also establishes a precedence among operators in the same syntactic
</TD></TR>
<TR><TD colspan=2>
<PRE>
  class. This precedence determines the order in which the operands are to be combined in determining the
<P>
  interpretation of the expression unless the order is changed by the use of parentheses.
<P>
        NOTE 10.9
<P>
       In interpreting a level-2-expr containing two or more binary operators + or –, each operand (add-operand)
<P>
       is combined from left to right. Similarly, the same left-to-right interpretation for a mult-operand in add-
<P>
       operand, as well as for other kinds of expressions, is a consequence of the general form. However, for
<P>
       interpreting a mult-operand expression when two or more exponentiation operators ** combine level-1-expr
<P>
       operands, each level-1-expr is combined from right to left.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        151
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
<PRE>
    NOTE 10.9 (cont.)
<P>
    For example, the expressions
<P>
        2.1 + 3.4 + 4.9
<P>
        2.1 * 3.4 * 4.9
<P>
        2.1 / 3.4 / 4.9
<P>
        2 ** 3 ** 4
<P>
        ’AB’ // ’CD’ // ’EF’
<P>
    have the same interpretations as the expressions
<P>
        (2.1 + 3.4) + 4.9
<P>
        (2.1 * 3.4) * 4.9
<P>
        (2.1 / 3.4) / 4.9
<P>
        2 ** (3 ** 4)
<P>
        (’AB’ // ’CD’) // ’EF’
<P>
    As a consequence of the general form (10.1.2), only the first add-operand of a level-2-expr can be preceded
<P>
    by the identity (+) or negation (–) operator. These formation rules do not permit expressions containing
<P>
    two consecutive numeric operators, such as A ** –B or A + –B. However, expressions such as A ** (–B)
<P>
    and A + (–B) are permitted. The rules do allow a binary operator or an intrinsic unary operator to be
<P>
    followed by a defined unary operator, such as:
<P>
        A * .INVERSE. B
<P>
        - .INVERSE. (B)
<P>
    As another example, in the expression
<P>
        A .OR. B .AND. C
<P>
    the general form implies a higher precedence for the .AND. operator than for the .OR. operator; therefore,
<P>
    the interpretation of the above expression is the same as the interpretation of the expression
<P>
        A .OR. (B .AND. C)
<P>
    NOTE 10.10
<P>
    An expression can contain more than one category of operator. The logical expression
<P>
        L .OR. A + B &gt;= C
<P>
    where A, B, and C are of type real, and L is of type logical, contains a numeric operator, a relational
<P>
    operator, and a logical operator. This expression would be interpreted the same as the expression
<P>
        L .OR. ((A + B) &gt;= C)
<P>
    NOTE 10.11
<P>
    If
<P>
        • the operator ** is extended to type logical,
<P>
        • the operator .STARSTAR. is defined to duplicate the function of ** on type real,
<P>
        • .MINUS. is defined to duplicate the unary operator –, and
<P>
        • L1 and L2 are type logical and X and Y are type real,
<P>
    then in precedence: L1 ** L2 is higher than X * Y; X * Y is higher than X .STARSTAR. Y; and .MINUS. X
<P>
    is higher than –X.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=3% nowrap>
<B>152</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=3%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>10.1.4</B> </TD><TD valign=bottom>
Evaluation of operations
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 An intrinsic operation requires the values of its operands.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 Execution of a function reference in the logical expression in an IF statement (11.1.8.4), the mask expression in a
<P>
<PRE>
  WHERE statement (10.2.3.1), or the concurrent-limits and concurrent-steps in a FORALL statement (10.2.4) is permitted to
<P>
  define variables in the subsidiary action-stmt, where-assignment-stmt, or forall-assignment-stmt respectively. Except
<P>
  in those cases:
<P>
      • the evaluation of a function reference shall neither affect nor be affected by the evaluation of any other
<P>
        entity within the statement;
<P>
      • if a function reference causes definition or undefinition of an actual argument of the function, that argument
<P>
        or any associated entities shall not appear elsewhere in the same statement.
<P>
       NOTE 10.12
<P>
       For example, the statements
<P>
            A (I) = F (I)
<P>
            Y = G (X) + X
<P>
       are prohibited if the reference to F defines or undefines I or the reference to G defines or undefines X.
<P>
       However, in the statements
<P>
            IF (F (X)) A = X
<P>
            WHERE (G (X)) B = X
<P>
       the reference to F and/or the reference to G can define X.
<P>
</PRE>
3 The appearance of an array constructor requires the evaluation of each scalar-int-expr of the ac-implied-do-control
<P>
<PRE>
  in any ac-implied-do it may contain.
<P>
</PRE>
4 When an elemental binary operation is applied to a scalar and an array or to two arrays of the same shape, the
<P>
<PRE>
  operation is performed element-by-element on corresponding array elements of the array operands.
<P>
       NOTE 10.13
<P>
       For example, the array expression
<P>
            A + B
<P>
       produces an array of the same shape as A and B. The individual array elements of the result have the
<P>
       values of the first element of A added to the first element of B, the second element of A added to the second
<P>
       element of B, etc.
<P>
</PRE>
5 When an elemental unary operator operates on an array operand, the operation is performed element-by-element,
<P>
<PRE>
  and the result is the same shape as the operand. If an elemental operation is intrinsically pure or is implemented
<P>
  by a pure elemental function (15.8), the element operations may be performed simultaneously or in any order.
<P>
  10.1.5      Intrinsic operations
<P>
  10.1.5.1     Intrinsic operation classification
<P>
</PRE>
1 An intrinsic operation is either a unary or binary operation. An intrinsic unary operation is an operation of
<P>
<PRE>
  the form intrinsic-operator x2 where x2 is of an intrinsic type (7.4) listed in Table 10.2 for the unary intrinsic
<P>
  operator.
<P>
</PRE>
2 An intrinsic binary operation is an operation of the form x1 intrinsic-operator x2 where x1 and x2 are conformable
<P>
<PRE>
  and of the intrinsic types (7.4) listed in Table 10.2 for the binary intrinsic operator.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              153
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 A numeric intrinsic operation is an intrinsic operation for which the intrinsic-operator is a numeric operator (+,
<P>
<PRE>
  –, *, /, or **). A numeric intrinsic operator is the operator in a numeric intrinsic operation.
<P>
</PRE>
4 The character intrinsic operation is the intrinsic operation for which the intrinsic-operator is (//) and both
<P>
<PRE>
  operands are of type character with the same kind type parameter. The character intrinsic operator is the
<P>
  operator in a character intrinsic operation.
<P>
</PRE>
5 A logical intrinsic operation is an intrinsic operation for which the intrinsic-operator is .AND., .OR., .NOT.,
<P>
<PRE>
  .EQV., or .NEQV. and both operands are of type logical. A logical intrinsic operator is the operator in a logical
<P>
  intrinsic operation.
<P>
</PRE>
6 A relational intrinsic operator is an intrinsic-operator that is .EQ., .NE., .GT., .GE., .LT., .LE., ==, /=, &gt;,
<P>
<PRE>
  &gt;=, &lt;, or &lt;=. A relational intrinsic operation is an intrinsic operation for which the intrinsic-operator is a
<P>
  relational intrinsic operator. A numeric relational intrinsic operation is a relational intrinsic operation for which
<P>
  both operands are of numeric type. A character relational intrinsic operation is a relational intrinsic operation for
<P>
  which both operands are of type character. The kind type parameters of the operands of a character relational
<P>
  intrinsic operation shall be the same.
<P>
</PRE>
7 The interpretations defined in subclause 10.1.5 apply to both scalars and arrays; the interpretation for arrays is
<P>
<PRE>
  obtained by applying the interpretation for scalars element by element.
<P>
                        Table 10.2: Type of operands and results for intrinsic operators
<P>
                           Intrinsic operator          Type of Type of                 Type of
<P>
                                   op                     x1          x2             [x1 ] op x2
<P>
                              Unary +, –                           I, R, Z             I, R, Z
<P>
                                                           I       I, R, Z             I, R, Z
<P>
                          Binary +, –, *, /, **           R        I, R, Z             R, R, Z
<P>
                                                          Z        I, R, Z             Z, Z, Z
<P>
                                   //                     C           C                    C
<P>
                                                           I       I, R, Z             L, L, L
<P>
                              .EQ., .NE.,                 R        I, R, Z             L, L, L
<P>
                                ==, /=                    Z        I, R, Z             L, L, L
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; C C L</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>I</B> </TD><TD valign=bottom>
I, R                L, L
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>.GT., .GE., .LT., .LE.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
R          I, R                L, L
</TD></TR>
<TR><TD colspan=2>
<PRE>
                            &gt;, &gt;=, &lt;, &lt;=                  C           C                    L
<P>
                                 .NOT.                                 L                   L
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>.AND., .OR., .EQV., .NEQV.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
L            L                   L
</TD></TR>
<TR></TR></TABLE>Note: The symbols I, R, Z, C, and L stand for the types integer, real, complex,
<P>
<PRE>
                           character, and logical, respectively. Where more than one type for x2 is
<P>
                           given, the type of the result of the operation is given in the same relative
<P>
                           position in the next column.
<P>
</PRE>
NOTE 10.14
</TD></TR>
<TR><TD colspan=2>
For example, if X is of type real and J is of type integer, the expression X + J is of type real.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>10.1.5.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Numeric intrinsic operations
</TD></TR>
<TR valign=top><TD colspan=2>
<B>10.1.5.2.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Interpretation of numeric intrinsic operations
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The two operands of numeric intrinsic binary operations may be of different numeric types or different kind
</TD></TR>
<TR><TD colspan=2>
<PRE>
  type parameters. Except for a value of type real or complex raised to an integer power, if the operands have
<P>
  different types or kind type parameters, the effect is as if each operand that differs in type or kind type parameter
<P>
  from those of the result is converted to the type and kind type parameter of the result before the operation is
<P>
  performed. When a value of type real or complex is raised to an integer power, the integer operand need not be
<P>
  converted.
<P>
  154                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 A numeric operation is used to express a numeric computation. Evaluation of a numeric operation produces a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  numeric value. The permitted data types for operands of the numeric intrinsic operations are specified in 10.1.5.1.
<P>
</PRE>
3 The numeric operators and their interpretation in an expression are given in Table 10.3, where x1 denotes the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  operand to the left of the operator and x2 denotes the operand to the right of the operator.
<P>
                            Table 10.3: Interpretation of the numeric intrinsic operators
<P>
                         Operator Representing        Use of operator Interpretation
<P>
                             **      Exponentiation       x1 ** x2       Raise x1 to the power x2
<P>
                              /      Division              x1 / x2       Divide x1 by x2
<P>
                              *      Multiplication        x1 * x2       Multiply x1 by x2
<P>
                             −       Subtraction           x1 - x2       Subtract x2 from x1
<P>
                             −       Negation               - x2         Negate x2
<P>
                             +       Addition             x1 + x2        Add x1 and x2
<P>
                             +       Identity               + x2         Same as x2
<P>
</PRE>
4 The interpretation of a division operation depends on the types of the operands (10.1.5.2.2).
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
5 If x1 and x2 are of type integer and x2 has a negative value, the interpretation of x1 ** x2 is the same as the
<P>
<PRE>
  interpretation of 1/(x1 ** ABS (x2 )), which is subject to the rules of integer division (10.1.5.2.2).
<P>
        NOTE 10.15
<P>
        For example, 2 ** (−3) has the value of 1/(2 ** 3), which is zero.
<P>
  10.1.5.2.2       Integer division
<P>
</PRE>
1 One operand of type integer may be divided by another operand of type integer. Although the mathematical
<P>
<PRE>
  quotient of two integers is not necessarily an integer, Table 10.2 specifies that an expression involving the division
<P>
  operator with two operands of type integer is interpreted as an expression of type integer. The result of such an
<P>
  operation is the integer closest to the mathematical quotient and between zero and the mathematical quotient
<P>
  inclusively.
<P>
        NOTE 10.16
<P>
        For example, the expression (−8) / 3 has the value (−2).
<P>
  10.1.5.2.3       Complex exponentiation
<P>
</PRE>
1 In the case of a complex value raised to a complex power, the value of the operation x1 ** x2 is the principal
<P>
<PRE>
  value of xx1 2 .
<P>
  10.1.5.2.4       Evaluation of numeric intrinsic operations
<P>
</PRE>
1 The execution of any numeric operation whose result is not defined by the arithmetic used by the processor is
<P>
<PRE>
  prohibited. Raising a negative real value to a real power is prohibited.
<P>
</PRE>
2 Once the interpretation of a numeric intrinsic operation is established, the processor may evaluate any mathem-
<P>
<PRE>
  atically equivalent expression, provided that the integrity of parentheses is not violated.
<P>
</PRE>
3 Two expressions of a numeric type are mathematically equivalent if, for all possible values of their primaries, their
<P>
<PRE>
  mathematical values are equal. However, mathematically equivalent expressions of numeric type may produce
<P>
  different computational results.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            155
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
    NOTE 10.17
<P>
    Any difference between the values of the expressions (1./3.)*3. and 1. is a computational difference,
<P>
    not a mathematical difference. The difference between the values of the expressions 5/2 and 5./2. is a
<P>
    mathematical difference, not a computational difference.
<P>
    The mathematical definition of integer division is given in 10.1.5.2.2.
<P>
    NOTE 10.18
<P>
    The following are examples of expressions with allowable alternative forms that can be used by the processor
<P>
    in the evaluation of those expressions. A, B, and C represent arbitrary real or complex operands; I and J
<P>
    represent arbitrary integer operands; and X, Y, and Z represent arbitrary operands of numeric type.
<P>
          Expression                                         Allowable alternative form
<P>
          X+Y                                                Y+X
<P>
          X*Y                                                Y*X
<P>
          -X + Y                                             Y-X
<P>
          X+Y+Z                                              X + (Y + Z)
<P>
          X-Y+Z                                              X - (Y - Z)
<P>
          X*A/Z                                              X * (A / Z)
<P>
          X*Y-X*Z                                            X * (Y - Z)
<P>
          A/B/C                                              A / (B * C)
<P>
          A / 5.0                                            0.2 * A
<P>
    The following are examples of expressions with forbidden alternative forms that cannot be used by a
<P>
    processor in the evaluation of those expressions.
<P>
          Expression                                         Forbidden alternative form
<P>
          I/2                                                0.5 * I
<P>
          X*I/J                                              X * (I / J)
<P>
          I/J/A                                              I / (J * A)
<P>
          (X + Y) + Z                                        X + (Y + Z)
<P>
          (X * Y) - (X * Z)                                  X * (Y - Z)
<P>
          X * (Y - Z)                                        X*Y-X*Z
<P>
    NOTE 10.19
<P>
    In addition to the parentheses required to establish the desired interpretation, parentheses can be included to
<P>
    restrict the alternative forms that can be used by the processor in the actual evaluation of the expression.
<P>
    This is useful for controlling the magnitude and accuracy of intermediate values developed during the
<P>
    evaluation of an expression.
<P>
    For example, in the expression
<P>
        A + (B - C)
<P>
    the parenthesized expression (B − C) is evaluated and then added to A.
<P>
    The inclusion of parentheses could change the mathematical value of an expression. For example, the two
<P>
    expressions
<P>
        A * I / J
<P>
        A * (I / J)
<P>
    could have different mathematical values if I and J are of type integer.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>156</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 10.20
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
Each operand in a numeric intrinsic operation has a type that can depend on the order of evaluation used
<P>
by the processor.
<P>
For example, in the evaluation of the expression
<P>
<PRE>
           Z + R + I
<P>
</PRE>
where Z, R, and I represent data objects of complex, real, and integer type, respectively, the type of the
<P>
operand that is added to I could be either complex or real, depending on which pair of operands (Z and R,
<P>
R and I, or Z and I) is added first.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>10.1.5.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Character intrinsic operation
<TABLE width=100% cellpadding=3><!-- tsb: Character intrinsic operation
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>10.1.5.3.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Interpretation of the character intrinsic operation
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The character intrinsic operator // is used to concatenate two operands of type character with the same kind
</TD></TR>
<TR><TD colspan=2>
<PRE>
  type parameter. Evaluation of the character intrinsic operation produces a result of type character.
<P>
</PRE>
2 The interpretation of the character intrinsic operator // when used to form an expression is given in Table 10.4,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  where x1 denotes the operand to the left of the operator and x2 denotes the operand to the right of the operator.
<P>
                       Table 10.4: Interpretation of the character intrinsic operator //
<P>
                       Operator Representing         Use of operator Interpretation
<P>
                           //      Concatenation        x1 // x2        Concatenate x1 with x2
<P>
</PRE>
3 The result of the character intrinsic operation x1 // x2 is a character string whose value is the value of x1
</TD></TR>
<TR><TD colspan=2>
<PRE>
  concatenated on the right with the value of x2 and whose length is the sum of the lengths of x1 and x2 . Parentheses
<P>
  used to specify the order of evaluation have no effect on the value of a character expression.
<P>
       NOTE 10.21
<P>
       For example, the value of (’AB’ // ’CDE’) // ’F’ is the string ’ABCDEF’. Also, the value of
<P>
       ’AB’ // (’CDE’ // ’F’) is the string ’ABCDEF’.
<P>
  10.1.5.3.2   Evaluation of the character intrinsic operation
<P>
</PRE>
1 A processor is only required to evaluate as much of the character intrinsic operation as is required by the context
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in which the expression appears.
<P>
       NOTE 10.22
<P>
       For example, the statements
<P>
           CHARACTER (LEN = 2) C1, C2, C3, CF
<P>
           C1 = C2 // CF (C3)
<P>
       do not require the function CF to be evaluated, because only the value of C2 is needed to determine the
<P>
       value of C1 because C1 and C2 both have a length of 2.
<P>
  10.1.5.4   Logical intrinsic operations
<P>
  10.1.5.4.1   Interpretation of logical intrinsic operations
<P>
</PRE>
1 A logical operation is used to express a logical computation. Evaluation of a logical operation produces a result
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of type logical. The permitted types for operands of the logical intrinsic operations are specified in 10.1.5.1.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           157
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The logical operators and their interpretation when used to form an expression are given in Table 10.5, where x1
</TD></TR>
<TR><TD colspan=2>
<PRE>
  denotes the operand to the left of the operator and x2 denotes the operand to the right of the operator.
<P>
                           Table 10.5: Interpretation of the logical intrinsic operators
<P>
           Operator    Representing                         Use of operator Interpretation
<P>
           .NOT.       Logical negation                     .NOT. x2         True if x2 is false
<P>
           .AND.       Logical conjunction                  x1 .AND. x2      True if x1 and x2 are both true
<P>
           .OR.        Logical inclusive disjunction        x1 .OR. x2       True if x1 and/or x2 is true
<P>
                                                                             True if both x1 and x2 are true or
<P>
           .EQV.       Logical equivalence                  x1 .EQV. x2
<P>
                                                                             both are false
<P>
                                                                             True if either x1 or x2 is true, but
<P>
           .NEQV.      Logical nonequivalence               x1 .NEQV. x2
<P>
                                                                             not both
<P>
</PRE>
3 The values of the logical intrinsic operations are shown in Table 10.6.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                   Table 10.6: The values of operations involving logical intrinsic operators
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>x1</B> </TD><TD valign=bottom>
x2     .NOT. x2 x1 .AND. x2 x1 .OR. x2 x1 .EQV. x2 x1 .NEQV. x2
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>true true</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
false          true            true          true              false
<TABLE width=100% cellpadding=3><!-- tsb: false          true            true          true              false
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>true false</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
true          false           true          false             true
</TD></TR>
<TR valign=top><TD colspan=2>
<B>false true</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
false          false           true          false             true
</TD></TR>
<TR valign=top><TD colspan=2>
<B>false false</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
true          false           false         true              false
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>10.1.5.4.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Evaluation of logical intrinsic operations
<P>
1 Once the interpretation of a logical intrinsic operation is established, the processor may evaluate any other
<P>
<PRE>
  expression that is logically equivalent, provided that the integrity of parentheses in any expression is not violated.
<P>
        NOTE 10.23
<P>
        For example, for the variables L1, L2, and L3 of type logical, the processor could choose to evaluate the
<P>
        expression
<P>
            L1 .AND. L2 .AND. L3
<P>
        as
<P>
            L1 .AND. (L2 .AND. L3)
<P>
</PRE>
2 Two expressions of type logical are logically equivalent if their values are equal for all possible values of their
<P>
<PRE>
  primaries.
<P>
  10.1.5.5    Relational intrinsic operations
<P>
  10.1.5.5.1    Interpretation of relational intrinsic operations
<P>
</PRE>
1 A relational intrinsic operation is used to compare values of two operands using the relational intrinsic operators
<P>
<PRE>
  .LT., .LE., .GT., .GE., .EQ., .NE., &lt;, &lt;=, &gt;, &gt;=, ==, and /=. The permitted types for operands of the
<P>
  relational intrinsic operators are specified in 10.1.5.1.
<P>
</PRE>
2 The operators &lt;, &lt;=, &gt;, &gt;=, ==, and /= always have the same interpretations as the operators .LT., .LE.,
<P>
<PRE>
  .GT., .GE., .EQ., and .NE., respectively.
<P>
        NOTE 10.24
<P>
        As shown in Table 10.2, a relational intrinsic operator cannot be used to compare the value of an expression
<P>
        of a numeric type with one of type character or logical. Also, two operands of type logical cannot be
<P>
  158                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 10.24 (cont.)
<P>
        compared, a complex operand can be compared with another numeric operand only when the operator is
<P>
        .EQ., .NE., ==, or /=, and two character operands cannot be compared unless they have the same kind
<P>
        type parameter value.
<P>
</PRE>
3 Evaluation of a relational intrinsic operation produces a default logical result.
<P>
4 The interpretation of the relational intrinsic operators is given in Table 10.7, where x1 denotes the operand to
<P>
<PRE>
  the left of the operator and x2 denotes the operand to the right of the operator.
<P>
                         Table 10.7: Interpretation of the relational      intrinsic operators
<P>
                Operator Representing                   Use of operator    Interpretation
<P>
                  .LT.     Less than                       x1 .LT. x2      x1 less than x2
<P>
                    &lt;      Less than                        x1 &lt; x 2       x1 less than x2
<P>
                  .LE.     Less than or equal to           x1 .LE. x2      x1 less than or equal to x2
<P>
                   &lt;=      Less than or equal to           x1 &lt;= x2        x1 less than or equal to x2
<P>
                  .GT.     Greater than                   x1 .GT. x2       x1 greater than x2
<P>
                    &gt;      Greater than                     x1 &gt; x 2       x1 greater than x2
<P>
                  .GE.     Greater than or equal to       x1 .GE. x2       x1 greater than or equal to x2
<P>
                   &gt;=      Greater than or equal to        x1 &gt;= x2        x1 greater than or equal to x2
<P>
                  .EQ.     Equal to                       x1 .EQ. x2       x1 equal to x2
<P>
                   ==      Equal to                        x1 == x2        x1 equal to x2
<P>
                  .NE.     Not equal to                   x1 .NE. x2       x1 not equal to x2
<P>
                   /=      Not equal to                     x1 /= x2       x1 not equal to x2
<P>
</PRE>
5 A numeric relational intrinsic operation is interpreted as having the logical value true if and only if the values of
<P>
<PRE>
  the operands satisfy the relation specified by the operator.
<P>
</PRE>
6 In the numeric relational operation
<P>
<PRE>
         x1 rel-op x2
<P>
</PRE>
if the types or kind type parameters of x1 and x2 differ, their values are converted to the type and kind type
<TABLE width=100% cellpadding=3><!-- tsb: if the types or kind type parameters of x1 and x2 differ, their values are converted to the type and kind type
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
parameter of the expression x1 + x2 before evaluation.
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
7 A character relational intrinsic operation is interpreted as having the logical value true if and only if the values
<P>
<PRE>
  of the operands satisfy the relation specified by the operator.
<P>
</PRE>
8 For a character relational intrinsic operation, the operands are compared one character at a time in order,
<P>
<PRE>
  beginning with the first character of each character operand. If the operands are of unequal length, the shorter
<P>
  operand is treated as if it were extended on the right with blanks to the length of the longer operand. If both
<P>
  x1 and x2 are of zero length, x1 is equal to x2 ; if every character of x1 is the same as the character in the
<P>
  corresponding position in x2 , x1 is equal to x2 . Otherwise, at the first position where the character operands
<P>
  differ, the character operand x1 is considered to be less than x2 if the character value of x1 at this position
<P>
  precedes the value of x2 in the collating sequence (3.31); x1 is greater than x2 if the character value of x1 at this
<P>
  position follows the value of x2 in the collating sequence.
<P>
        NOTE 10.25
<P>
        The collating sequence depends partially on the processor; however, the result of the use of the operators
<P>
        .EQ., .NE., ==, and /= does not depend on the collating sequence.
<P>
        For nondefault character kinds, the blank padding character is processor dependent.
<P>
  10.1.5.5.2     Evaluation of relational intrinsic operations
<P>
</PRE>
1 Once the interpretation of a relational intrinsic operation is established, the processor may evaluate any other
<P>
<PRE>
  expression that is relationally equivalent, provided that the integrity of parentheses in any expression is not
<P>
  violated.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           159
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 Two relational intrinsic operations are relationally equivalent if their logical values are equal for all possible values
<P>
<PRE>
  of their primaries.
<P>
        NOTE 10.26
<P>
        Whether an operand of a relational intrinsic operation could be an IEEE NaN affects whether expressions
<P>
        are equivalent. For example, if x or y could be a NaN, the expressions
<P>
               .NOT. (x .LT. y)         and   x .GE. y
<P>
        are not equivalent.
<P>
  10.1.6      Defined operations
<P>
  10.1.6.1    Definitions
<P>
</PRE>
1 A defined operation is either a unary operation or a binary operation. A unary defined operation is an operation
<P>
<PRE>
  that has the form defined-unary-op x2 or intrinsic-operator x2 and that is defined by a function and a generic
<P>
  interface (7.5.5, 15.4.3.4).
<P>
</PRE>
2 A function defines the unary operation op x2 if
<P>
<PRE>
         (1)    the function is specified with a FUNCTION (15.6.2.2) or ENTRY (15.6.2.6) statement that specifies one
<P>
                dummy argument d2 ,
<P>
         (2)    either
<P>
                (a)    a generic interface (15.4.3.2) provides the function with a generic-spec of OPERATOR (op),
<P>
                       or
<P>
                (b)    there is a generic binding (7.5.5) in the declared type of x2 with a generic-spec of OPER-
<P>
                       ATOR (op) and there is a corresponding binding to the function in the dynamic type of x2 ,
<P>
         (3)    the type of d2 is compatible with the dynamic type of x2 ,
<P>
         (4)    the type parameters, if any, of d2 match the corresponding type parameters of x2 , and
<P>
         (5)    either
<P>
                (a)    the rank of x2 matches that of d2 or
<P>
                (b)    the function is elemental and there is no other function that defines the operation.
<P>
</PRE>
3 If d2 is an array, the shape of x2 shall match the shape of d2 .
<P>
4 A binary defined operation is an operation that has the form x1 defined-binary-op x2 or x1 intrinsic-operator x2
<P>
<PRE>
  and that is defined by a function and a generic interface.
<P>
</PRE>
5 A function defines the binary operation x1 op x2 if
<P>
<PRE>
         (1)    the function is specified with a FUNCTION (15.6.2.2) or ENTRY (15.6.2.6) statement that specifies
<P>
                two dummy arguments, d1 and d2 ,
<P>
         (2)    either
<P>
                (a)    a generic interface (15.4.3.2) provides the function with a generic-spec of OPERATOR (op),
<P>
                       or
<P>
                (b)    there is a generic binding (7.5.5) in the declared type of x1 or x2 with a generic-spec of
<P>
                       OPERATOR (op) and there is a corresponding binding to the function in the dynamic type
<P>
                       of x1 or x2 , respectively,
<P>
         (3)    the types of d1 and d2 are compatible with the dynamic types of x1 and x2 , respectively,
<P>
         (4)    the type parameters, if any, of d1 and d2 match the corresponding type parameters of x1 and x2 ,
<P>
                respectively, and
<P>
         (5)    either
<P>
                (a)    the ranks of x1 and x2 match those of d1 and d2 , respectively, or
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>160</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>(b)</B> </TD><TD valign=bottom>
the function is elemental, x1 and x2 are conformable, and there is no other function that defines
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                       the operation.
<P>
</PRE>
6 If d1 or d2 is an array, the shapes of x1 and x2 shall match the shapes of d1 and d2 , respectively.
<P>
<PRE>
        NOTE 10.27
<P>
        An intrinsic operator can be used as the operator in a defined operation. In such a case, the generic
<P>
        properties of the operator are extended.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>10.1.6.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Interpretation of a defined operation
<P>
1 The interpretation of a defined operation is provided by the function that defines the operation.
<P>
2 The operators &lt;, &lt;=, &gt;, &gt;=, ==, and /= always have the same interpretations as the operators .LT., .LE.,
<P>
<PRE>
  .GT., .GE., .EQ., and .NE., respectively.
<P>
  10.1.6.3     Evaluation of a defined operation
<P>
</PRE>
1 Once the interpretation of a defined operation is established, the processor may evaluate any other expression
<P>
<PRE>
  that is equivalent, provided that the integrity of parentheses is not violated.
<P>
</PRE>
2 Two expressions of derived type are equivalent if their values are equal for all possible values of their primaries.
<P>
<PRE>
  10.1.7      Evaluation of operands
<P>
</PRE>
1 It is not necessary for a processor to evaluate all of the operands of an expression, or to evaluate entirely each
<P>
<PRE>
  operand, if the value of the expression can be determined otherwise.
<P>
        NOTE 10.28
<P>
        This principle is most often applicable to logical expressions, zero-sized arrays, and zero-length strings, but
<P>
        it applies to all expressions.
<P>
        For example, in evaluating the expression
<P>
                  X &gt; Y .OR. L (Z)
<P>
        where X, Y, and Z are real and L is a function of type logical, the function reference L (Z) need not be
<P>
        evaluated if X is greater than Y. Similarly, in the array expression
<P>
                  W (Z) + A
<P>
        where A is of size zero and W is a function, the function reference W (Z) need not be evaluated.
<P>
</PRE>
2 If a statement contains a function reference in a part of an expression that need not be evaluated, all entities that
<P>
<PRE>
  would have become defined in the execution of that reference become undefined at the completion of evaluation
<P>
  of the expression containing the function reference.
<P>
        NOTE 10.29
<P>
        In the examples in NOTE 10.28, if L or W defines its argument, evaluation of the expressions under the
<P>
        specified conditions causes Z to become undefined, no matter whether or not L(Z) or W(Z) is evaluated.
<P>
</PRE>
3 If a statement contains a function reference in a part of an expression that need not be evaluated, no invocation
<P>
<PRE>
  of that function in that part of the expression shall execute an image control statement other than CRITICAL
<P>
  or END CRITICAL.
<P>
        NOTE 10.30
<P>
        This restriction is intended to avoid inadvertent deadlock caused by optimization.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             161
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  10.1.8       Integrity of parentheses
<P>
</PRE>
1 The rules for evaluation specified in subclause 10.1.5 state certain conditions under which a processor may
<P>
<PRE>
  evaluate an expression that is different from the one specified by applying the rules given in 10.1.2 and rules for
<P>
  interpretation specified in subclause 10.1.5. However, any expression in parentheses shall be treated as a data
<P>
  entity.
<P>
        NOTE 10.31
<P>
        For example, in evaluating the expression A + (B – C) where A, B, and C are of numeric types, the
<P>
        difference of B and C shall be evaluated before the addition operation is performed; the processor shall not
<P>
        evaluate the mathematically equivalent expression (A + B) – C.
<P>
  10.1.9       Type, type parameters, and shape of an expression
<P>
  10.1.9.1     General
<P>
</PRE>
1 The type, type parameters, and shape of an expression depend on the operators and on the types, type parameters,
<P>
<PRE>
  and shapes of the primaries used in the expression, and are determined recursively from the syntactic form of the
<P>
  expression. The type of an expression is one of the intrinsic types (7.4) or a derived type (7.5).
<P>
</PRE>
2 If an expression is a polymorphic primary or defined operation, the type parameters and the declared and dynamic
<P>
<PRE>
  types of the expression are the same as those of the primary or defined operation. Otherwise the type parameters
<P>
  and dynamic type of the expression are the same as its declared type and type parameters; they are referred to
<P>
  simply as the type and type parameters of the expression.
<P>
  R1024 logical-expr                      is   expr
<P>
  C1006 (R1024) logical-expr shall be of type logical.
<P>
  R1025 default-char-expr                 is   expr
<P>
  C1007 (R1025) default-char-expr shall be default character.
<P>
  R1026 int-expr                          is   expr
<P>
  C1008 (R1026) int-expr shall be of type integer.
<P>
  R1027 numeric-expr                      is   expr
<P>
  C1009 (R1027) numeric-expr shall be of type integer, real, or complex.
<P>
  10.1.9.2     Type, type parameters, and shape of a primary
<P>
</PRE>
1 The type, type parameters, and shape of a primary are determined according to whether the primary is a literal
<P>
<PRE>
  constant, designator, array constructor, structure constructor, function reference, type parameter inquiry, type
<P>
  parameter name, or parenthesized expression. If a primary is a literal constant, its type, type parameters, and
<P>
  shape are those of the literal constant. If it is a structure constructor, it is scalar and its type and type parameters
<P>
  are as described in 7.5.10. If it is an array constructor, its type, type parameters, and shape are as described in
<P>
  7.8. If it is a designator or function reference, its type, type parameters, and shape are those of the designator
<P>
  (8.2, 8.5) or the function reference (15.5.3), respectively. If the function reference is generic (15.4.3.2, 16.7)
<P>
  then its type, type parameters, and shape are those of the specific function referenced, which is determined by
<P>
  the declared types, type parameters, and ranks of its actual arguments as specified in 15.5.5.2. If it is a type
<P>
  parameter inquiry or type parameter name, it is a scalar integer with the kind of the type parameter.
<P>
</PRE>
2 If a primary is a parenthesized expression, its type, type parameters, and shape are those of the expression.
<P>
3 The associated target object is referenced if a pointer appears as
<P>
<PRE>
      • a primary in an intrinsic or defined operation,
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>162</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                        c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
• the expr of a parenthesized primary, or
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
• the only primary on the right-hand side of an intrinsic assignment statement.
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
4 The type, type parameters, and shape of the primary are those of the target. If the pointer is not associated with
<P>
<PRE>
  a target, it may appear as a primary only as an actual argument in a reference to a procedure whose corresponding
<P>
  dummy argument is declared to be a pointer, as the target in a pointer assignment statement, or as explicitly
<P>
  permitted elsewhere in this document.
<P>
</PRE>
5 A disassociated array pointer or an unallocated allocatable array has no shape but does have rank. The type,
<P>
<PRE>
  type parameters, and rank of the result of the intrinsic function NULL (16.9.144) depend on context.
<P>
  10.1.9.3     Type, type parameters, and shape of the result of an operation
<P>
</PRE>
1 The type of the result of an intrinsic operation [x1 ] op x2 is specified by Table 10.2. The shape of the result of
<P>
<PRE>
  an intrinsic operation is the shape of x2 if op is unary or if x1 is scalar, and is the shape of x1 otherwise.
<P>
</PRE>
2 The type, type parameters, and shape of the result of a defined operation [x1 ] op x2 are specified by the function
<P>
<PRE>
  defining the operation (10.1.6).
<P>
</PRE>
3 An expression of an intrinsic type has a kind type parameter. An expression of type character also has a character
<P>
<PRE>
  length parameter.
<P>
</PRE>
4 The type parameters of the result of an intrinsic operation are as follows.
<P>
<PRE>
      • For an expression x1 // x2 where // is the character intrinsic operator and x1 and x2 are of type character,
<P>
        the character length parameter is the sum of the lengths of the operands and the kind type parameter is
<P>
        the kind type parameter of x1 , which shall be the same as the kind type parameter of x2 .
<P>
      • For an expression op x2 where op is an intrinsic unary operator and x2 is of type integer, real, complex, or
<P>
        logical, the kind type parameter of the expression is that of the operand.
<P>
      • For an expression x1 op x2 where op is a numeric intrinsic binary operator with one operand of type integer
<P>
        and the other of type real or complex, the kind type parameter of the expression is that of the real or
<P>
        complex operand.
<P>
      • For an expression x1 op x2 where op is a numeric intrinsic binary operator with both operands of the same
<P>
        type and kind type parameters, or with one real and one complex with the same kind type parameters, the
<P>
        kind type parameter of the expression is identical to that of each operand. In the case where both operands
<P>
        are integer with different kind type parameters, the kind type parameter of the expression is that of the
<P>
        operand with the greater decimal exponent range if the decimal exponent ranges are different; if the decimal
<P>
        exponent ranges are the same, the kind type parameter of the expression is processor dependent, but it is
<P>
        the same as that of one of the operands. In the case where both operands are any of type real or complex
<P>
        with different kind type parameters, the kind type parameter of the expression is that of the operand with
<P>
        the greater decimal precision if the decimal precisions are different; if the decimal precisions are the same,
<P>
        the kind type parameter of the expression is processor dependent, but it is the same as that of one of the
<P>
        operands.
<P>
      • For an expression x1 op x2 where op is a logical intrinsic binary operator with both operands of the same
<P>
        kind type parameter, the kind type parameter of the expression is identical to that of each operand. In the
<P>
        case where both operands are of type logical with different kind type parameters, the kind type parameter
<P>
        of the expression is processor dependent, but it is the same as that of one of the operands.
<P>
      • For an expression x1 op x2 where op is a relational intrinsic operator, the kind type parameter of the
<P>
        expression is default logical.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>10.1.10</B> </TD><TD valign=bottom>
Conformability rules for elemental operations
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 An elemental operation is an intrinsic operation or a defined operation for which the function is elemental (15.8).
<P>
2 For all elemental binary operations, the two operands shall be conformable. In the case where one is a scalar and
<P>
<PRE>
  the other an array, the scalar is treated as if it were an array of the same shape as the array operand with every
<P>
  element, if any, of the array equal to the value of the scalar.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           163
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  10.1.11       Specification expression
<P>
</PRE>
1 A specification expression is an expression with limitations that make it suitable for use in specifications such as
<P>
<PRE>
  length type parameters (C704) and array bounds (R817, R818). A specification-expr shall be a constant expression
<P>
  unless it is in an interface body (15.4.3.2), the specification part of a subprogram or BLOCK construct, a derived
<P>
  type definition, or the declaration-type-spec of a FUNCTION statement (15.6.2.2).
<P>
  R1028 specification-expr                    is   scalar-int-expr
<P>
  C1010 (R1028) The scalar-int-expr shall be a restricted expression.
<P>
</PRE>
2 A restricted expression is an expression in which each operation is intrinsic or defined by a specification function
<P>
<PRE>
  and each primary is
<P>
        (1)      a constant or subobject of a constant,
<P>
        (2)      an object designator with a base object that is a dummy argument that has neither the OPTIONAL
<P>
                 nor the INTENT (OUT) attribute,
<P>
        (3)      an object designator with a base object that is in a common block,
<P>
        (4)      an object designator with a base object that is made accessible by use or host association,
<P>
        (5)      an array constructor where each element and each scalar-int-expr of each ac-implied-do-control is a
<P>
                 restricted expression,
<P>
        (6)      a structure constructor where each component is a restricted expression,
<P>
        (7)      a specification inquiry where each designator or argument is
<P>
                 (a)    a restricted expression or
<P>
                 (b)    a variable that is not an optional dummy argument, and whose properties inquired about are
<P>
                        not
<P>
                        (i)     dependent on the upper bound of the last dimension of an assumed-size array,
<P>
                        (ii)    deferred, or
<P>
                        (iii)   defined by an expression that is not a restricted expression,
<P>
        (8)      a specification inquiry that is a constant expression,
<P>
        (9)      a reference to the intrinsic function PRESENT,
<P>
        (10)     a reference to any other standard intrinsic function where each argument is a restricted expression,
<P>
        (11)     a reference to a transformational function from the intrinsic module IEEE_ARITHMETIC, IEEE_-
<P>
                 EXCEPTIONS, or ISO_C_BINDING, where each argument is a restricted expression,
<P>
        (12)     a reference to a specification function where each argument is a restricted expression,
<P>
        (13)     a type parameter of the derived type being defined,
<P>
        (14)     an ac-do-variable within an array constructor where each scalar-int-expr of the corresponding ac-
<P>
                 implied-do-control is a restricted expression, or
<P>
        (15)     a restricted expression enclosed in parentheses,
<P>
</PRE>
3 where each subscript, section subscript, substring starting point, substring ending point, and type parameter
<P>
<PRE>
  value is a restricted expression, and where any final subroutine that is invoked is pure.
<P>
</PRE>
4 A specification inquiry is a reference to
<P>
<PRE>
        (1)      an intrinsic inquiry function other than PRESENT,
<P>
        (2)      a type parameter inquiry (9.4.5),
<P>
        (3)      an inquiry function from the intrinsic modules IEEE_ARITHMETIC and IEEE_EXCEPTIONS
<P>
                 (17.10),
<P>
        (4)      the function C_SIZEOF from the intrinsic module ISO_C_BINDING (18.2.3.7), or
<P>
        (5)      the COMPILER_VERSION or COMPILER_OPTIONS function from the intrinsic module ISO_-
<P>
                 FORTRAN_ENV (16.10.2.6, 16.10.2.7).
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>164</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 A function is a specification function if it is a pure function, is not a standard intrinsic function, is not an internal
</TD></TR>
<TR><TD colspan=2>
<PRE>
  function, is not a statement function, and does not have a dummy procedure argument.
<P>
</PRE>
6 Evaluation of a specification expression shall not directly or indirectly cause a procedure defined by the subpro-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  gram in which it appears to be invoked.
<P>
        NOTE 10.32
<P>
        Specification functions are nonintrinsic functions that can be used in specification expressions to determine
<P>
        the attributes of data objects. The requirement that they be pure ensures that they cannot have side effects
<P>
        that could affect other objects being declared in the same specification-part. The requirement that they
<P>
        not be internal ensures that they cannot inquire, via host association, about other objects being declared
<P>
        in the same specification-part. The prohibition against recursion avoids the creation of a new instance of a
<P>
        procedure while construction of one is in progress.
<P>
</PRE>
7 A variable in a specification expression shall have its type and type parameters, if any, specified by a previous
</TD></TR>
<TR><TD colspan=2>
<PRE>
  declaration in the same scoping unit, by the implicit typing rules in effect for the scoping unit, or by host or use
<P>
  association. If a variable in a specification expression is typed by the implicit typing rules, its appearance in any
<P>
  subsequent type declaration statement shall confirm the implied type and type parameters.
<P>
</PRE>
8 If a specification expression includes a specification inquiry that depends on a type parameter, array bound,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  or cobound of an entity specified in the same specification-part, the type parameter, array bound, or cobound
<P>
  shall be specified in a prior specification of the specification-part. The prior specification may be to the left of
<P>
  the specification inquiry in the same statement, but shall not be within the same entity-decl. If a specification
<P>
  expression includes a reference to the value of an element of an array specified in the same specification-part, the
<P>
  array shall be completely specified in prior declarations.
<P>
</PRE>
9 A generic entity referenced in a specification expression in the specification-part of a scoping unit shall have no
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specific procedures defined in the scoping unit, or its host scoping unit, subsequent to the specification expression.
<P>
        NOTE 10.33
<P>
        The following are examples of specification expressions:
<P>
                  LBOUND (B, 1) + 5        ! B is an assumed-shape dummy array
<P>
                  M + LEN (C)              ! M and C are dummy arguments
<P>
                  2 * PRECISION (A)        ! A is a real variable made accessible by a USE statement
<P>
  10.1.12       Constant expression
<P>
</PRE>
1 A constant expression is an expression with limitations that make it suitable for use as a kind type parameter,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  initializer, or named constant. It is an expression in which each operation is intrinsic, and each primary is
<P>
          (1)   a constant or subobject of a constant,
<P>
          (2)   an array constructor where each element and each scalar-int-expr of each ac-implied-do-control is a
<P>
                constant expression,
<P>
          (3)   a structure constructor where each component-spec corresponding to
<P>
                (a)     an allocatable component is a reference to the intrinsic function NULL,
<P>
                (b)     a pointer component is an initialization target or a reference to the intrinsic function NULL,
<P>
                        and
<P>
                (c)     any other component is a constant expression,
<P>
          (4)   a specification inquiry where each designator or argument is
<P>
                (a)     a constant expression or
<P>
                (b)     a variable whose properties inquired about are not
<P>
                        (i)    assumed,
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               165
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                       (ii)  deferred, or
<P>
                       (iii) defined by an expression that is not a constant expression,
<P>
          (5)   a reference to an elemental standard intrinsic function, where each argument is a constant expression,
<P>
          (6)   a reference to a standard intrinsic function that is transformational, other than COMMAND_ARGU-
<P>
                MENT_COUNT, NULL, NUM_IMAGES, THIS_IMAGE, or TRANSFER, where each argument
<P>
                is a constant expression,
<P>
          (7)   a reference to the intrinsic function NULL that does not have an argument with a type parameter
<P>
                that is assumed or is defined by an expression that is not a constant expression,
<P>
          (8)   a reference to the intrinsic function TRANSFER where each argument is a constant expression and
<P>
                each ultimate pointer component of the SOURCE argument is disassociated,
<P>
          (9)   a reference to a transformational function from the intrinsic module IEEE_ARITHMETIC or IEEE_-
<P>
                EXCEPTIONS, where each argument is a constant expression,
<P>
          (10)  a previously declared kind type parameter of the derived type being defined,
<P>
          (11)  a data-i-do-variable within a data-implied-do,
<P>
          (12)  an ac-do-variable within an array constructor where each scalar-int-expr of the corresponding ac-
<P>
                implied-do-control is a constant expression, or
<P>
          (13)  a constant expression enclosed in parentheses,
<P>
  and where each subscript, section subscript, substring starting point, substring ending point, and type parameter
<P>
  value is a constant expression.
<P>
  R1029 constant-expr                     is   expr
<P>
  C1011 (R1029) constant-expr shall be a constant expression.
<P>
  R1030 default-char-constant-expr        is   default-char-expr
<P>
  C1012 (R1030) default-char-constant-expr shall be a constant expression.
<P>
  R1031 int-constant-expr                 is   int-expr
<P>
  C1013 (R1031) int-constant-expr shall be a constant expression.
<P>
</PRE>
2 If a constant expression includes a specification inquiry that depends on a type parameter or an array bound of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  an entity specified in the same specification-part, the type parameter or array bound shall be specified in a prior
<P>
  specification of the specification-part. The prior specification may be to the left of the specification inquiry in the
<P>
  same statement, but shall not be within the same entity-decl unless the specification inquiry appears within an
<P>
  initialization.
<P>
</PRE>
3 A generic entity referenced in a constant expression in the specification-part of a scoping unit shall have no specific
</TD></TR>
<TR><TD colspan=2>
<PRE>
  procedures defined in that scoping unit, or its host scoping unit, subsequent to the constant expression.
<P>
        NOTE 10.34
<P>
        The following are examples of constant expressions:
<P>
                 3
<P>
                 -3 + 4
<P>
                 ’AB’
<P>
                 ’AB’ // ’CD’
<P>
                 (’AB’ // ’CD’) // ’EF’
<P>
                 SIZE (A)
<P>
                 DIGITS (X) + 4
<P>
                 4.0 * ATAN (1.0)
<P>
                 CEILING (number_of_decimal_digits / LOG10 (REAL (RADIX (0.0))))
<P>
        where A is an explicit-shape array with constant bounds, X is default real, and number_of_decimal_digits
<P>
        is an integer named constant.
<P>
  166                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
  10.2        Assignment
<P>
  10.2.1      Assignment statement
<P>
  10.2.1.1    General form
<P>
  R1032 assignment-stmt                      is   variable = expr
<P>
  C1014 (R1032) The variable shall not be a whole assumed-size array.
<P>
        NOTE 10.35
<P>
        Examples of an assignment statement are:
<P>
                 A = 3.5 + X * Y
<P>
                 I = INT (A)
<P>
</PRE>
1 An assignment-stmt shall meet the requirements of either a defined assignment statement or an intrinsic assign-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ment statement.
<P>
  10.2.1.2    Intrinsic assignment statement
<P>
</PRE>
1 An intrinsic assignment statement is an assignment statement that is not a defined assignment statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
  (10.2.1.4). In an intrinsic assignment statement,
<P>
          (1)   if the variable is polymorphic it shall be allocatable and not a coarray,
<P>
          (2)   if expr is an array then the variable shall also be an array,
<P>
          (3)   the variable and expr shall be conformable unless the variable is an allocatable array that has the
<P>
                same rank as expr and is not a coarray,
<P>
          (4)   if the variable is polymorphic it shall be type compatible with expr; otherwise the declared types of
<P>
                the variable and expr shall conform as specified in Table 10.8,
<P>
          (5)   if the variable is of type character and of ISO 10646, ASCII, or default character kind, expr shall be
<P>
                of ISO 10646, ASCII, or default character kind,
<P>
          (6)   otherwise if the variable is of type character expr shall have the same kind type parameter,
<P>
          (7)   if the variable is of derived type each kind type parameter of the variable shall have the same value
<P>
                as the corresponding kind type parameter of expr, and
<P>
          (8)   if the variable is of derived type each length type parameter of the variable shall have the same value
<P>
                as the corresponding type parameter of expr unless the variable is allocatable, is not a coarray, and
<P>
                its corresponding type parameter is deferred.
<P>
                                  Table 10.8: Intrinsic assignment type conformance
<P>
                                  Type of the variable                Type of expr
<P>
                                          integer                 integer, real, complex
<P>
                                            real                  integer, real, complex
<P>
                                         complex                  integer, real, complex
<P>
                                        character                       character
<P>
                                          logical                         logical
<P>
                                      derived type          same derived type as the variable
<P>
</PRE>
2 If the variable in an intrinsic assignment statement is a coindexed object,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      •  the variable shall not be polymorphic,
<P>
      •  the variable shall not have an allocatable ultimate component,
<P>
      •  the variable shall be conformable with expr, and
<P>
      •  each deferred length type parameter of the variable shall have the same value as the corresponding type
<P>
         parameter of expr.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
167
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
3 If the variable is a pointer, it shall be associated with a definable target such that the type, type parameters,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and shape of the target and expr conform. If the variable is a coarray or a coindexed object, it shall not be an
<P>
  unallocated allocatable variable.
<P>
  10.2.1.3    Interpretation of intrinsic assignments
<P>
</PRE>
1 Execution of an intrinsic assignment causes, in effect, the evaluation of the expression expr and all expressions
</TD></TR>
<TR><TD colspan=2>
<PRE>
  within variable (10.1), the possible conversion of expr to the type and type parameters of the variable (Table
<P>
  10.9), and the definition of the variable with the resulting value. The execution of the assignment shall have
<P>
  the same effect as if the evaluation of expr and the evaluation of all expressions in variable occurred before any
<P>
  portion of the variable is defined by the assignment. The evaluation of expressions within variable shall neither
<P>
  affect nor be affected by the evaluation of expr.
<P>
</PRE>
2 If the variable is a pointer, the value of expr is assigned to the target of the variable.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 If the variable is an unallocated allocatable array, expr shall have the same rank. If the variable is an allocated
<P>
<PRE>
  allocatable variable, it is deallocated if expr is an array of different shape, any corresponding length type parameter
<P>
  values of the variable and expr differ, or the variable is polymorphic and the dynamic type or any corresponding
<P>
  kind type parameter values of the variable and expr differ. If the variable is or becomes an unallocated allocatable
<P>
  variable, it is then allocated with
<P>
      •  the same dynamic type and kind type parameter values as expr if the variable is polymorphic,
<P>
      •  each deferred type parameter equal to the corresponding type parameter of expr,
<P>
      •  the same bounds as before if the variable is an array and expr is scalar, and
<P>
      •  the shape of expr with each lower bound equal to the corresponding element of LBOUND (expr) if expr is
<P>
         an array.
<P>
        NOTE 10.36
<P>
        For example, given the declaration
<P>
                 CHARACTER(:),ALLOCATABLE :: NAME
<P>
        then after the assignment statement
<P>
                 NAME = ’Dr. ’//FIRST_NAME//’ ’//SURNAME
<P>
        NAME will have the length LEN (FIRST_NAME) + LEN (SURNAME) + 5, even if it had previously
<P>
        been unallocated, or allocated with a different length. However, the assignment statement
<P>
                 NAME(:) = ’Dr. ’//FIRST_NAME//’ ’//SURNAME
<P>
        is only conforming if NAME is already allocated at the time of the assignment; the assigned value is
<P>
        truncated or blank padded to the previously allocated length of NAME.
<P>
</PRE>
4 Both variable and expr may contain references to any portion of the variable.
<P>
<PRE>
        NOTE 10.37
<P>
        For example, in the character intrinsic assignment statement:
<P>
                 STRING (2:5) = STRING (1:4)
<P>
        the assignment of the first character of STRING to the second character does not affect the evaluation of
<P>
        STRING (1:4). If the value of STRING prior to the assignment was ’ABCDEF’, the value following the
<P>
        assignment is ’AABCDF’.
<P>
</PRE>
5 If expr is a scalar and the variable is an array, the expr is treated as if it were an array of the same shape as the
<P>
<PRE>
  variable with every element of the array equal to the scalar value of expr.
<P>
  168                                                                     ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 If the variable is an array, the assignment is performed element-by-element on corresponding array elements of
<P>
<PRE>
   the variable and expr.
<P>
        NOTE 10.38
<P>
        For example, if A and B are arrays of the same shape, the array intrinsic assignment
<P>
            A = B
<P>
        assigns the corresponding elements of B to those of A; that is, the first element of B is assigned to the first
<P>
        element of A, the second element of B is assigned to the second element of A, etc.
<P>
        If C is an allocatable array of rank 1, then
<P>
            C = PACK (ARRAY, ARRAY&gt;0)
<P>
        will cause C to contain all the positive elements of ARRAY in array element order; if C is not allocated or
<P>
        is allocated with the wrong size, it will be re-allocated to be of the correct size to hold the result of PACK.
<P>
</PRE>
7 The processor may perform the element-by-element assignment in any order.
<P>
<PRE>
        NOTE 10.39
<P>
        For example, the following program segment results in the values of the elements of array X being reversed:
<P>
            REAL X (10)
<P>
                &#46;&#46;&#46;
<P>
            X (1:10) = X (10:1:-1)
<P>
</PRE>
8 For an intrinsic assignment statement where the variable is of numeric type, the expr can have a different numeric
<P>
<PRE>
   type or kind type parameter, in which case the value of expr is converted to the type and kind type parameter
<P>
   of the variable according to the rules of Table 10.9.
<P>
                           Table 10.9: Numeric conversion and the assignment statement
<P>
                              Type of the variable Value assigned
<P>
                              integer                 INT (expr, KIND = KIND (variable))
<P>
                              real                    REAL (expr, KIND = KIND (variable))
<P>
                              complex                 CMPLX (expr, KIND = KIND (variable))
<P>
                              Note: INT, REAL, CMPLX, and KIND are the generic names
<P>
                                     of functions defined in 16.9.
<P>
</PRE>
9 For an intrinsic assignment statement where the variable is of type logical, the expr can have a different kind
<P>
<PRE>
   type parameter, in which case the value of expr is converted to the kind type parameter of the variable.
<P>
</PRE>
10 For an intrinsic assignment statement where the variable is of type character, the expr can have a different
<P>
<PRE>
   character length parameter in which case the conversion of expr to the length of the variable is as follows.
<P>
          (1)    If the length of the variable is less than that of expr, the value of expr is truncated from the right
<P>
                 until it is the same length as the variable.
<P>
          (2)    If the length of the variable is greater than that of expr, the value of expr is extended on the right
<P>
                 with blanks until it is the same length as the variable.
<P>
</PRE>
11 For an intrinsic assignment statement where the variable is of type character, if expr has a different kind type para-
<P>
<PRE>
   meter, each character c in expr is converted to the kind type parameter of the variable by ACHAR (IACHAR(c),
<P>
   KIND (variable)).
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                             169
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
         NOTE 10.40
<P>
         For nondefault character kinds, the blank padding character is processor dependent. When assigning a char-
<P>
         acter expression to a variable of a different kind, each character of the expression that is not representable
<P>
         in the kind of the variable is replaced by a processor-dependent character.
<P>
</PRE>
12 For an intrinsic assignment of the type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING,
<P>
<PRE>
   or of the type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, the variable becomes undefined
<P>
   if the variable and expr are not on the same image.
<P>
         NOTE 10.41
<P>
         An intrinsic assignment statement for a variable of declared type C_PTR, C_FUNPTR, or TEAM_TYPE
<P>
         cannot involve a coindexed object, see C915, which prevents inappropriate copying from one image to
<P>
         another. However, such copying can occur for a component in a derived-type intrinsic assignment.
<P>
</PRE>
13 An intrinsic assignment where the variable is of derived type is performed as if each component of the variable
<P>
<PRE>
   were assigned from the corresponding component of expr using pointer assignment (10.2.2) for each pointer
<P>
   component, defined assignment for each nonpointer nonallocatable component of a type that has a type-bound
<P>
   defined assignment consistent with the component, intrinsic assignment for each other nonpointer nonallocatable
<P>
   component, and intrinsic assignment for each allocated coarray component. For unallocated coarray components,
<P>
   the corresponding component of the variable shall be unallocated. For a noncoarray allocatable component the
<P>
   following sequence of operations is applied.
<P>
           (1)   If the component of the variable is allocated, it is deallocated.
<P>
           (2)   If the component of the value of expr is allocated, the corresponding component of the variable is
<P>
                 allocated with the same dynamic type and type parameters as the component of the value of expr.
<P>
                 If it is an array, it is allocated with the same bounds. The value of the component of the value of
<P>
                 expr is then assigned to the corresponding component of the variable using defined assignment if the
<P>
                 declared type of the component has a type-bound defined assignment consistent with the component,
<P>
                 and intrinsic assignment for the dynamic type of that component otherwise.
<P>
</PRE>
14 The processor may perform the component-by-component assignment in any order or by any means that has the
<P>
<PRE>
   same effect.
<P>
         NOTE 10.42
<P>
         For an example of a derived-type intrinsic assignment statement, if C and D are of the same derived type
<P>
         with a pointer component P and nonpointer components S, T, U, and V of type integer, logical, character,
<P>
         and another derived type, respectively, the intrinsic assignment
<P>
                  C = D
<P>
         pointer assigns D%P to C%P. It assigns D%S to C%S, D%T to C%T, and D%U to C%U using intrinsic
<P>
         assignment. It assigns D%V to C%V using defined assignment if objects of that type have a compatible
<P>
         type-bound defined assignment, and intrinsic assignment otherwise.
<P>
         NOTE 10.43
<P>
         If an allocatable component of expr is unallocated, the corresponding component of the variable has an
<P>
         allocation status of unallocated after execution of the assignment.
<P>
   10.2.1.4    Defined assignment statement
<P>
</PRE>
1 A defined assignment statement is an assignment statement that is defined by a subroutine and a generic interface
<P>
<PRE>
   (7.5.5, 15.4.3.4.3) that specifies ASSIGNMENT (=).
<P>
</PRE>
2 A subroutine defines the defined assignment x1 = x2 if
<P>
<PRE>
           (1)   the subroutine is specified with a SUBROUTINE (15.6.2.3) or ENTRY (15.6.2.6) statement that specifies
<P>
                 two dummy arguments, d1 and d2 ,
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>170</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>(2)</B> </TD><TD valign=bottom>
either
</TD></TR>
<TR><TD colspan=2>
<PRE>
                 (a)    a generic interface (15.4.3.2) provides the subroutine with a generic-spec of ASSIGNMENT (=),
<P>
                        or
<P>
                 (b)    there is a generic binding (7.5.5) in the declared type of x1 or x2 with a generic-spec of
<P>
                        ASSIGNMENT (=) and there is a corresponding binding to the subroutine in the dynamic
<P>
                        type of x1 or x2 , respectively,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>(3)</B> </TD><TD valign=bottom>
the types of d1 and d2 are compatible with the dynamic types of x1 and x2 , respectively,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>(4)</B> </TD><TD valign=bottom>
the type parameters, if any, of d1 and d2 match the corresponding type parameters of x1 and x2 ,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                 respectively, and
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>(5)</B> </TD><TD valign=bottom>
either
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                 (a)    the ranks of x1 and x2 match those of d1 and d2 or
<P>
                 (b)    the subroutine is elemental, x2 is scalar or has the same rank as x1 , and there is no other
<P>
                        subroutine that defines the assignment.
<P>
</PRE>
3 If d1 or d2 is an array, the shapes of x1 and x2 shall match the shapes of d1 and d2 , respectively. If the subroutine
<P>
<PRE>
  is elemental, x2 shall be conformable with x1 .
<P>
  10.2.1.5     Interpretation of defined assignment statements
<P>
</PRE>
1 The interpretation of a defined assignment is provided by the subroutine that defines it.
</TD></TR>
<TR><TD colspan=2>
2 If the defined assignment is an elemental assignment and the variable in the assignment is an array, the defined
</TD></TR>
<TR><TD colspan=2>
<PRE>
  assignment is performed element-by-element, on corresponding elements of the variable and expr. If expr is a
<P>
  scalar, it is treated as if it were an array of the same shape as the variable with every element of the array equal
<P>
  to the scalar value of expr.
<P>
        NOTE 10.44
<P>
        The rules of defined assignment (15.4.3.4.3), procedure references (15.5), subroutine references (15.5.4), and
<P>
        elemental subroutine arguments (15.8.3) ensure that the defined assignment has the same effect as if the
<P>
        evaluation of all operations in x2 and x1 occurs before any portion of x1 is defined. If an elemental assignment
<P>
        is defined by a pure elemental subroutine, the element assignments can be performed simultaneously or in
<P>
        any order.
<P>
  10.2.2       Pointer assignment
<P>
  10.2.2.1     General
<P>
</PRE>
1 Pointer assignment causes a pointer to become associated with a target or causes its pointer association status
</TD></TR>
<TR><TD colspan=2>
<PRE>
  to become disassociated or undefined. Any previous association between the pointer and a target is broken.
<P>
</PRE>
2 Pointer assignment for a pointer component of a structure may also take place by execution of a derived-type
</TD></TR>
<TR><TD colspan=2>
<PRE>
  intrinsic assignment statement (10.2.1.3).
<P>
  10.2.2.2     Syntax of the pointer assignment statement
<P>
  R1033 pointer-assignment-stmt             is data-pointer-object [ (bounds-spec-list) ] =&gt; data-target
<P>
                                            or data-pointer-object (bounds-remapping-list ) =&gt; data-target
<P>
                                            or proc-pointer-object =&gt; proc-target
<P>
  R1034 data-pointer-object                 is variable-name
<P>
                                            or scalar-variable % data-pointer-component-name
<P>
  C1015 (R1033) If data-target is not unlimited polymorphic, data-pointer-object shall be type compatible (7.3.2.3)
<P>
            with it and the corresponding kind type parameters shall be equal.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              171
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
C1016 (R1033) If data-target is unlimited polymorphic, data-pointer-object shall be unlimited polymorphic, or
<P>
<PRE>
       of a type with the BIND attribute or the SEQUENCE attribute.
<P>
</PRE>
C1017 (R1033) If bounds-spec-list is specified, the number of bounds-specs shall equal the rank of data-pointer-
<P>
<PRE>
       object.
<P>
</PRE>
C1018 (R1033) If bounds-remapping-list is specified, the number of bounds-remappings shall equal the rank of
<P>
<PRE>
       data-pointer-object.
<P>
</PRE>
C1019 (R1033) If bounds-remapping-list is not specified, the ranks of data-pointer-object and data-target shall
<P>
<PRE>
       be the same.
<P>
</PRE>
C1020 (R1033) A coarray data-target shall have the VOLATILE attribute if and only if the data-pointer-object
<P>
<PRE>
       has the VOLATILE attribute.
<P>
</PRE>
C1021 (R1034) A variable-name shall have the POINTER attribute.
<P>
C1022 (R1034) A scalar-variable shall be a data-ref .
<P>
C1023 (R1034) A data-pointer-component-name shall be the name of a component of scalar-variable that is a
<P>
<PRE>
       data pointer.
<P>
</PRE>
C1024 (R1034) A data-pointer-object shall not be a coindexed object.
<TABLE width=100% cellpadding=3><!-- tsb: C1024 (R1034) A data-pointer-object shall not be a coindexed object.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>R1035 bounds-spec</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   lower-bound-expr :
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1036 bounds-remapping</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   lower-bound-expr : upper-bound-expr
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1037 data-target</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   expr
</TD></TR>
<TR><TD colspan=2>
C1025 (R1037) The expr shall be a designator that designates a variable with either the TARGET or POINTER
</TD></TR>
<TR><TD colspan=2>
<PRE>
       attribute and is not an array section with a vector subscript, or it shall be a reference to a function that
<P>
       returns a data pointer.
<P>
</PRE>
C1026 (R1037) A data-target shall not be a coindexed object.
</TD></TR>
<TR><TD colspan=2>
<PRE>
    NOTE 10.45
<P>
    A data pointer and its target are always on the same image. A coarray can be of a derived type with pointer
<P>
    or allocatable subcomponents. For example, if PTR is a pointer component, and Z%PTR on image P has
<P>
    been associated with a target by execution of an ALLOCATE statement or a pointer assignment on image
<P>
    P, Z[P]%PTR will be a reference to that target.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1038 proc-pointer-object</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is proc-pointer-name
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                           or proc-component-ref
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1039 proc-component-ref</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   scalar-variable % procedure-component-name
</TD></TR>
<TR><TD colspan=2>
C1027 (R1039) The scalar-variable shall be a data-ref that is not a coindexed object.
</TD></TR>
<TR><TD colspan=2>
C1028 (R1039) The procedure-component-name shall be the name of a procedure pointer component of the
</TD></TR>
<TR><TD colspan=2>
<PRE>
       declared type of scalar-variable.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1040 proc-target</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is expr
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                           or procedure-name
<P>
                                           or proc-component-ref
<P>
</PRE>
C1029 (R1040) An expr shall be a reference to a function whose result is a procedure pointer.
</TD></TR>
<TR><TD colspan=2>
C1030 (R1040) A procedure-name shall be the name of an internal, module, or dummy procedure, a procedure
</TD></TR>
<TR><TD colspan=2>
<PRE>
       pointer, a specific intrinsic function listed in Table 16.2, or an external procedure that is accessed by use or host
<P>
       association, referenced in the scoping unit as a procedure, or that has the EXTERNAL attribute.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>172</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
C1031 (R1040) The proc-target shall not be a nonintrinsic elemental procedure.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
1 In a pointer assignment statement, data-pointer-object or proc-pointer-object denotes the pointer object and
<P>
<PRE>
   data-target or proc-target denotes the pointer target.
<P>
</PRE>
2 For pointer assignment performed by a derived-type intrinsic assignment statement, the pointer object is the
<P>
<PRE>
   pointer component of the variable and the pointer target is the corresponding component of expr.
<P>
   10.2.2.3    Data pointer assignment
<P>
</PRE>
1 If the pointer object is not polymorphic (7.3.2.3) and the pointer target is polymorphic with dynamic type that
<P>
<PRE>
   differs from its declared type, the assignment target is the ancestor component of the pointer target that has the
<P>
   type of the pointer object. Otherwise, the assignment target is the pointer target.
<P>
</PRE>
2 If the pointer target is not a pointer, the pointer object becomes pointer associated with the assignment target;
<P>
<PRE>
   if the pointer target is a pointer with a target that is not on the same image, the pointer association status of the
<P>
   pointer object becomes undefined. Otherwise, the pointer association status of the pointer object becomes that
<P>
   of the pointer target; if the pointer target is associated with an object, the pointer object becomes associated
<P>
   with the assignment target. If the pointer target is allocatable, it shall be allocated.
<P>
         NOTE 10.46
<P>
         A pointer assignment statement is not permitted to involve a coindexed pointer or target, see C1024 and
<P>
         C1026. This prevents a pointer assignment statement from associating a pointer with a target on another
<P>
         image. If such an association would otherwise be implied, the association status of the pointer becomes
<P>
         undefined. For example, a derived-type intrinsic assignment where the variable and expr are on different
<P>
         images and the variable has an ultimate pointer component.
<P>
</PRE>
3 If the pointer object is polymorphic, it assumes the dynamic type of the pointer target. If the pointer object is
<P>
<PRE>
   of a type with the BIND attribute or the SEQUENCE attribute, the dynamic type of the pointer target shall be
<P>
   that type.
<P>
</PRE>
4 If the pointer target is a disassociated pointer, all nondeferred type parameters of the declared type of the pointer
<P>
<PRE>
   object that correspond to nondeferred type parameters of the pointer target shall have the same values as the
<P>
   corresponding type parameters of the pointer target.
<P>
</PRE>
5 Otherwise, all nondeferred type parameters of the declared type of the pointer object shall have the same values
<P>
<PRE>
   as the corresponding type parameters of the pointer target.
<P>
</PRE>
6 If the pointer object has nondeferred type parameters that correspond to deferred type parameters of the pointer
<P>
<PRE>
   target, the pointer target shall not be a pointer with undefined association status.
<P>
</PRE>
7 If the pointer object has the CONTIGUOUS attribute, the pointer target shall be contiguous.
<P>
8 If the target of a pointer is a coarray, the pointer shall have the VOLATILE attribute if and only if the coarray
<P>
<PRE>
   has the VOLATILE attribute.
<P>
</PRE>
9 If bounds-remapping-list appears, it specifies the upper and lower bounds of each dimension of the pointer,
<P>
<PRE>
   and thus the extents; the pointer target shall be simply contiguous (9.5.4) or of rank one, and shall not be a
<P>
   disassociated or undefined pointer. The number of elements of the pointer target shall not be less than the
<P>
   number implied by the bounds-remapping-list. The elements of the pointer object are associated with those of
<P>
   the pointer target, in array element order; if the pointer target has more elements than specified for the pointer
<P>
   object, the remaining elements are not associated with the pointer object.
<P>
</PRE>
10 If no bounds-remapping-list appears, the extent of a dimension of the pointer object is the extent of the corres-
<P>
<PRE>
   ponding dimension of the pointer target. If bounds-spec-list appears, it specifies the lower bounds; otherwise,
<P>
   the lower bound of each dimension is the result of the intrinsic function LBOUND (16.9.109) applied to the
<P>
   corresponding dimension of the pointer target. The upper bound of each dimension is one less than the sum of
<P>
   the lower bound and the extent.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                           173
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>10.2.2.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Procedure pointer assignment
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
1 If the pointer target is not a pointer, the pointer object becomes pointer associated with the pointer target.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Otherwise, the pointer association status of the pointer object becomes that of the pointer target; if the pointer
<P>
  target is associated with a procedure, the pointer object becomes associated with the same procedure.
<P>
</PRE>
2 The host instance (15.6.2.4) of an associated procedure pointer is the host instance of its target.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 If the pointer object has an explicit interface, its characteristics shall be the same as the pointer target except
<P>
<PRE>
  that the pointer target may be pure even if the pointer object is not pure and the pointer target may be an
<P>
  elemental intrinsic procedure even if the pointer object is not elemental.
<P>
</PRE>
4 If the characteristics of the pointer object or the pointer target are such that an explicit interface is required,
<P>
<PRE>
  both the pointer object and the pointer target shall have an explicit interface.
<P>
</PRE>
5 If the pointer object has an implicit interface and is explicitly typed or referenced as a function, the pointer target
<P>
<PRE>
  shall be a function. If the pointer object has an implicit interface and is referenced as a subroutine, the pointer
<P>
  target shall be a subroutine.
<P>
</PRE>
6 If the pointer object is a function with an implicit interface, the pointer target shall be a function with the same
<P>
<PRE>
  type; corresponding type parameters shall have the same value.
<P>
</PRE>
7 If procedure-name is a specific procedure name that is also a generic name, only the specific procedure is associated
<P>
<PRE>
  with the pointer object.
<P>
  10.2.2.5     Examples
<P>
        NOTE 10.47
<P>
        The following are examples of pointer assignment statements. (See NOTE 15.14 for declarations of P and
<P>
        BESSEL.)
<P>
                 NEW_NODE % LEFT =&gt; CURRENT_NODE
<P>
                 SIMPLE_NAME =&gt; TARGET_STRUCTURE % SUBSTRUCT % COMPONENT
<P>
                 PTR =&gt; NULL ( )
<P>
                 ROW =&gt; MAT2D (N, :)
<P>
                 WINDOW =&gt; MAT2D (I-1:I+1, J-1:J+1)
<P>
                 POINTER_OBJECT =&gt; POINTER_FUNCTION (ARG_1, ARG_2)
<P>
                 EVERY_OTHER =&gt; VECTOR (1:N:2)
<P>
                 WINDOW2 (0:, 0:) =&gt; MAT2D (ML:MU, NL:NU)
<P>
                 ! P is a procedure pointer and BESSEL is a procedure with a
<P>
                 ! compatible interface.
<P>
                 P =&gt; BESSEL
<P>
                 ! Likewise for a structure component.
<P>
                 STRUCT % COMPONENT =&gt; BESSEL
<P>
        NOTE 10.48
<P>
        It is possible to obtain different-rank views of parts of an object by specifying upper bounds in pointer
<P>
        assignment statements. This requires that the object be either rank one or contiguous. Consider the
<P>
        following example, in which a matrix is under consideration. The matrix is stored as a rank-one object in
<P>
        MYDATA because its diagonal is needed for some reason – the diagonal cannot be gotten as a single object
<P>
        from a rank-two representation. The matrix is represented as a rank-two view of MYDATA.
<P>
                 real, target :: MYDATA ( NR*NC )               ! An automatic array
<P>
                 real, pointer :: MATRIX ( :, : )               ! A rank-two view of MYDATA
<P>
                 real, pointer :: VIEW_DIAG ( : )
<P>
                 MATRIX (1:NR, 1:NC) =&gt; MYDATA                  ! The MATRIX view of the data
<P>
  174                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 10.48 (cont.)
<P>
                VIEW_DIAG =&gt; MYDATA (1::NR+1)                 ! The diagonal of MATRIX
<P>
        Rows, columns, or blocks of the matrix can be accessed as sections of MATRIX.
<P>
        Rank remapping can be applied to CONTIGUOUS arrays, for example:
<P>
                REAL, CONTIGUOUS, POINTER :: A (:)
<P>
                REAL, CONTIGUOUS, TARGET :: B (:,:) ! Dummy argument
<P>
                A (1:SIZE(B)) =&gt; B                            ! Linear view of a rank-2 array
<P>
  10.2.3      Masked array assignment – WHERE
<P>
  10.2.3.1    General form of the masked array assignment
<P>
</PRE>
1 A masked array assignment is either a WHERE statement or a WHERE construct. It is used to mask the
<P>
<PRE>
  evaluation of expressions and assignment of values in array assignment statements, according to the value of a
<P>
  logical array expression.
<P>
  R1041 where-stmt                       is WHERE ( mask-expr ) where-assignment-stmt
<P>
  R1042 where-construct                  is where-construct-stmt
<P>
                                                      [ where-body-construct ] &#46;&#46;&#46;
<P>
                                                 [ masked-elsewhere-stmt
<P>
                                                      [ where-body-construct ] &#46;&#46;&#46; ] ...
<P>
                                                 [ elsewhere-stmt
<P>
                                                      [ where-body-construct ] &#46;&#46;&#46; ]
<P>
                                                 end-where-stmt
<P>
  R1043 where-construct-stmt             is [where-construct-name:] WHERE ( mask-expr )
<P>
  R1044 where-body-construct             is where-assignment-stmt
<P>
                                         or where-stmt
<P>
                                         or where-construct
<P>
  R1045 where-assignment-stmt            is assignment-stmt
<P>
  R1046 mask-expr                        is logical-expr
<P>
  R1047 masked-elsewhere-stmt            is ELSEWHERE (mask-expr) [where-construct-name]
<P>
  R1048 elsewhere-stmt                   is ELSEWHERE [where-construct-name]
<P>
  R1049 end-where-stmt                   is END WHERE [where-construct-name]
<P>
  C1032 (R1045) A where-assignment-stmt that is a defined assignment shall be elemental.
<P>
  C1033 (R1042) If the where-construct-stmt is identified by a where-construct-name, the corresponding end-
<P>
           where-stmt shall specify the same where-construct-name. If the where-construct-stmt is not identified by
<P>
           a where-construct-name, the corresponding end-where-stmt shall not specify a where-construct-name. If
<P>
           an elsewhere-stmt or a masked-elsewhere-stmt is identified by a where-construct-name, the corresponding
<P>
           where-construct-stmt shall specify the same where-construct-name.
<P>
  C1034 (R1044) A statement that is part of a where-body-construct shall not be a branch target statement.
<P>
</PRE>
2 If a where-construct contains a where-stmt, a masked-elsewhere-stmt, or another where-construct then each mask-
<P>
<PRE>
  expr within the where-construct shall have the same shape. In each where-assignment-stmt, the mask-expr and
<P>
  the variable being defined shall be arrays of the same shape.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        175
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 10.49
<P>
       Examples of a masked array assignment are:
<P>
                WHERE (TEMP &gt; 100.0) TEMP = TEMP - REDUCE_TEMP
<P>
                WHERE (PRESSURE &lt;= 1.0)
<P>
                   PRESSURE = PRESSURE + INC_PRESSURE
<P>
                   TEMP = TEMP - 5.0
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; ELSEWHERE</H4>
</A>
<BLOCKQUOTE>
<P>
RAINING = .TRUE.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END WHERE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>10.2.3.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Interpretation of masked array assignments
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 When a WHERE statement or a where-construct-stmt is executed, a control mask is established. In addition,
<P>
<PRE>
  when a WHERE construct statement is executed, a pending control mask is established. If the statement does
<P>
  not appear as part of a where-body-construct, the mask-expr of the statement is evaluated, and the control mask is
<P>
  established to be the value of mask-expr. The pending control mask is established to have the value .NOT. mask-
<P>
  expr upon execution of a WHERE construct statement that does not appear as part of a where-body-construct.
<P>
  The mask-expr is evaluated only once.
<P>
</PRE>
2 Each statement in a WHERE construct is executed in sequence.
<BLOCKQUOTE>
<P>
3 Upon execution of a masked-elsewhere-stmt, the following actions take place in sequence.
<P>
<PRE>
         (1)   The control mask mc is established to have the value of the pending control mask.
<P>
         (2)   The pending control mask is established to have the value mc .AND. (.NOT. mask-expr).
<P>
         (3)   The control mask mc is established to have the value mc .AND. mask-expr.
<P>
</PRE>
4 The mask-expr is evaluated at most once.
<P>
5 Upon execution of an ELSEWHERE statement, the control mask is established to have the value of the pending
<P>
<PRE>
  control mask. No new pending control mask value is established.
<P>
</PRE>
6 Upon execution of an ENDWHERE statement, the control mask and pending control mask are established to
<P>
<PRE>
  have the values they had prior to the execution of the corresponding WHERE construct statement. Following
<P>
  the execution of a WHERE statement that appears as a where-body-construct, the control mask is established to
<P>
  have the value it had prior to the execution of the WHERE statement.
<P>
       NOTE 10.50
<P>
       The establishment of control masks and the pending control mask is illustrated with the following example:
<P>
                WHERE(cond1)             ! Statement 1
<P>
                  &#46;&#46;&#46;
<P>
                ELSEWHERE(cond2)         ! Statement 2
<P>
                  &#46;&#46;&#46;
<P>
                ELSEWHERE                ! Statement 3
<P>
                  &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END WHERE</H4>
</A>
<BLOCKQUOTE>
<P>
Following execution of statement 1, the control mask has the value cond1 and the pending
<TABLE cellpadding=3><!-- tsb: Following execution of statement 1, the control mask has the value cond1 and the pending
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>control mask has the value .NOT. cond1.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Following execution of statement 2, the control
</TD></TR>
<TR></TR></TABLE>mask has the value (.NOT. cond1) .AND. cond2 and the pending control mask has the value
<P>
(.NOT. cond1) .AND. (.NOT. cond2). Following execution of statement 3, the control mask has the value
<P>
(.NOT. cond1) .AND. (.NOT. cond2). The false condition values are propagated through the execution of
<P>
the masked ELSEWHERE statement.
</BLOCKQUOTE>
<P>
7 Upon execution of a WHERE construct statement that is part of a where-body-construct, the pending control
<P>
<PRE>
  mask is established to have the value mc .AND. (.NOT. mask-expr). The control mask is then established to
<P>
  have the value mc .AND. mask-expr. The mask-expr is evaluated at most once.
<P>
  176                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 Upon execution of a WHERE statement that is part of a where-body-construct, the control mask is established
<P>
<PRE>
   to have the value mc .AND. mask-expr. The pending control mask is not altered.
<P>
</PRE>
9 If a nonelemental function reference occurs in the expr or variable of a where-assignment-stmt or in a mask-expr,
<P>
<PRE>
   the function is evaluated without any masked control; that is, all of its argument expressions are fully evaluated
<P>
   and the function is fully evaluated. If the result is an array and the reference is not within the argument list
<P>
   of a nonelemental function, elements corresponding to true values in the control mask are selected for use in
<P>
   evaluating the expr, variable or mask-expr.
<P>
</PRE>
10 If an elemental operation or function reference occurs in the expr or variable of a where-assignment-stmt or in a
<P>
<PRE>
   mask-expr, and is not within the argument list of a nonelemental function reference, the operation is performed
<P>
   or the function is evaluated only for the elements corresponding to true values of the control mask.
<P>
</PRE>
11 If an array constructor appears in a where-assignment-stmt or in a mask-expr, the array constructor is evaluated
<P>
<PRE>
   without any masked control and then the where-assignment-stmt is executed or the mask-expr is evaluated.
<P>
</PRE>
12 When a where-assignment-stmt is executed, the values of expr that correspond to true values of the control mask
<P>
<PRE>
   are assigned to the corresponding elements of the variable.
<P>
</PRE>
13 The value of the control mask is established by the execution of a WHERE statement, a WHERE construct
<P>
<PRE>
   statement, an ELSEWHERE statement, a masked ELSEWHERE statement, or an ENDWHERE statement.
<P>
   Subsequent changes to the value of entities in a mask-expr have no effect on the value of the control mask. The
<P>
   execution of a function reference in the mask expression of a WHERE statement is permitted to affect entities in
<P>
   the assignment statement.
<P>
         NOTE 10.51
<P>
         Examples of function references in masked array assignments are:
<P>
            WHERE (A &gt; 0.0)
<P>
                 A = LOG (A)                      ! LOG is invoked only for positive elements.
<P>
                 A = A / SUM (LOG (A))            ! LOG is invoked for all elements
<P>
                                                  ! because SUM is transformational
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END WHERE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>10.2.4</B> </TD><TD valign=bottom>
FORALL
</TD></TR>
<TR valign=top><TD colspan=2>
<B>10.2.4.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Form of the FORALL Construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The FORALL construct allows multiple assignments, masked array (WHERE) assignments, and nested FORALL constructs and
<P>
<PRE>
   statements to be controlled by a single concurrent-control-list and scalar-mask-expr.
<P>
   R1050    forall-construct                   is  forall-construct-stmt
<P>
                                                         [forall-body-construct ] &#46;&#46;&#46;
<P>
                                                         end-forall-stmt
<P>
   R1051    forall-construct-stmt              is  [forall-construct-name :] FORALL concurrent-header
<P>
   R1052    forall-body-construct              is  forall-assignment-stmt
<P>
                                               or  where-stmt
<P>
                                               or  where-construct
<P>
                                               or  forall-construct
<P>
                                               or  forall-stmt
<P>
   R1053    forall-assignment-stmt             is  assignment-stmt
<P>
                                               or  pointer-assignment-stmt
<P>
   R1054    end-forall-stmt                    is  END FORALL [forall-construct-name ]
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                          177
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C1035</B> </TD><TD valign=bottom>
(R1054) If the forall-construct-stmt has a forall-construct-name, the end-forall-stmt shall have the same forall-construct-
</TD></TR>
<TR><TD colspan=2>
<PRE>
              name. If the end-forall-stmt has a forall-construct-name, the forall-construct-stmt shall have the same forall-construct-
<P>
              name.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C1036</B> </TD><TD valign=bottom>
(R1052) A statement in a forall-body-construct shall not define an index-name of the forall-construct.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C1037</B> </TD><TD valign=bottom>
(R1052) Any procedure referenced in a forall-body-construct, including one referenced by a defined operation, assignment,
</TD></TR>
<TR><TD colspan=2>
<PRE>
              or finalization, shall be a pure procedure.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C1038</B> </TD><TD valign=bottom>
(R1052) A forall-body-construct shall not be a branch target.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
2 The scope and attributes of an index-name in a concurrent-header in a FORALL construct or statement are described in 19.4.
<P>
<PRE>
  10.2.4.2       Execution of the FORALL construct
<P>
  10.2.4.2.1         Execution stages
<P>
</PRE>
1 There are three stages in the execution of a FORALL construct:
<P>
<PRE>
           (1)      determination of the values for index-name variables,
<P>
           (2)      evaluation of the scalar-mask-expr, and
<P>
           (3)      execution of the FORALL body constructs.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>10.2.4.2.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Determination of the values for index variables
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The values of the index variables are determined as they are for the DO CONCURRENT statement (11.1.7.4.2).
<P>
<PRE>
  10.2.4.2.3         Evaluation of the mask expression
<P>
</PRE>
1 The mask expression is evaluated as it is for the DO CONCURRENT statement (11.1.7.4.2).
<P>
<PRE>
  10.2.4.2.4         Execution of the FORALL body constructs
<P>
</PRE>
1 The forall-body-constructs are executed in the order in which they appear. Each construct is executed for all active combinations of
<P>
<PRE>
  the index-name values with the following interpretation:
<P>
</PRE>
2 Execution of a forall-assignment-stmt that is an assignment-stmt causes the evaluation of expr and all expressions within variable
<P>
<PRE>
  for all active combinations of index-name values. These evaluations may be done in any order. After all these evaluations have been
<P>
  performed, each expr value is assigned to the corresponding variable. The assignments may occur in any order.
<P>
</PRE>
3 Execution of a forall-assignment-stmt that is a pointer-assignment-stmt causes the evaluation of all expressions within data-target
<P>
<PRE>
  and data-pointer-object or proc-target and proc-pointer-object, the determination of any pointers within data-pointer-object or proc-
<P>
  pointer-object, and the determination of the target for all active combinations of index-name values. These evaluations may be done
<P>
  in any order. After all these evaluations have been performed, each data-pointer-object or proc-pointer-object is associated with the
<P>
  corresponding target. These associations may occur in any order.
<P>
</PRE>
4 In a forall-assignment-stmt, a defined assignment subroutine shall not reference any variable that becomes defined by the statement.
<P>
<PRE>
         NOTE 10.52
<P>
         If a variable defined in an assignment statement within a FORALL construct is referenced in a later statement in that construct,
<P>
         the later statement uses the value(s) computed in the preceding assignment statement, not the value(s) the variable had prior
<P>
         to execution of the FORALL.
<P>
</PRE>
5 Each statement in a where-construct (10.2.3) within a forall-construct is executed in sequence. When a where-stmt, where-construct-
<P>
<PRE>
  stmt or masked-elsewhere-stmt is executed, the statement’s mask-expr is evaluated for all active combinations of index-name values
<P>
  as determined by the outer forall-constructs, masked by any control mask corresponding to outer where-constructs. Any where-
<P>
  assignment-stmt is executed for all active combinations of index-name values, masked by the control mask in effect for the where-
<P>
  assignment-stmt.
<P>
</PRE>
6 Execution of a forall-stmt or forall-construct causes the evaluation of the concurrent-limit and concurrent-step expressions in the
<P>
<PRE>
  concurrent-control-list for all active combinations of the index-name values of the outer FORALL construct. The set of combinations
<P>
  178                                                                           ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
  of index-name values for the inner FORALL is the union of the sets defined by these limits and steps for each active combination of the
<P>
  outer index-name values; it also includes the outer index-name values. The scalar-mask-expr is then evaluated for all combinations
<P>
  of the index-name values of the inner construct to produce a set of active combinations for the inner construct. If there is no
<P>
  scalar-mask-expr, it is as if it appeared with the value true. Each statement in the inner FORALL is then executed for each active
<P>
  combination of the index-name values.
<P>
  10.2.4.3      The FORALL statement
<P>
</PRE>
1 The FORALL statement allows a single assignment statement or pointer assignment statement to be controlled by a set of index
<P>
<PRE>
  values and an optional mask expression.
<P>
  R1055      forall-stmt                       is   FORALL concurrent-header forall-assignment-stmt
<P>
</PRE>
2 A FORALL statement is equivalent to a FORALL construct containing a single forall-body-construct that is a forall-assignment-stmt.
<BLOCKQUOTE>
<P>
3 The scope of an index-name in a forall-stmt is the statement itself (19.4).
<P>
<PRE>
  10.2.4.4      Restrictions on FORALL constructs and statements
<P>
</PRE>
1 A many-to-one assignment is more than one assignment to the same object, or association of more than one target with the same
<P>
<PRE>
  pointer, whether the object is referenced directly or indirectly through a pointer. A many-to-one assignment shall not occur within
<P>
  a single statement in a FORALL construct or statement. It is possible to assign or pointer-assign to the same object in different
<P>
  assignment or pointer assignment statements in a FORALL construct.
<P>
        NOTE 10.53
<P>
        The appearance of each index-name in the identification of the left-hand side of an assignment statement is helpful in eliminating
<P>
        many-to-one assignments, but it is not sufficient to guarantee there will be none. For example, the following is allowed
<P>
             FORALL (I = 1:10)
<P>
                  A (INDEX (I)) = B(I)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FORALL</H4>
</A>
<BLOCKQUOTE>
<P>
if and only if <B>INDEX</B>(1:10) contains no repeated values.
</BLOCKQUOTE>
<P>
2 Within the scope of a FORALL construct, a nested FORALL statement or FORALL construct shall not have the same index-name.
<P>
<PRE>
  The concurrent-header expressions within a nested FORALL may depend on the values of outer index-name variables.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                               179
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>180</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
11 Execution control
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1</B> </TD><TD valign=bottom>
Executable constructs containing blocks
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>11.1.1</B> </TD><TD valign=bottom>
Blocks
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The following are executable constructs that contain blocks:
</TD></TR>
<TR><TD colspan=2>
<PRE>
      •  ASSOCIATE construct;
<P>
      •  BLOCK construct;
<P>
      •  CHANGE TEAM construct;
<P>
      •  CRITICAL construct;
<P>
      •  DO construct;
<P>
      •  IF construct;
<P>
      •  SELECT CASE construct;
<P>
      •  SELECT RANK construct;
<P>
      •  SELECT TYPE construct.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>R1101 block</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  [ execution-part-construct ] &#46;&#46;&#46;
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>2 Executable constructs may be used to control which blocks of a program are executed or how many times a block
<P>
<PRE>
  is executed. Blocks are always bounded by statements that are particular to the construct in which they are
<P>
  embedded.
<P>
        NOTE 11.1
<P>
        An example of a construct containing a block is:
<P>
        IF (A &gt; 0.0) THEN
<P>
            B = SQRT (A) ! These two statements
<P>
            C = LOG (A)     ! form a block.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.2</B> </TD><TD valign=bottom>
Rules governing blocks
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11.1.2.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Control flow in blocks
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Transfer of control to the interior of a block from outside the block is prohibited, except for the return from a
<P>
<PRE>
  procedure invoked within the block. Transfers within a block and transfers from the interior of a block to outside
<P>
  the block may occur.
<P>
</PRE>
2 Subroutine and function references (15.5.3, 15.5.4) may appear in a block.
<P>
<PRE>
  11.1.2.2    Execution of a block
<P>
</PRE>
1 Execution of a block begins with the execution of the first executable construct in the block.
<BLOCKQUOTE>
<P>
2 Execution of the block is completed when
<P>
<PRE>
      • execution of the last executable construct in the block completes without branching to a statement within
<P>
         the block,
<P>
      • a branch (11.2) within the block that has a branch target outside the block occurs,
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
181
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
      • a RETURN statement within the block is executed, or
<P>
      • an EXIT statement or CYCLE statement statement that belongs to a construct that contains the block is
<P>
         executed.
<P>
        NOTE 11.2
<P>
        The action that takes place at the terminal boundary depends on the particular construct and on the block
<P>
        within that construct.
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.3</B> </TD><TD valign=bottom>
ASSOCIATE construct
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11.1.3.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Purpose and form of the ASSOCIATE construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The ASSOCIATE construct associates named entities with expressions or variables during the execution of its
<P>
<PRE>
  block. These named construct entities (19.4) are associating entities (19.5.1.6). The names are associate names.
<P>
  R1102 associate-construct              is  associate-stmt
<P>
                                                  block
<P>
                                                  end-associate-stmt
<P>
  R1103 associate-stmt                   is  [ associate-construct-name : ] ASSOCIATE
<P>
                                                (association-list )
<P>
  R1104 association                      is  associate-name =&gt; selector
<P>
  R1105 selector                         is expr
<P>
                                         or variable
<P>
  C1101 (R1104) If selector is not a variable or is a variable that has a vector subscript, neither associate-name
<P>
           nor any subobject thereof shall appear in a variable definition context (19.6.7).
<P>
  C1102 (R1104) An associate-name shall not be the same as another associate-name in the same associate-stmt.
<P>
  C1103 (R1105) variable shall not be a coindexed object.
<P>
  C1104 (R1105) expr shall not be a variable.
<P>
  C1105 (R1105) expr shall not be a designator of a procedure pointer or a function reference that returns a
<P>
           procedure pointer.
<P>
  R1106 end-associate-stmt               is  END ASSOCIATE [ associate-construct-name ]
<P>
  C1106 (R1106) If the associate-stmt of an associate-construct specifies an associate-construct-name, the corres-
<P>
           ponding end-associate-stmt shall specify the same associate-construct-name. If the associate-stmt of an
<P>
           associate-construct does not specify an associate-construct-name, the corresponding end-associate-stmt
<P>
           shall not specify an associate-construct-name.
<P>
  11.1.3.2    Execution of the ASSOCIATE construct
<P>
</PRE>
1 Execution of an ASSOCIATE construct causes evaluation of every expression within every selector that is a
<P>
<PRE>
  variable designator and evaluation of every other selector, followed by execution of its block. During execution of
<P>
  that block each associate name identifies an entity which is associated (19.5.1.6) with the corresponding selector.
<P>
  The associating entity assumes the declared type and type parameters of the selector. If and only if the selector
<P>
  is polymorphic, the associating entity is polymorphic.
<P>
</PRE>
2 The other attributes of the associating entity are described in 11.1.3.3.
<BLOCKQUOTE>
<P>
3 It is permissible to branch to an end-associate-stmt only from within its ASSOCIATE construct.
<P>
<PRE>
  182                                                                ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  11.1.3.3    Other attributes of associate names
<P>
</PRE>
1 Within an ASSOCIATE, CHANGE TEAM, or SELECT TYPE construct, each associating entity has the same
<P>
<PRE>
  rank as its associated selector. The lower bound of each dimension is the result of the intrinsic function LBOUND
<P>
  (16.9.109) applied to the corresponding dimension of selector. The upper bound of each dimension is one less
<P>
  than the sum of the lower bound and the extent. The associating entity does not have the ALLOCATABLE or
<P>
  POINTER attributes; it has the TARGET attribute if and only if the selector is a variable and has either the
<P>
  TARGET or POINTER attribute.
<P>
</PRE>
2 Within an ASSOCIATE, SELECT RANK, or SELECT TYPE construct, each associating entity has the same
<P>
<PRE>
  corank as its associated selector. If the selector is a coarray, the cobounds of each codimension of the associating
<P>
  entity are the same as those of the selector.
<P>
</PRE>
3 Within a CHANGE TEAM construct, the associating entity is a coarray. Its corank and cobounds are as specified
<P>
<PRE>
  in its codimension-decl.
<P>
</PRE>
4 Within an ASSOCIATE, CHANGE TEAM, SELECT RANK, or SELECT TYPE construct, the associating
<P>
<PRE>
  entity has the ASYNCHRONOUS or VOLATILE attribute if and only if the selector is a variable and has the
<P>
  attribute. If the associating entity is polymorphic, it assumes the dynamic type and type parameter values of the
<P>
  selector. If the selector has the OPTIONAL attribute, it shall be present. The associating entity is contiguous if
<P>
  and only if the selector is contiguous.
<P>
</PRE>
5 The associating entity itself is a variable, but if the selector is not a definable variable, the associating entity
<P>
<PRE>
  is not definable and shall not be defined or become undefined. If a selector is not permitted to appear in
<P>
  a variable definition context (19.6.7), neither the associate name nor any subobject thereof shall appear in a
<P>
  variable definition context.
<P>
  11.1.3.4    Examples of the ASSOCIATE construct
<P>
        NOTE 11.3
<P>
        The following example illustrates an association with an expression.
<P>
        ASSOCIATE ( Z =&gt; EXP (-(X**2+Y**2)) * COS (THETA) )
<P>
          PRINT *, A+Z, A-Z
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END ASSOCIATE</H4>
</A>
<BLOCKQUOTE>
<P>
The following example illustrates an association with a derived-type variable.
<P>
ASSOCIATE ( XC =&gt; <B>AX%B</B>(I,J)%C )
<P>
<PRE>
          XC%DV = XC%DV + PRODUCT (XC%EV(1:N))
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END ASSOCIATE</H4>
</A>
<BLOCKQUOTE>
<P>
The following example illustrates association with an array section.
<P>
ASSOCIATE ( ARRAY =&gt; <B>AX%B</B>(I,:)%C )
<P>
<PRE>
          ARRAY(N)%EV = ARRAY(N-1)%EV
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END ASSOCIATE</H4>
</A>
<BLOCKQUOTE>
<P>
The following example illustrates multiple associations.
<P>
ASSOCIATE ( W =&gt; <B>RESULT</B>(I,J)%W, ZX =&gt; <B>AX%B</B>(I,J)%D, ZY =&gt; <B>AY%B</B>(I,J)%D )
<P>
<PRE>
          W = ZX*X + ZY*Y
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END ASSOCIATE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.4</B> </TD><TD valign=bottom>
BLOCK construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The BLOCK construct is an executable construct that may contain declarations.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          183
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1107 block-construct                  is  block-stmt
<P>
                                                   [ block-specification-part ]
<P>
                                                   block
<P>
                                                   end-block-stmt
<P>
  R1108 block-stmt                       is  [ block-construct-name : ] BLOCK
<P>
  R1109 block-specification-part         is  [ use-stmt ]&#46;&#46;&#46;
<P>
                                             [ import-stmt ] &#46;&#46;&#46;
<P>
                                             [ [ declaration-construct ] &#46;&#46;&#46;
<P>
                                                specification-construct ]
<P>
  R1110 end-block-stmt                   is  END BLOCK [ block-construct-name ]
<P>
  C1107 (R1107) A block-specification-part shall not contain a COMMON, EQUIVALENCE, INTENT, NAMELIST,
<P>
           OPTIONAL, statement function, or VALUE statement.
<P>
  C1108 (R1107) A SAVE statement in a BLOCK construct shall contain a saved-entity-list that does not specify a
<P>
           common-block-name .
<P>
  C1109 (R1107) If the block-stmt of a block-construct specifies a block-construct-name, the corresponding end-
<P>
           block-stmt shall specify the same block-construct-name. If the block-stmt does not specify a block-
<P>
           construct-name, the corresponding end-block-stmt shall not specify a block-construct-name.
<P>
</PRE>
2 Except for the ASYNCHRONOUS and VOLATILE statements, specifications in a BLOCK construct declare
<P>
<PRE>
  construct entities whose scope is that of the BLOCK construct (19.4). The appearance of the name of an object
<P>
  that is not a construct entity in an ASYNCHRONOUS or VOLATILE statement in a BLOCK construct specifies
<P>
  that the object has the attribute within the construct even if it does not have the attribute outside the construct.
<P>
</PRE>
3 Execution of a BLOCK construct causes evaluation of the specification expressions within its specification part
<P>
<PRE>
  in a processor-dependent order, followed by execution of its block.
<P>
</PRE>
4 It is permissible to branch to an end-block-stmt only from within its BLOCK construct.
<P>
<PRE>
        NOTE 11.4
<P>
        The following is an example of a BLOCK construct.
<P>
               IF (swapxy) THEN
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
REAL (KIND (x)) tmp
<P>
tmp = x
<P>
x = y
<P>
y = tmp
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
Actions on a variable local to a BLOCK construct do not affect any variable of the same name outside the
<P>
construct. For example,
<P>
<PRE>
               F = 254E-2
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; REAL F</H4>
</A>
<BLOCKQUOTE>
<P>
F = 39.37
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
! F is still equal to 254E-2.
</BLOCKQUOTE>
<P>
A SAVE statement outside a BLOCK construct does not affect variables local to the BLOCK construct,
<BLOCKQUOTE>
<P>
because a SAVE statement affects variables in its scoping unit rather than in its inclusive scope. For
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: because a SAVE statement affects variables in its scoping unit rather than in its inclusive scope. For
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>184</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 11.4 (cont.)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
example,
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE S</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SAVE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>REAL X</B> </TD><TD valign=bottom>
! Not saved.
</TD></TR>
<TR><TD colspan=2>
REAL,SAVE :: <B>Y</B>(100) ! SAVE attribute is allowed.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>Z = 3</B> </TD><TD valign=bottom>
! Implicitly declared in S, thus saved.
</TD></TR>
<TR></TR></TABLE>&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.5</B> </TD><TD valign=bottom>
CHANGE TEAM construct
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11.1.5.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Purpose and form of the CHANGE TEAM construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The CHANGE TEAM construct changes the current team. Named construct entities (19.4) can be associated
<P>
<PRE>
  (19.5.1.6) with coarrays in the containing scoping unit, in the same way as for the ASSOCIATE construct.
<P>
  R1111 change-team-construct            is  change-team-stmt
<P>
                                                   block
<P>
                                                   end-change-team-stmt
<P>
  R1112 change-team-stmt                 is  [ team-construct-name : ] CHANGE TEAM ( team-value
<P>
                                                 [ , coarray-association-list ] [ , sync-stat-list ] )
<P>
  R1113 coarray-association              is  codimension-decl =&gt; selector
<P>
  R1114 end-change-team-stmt             is  END TEAM [ ( [ sync-stat-list ] ) ] [ team-construct-name ]
<P>
  R1115 team-value                       is  scalar-expr
<P>
  C1110 A branch (11.2) within a CHANGE TEAM construct shall not have a branch target that is outside the
<P>
           construct.
<P>
  C1111 A RETURN statement shall not appear within a CHANGE TEAM construct.
<P>
  C1112 If the change-team-stmt of a change-team-construct specifies a team-construct-name, the corresponding
<P>
           end-change-team-stmt shall specify the same team-construct-name. If the change-team-stmt of a change-
<P>
           team-construct does not specify a team-construct-name, the corresponding end-change-team-stmt shall
<P>
           not specify a team-construct-name.
<P>
  C1113 In a change-team-stmt, a coarray-name in a codimension-decl shall not be the same as a selector, or
<P>
           another coarray-name, in that statement.
<P>
  C1114 A team-value shall be of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
<P>
  C1115 No selector shall appear more than once in a given change-team-stmt.
<P>
  C1116 A selector in a coarray-association shall be a named coarray.
<P>
</PRE>
2 Each coarray-name in a codimension-decl in the CHANGE TEAM statement is an associate name which is
<P>
<PRE>
  associated with the corresponding selector. Each associating entity assumes the type and type parameters of
<P>
  its selector; it is polymorphic if and only if the selector is polymorphic. The other attributes of the associating
<P>
  entities are described in 11.1.3.3.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         185
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  11.1.5.2      Execution of a CHANGE TEAM construct
<P>
</PRE>
1 The team-values on the active images that execute the CHANGE TEAM statement shall be those of team variables
<P>
<PRE>
  defined by corresponding executions of the same FORM TEAM statement (11.6.9). When the CHANGE TEAM
<P>
  statement is executed, the current team shall be the team that was current when those team variables were defined.
<P>
  The current team for the statements of the CHANGE TEAM block is the team identified by the team-value. If
<P>
  team-value is a variable, the variable shall not be defined or become undefined during execution of the CHANGE
<P>
  TEAM construct. A CHANGE TEAM construct completes execution by executing its END TEAM statement,
<P>
  which restores the current team to the original team that was current for the CHANGE TEAM statement.
<P>
</PRE>
2 Execution of a CHANGE TEAM construct causes evaluation of the expressions within each codimension-decl in
<P>
<PRE>
  the CHANGE TEAM statement, followed by execution of its block. Each selector shall be an established coarray
<P>
  when the CHANGE TEAM statement begins execution.
<P>
</PRE>
3 It is permissible to branch to an end-change-team-stmt only from within its CHANGE TEAM construct.
<BLOCKQUOTE>
<P>
4 An allocatable coarray that was allocated immediately before executing a CHANGE TEAM statement shall not
<P>
<PRE>
  be deallocated during execution of the construct. An allocatable coarray that was unallocated immediately before
<P>
  executing a CHANGE TEAM statement, and which is allocated immediately before executing the corresponding
<P>
  END TEAM statement, is deallocated by the execution of the END TEAM statement.
<P>
</PRE>
5 Successful execution of a CHANGE TEAM statement performs an implicit synchronization of all images of the
<P>
<PRE>
  new team that is identified by team-value. All active images of the new team shall execute the same CHANGE
<P>
  TEAM statement. On each image of the new team, execution of the segment following the CHANGE TEAM
<P>
  statement is delayed until all other images of that team have executed the same statement the same number of
<P>
  times in the original team.
<P>
</PRE>
6 If the new team contains a failed image and no other error condition occurs, there is an implicit synchronization
<P>
<PRE>
  of all active images of the new team. On each active image of the new team, execution of the segment following
<P>
  the CHANGE TEAM statement is delayed until all other active images of that team have executed the same
<P>
  statement the same number of times in the original team.
<P>
</PRE>
7 If no error condition other than the new team containing a failed image occurs, the segments that executed before
<P>
<PRE>
  the CHANGE TEAM statement on an active image of the new team precede the segments that execute after the
<P>
  CHANGE TEAM statement on another active image of that team.
<P>
</PRE>
8 When a CHANGE TEAM construct completes execution, there is an implicit synchronization of all active images
<P>
<PRE>
  in the new team. On each active image of the new team, execution of the segment following the END TEAM
<P>
  statement is delayed until all other active images of this team have executed the same construct the same number
<P>
  of times in this team. The segments that executed before the END TEAM statement on an active image of the
<P>
  new team precede the segments that execute after the END TEAM statement on another active image of that
<P>
  team.
<P>
        NOTE 11.5
<P>
        Deallocation of an allocatable coarray that was not allocated at the beginning of a CHANGE TEAM
<P>
        construct, but is allocated at the end of execution of the construct, occurs even for allocatable coarrays
<P>
        with the SAVE attribute.
<P>
        NOTE 11.6
<P>
        Execution of a CHANGE TEAM statement includes a synchronization of the executing image with the other
<P>
        images that will be in the same team after execution of the CHANGE TEAM statement. Synchronization
<P>
        of these images occurs again when the corresponding END TEAM statement is executed.
<P>
        If it is desired to synchronize all of the images in the team that was current when the CHANGE TEAM
<P>
        statement was executed, a SYNC TEAM statement that specifies the parent team can be executed imme-
<P>
        diately after the CHANGE TEAM statement. If similar semantics are desired following the END TEAM
<P>
        statement, a SYNC ALL statement could immediately follow the END TEAM statement.
<P>
  186                                                                ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 11.7
<P>
        A coarray that is established when a CHANGE TEAM statement is executed retains its corank and cobounds
<P>
        inside the block. If it is desired to perform remote accesses based on corank or cobounds different from
<P>
        those of the original coarray, an associating coarray can be used. An example of this is in C.6.7.
<P>
  11.1.6       CRITICAL construct
<P>
</PRE>
1 A CRITICAL construct limits execution of a block to one image at a time.
<P>
<PRE>
  R1116 critical-construct                 is  critical-stmt
<P>
                                                     block
<P>
                                                     end-critical-stmt
<P>
  R1117 critical-stmt                      is  [ critical-construct-name : ] CRITICAL [ ( [ sync-stat-list ] ) ]
<P>
  R1118 end-critical-stmt                  is  END CRITICAL [ critical-construct-name ]
<P>
  C1117 (R1116) If the critical-stmt of a critical-construct specifies a critical-construct-name, the corresponding
<P>
            end-critical-stmt shall specify the same critical-construct-name. If the critical-stmt of a critical-construct
<P>
            does not specify a critical-construct-name, the corresponding end-critical-stmt shall not specify a critical-
<P>
            construct-name.
<P>
  C1118 (R1116) The block of a critical-construct shall not contain a RETURN statement or an image control
<P>
            statement.
<P>
  C1119 A branch (11.2) within a CRITICAL construct shall not have a branch target that is outside the construct.
<P>
</PRE>
2 Execution of the CRITICAL construct is completed when execution of its block is completed, or the executing
<P>
<PRE>
  image fails (5.3.6). A procedure invoked, directly or indirectly, from a CRITICAL construct shall not execute an
<P>
  image control statement.
<P>
</PRE>
3 The processor shall ensure that once an image has commenced executing block, no other image shall commence
<P>
<PRE>
  executing block until this image has completed execution of the construct. The image shall not execute an image
<P>
  control statement during the execution of block. The sequence of executed statements is therefore a segment
<P>
  (11.6.2). If image M completes execution of the construct without failing and image T is the next to execute the
<P>
  construct, the segment on image M precedes the segment on image T. Otherwise, if image M completes execution
<P>
  of the construct by failing, and image T is the next to execute the construct, the previous segment on image M
<P>
  precedes the segment on image T.
<P>
</PRE>
4 The effect of a STAT= or ERRMSG= specifier in a CRITICAL statement is specified in subclause 11.6.11.
<P>
5 It is permissible to branch to an end-critical-stmt only from within its CRITICAL construct.
<P>
<PRE>
        NOTE 11.8
<P>
        If more than one image executes the block of a CRITICAL construct without failing, its execution by one
<P>
        image always either precedes or succeeds its execution by another nonfailed image. Typically no other
<P>
        statement ordering is needed. Consider the following example:
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CRITICAL</H4>
</A>
<BLOCKQUOTE>
<P>
GLOBAL_COUNTER[1] = GLOBAL_COUNTER[1] + 1
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END CRITICAL</H4>
</A>
<BLOCKQUOTE>
<P>
The definition of GLOBAL_COUNTER [1] by a particular image will always precede the reference to the
<P>
same variable by the next image to execute the block.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: same variable by the next image to execute the block.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
187
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
       NOTE 11.9
<P>
       The following example permits a large number of jobs to be shared among the images:
<P>
       INTEGER :: NUM_JOBS[*], JOB
<P>
       IF (THIS_IMAGE() == 1) READ(*,*) NUM_JOBS
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CRITICAL</H4>
</A>
<BLOCKQUOTE>
<P>
JOB = NUM_JOBS[1]
<P>
NUM_JOBS[1] = JOB - 1
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END CRITICAL</H4>
</A>
<BLOCKQUOTE>
<P>
IF (JOB &gt; 0) THEN
<P>
<PRE>
                ! Work on JOB
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; EXIT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.7</B> </TD><TD valign=bottom>
DO construct
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11.1.7.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Purpose and form of the DO construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The DO construct specifies the repeated execution of a sequence of executable constructs. Such a repeated
<P>
<PRE>
  sequence is called a loop.
<P>
</PRE>
2 The number of iterations of a loop can be determined at the beginning of execution of the DO construct, or can
<P>
<PRE>
  be left indefinite (“DO forever” or DO WHILE). The execution order of the iterations can be left indeterminate
<P>
  (DO CONCURRENT); except in this case, the loop can be terminated immediately (11.1.7.4.5). An iteration of
<P>
  the loop can be curtailed by executing a CYCLE statement (11.1.7.4.4).
<P>
</PRE>
3 There are three phases in the execution of a DO construct: initiation of the loop, execution of each iteration of
<P>
<PRE>
  the loop, and termination of the loop.
<P>
</PRE>
4 The scope and attributes of an index-name in a concurrent-header (DO CONCURRENT) are described in 19.4.
<P>
<PRE>
  11.1.7.2    Form of the DO construct
<P>
  R1119 do-construct                   is  do-stmt
<P>
                                                 block
<P>
                                                 end-do
<P>
  R1120 do-stmt                        is  nonlabel-do-stmt
<P>
                                       or  label-do-stmt
<P>
  R1121    label-do-stmt               is  [ do-construct-name : ] DO label [ loop-control ]
<P>
  R1122 nonlabel-do-stmt               is  [ do-construct-name : ] DO [ loop-control ]
<P>
  R1123 loop-control                   is  [ , ] do-variable = scalar-int-expr, scalar-int-expr
<P>
                                              [ , scalar-int-expr ]
<P>
                                       or [ , ] WHILE ( scalar-logical-expr )
<P>
                                       or [ , ] CONCURRENT concurrent-header concurrent-locality
<P>
  R1124 do-variable                    is  scalar-int-variable-name
<P>
  188                                                                ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
C1120 (R1124) The do-variable shall be a variable of type integer.
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: C1120 (R1124) The do-variable shall be a variable of type integer.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>R1125 concurrent-header</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  ( [ integer-type-spec :: ] concurrent-control-list [ , scalar-mask-expr ] )
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1126 concurrent-control</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  index-name = concurrent-limit : concurrent-limit [ : concurrent-step ]
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1127 concurrent-limit</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  scalar-int-expr
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1128 concurrent-step</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  scalar-int-expr
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1129 concurrent-locality</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  [ locality-spec ]&#46;&#46;&#46;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1130 locality-spec</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  LOCAL ( variable-name-list )
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                     or  LOCAL_INIT ( variable-name-list )
<P>
                                     or  SHARED ( variable-name-list )
<P>
                                     or  DEFAULT ( NONE )
<P>
</PRE>
C1121 (R1125) Any procedure referenced in the scalar-mask-expr, including one referenced by a defined opera-
</TD></TR>
<TR><TD colspan=2>
<PRE>
      tion, shall be a pure procedure (15.7).
<P>
</PRE>
C1122 (R1126) The index-name shall be a named scalar variable of type integer.
</TD></TR>
<TR><TD colspan=2>
C1123 (R1126) A concurrent-limit or concurrent-step in a concurrent-control shall not contain a reference to
</TD></TR>
<TR><TD colspan=2>
<PRE>
      any index-name in the concurrent-control-list in which it appears.
<P>
</PRE>
C1124 A variable-name in a locality-spec shall be the name of a variable in the innermost executable construct
</TD></TR>
<TR><TD colspan=2>
<PRE>
      or scoping unit that includes the DO CONCURRENT statement.
<P>
</PRE>
C1125 A variable-name in a locality-spec shall not be the same as an index-name in the concurrent-header of
</TD></TR>
<TR><TD colspan=2>
<PRE>
      the same DO CONCURRENT statement.
<P>
</PRE>
C1126 The name of a variable shall not appear in more than one variable-name-list, or more than once in a
</TD></TR>
<TR><TD colspan=2>
<PRE>
      variable-name-list, in a given concurrent-locality.
<P>
</PRE>
C1127 The DEFAULT ( NONE ) locality-spec shall not appear more than once in a given concurrent-locality.
</TD></TR>
<TR><TD colspan=2>
C1128 A variable-name that appears in a LOCAL or LOCAL_INIT locality-spec shall not have the ALLOCAT-
</TD></TR>
<TR><TD colspan=2>
<PRE>
      ABLE, INTENT (IN), or OPTIONAL attribute, shall not be of finalizable type, shall not be a nonpointer
<P>
      polymorphic dummy argument, and shall not be a coarray or an assumed-size array. A variable-name that
<P>
      is not permitted to appear in a variable definition context shall not appear in a LOCAL or LOCAL_INIT
<P>
      locality-spec.
<P>
</PRE>
C1129 A variable that is referenced by the scalar-mask-expr of a concurrent-header or by any concurrent-limit
</TD></TR>
<TR><TD colspan=2>
<PRE>
      or concurrent-step in that concurrent-header shall not appear in a LOCAL locality-spec in the same DO
<P>
      CONCURRENT statement.
<P>
</PRE>
C1130 If the locality-spec DEFAULT ( NONE ) appears in a DO CONCURRENT statement, a variable that is
</TD></TR>
<TR><TD colspan=2>
<PRE>
      a local or construct entity of a scope containing the DO CONCURRENT construct, and that appears in
<P>
      the block of the construct, shall have its locality explicitly specified by that statement.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1131 end-do</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  end-do-stmt
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                     or  continue-stmt
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1132 end-do-stmt</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is  END DO [ do-construct-name ]
</TD></TR>
<TR><TD colspan=2>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
189
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1131 (R1119) If the do-stmt of a do-construct specifies a do-construct-name, the corresponding end-do shall be
<P>
             an end-do-stmt specifying the same do-construct-name. If the do-stmt of a do-construct does not specify
<P>
             a do-construct-name, the corresponding end-do shall not specify a do-construct-name.
<P>
  C1132 (R1119) If the do-stmt is a nonlabel-do-stmt, the corresponding end-do shall be an end-do-stmt.
<P>
  C1133      (R1119) If the do-stmt is a label-do-stmt, the corresponding end-do shall be identified with the same label.
<P>
</PRE>
1 It is permissible to branch to an end-do only from within its DO construct.
<P>
<PRE>
  11.1.7.3      Active and inactive DO constructs
<P>
</PRE>
1 A DO construct is either active or inactive. Initially inactive, a DO construct becomes active only when its DO
<P>
<PRE>
  statement is executed.
<P>
</PRE>
2 Once active, the DO construct becomes inactive only when it terminates (11.1.7.4.5).
<P>
<PRE>
  11.1.7.4      Execution of a DO construct
<P>
  11.1.7.4.1      Loop initiation
<P>
</PRE>
1 When the DO statement is executed, the DO construct becomes active. If loop-control is
<P>
<PRE>
       [ , ] do-variable = scalar-int-expr 1 , scalar-int-expr 2 [ , scalar-int-expr 3 ]
<P>
</PRE>
the following steps are performed in sequence.
<P>
<PRE>
          (1)    The initial parameter m1 , the terminal parameter m2 , and the incrementation parameter m3 are
<P>
                 of type integer with the same kind type parameter as the do-variable. Their values are established
<P>
                 by evaluating scalar-int-expr 1 , scalar-int-expr 2 , and scalar-int-expr 3 , respectively, including, if ne-
<P>
                 cessary, conversion to the kind type parameter of the do-variable according to the rules for numeric
<P>
                 conversion (Table 10.9). If scalar-int-expr 3 does not appear, m3 has the value 1. The value of m3
<P>
                 shall not be zero.
<P>
          (2)    The DO variable becomes defined with the value of the initial parameter m1 .
<P>
          (3)    The iteration count is established and is the value of the expression (m2 − m1 + m3 )/m3 , unless that
<P>
                 value is negative, in which case the iteration count is 0.
<P>
</PRE>
NOTE 11.10
<BLOCKQUOTE>
<P>
The iteration count is zero whenever:
<P>
<PRE>
              m1 &gt; m2 and m3 &gt; 0, or
<P>
              m1 &lt; m2 and m3 &lt; 0.
<P>
</PRE>
2 If loop-control is omitted, no iteration count is calculated. The effect is as if a large positive iteration count,
<P>
<PRE>
  impossible to decrement to zero, were established. If loop-control is [ , ] WHILE (scalar-logical-expr), the effect
<P>
  is as if loop-control were omitted and the following statement inserted as the first statement of the block:
<P>
      IF (.NOT. (scalar- logical-expr )) EXIT
<P>
</PRE>
3 For a DO CONCURRENT construct, the values of the index variables for the iterations of the construct are
<P>
<PRE>
  determined by the rules in 11.1.7.4.2.
<P>
</PRE>
4 At the completion of the execution of the DO statement, the execution cycle begins.
<P>
<PRE>
  11.1.7.4.2      DO CONCURRENT loop control
<P>
</PRE>
1 The concurrent-limit and concurrent-step expressions in the concurrent-control-list are evaluated. These ex-
<P>
<PRE>
  pressions may be evaluated in any order. The set of values that a particular index-name variable assumes is
<P>
  determined as follows.
<P>
  190                                                                          ⃝
<P>
                                                                               c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
         (1)     The lower bound m1 , the upper bound m2 , and the step m3 are of type integer with the same kind
<P>
                 type parameter as the index-name. Their values are established by evaluating the first concurrent-
<P>
                 limit, the second concurrent-limit, and the concurrent-step expressions, respectively, including, if
<P>
                 necessary, conversion to the kind type parameter of the index-name according to the rules for numeric
<P>
                 conversion (Table 10.9). If concurrent-step does not appear, m3 has the value 1. The value m3 shall
<P>
                 not be zero.
<P>
         (2)     Let the value of max be (m2 − m1 + m3 )/m3 . If max≤ 0 for some index-name, the execution of the
<P>
                 construct is complete. Otherwise, the set of values for the index-name is
<P>
                       m1 + (k − 1) × m3         where k = 1, 2, &#46;&#46;&#46;, max.
<P>
</PRE>
2 The set of combinations of index-name values is the Cartesian product of the sets defined by each triplet specific-
<P>
<PRE>
  ation. An index-name becomes defined when this set is evaluated.
<P>
</PRE>
3 The scalar-mask-expr, if any, is evaluated for each combination of index-name values. If there is no scalar-
<P>
<PRE>
  mask-expr, it is as if it appeared with the value true. The index-name variables may be primaries in the
<P>
  scalar-mask-expr.
<P>
</PRE>
4 The set of active combinations of index-name values is the subset of all possible combinations for which the
<P>
<PRE>
  scalar-mask-expr has the value true.
<P>
       NOTE 11.11
<P>
       The index-name variables can appear in the mask, for example
<P>
           DO CONCURRENT (I=1:10, J=1:10, A(I) &gt; 0.0 .AND. B(J) &lt; 1.0)
<P>
           . . .
<P>
  11.1.7.4.3      The execution cycle
<P>
</PRE>
1 The execution cycle of a DO construct that is not a DO CONCURRENT construct consists of the following steps
<P>
<PRE>
  performed in sequence repeatedly until termination.
<P>
         (1)     The iteration count, if any, is tested. If it is zero, the loop terminates and the DO construct becomes
<P>
                 inactive. If loop-control is [ , ] WHILE (scalar-logical-expr), the scalar-logical-expr is evaluated; if
<P>
                 the value of this expression is false, the loop terminates and the DO construct becomes inactive.
<P>
         (2)     The block of the loop is executed.
<P>
         (3)     The iteration count, if any, is decremented by one. The DO variable, if any, is incremented by the
<P>
                 value of the incrementation parameter m3 .
<P>
</PRE>
2 Except for the incrementation of the DO variable that occurs in step (3), the DO variable shall neither be redefined
<P>
<PRE>
  nor become undefined while the DO construct is active.
<P>
</PRE>
3 The block of a DO CONCURRENT construct is executed for every active combination of the index-name values.
<P>
<PRE>
  Each execution of the block is an iteration. The executions may occur in any order.
<P>
  11.1.7.4.4      CYCLE statement
<P>
</PRE>
1 Execution of a loop iteration can be curtailed by executing a CYCLE statement that belongs to the construct.
<P>
<PRE>
  R1133 cycle-stmt                         is   CYCLE [ do-construct-name ]
<P>
  C1134 If a do-construct-name appears on a CYCLE statement, the CYCLE statement shall be within that
<P>
           do-construct; otherwise, it shall be within at least one do-construct.
<P>
  C1135 A cycle-stmt shall not appear within a CHANGE TEAM, CRITICAL, or DO CONCURRENT construct
<P>
           if it belongs to an outer construct.
<P>
</PRE>
2 A CYCLE statement belongs to a particular DO construct. If the CYCLE statement contains a DO construct
<P>
<PRE>
  name, it belongs to that DO construct; otherwise, it belongs to the innermost DO construct in which it appears.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             191
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Execution of a CYCLE statement that belongs to a DO construct that is not a DO CONCURRENT construct
<P>
<PRE>
  causes immediate progression to step (3) of the execution cycle of the DO construct to which it belongs.
<P>
</PRE>
4 Execution of a CYCLE statement that belongs to a DO CONCURRENT construct completes execution of that
<P>
<PRE>
  iteration of the construct.
<P>
</PRE>
5 In a DO construct, a transfer of control to the end-do has the same effect as execution of a CYCLE statement
<P>
<PRE>
  belonging to that construct.
<P>
  11.1.7.4.5     Loop termination
<P>
</PRE>
1 For a DO construct that is not a DO CONCURRENT construct, the loop terminates, and the DO construct
<P>
<PRE>
  becomes inactive, when any of the following occurs.
<P>
      • The iteration count is determined to be zero or the scalar-logical-expr is false, when tested during step (1)
<P>
         of the above execution cycle.
<P>
      • An EXIT statement that belongs to the DO construct is executed.
<P>
      • An EXIT or CYCLE statement that belongs to an outer construct and is within the DO construct is
<P>
         executed.
<P>
      • A branch occurs within the DO construct and the branch target statement is outside the construct.
<P>
      • A RETURN statement within the DO construct is executed.
<P>
</PRE>
2 For a DO CONCURRENT construct, the loop terminates, and the DO construct becomes inactive when all of
<P>
<PRE>
  the iterations have completed execution.
<P>
</PRE>
3 When a DO construct becomes inactive, the DO variable, if any, of the DO construct retains its last defined
<P>
<PRE>
  value.
<P>
  11.1.7.5    Additional semantics for DO CONCURRENT constructs
<P>
  C1136 A RETURN statement shall not appear within a DO CONCURRENT construct.
<P>
  C1137 An image control statement shall not appear within a DO CONCURRENT construct.
<P>
  C1138 A branch (11.2) within a DO CONCURRENT construct shall not have a branch target that is outside
<P>
            the construct.
<P>
  C1139 A reference to an impure procedure shall not appear within a DO CONCURRENT construct.
<P>
  C1140 A statement that might result in the deallocation of a polymorphic entity shall not appear within a DO
<P>
            CONCURRENT construct.
<P>
  C1141 A reference to the procedure IEEE_GET_FLAG, IEEE_SET_HALTING_MODE, or IEEE_GET_-
<P>
            HALTING_MODE from the intrinsic module IEEE_EXCEPTIONS, shall not appear within a DO
<P>
            CONCURRENT construct.
<P>
</PRE>
1 The locality of a variable that appears in a DO CONCURRENT construct is LOCAL, LOCAL_INIT, SHARED,
<P>
<PRE>
  or unspecified. A construct or statement entity of a construct or statement within the DO CONCURRENT
<P>
  construct has SHARED locality if it has the SAVE attribute. If it does not have the SAVE attribute, it is a
<P>
  different entity in each iteration, similar to LOCAL locality.
<P>
</PRE>
2 A variable that has LOCAL or LOCAL_INIT locality is a construct entity with the same type, type parameters,
<P>
<PRE>
  and rank as the variable with the same name in the innermost executable construct or scoping unit that includes
<P>
  the DO CONCURRENT construct, and the outside variable is inaccessible by that name within the construct. The
<P>
  construct entity has the ASYNCHRONOUS, CONTIGUOUS, POINTER, TARGET, or VOLATILE attribute if
<P>
  and only if the outside variable has that attribute; it does not have the BIND, INTENT, PROTECTED, SAVE
<P>
  or VALUE attribute, even if the outside variable has that attribute. If it is not a pointer, it has the same bounds
<P>
  as the outside variable. At the beginning of execution of each iteration,
<P>
  192                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
      • if a variable with LOCAL locality is a pointer it has undefined pointer association status, and otherwise it
<P>
         is undefined except for any subobjects that are default-initialized;
<P>
      • a variable with LOCAL_INIT locality has the pointer association status and definition status of the out-
<P>
         side variable with that name; the outside variable shall not be an undefined pointer or a nonallocatable
<P>
         nonpointer variable that is undefined.
<P>
  If a variable with LOCAL or LOCAL_INIT locality becomes an affector of a pending input/output operation,
<P>
  the operation shall have completed before the end of the iteration. If a variable with LOCAL or LOCAL_INIT
<P>
  locality has the TARGET attribute, a pointer associated with it during an iteration becomes undefined when
<P>
  execution of that iteration completes.
<P>
</PRE>
3 If a variable has SHARED locality, appearances of the variable within the DO CONCURRENT construct refer
<P>
<PRE>
  to the variable in the innermost executable construct or scoping unit that includes the DO CONCURRENT
<P>
  construct. If it is defined or becomes undefined during any iteration, it shall not be referenced, defined, or
<P>
  become undefined during any other iteration. If it is allocated, deallocated, nullified, or pointer-assigned during
<P>
  an iteration it shall not have its allocation or association status, dynamic type, array bounds, shape, or a deferred
<P>
  type parameter value inquired about in any other iteration. A noncontiguous array with SHARED locality shall
<P>
  not be supplied as an actual argument corresponding to a contiguous INTENT (INOUT) dummy argument.
<P>
</PRE>
4 If a variable has unspecified locality,
<P>
<PRE>
      • if it is referenced in an iteration it shall either be previously defined during that iteration, or shall not be
<P>
         defined or become undefined during any other iteration; if it is defined or becomes undefined by more than
<P>
         one iteration it becomes undefined when the loop terminates;
<P>
      • if it is noncontiguous and is supplied as an actual argument corresponding to a contiguous INTENT (IN-
<P>
         OUT) dummy argument in an iteration, it shall either be previously defined in that iteration or shall not
<P>
         be defined in any other iteration;
<P>
      • if it is a pointer and is used in an iteration other than as the pointer in pointer assignment, allocation,
<P>
         or nullification, it shall either be previously pointer associated during that iteration or shall not have its
<P>
         pointer association changed during any iteration;
<P>
      • if it is a pointer whose pointer association is changed in more than one iteration, it has an association status
<P>
         of undefined when the construct terminates;
<P>
      • if it is allocatable and is allocated in more than one iteration, it shall have an allocation status of unallocated
<P>
         at the end of every iteration;
<P>
      • if it is allocatable and is referenced, defined, deallocated, or has its allocation status, dynamic type, or a
<P>
         deferred type parameter value inquired about, in any iteration, it shall either be previously allocated in
<P>
         that iteration or shall not be allocated or deallocated in any other iteration.
<P>
</PRE>
5 A DO CONCURRENT construct shall not contain an input/output statement that has an ADVANCE= specifier.
</BLOCKQUOTE>
<P>
6 If data are written to a file record or position in one iteration, that record or position in that file shall not be
<P>
<PRE>
  read from or written to in a different iteration. If records are written to a file connected for sequential access by
<P>
  more than one iteration, the ordering of records written by different iterations is processor dependent.
<P>
        NOTE 11.12
<P>
        The restrictions on referencing variables defined in an iteration of a DO CONCURRENT construct apply
<P>
        to any procedure invoked within the loop.
<P>
        NOTE 11.13
<P>
        The restrictions on the statements in a DO CONCURRENT construct are designed to ensure there are no
<P>
        data dependencies between iterations of the loop. This permits code optimizations that might otherwise be
<P>
        difficult or impossible because they would depend on properties of the program not visible to the compiler.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                193
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>11.1.7.6</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Examples of DO constructs
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
     NOTE 11.14
<P>
     The following program fragment computes a tensor product of two arrays:
<P>
     DO I = 1, M
<P>
         DO J = 1, N
<P>
            C (I, J) = DOT_PRODUCT (A (I, J, :), B(:, I, J))
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.15
<P>
The following program fragment contains a DO construct that uses the WHILE form of loop-control. The
<P>
loop will continue to execute until an end-of-file or input/output error is encountered, at which point the
<P>
DO statement terminates the loop. When a negative value of X is read, the program skips immediately to
<P>
the next READ statement, bypassing most of the block of the loop.
<P>
READ (IUN, ’(1X, G14.7)’, IOSTAT = IOS) X
<P>
DO WHILE (IOS == 0)
<P>
<PRE>
         IF (X &gt;= 0.) THEN
<P>
            CALL SUBA (X)
<P>
            CALL SUBB (X)
<P>
                  &#46;&#46;&#46;
<P>
            CALL SUBZ (X)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ENDIF</H4>
</A>
<BLOCKQUOTE>
<P>
READ (IUN, ’(1X, G14.7)’, IOSTAT = IOS) X
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.16
<P>
The following example behaves exactly the same as the one in NOTE 11.15. However, the READ statement
<P>
has been moved to the interior of the loop, so that only one READ statement is needed. Also, a CYCLE
<P>
statement has been used to avoid an extra level of IF nesting.
<TABLE cellpadding=3><!-- tsb: statement has been used to avoid an extra level of IF nesting.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>DO</B> </TD><TD valign=bottom>
! A "DO WHILE + 1/2" loop
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         READ (IUN, ’(1X, G14.7)’, IOSTAT = IOS) X
<P>
         IF (IOS /= 0) EXIT
<P>
         IF (X &lt; 0.) CYCLE
<P>
         CALL SUBA (X)
<P>
         CALL SUBB (X)
<P>
            . . .
<P>
         CALL SUBZ (X)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.17
<P>
The following example illustrates a case in which the user knows that there are no repeated values in the
<P>
index array IND. The DO CONCURRENT construct makes it easier for the processor to generate vector
<P>
gather/scatter code, unroll the loop, or parallelize the code for this loop, potentially improving performance.
<P>
INTEGER :: <B>A</B>(N),IND(N)
<P>
DO CONCURRENT (I=1:M)
<P>
<PRE>
         A(IND(I)) = I
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>194</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 11.18
<BLOCKQUOTE>
<P>
The following code demonstrates the use of the LOCAL clause so that the X inside the DO CONCURRENT
<P>
construct is a temporary variable, and will not affect the X outside the construct.
<P>
<PRE>
                  X = 1.0
<P>
                  DO CONCURRENT (I=1:10) LOCAL (X)
<P>
                    IF (A (I) &gt; 0) THEN
<P>
                       X = SQRT (A (I))
<P>
                       A (I) = A (I) - X**2
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
B (I) = B (I) - A (I)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>PRINT *, X</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Always prints 1.0.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
NOTE 11.19
<BLOCKQUOTE>
<P>
Additional examples of DO constructs are in C.6.3.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: Additional examples of DO constructs are in C.6.3.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>11.1.8</B> </TD><TD valign=bottom>
IF construct and statement
<TABLE width=100% cellpadding=3><!-- tsb: IF construct and statement
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>11.1.8.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Purpose and form of the IF construct
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 The IF construct selects for execution at most one of its constituent blocks. The selection is based on a sequence
<P>
<PRE>
  of logical expressions.
<P>
  R1134 if-construct                    is   if-then-stmt
<P>
                                                        block
<P>
                                                   [ else-if-stmt
<P>
                                                        block ] &#46;&#46;&#46;
<P>
                                                   [ else-stmt
<P>
                                                        block ]
<P>
                                                   end-if-stmt
<P>
  R1135 if-then-stmt                    is   [ if-construct-name : ] IF ( scalar-logical-expr ) THEN
<P>
  R1136 else-if-stmt                    is   ELSE IF ( scalar-logical-expr ) THEN [ if-construct-name ]
<P>
  R1137 else-stmt                       is   ELSE [ if-construct-name ]
<P>
  R1138 end-if-stmt                     is   END IF [ if-construct-name ]
<P>
  C1142 (R1134) If the if-then-stmt of an if-construct specifies an if-construct-name, the corresponding end-if-
<P>
           stmt shall specify the same if-construct-name. If the if-then-stmt of an if-construct does not specify an
<P>
           if-construct-name, the corresponding end-if-stmt shall not specify an if-construct-name. If an else-if-
<P>
           stmt or else-stmt specifies an if-construct-name, the corresponding if-then-stmt shall specify the same
<P>
           if-construct-name.
<P>
  11.1.8.2    Execution of an IF construct
<P>
</PRE>
1 At most one of the blocks in the IF construct is executed. If there is an ELSE statement in the construct,
<P>
<PRE>
  exactly one of the blocks in the construct is executed. The scalar logical expressions are evaluated in the order
<P>
  of their appearance in the construct until a true value is found or an ELSE statement or END IF statement is
<P>
  encountered. If a true value or an ELSE statement is found, the block immediately following is executed and this
<P>
  completes the execution of the construct. The scalar logical expressions in any remaining ELSE IF statements of
<P>
  the IF construct are not evaluated. If none of the evaluated expressions is true and there is no ELSE statement,
<P>
  the execution of the construct is completed without the execution of any block within the construct.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         195
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 It is permissible to branch to an END IF statement only from within its IF construct. Execution of an END IF
<P>
<PRE>
  statement has no effect.
<P>
  11.1.8.3   Examples of IF constructs
<P>
        NOTE 11.20
<P>
                IF (CVAR == ’RESET’) THEN
<P>
                    I = 0; J = 0; K = 0
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
PROOF_DONE: IF (PROP) THEN
<P>
<PRE>
                    WRITE (3, ’(’’QED’’)’)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; STOP</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
PROP = NEXTPROP
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF PROOF_DONE</H4>
</A>
<BLOCKQUOTE>
<P>
IF (A &gt; 0) THEN
<P>
<PRE>
                    B = C/A
<P>
                    IF (B &gt; 0) THEN
<P>
                        D = 1.0
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
ELSE IF (C &gt; 0) THEN
<P>
<PRE>
                    B = A/C
<P>
                    D = -1.0
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
B = ABS (MAX (A, C))
<P>
D = 0
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>11.1.8.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IF statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The IF statement controls the execution of a single action statement based on a single logical expression.
<P>
<PRE>
  R1139 if-stmt                        is   IF ( scalar-logical-expr ) action-stmt
<P>
  C1143 (R1139) The action-stmt in the if-stmt shall not be an if-stmt.
<P>
</PRE>
2 Execution of an IF statement causes evaluation of the scalar logical expression. If the value of the expression is
<P>
<PRE>
  true, the action statement is executed. If the value is false, the action statement is not executed.
<P>
</PRE>
3 The execution of a function reference in the scalar logical expression may affect entities in the action statement.
<P>
<PRE>
        NOTE 11.21
<P>
        An example of an IF statement is:
<P>
                IF (A &gt; 0.0) A = LOG (A)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.9</B> </TD><TD valign=bottom>
SELECT CASE construct
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11.1.9.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Purpose and form of the SELECT CASE construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The SELECT CASE construct selects for execution at most one of its constituent blocks. The selection is based
<P>
<PRE>
  on the value of an expression.
<P>
  R1140 case-construct                 is   select-case-stmt
<P>
                                                 [ case-stmt
<P>
                                                      block ] &#46;&#46;&#46;
<P>
                                                 end-select-stmt
<P>
  196                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1141 select-case-stmt                  is   [ case-construct-name : ] SELECT CASE ( case-expr )
<P>
  R1142 case-stmt                         is   CASE case-selector [case-construct-name]
<P>
  R1143 end-select-stmt                   is   END SELECT [ case-construct-name ]
<P>
  C1144 (R1140) If the select-case-stmt of a case-construct specifies a case-construct-name, the corresponding end-
<P>
           select-stmt shall specify the same case-construct-name. If the select-case-stmt of a case-construct does
<P>
           not specify a case-construct-name, the corresponding end-select-stmt shall not specify a case-construct-
<P>
           name. If a case-stmt specifies a case-construct-name, the corresponding select-case-stmt shall specify the
<P>
           same case-construct-name.
<P>
  R1144 case-expr                         is   scalar-expr
<P>
  C1145 case-expr shall be of type character, integer, or logical.
<P>
  R1145 case-selector                     is ( case-value-range-list )
<P>
                                          or DEFAULT
<P>
  C1146 (R1140) No more than one of the selectors of one of the CASE statements shall be DEFAULT.
<P>
  R1146 case-value-range                  is   case-value
<P>
                                          or   case-value :
<P>
                                          or   : case-value
<P>
                                          or   case-value : case-value
<P>
  R1147 case-value                        is   scalar-constant-expr
<P>
  C1147 (R1140) For a given case-construct, each case-value shall be of the same type as case-expr. For character
<P>
           type, the kind type parameters shall be the same; character length differences are allowed.
<P>
  C1148 (R1140) A case-value-range using a colon shall not be used if case-expr is of type logical.
<P>
  C1149 (R1140) For a given case-construct, there shall be no possible value of the case-expr that matches more
<P>
           than one case-value-range.
<P>
  11.1.9.2    Execution of a SELECT CASE construct
<P>
</PRE>
1 The execution of the SELECT CASE statement causes the case expression to be evaluated. For a case value
<P>
<PRE>
  range list, a match occurs if the case expression value matches any of the case value ranges in the list. For a case
<P>
  expression with a value of c, a match is determined as follows.
<P>
         (1)    If the case value range contains a single value v without a colon, a match occurs for type logical if
<P>
                the expression c .EQV. v is true, and a match occurs for type integer or character if the expression
<P>
                c == v is true.
<P>
         (2)    If the case value range is of the form low : high, a match occurs if the expression low &lt;= c .AND.
<P>
                c &lt;= high is true.
<P>
         (3)    If the case value range is of the form low :, a match occurs if the expression low &lt;= c is true.
<P>
         (4)    If the case value range is of the form : high, a match occurs if the expression c &lt;= high is true.
<P>
         (5)    If no other selector matches and a DEFAULT selector appears, it matches the case index.
<P>
         (6)    If no other selector matches and the DEFAULT selector does not appear, there is no match.
<P>
</PRE>
2 The block following the CASE statement containing the matching selector, if any, is executed. This completes
<P>
<PRE>
  execution of the construct.
<P>
</PRE>
3 It is permissible to branch to an end-select-stmt only from within its SELECT CASE construct.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            197
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>11.1.9.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Examples of SELECT CASE constructs
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
     NOTE 11.22
<P>
     An integer signum function:
<P>
              INTEGER FUNCTION SIGNUM (N)
<P>
              SELECT CASE (N)
<P>
              CASE (:-1)
<P>
                 SIGNUM = -1
<P>
              CASE (0)
<P>
                 SIGNUM = 0
<P>
              CASE (1:)
<P>
                 SIGNUM = 1
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.23
<P>
A code fragment to check for balanced parentheses:
<P>
<PRE>
              CHARACTER (80) :: LINE
<P>
                 &#46;&#46;&#46;
<P>
              LEVEL = 0
<P>
              SCAN_LINE: DO I = 1, 80
<P>
                 CHECK_PARENS: SELECT CASE (LINE (I:I))
<P>
                 CASE (’(’)
<P>
                    LEVEL = LEVEL + 1
<P>
                 CASE (’)’)
<P>
                    LEVEL = LEVEL - 1
<P>
                    IF (LEVEL &lt; 0) THEN
<P>
                        PRINT *, ’UNEXPECTED RIGHT PARENTHESIS’
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; EXIT SCAN_LINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CASE DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
! Ignore all other characters
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT CHECK_PARENS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO SCAN_LINE</H4>
</A>
<BLOCKQUOTE>
<P>
IF (LEVEL &gt; 0) THEN
<P>
<PRE>
                 PRINT *, ’MISSING RIGHT PARENTHESIS’
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.24
<P>
The following three fragments are equivalent:
<P>
<PRE>
              IF (SILLY == 1) THEN
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL THIS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL THAT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
SELECT CASE (SILLY == 1)
<P>
CASE (.TRUE.)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL THIS</H4>
</A>
<BLOCKQUOTE>
<P>
CASE (.FALSE.)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL THAT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
SELECT CASE (SILLY)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: SELECT CASE (SILLY)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>198</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 11.24 (cont.)
<A name=>

    <H4>&nbsp; &nbsp; CASE DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL THAT</H4>
</A>
<BLOCKQUOTE>
<P>
CASE (1)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL THIS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.25
<P>
A code fragment showing several selections of one block:
<P>
<PRE>
                SELECT CASE (N)
<P>
                CASE (1, 3:5, 8)     ! Selects 1, 3, 4, 5, 8
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL SUB</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CASE DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL OTHER</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.10</B> </TD><TD valign=bottom>
SELECT RANK construct
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11.1.10.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Purpose and form of the SELECT RANK construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The SELECT RANK construct selects for execution at most one of its constituent blocks. The selection is based
<P>
<PRE>
  on the rank of an assumed-rank variable. A name is associated with the variable (19.4, 19.5.1.6), in the same
<P>
  way as for the ASSOCIATE construct.
<P>
  R1148 select-rank-construct           is select-rank-stmt
<P>
                                                [ select-rank-case-stmt
<P>
                                                  block ]&#46;&#46;&#46;
<P>
                                                end-select-rank-stmt
<P>
  R1149 select-rank-stmt                is [ select-construct-name : ] SELECT RANK
<P>
                                               ( [ associate-name =&gt; ] selector )
<P>
  C1150 The selector in a select-rank-stmt shall be the name of an assumed-rank array.
<P>
  R1150 select-rank-case-stmt           is RANK ( scalar-int-constant-expr ) [ select-construct-name ]
<P>
                                        or RANK ( * ) [ select-construct-name ]
<P>
                                        or RANK DEFAULT [ select-construct-name ]
<P>
  C1151 A scalar-int-constant-expr in a select-rank-case-stmt shall be nonnegative and less than or equal to the
<P>
          maximum possible rank of selector.
<P>
  C1152 For a given select-rank-construct, the same rank value shall not be specified in more than one select-rank-
<P>
          case-stmt.
<P>
  C1153 For a given select-rank-construct, there shall be at most one RANK ( * ) select-rank-case-stmt and at
<P>
          most one RANK DEFAULT select-rank-case-stmt.
<P>
  C1154 If select-construct-name appears on a select-rank-case-stmt the corresponding select-rank-stmt shall spe-
<P>
          cify the same select-construct-name.
<P>
  C1155 A SELECT RANK construct shall not have a select-rank-case-stmt that is RANK ( * ) if the selector
<P>
          has the ALLOCATABLE or POINTER attribute.
<P>
  R1151 end-select-rank-stmt            is END SELECT [ select-construct-name ]
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        199
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1156 If the select-rank-stmt of a select-rank-construct specifies a select-construct-name, the corresponding
<P>
            end-select-rank-stmt shall specify the same select-construct-name. If the select-rank-stmt of a select-
<P>
            rank-construct does not specify a select-construct-name, the corresponding end-select-rank-stmt shall not
<P>
            specify a select-construct-name.
<P>
</PRE>
2 The associate name of a SELECT RANK construct is the associate-name if specified; otherwise it is the name
<P>
<PRE>
  that constitutes the selector.
<P>
  11.1.10.2     Execution of the SELECT RANK construct
<P>
</PRE>
1 A SELECT RANK construct selects at most one block to be executed. During execution of that block, the
<P>
<PRE>
  associate name identifies an entity which is associated (19.5.1.6) with the selector. A RANK ( * ) statement
<P>
  matches the selector if the selector is argument associated with an assumed-size array. A RANK ( scalar-int-
<P>
  constant-expr ) statement matches the selector if the selector has that rank and is not argument associated with
<P>
  an assumed-size array. A RANK DEFAULT statement matches the selector if no other select-rank-case-stmt
<P>
  of the construct matches the selector. If a select-rank-case-stmt matches the selector, the block following that
<P>
  statement is executed; otherwise, control is transferred to the end-select-rank-stmt.
<P>
</PRE>
2 It is permissible to branch to an end-select-rank-stmt only from within its SELECT RANK construct.
<P>
<PRE>
  11.1.10.3     Attributes of a SELECT RANK associate name
<P>
</PRE>
1 Within the block following a RANK DEFAULT statement, the associating entity (19.5.5) is assumed-rank and has
<P>
<PRE>
  exactly the same attributes as the selector. Within the block following a RANK ( * ) statement, the associating
<P>
  entity has rank 1 and is assumed-size, as if it were declared with DIMENSION(1:*). Within the block following
<P>
  a RANK ( scalar-int-constant-expr ) statement, the associating entity has the specified rank; the lower bound of
<P>
  each dimension is the result of the intrinsic function LBOUND (16.9.109) applied to the corresponding dimension
<P>
  of the selector, and the upper bound of each dimension is the result of the intrinsic function UBOUND (16.9.196)
<P>
  applied to the corresponding dimension of the selector.
<P>
</PRE>
2 The associating entity has the ALLOCATABLE, POINTER, or TARGET attribute if the selector has that
<P>
<PRE>
  attribute. The other attributes of the associating entity are described in 11.1.3.3.
<P>
  11.1.10.4     Examples of the SELECT RANK construct
<P>
        NOTE 11.26
<P>
        This example shows how to use a SELECT RANK construct to process scalars and rank-2 arrays; anything
<P>
        else will be rejected as an error.
<P>
                  SUBROUTINE process(x)
<P>
                    REAL x(..)
<P>
                    !
<P>
                    SELECT RANK(x)
<P>
                    RANK (0)
<P>
                       x = 0
<P>
                    RANK (2)
<P>
                       IF (SIZE(x,2)&gt;=2) x(:,2) = 2
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; RANK DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
Print *, ’I did not expect rank’, <B>RANK</B>(x), ’shape’, <B>SHAPE</B>(x)
<P>
ERROR STOP ’process bad arg’
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.27
<P>
The following example shows how to process assumed-size arrays, including how to use sequence association
<P>
if you want to do multi-dimensional processing of an assumed-size array.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: if you want to do multi-dimensional processing of an assumed-size array.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>200</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 11.27 (cont.)
<P>
<PRE>
               SELECT RANK (y =&gt; x)
<P>
               RANK (*)
<P>
                 IF (RANK(x)==2) THEN
<P>
                   ! Special code for the rank two case.
<P>
                   CALL sequence_assoc_2(y, LBOUND(x,1), UBOUND(x,1), LBOUND(x,2))
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
! We just do all the other ranks in array element order.
<P>
i = 1
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; DO</H4>
</A>
<BLOCKQUOTE>
<P>
IF (y(i)==0) Exit
<P>
<B>y</B>(i) = -<B>y</B>(i)
<P>
i = i + 1
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
SUBROUTINE <B>sequence_assoc_2</B>(a, lb1, ub1, lb2)
<P>
<PRE>
                 INTEGER, INTENT (IN) :: lb1, ub1, lb2
<P>
                 REAL a(lb1:ub1,lb2:*)
<P>
                 j = lb2
<P>
</PRE>
outer: DO
<P>
<PRE>
                   DO i=lb1,ub1
<P>
                      IF (a(i,j)==0) EXIT outer
<P>
                      a(i,j) = a(i,j)**2
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
j = j + 1
<P>
IF (ANY(a(:,j)==0)) EXIT
<P>
j = j + 1
</BLOCKQUOTE>
<P>
END DO outer
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.11</B> </TD><TD valign=bottom>
SELECT TYPE construct
</TD></TR>
<TR valign=top><TD colspan=2>
<B>11.1.11.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Purpose and form of the SELECT TYPE construct
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The SELECT TYPE construct selects for execution at most one of its constituent blocks. The selection is based
<P>
<PRE>
  on the dynamic type of an expression. A name is associated with the expression or variable (19.4, 19.5.1.6), in
<P>
  the same way as for the ASSOCIATE construct.
<P>
  R1152 select-type-construct         is   select-type-stmt
<P>
                                                [ type-guard-stmt
<P>
                                                     block ] &#46;&#46;&#46;
<P>
                                                end-select-type-stmt
<P>
  R1153 select-type-stmt              is   [ select-construct-name : ] SELECT TYPE
<P>
                                               ( [ associate-name =&gt; ] selector )
<P>
  C1157 (R1153) If selector is not a named variable, associate-name =&gt; shall appear.
<P>
  C1158 (R1153) If selector is not a variable or is a variable that has a vector subscript, neither associate-name
<P>
          nor any subobject thereof shall appear in a variable definition context (19.6.7).
<P>
  C1159 (R1153) The selector in a select-type-stmt shall be polymorphic.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        201
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1154 type-guard-stmt                   is TYPE IS ( type-spec ) [ select-construct-name ]
<P>
                                          or CLASS IS ( derived-type-spec ) [ select-construct-name ]
<P>
                                          or CLASS DEFAULT [ select-construct-name ]
<P>
  C1160 (R1154) The type-spec or derived-type-spec shall specify that each length type parameter is assumed.
<P>
  C1161 (R1154) The type-spec or derived-type-spec shall not specify a type with the BIND attribute or the
<P>
           SEQUENCE attribute.
<P>
  C1162 (R1152) If selector is not unlimited polymorphic, each TYPE IS or CLASS IS type-guard-stmt shall
<P>
           specify an extension of the declared type of selector.
<P>
  C1163 (R1152) For a given select-type-construct, the same type and kind type parameter values shall not be
<P>
           specified in more than one TYPE IS type-guard-stmt and shall not be specified in more than one CLASS
<P>
           IS type-guard-stmt.
<P>
  C1164 (R1152) For a given select-type-construct, there shall be at most one CLASS DEFAULT type-guard-stmt.
<P>
  R1155 end-select-type-stmt              is  END SELECT [ select-construct-name ]
<P>
  C1165 (R1152) If the select-type-stmt of a select-type-construct specifies a select-construct-name, the correspond-
<P>
           ing end-select-type-stmt shall specify the same select-construct-name. If the select-type-stmt of a select-
<P>
           type-construct does not specify a select-construct-name, the corresponding end-select-type-stmt shall not
<P>
           specify a select-construct-name. If a type-guard-stmt specifies a select-construct-name, the corresponding
<P>
           select-type-stmt shall specify the same select-construct-name.
<P>
</PRE>
2 The associate name of a SELECT TYPE construct is the associate-name if specified; otherwise it is the name
<P>
<PRE>
  that constitutes the selector.
<P>
  11.1.11.2     Execution of the SELECT TYPE construct
<P>
</PRE>
1 Execution of a SELECT TYPE construct causes evaluation of every expression within a selector that is a variable
<P>
<PRE>
  designator, or evaluation of a selector that is not a variable designator.
<P>
</PRE>
2 A SELECT TYPE construct selects at most one block to be executed. During execution of that block, the
<P>
<PRE>
  associate name identifies an entity which is associated (19.5.1.6) with the selector.
<P>
</PRE>
3 A TYPE IS type guard statement matches the selector if the dynamic type and kind type parameter values of
<P>
<PRE>
  the selector are the same as those specified by the statement. A CLASS IS type guard statement matches the
<P>
  selector if the dynamic type of the selector is an extension of the type specified by the statement and the kind
<P>
  type parameter values specified by the statement are the same as the corresponding type parameter values of the
<P>
  dynamic type of the selector.
<P>
</PRE>
4 The block to be executed is selected as follows.
<P>
<PRE>
         (1)    If a TYPE IS type guard statement matches the selector, the block following that statement is
<P>
                executed.
<P>
         (2)    Otherwise, if exactly one CLASS IS type guard statement matches the selector, the block following
<P>
                that statement is executed.
<P>
         (3)    Otherwise, if several CLASS IS type guard statements match the selector, one of these statements
<P>
                will inevitably specify a type that is an extension of all the types specified in the others; the block
<P>
                following that statement is executed.
<P>
         (4)    Otherwise, if there is a CLASS DEFAULT type guard statement, the block following that statement
<P>
                is executed.
<P>
         (5)    Otherwise, no block is executed.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>202</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 11.28
<BLOCKQUOTE>
<P>
This algorithm does not examine the type guard statements in source text order when it looks for a match;
<P>
it selects the most particular type guard when there are several potential matches.
</BLOCKQUOTE>
<P>
5 Within the block following a TYPE IS type guard statement, the associating entity (19.5.5) is not polymorphic
<P>
<PRE>
  (7.3.2.3), has the type named in the type guard statement, and has the type parameter values of the selector.
<P>
</PRE>
6 Within the block following a CLASS IS type guard statement, the associating entity is polymorphic and has the
<P>
<PRE>
  declared type named in the type guard statement. The type parameter values of the associating entity are the
<P>
  corresponding type parameter values of the selector.
<P>
</PRE>
7 Within the block following a CLASS DEFAULT type guard statement, the associating entity is polymorphic and
<P>
<PRE>
  has the same declared type as the selector. The type parameter values of the associating entity are those of the
<P>
  declared type of the selector.
<P>
        NOTE 11.29
<P>
        If the declared type of the selector is T, specifying CLASS DEFAULT has the same effect as specifying
<P>
        CLASS IS (T).
<P>
</PRE>
8 The other attributes of the associating entity are described in 11.1.3.3.
<BLOCKQUOTE>
<P>
9 It is permissible to branch to an end-select-type-stmt only from within its SELECT TYPE construct.
<P>
<PRE>
  11.1.11.3     Examples of the SELECT TYPE construct
<P>
        NOTE 11.30
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
REAL :: X, Y
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE, <B>EXTENDS</B>(POINT) :: POINT_3D
<P>
<PRE>
           REAL :: Z
<P>
</PRE>
END TYPE POINT_3D
<P>
TYPE, <B>EXTENDS</B>(POINT) :: COLOR_POINT
<P>
<PRE>
           INTEGER :: COLOR
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE COLOR_POINT</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(POINT), TARGET :: P
<P>
<B>TYPE</B>(POINT_3D), TARGET :: P3
<P>
<B>TYPE</B>(COLOR_POINT), TARGET :: C
<P>
<B>CLASS</B>(POINT), POINTER :: P_OR_C
<P>
P_OR_C =&gt; C
<P>
SELECT TYPE ( A =&gt; P_OR_C )
<P>
CLASS IS ( POINT )
<P>
<PRE>
           ! "CLASS ( POINT ) :: A" implied here
<P>
           PRINT *, A%X, A%Y ! This block gets executed
<P>
</PRE>
TYPE IS ( POINT_3D )
<P>
<PRE>
           ! "TYPE ( POINT_3D ) :: A" implied here
<P>
           PRINT *, A%X, A%Y, A%Z
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 11.31
<P>
The following example illustrates the omission of associate-name. It uses the declarations from NOTE
<P>
11.30.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: 11.30.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
203
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
         NOTE 11.31 (cont.)
<P>
         P_OR_C =&gt; P3
<P>
         SELECT TYPE ( P_OR_C         )
<P>
         CLASS IS ( POINT )
<P>
           ! "CLASS ( POINT )         :: P_OR_C" implied here
<P>
           PRINT *, P_OR_C%X,         P_OR_C%Y
<P>
         TYPE IS ( POINT_3D )
<P>
           ! "TYPE ( POINT_3D         ) :: P_OR_C" implied here
<P>
           PRINT *, P_OR_C%X,         P_OR_C%Y, P_OR_C%Z ! This block gets executed
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.1.12</B> </TD><TD valign=bottom>
EXIT statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The EXIT statement provides one way of terminating a loop, or completing execution of another construct.
<P>
<PRE>
  R1156 exit-stmt                            is  EXIT [ construct-name ]
<P>
  C1166 If a construct-name appears on an EXIT statement, the EXIT statement shall be within that construct;
<P>
            otherwise, it shall be within at least one do-construct.
<P>
</PRE>
2 An EXIT statement belongs to a particular construct. If a construct name appears, the EXIT statement belongs
<P>
<PRE>
  to that construct; otherwise, it belongs to the innermost DO construct in which it appears.
<P>
  C1167 An exit-stmt shall not appear within a CHANGE TEAM, CRITICAL, or DO CONCURRENT construct
<P>
            if it belongs to that construct or an outer construct.
<P>
</PRE>
3 When an EXIT statement that belongs to a DO construct is executed, it terminates the loop (11.1.7.4.5) and
<P>
<PRE>
  any active loops contained within the terminated loop. When an EXIT statement that belongs to a non-DO
<P>
  construct is executed, it terminates any active loops contained within that construct, and completes execution of
<P>
  that construct.
<P>
  11.2         Branching
<P>
  11.2.1        Branch concepts
<P>
</PRE>
1 Branching is used to alter the normal execution sequence. A branch causes a transfer of control from one statement
<P>
<PRE>
  to a labeled branch target statement in the same inclusive scope. Branching may be caused by a GO TO state-
<P>
  ment, a computed GO TO statement, a CALL statement that has an alt-return-spec, or an input/output statement that has
<P>
  an END=, EOR=, or ERR= specifier. Although procedure references and control constructs can cause transfer
<P>
  of control, they are not branches. A branch target statement is an action-stmt, associate-stmt, end-associate-
<P>
  stmt, if-then-stmt, end-if-stmt, select-case-stmt, end-select-stmt, select-rank-stmt, end-select-rank-stmt, select-
<P>
  type-stmt, end-select-type-stmt, do-stmt, end-do-stmt, block-stmt, end-block-stmt, critical-stmt, end-critical-stmt,
<P>
  forall-construct-stmt, forall-stmt, where-construct-stmt, end-function-stmt, end-mp-subprogram-stmt, end-program-
<P>
  stmt, or end-subroutine-stmt.
<P>
  11.2.2        GO TO statement
<P>
  R1157 goto-stmt                            is  GO TO label
<P>
  C1168 (R1157) The label shall be the statement label of a branch target statement that appears in the same
<P>
            inclusive scope as the goto-stmt.
<P>
</PRE>
1 Execution of a GO TO statement causes a branch to the branch target statement identified by the label.
<P>
<PRE>
  204                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  11.2.3         Computed GO TO statement
<P>
  R1158      computed-goto-stmt                  is   GO TO ( label-list ) [ , ] scalar-int-expr
<P>
  C1169      (R1158) Each label in label-list shall be the statement label of a branch target statement that appears in the same inclusive
<P>
             scope as the computed-goto-stmt.
<P>
</PRE>
1 Execution of a computed GO TO statement causes evaluation of the scalar integer expression. If this value is i such that 1 ≤ i ≤ n
<P>
<PRE>
  where n is the number of labels in label-list, a branch occurs to the branch target statement identified by the ith label in the list of
<P>
  labels. If i is less than 1 or greater than n, the execution sequence continues as though a CONTINUE statement were executed.
<P>
  11.3          CONTINUE statement
<P>
</PRE>
1 Execution of a CONTINUE statement has no effect.
<P>
<PRE>
  R1159 continue-stmt                            is   CONTINUE
<P>
  11.4          STOP and ERROR STOP statements
<P>
  R1160 stop-stmt                                is   STOP [ stop-code ] [ , QUIET = scalar-logical-expr]
<P>
  R1161 error-stop-stmt                          is   ERROR STOP [ stop-code ] [ , QUIET = scalar-logical-expr]
<P>
  R1162 stop-code                                is scalar-default-char-expr
<P>
                                                 or scalar-int-expr
<P>
  C1170 (R1162) The scalar-int-expr shall be of default kind.
<P>
</PRE>
1 Execution of a STOP statement initiates normal termination of execution. Execution of an ERROR STOP
<P>
<PRE>
  statement initiates error termination of execution.
<P>
</PRE>
2 When an image is terminated by a STOP or ERROR STOP statement, its stop code, if any, is made available
<P>
<PRE>
  in a processor-dependent manner. If the stop-code is an integer, it is recommended that the value be used as
<P>
  the process exit status, if the processor supports that concept. If the stop-code in a STOP statement is of type
<P>
  character or does not appear, or if an end-program-stmt is executed, it is recommended that the value zero be
<P>
  supplied as the process exit status, if the processor supports that concept. If the stop-code in an ERROR STOP
<P>
  statement is of type character or does not appear, it is recommended that a processor-dependent nonzero value
<P>
  be supplied as the process exit status, if the processor supports that concept.
<P>
</PRE>
3 If QUIET= is omitted or the scalar-logical-expr has the value false:
<P>
<PRE>
      • if any exception (17) is signaling on that image, the processor shall issue a warning indicating which
<P>
         exceptions are signaling, and this warning shall be on the unit identified by the named constant ERROR_-
<P>
         UNIT from the intrinsic module ISO_FORTRAN_ENV (16.10.2.9);
<P>
      • if a stop code is specified, it is recommended that it be made available by formatted output to the same
<P>
         unit.
<P>
</PRE>
4 If QUIET= appears and the scalar-logical-expr has the value true, no output of signaling exceptions or stop code
<P>
<PRE>
  shall be produced.
<P>
        NOTE 11.32
<P>
        When normal termination occurs on more than one image, it is expected that a processor-dependent sum-
<P>
        mary of any stop codes and signaling exceptions will be made available.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                             205
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 11.33
<P>
        If the integer stop-code is used as the process exit status, the processor might be able to interpret only values
<P>
        within a limited range, or only a limited portion of the integer value (for example, only the least-significant
<P>
        8 bits).
<P>
  11.5        FAIL IMAGE statement
<P>
  R1163 fail-image-stmt                    is   FAIL IMAGE
<P>
</PRE>
1 Execution of a FAIL IMAGE statement causes the executing image to cease participating in program execution
<P>
<PRE>
  without initiating termination. No further statements are executed by that image.
<P>
        NOTE 11.34
<P>
        The FAIL IMAGE statement allows a program to test a recovery algorithm without needing an actual
<P>
        failure.
<P>
        On a processor that does not have the ability to detect that an image has failed, execution of a FAIL
<P>
        IMAGE statement might provide a simulated failure environment that provides debug information.
<P>
        In a piece of code that executes about once a second, invoking this subroutine on an image
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE FAIL</H4>
</A>
<BLOCKQUOTE>
<P>
REAL :: X
<P>
CALL RANDOM_NUMBER (X)
<P>
IF (X&lt;0.001) FAIL IMAGE
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE FAIL</H4>
</A>
<BLOCKQUOTE>
<P>
will cause that image to have an independent 1/1000 chance of failure every second if the random number
<P>
generators on different images are independent.
<P>
Note that FAIL IMAGE is not an image control statement.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: Note that FAIL IMAGE is not an image control statement.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>11.6</B> </TD><TD valign=bottom>
Image execution control
<TABLE width=100% cellpadding=3><!-- tsb: Image execution control
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>11.6.1</B> </TD><TD valign=bottom>
Image control statements
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The execution sequence on each image is specified in 5.3.5.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 Execution of an image control statement divides the execution sequence on an image into segments. Each of the
<P>
<PRE>
  following is an image control statement:
<P>
      •  SYNC ALL statement;
<P>
      •  SYNC IMAGES statement;
<P>
      •  SYNC MEMORY statement;
<P>
      •  SYNC TEAM statement;
<P>
      •  ALLOCATE or DEALLOCATE statement that has a coarray allocate-object;
<P>
      •  CHANGE TEAM or END TEAM statement (11.1.5);
<P>
      •  CRITICAL or END CRITICAL statement (11.1.6);
<P>
      •  EVENT POST or EVENT WAIT statement;
<P>
      •  FORM TEAM statement;
<P>
      •  LOCK or UNLOCK statement;
<P>
      •  any statement that completes execution of a block or procedure and which results in the implicit deallocation
<P>
         of a coarray;
<P>
  206                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
      • a CALL statement that references the intrinsic subroutine MOVE_ALLOC with coarray arguments;
<P>
      • STOP statement;
<P>
      • END statement of a main program.
<P>
</PRE>
3 All image control statements except CRITICAL, END CRITICAL, EVENT POST, EVENT WAIT, FORM
<P>
<PRE>
  TEAM, LOCK, and UNLOCK include the effect of executing a SYNC MEMORY statement (11.6.5).
<P>
</PRE>
4 During an execution of a statement that invokes more than one procedure, at most one invocation shall cause
<P>
<PRE>
  execution of an image control statement other than CRITICAL or END CRITICAL.
<P>
  11.6.2       Segments
<P>
</PRE>
1 On each image, the sequence of statements executed before the first execution of an image control statement,
<P>
<PRE>
  between the execution of two image control statements, or after the last execution of an image control statement
<P>
  is a segment. The segment executed immediately before the execution of an image control statement includes the
<P>
  evaluation of all expressions within the statement.
<P>
</PRE>
2 By execution of image control statements or user-defined ordering (11.6.5), the program can ensure that the
<P>
<PRE>
  execution of the ith segment on image P, Pi , either precedes or succeeds the execution of the j th segment on
<P>
  another image Q, Qj . If the program does not ensure this, segments Pi and Qj are unordered; depending on the
<P>
  relative execution speeds of the images, some or all of the execution of the segment Pi may take place at the same
<P>
  time as some or all of the execution of the segment Qj .
<P>
</PRE>
3 A coarray may be referenced or defined by execution of an atomic subroutine during the execution of a segment
<P>
<PRE>
  that is unordered relative to the execution of a segment in which the coarray is referenced or defined by execution
<P>
  of an atomic subroutine. An event variable may be referenced or defined during the execution of a segment that
<P>
  is unordered relative to the execution of another segment in which that event variable is defined. Otherwise,
<P>
      • if a variable is defined or becomes undefined on an image in a segment, it shall not be referenced, defined,
<P>
         or become undefined in a segment on another image unless the segments are ordered,
<P>
      • if the allocation of an allocatable subobject of a coarray or the pointer association of a pointer subobject
<P>
         of a coarray is changed on an image in a segment, that subobject shall not be referenced, defined, or have
<P>
         its allocation or association status, dynamic type, array bounds, shape, or a deferred type parameter value
<P>
         inquired about in a segment on another image unless the segments are ordered, and
<P>
      • if a procedure invocation on image P is in execution in segments Pi , Pi+1 , &#46;&#46;&#46;, Pk and defines a noncoarray
<P>
         dummy argument, the effective argument shall not be referenced, defined, or become undefined on another
<P>
         image Q in a segment Qj unless Qj precedes Pi or succeeds Pk .
<P>
        NOTE 11.35
<P>
        The set of all segments on all images is partially ordered: the segment Pi precedes segment Qj if and
<P>
        only if there is a sequence of segments starting with Pi and ending with Qj such that each segment of the
<P>
        sequence precedes the next either because they are consecutive segments on the same image or because of
<P>
        the execution of image control statements.
<P>
        NOTE 11.36
<P>
        If the segments S1 , S2 , &#46;&#46;&#46;, Sk on the distinct images P1 , P2 , ..., Pk are all unordered with respect to each
<P>
        other, it is expected that the processor will ensure that each of these images is provided with an equitable
<P>
        share of resources for executing its segment.
<P>
        NOTE 11.37
<P>
        Because of the restrictions on references and definitions in unordered segments, the processor can apply
<P>
        code motion optimizations within a segment as if it were the only image in execution, provided calls to
<P>
        atomic subroutines are not involved.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               207
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 11.38
<P>
       The model upon which the interpretation of a program is based is that there is a permanent memory
<P>
       location for each coarray and that all images on which it is established can access it.
<P>
       In practice, apart from executions of atomic subroutines, the processor could make a copy of a nonvolatile
<P>
       coarray on an image (in cache or a register, for example) and, as an optimization, defer copying a changed
<P>
       value back to the permanent memory location while it is still being used. Since the variable is not volatile,
<P>
       it is safe to defer this transfer until the end of the segment and thereafter to reload from permanent memory
<P>
       any coarray that was not defined within the segment. It might not be safe to defer these actions beyond
<P>
       the end of the segment since another image might reference the variable then.
<P>
       The value of the ATOM argument of an atomic subroutine might be accessed or modified by another
<P>
       concurrently executing image. Therefore, execution of an atomic subroutine that references the ATOM
<P>
       argument cannot rely on a local copy, but instead always gets its value from its permanent memory location.
<P>
       Execution of an atomic subroutine that defines the ATOM argument does not complete until the value of
<P>
       its ATOM argument has been sent to its permanent memory location.
<P>
       NOTE 11.39
<P>
       The incorrect sequencing of image control statements can suspend execution indefinitely. For example, one
<P>
       image might be executing a SYNC ALL statement while another is executing an ALLOCATE statement
<P>
       for a coarray.
<P>
  11.6.3       SYNC ALL statement
<P>
  R1164 sync-all-stmt                      is    SYNC ALL [ ( [ sync-stat-list ] ) ]
<P>
  R1165 sync-stat                          is STAT = stat-variable
<P>
                                           or ERRMSG = errmsg-variable
<P>
  C1171 No specifier shall appear more than once in a given sync-stat-list.
<P>
  C1172 A stat-variable or errmsg-variable in a sync-stat shall not be a coindexed object.
<P>
</PRE>
1 The STAT= and ERRMSG= specifiers for image control statements are described in 11.6.11.
<P>
2 Successful execution of a SYNC ALL statement performs a synchronization of all images in the current team.
<P>
<PRE>
  Execution on an image, M, of the segment following the SYNC ALL statement is delayed until each other image
<P>
  in the current team has executed a SYNC ALL statement as many times as has image M in this team. The
<P>
  segments that executed before the SYNC ALL statement on an image precede the segments that execute after
<P>
  the SYNC ALL statement on another image.
<P>
       NOTE 11.40
<P>
       The processor might have special hardware or employ an optimized algorithm to make the SYNC ALL
<P>
       statement execute efficiently.
<P>
       Here is a simple example of its use. Image 1 reads data and broadcasts it to other images:
<P>
                  REAL :: P[*]
<P>
                  &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
IF (THIS_IMAGE()==1) THEN
<P>
<PRE>
                      READ (*,*) P
<P>
                      DO I = 2, NUM_IMAGES()
<P>
                         P[I] = P
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>208</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.6.4</B> </TD><TD valign=bottom>
SYNC IMAGES statement
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1166 sync-images-stmt</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   SYNC IMAGES ( image-set [ , sync-stat-list ] )
</TD></TR>
<TR valign=top><TD colspan=2>
<B>R1167 image-set</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is int-expr
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                         or *
<P>
</PRE>
C1173 An image-set that is an int-expr shall be scalar or of rank one.
<P>
C1174 The value of image-set shall not depend on the value of stat-variable or errmsg-variable.
</BLOCKQUOTE>
<P>
1 If image-set is an array expression, the value of each element shall be positive and not greater than the number
<P>
<PRE>
  of images in the current team, and there shall be no repeated values.
<P>
</PRE>
2 If image-set is a scalar expression, its value shall be positive and not greater than the number of images in the
<P>
<PRE>
  current team.
<P>
</PRE>
3 An image-set that is an asterisk specifies all images in the current team.
<BLOCKQUOTE>
<P>
4 Execution of a SYNC IMAGES statement performs a synchronization of the image with each of the other images
<P>
<PRE>
  in the image-set. Executions of SYNC IMAGES statements on images M and T correspond if the number of
<P>
  times image M has executed a SYNC IMAGES statement in the current team with T in its image set is the same
<P>
  as the number of times image T has executed a SYNC IMAGES statement with M in its image set in this team.
<P>
  The segments that executed before the SYNC IMAGES statement on either image precede the segments that
<P>
  execute after the corresponding SYNC IMAGES statement on the other image.
<P>
       NOTE 11.41
<P>
       A SYNC IMAGES statement that specifies the single image index value THIS_IMAGE ( ) in its image set
<P>
       is allowed. This simplifies writing programs for an arbitrary number of images by allowing correct execution
<P>
       in the limiting case of the number of images being equal to one.
<P>
       NOTE 11.42
<P>
       In a program that uses SYNC ALL as its only synchronization mechanism, every SYNC ALL statement
<P>
       could be replaced by a SYNC IMAGES (*) statement, but SYNC ALL might give better performance.
<P>
       SYNC IMAGES statements are not required to specify the entire image set, or even the same image set,
<P>
       on all images participating in the synchronization. In the following example, image 1 will wait for each of
<P>
       the other images to execute the statement SYNC IMAGES (1). The other images wait for image 1 to set
<P>
       up the data, but do not wait on any other image.
<P>
                IF (THIS_IMAGE() == 1) then
<P>
                    ! Set up coarray data needed by all other images.
<P>
                    SYNC IMAGES(*)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
SYNC <B>IMAGES</B>(1)
<P>
! Use the data set up by image 1.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
When the following example runs on five or more images, each image synchronizes with both of its neighbors,
<P>
in a circular fashion.
<P>
<PRE>
                INTEGER :: up, down
<P>
                &#46;&#46;&#46;
<P>
                IF (NUM_IMAGES () &gt; 1) THEN
<P>
                    up    = THIS_IMAGE () + 1; IF (up&gt;NUM_IMAGES ()) up = 1
<P>
                    down = THIS_IMAGE () - 1; IF (down==0) down = NUM_IMAGES ()
<P>
                    SYNC IMAGES ( (/ up, down /) )
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
209
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
        NOTE 11.42 (cont.)
<P>
        This might appear to have the same effect as SYNC ALL but there is no ordering between the preceding
<P>
        and succeeding segments on non-adjacent images. For example, the segment preceding the SYNC IMAGES
<P>
        statement on image 3 will be ordered before those succeeding it on images 2 and 4, but not those on images
<P>
        1 and 5.
<P>
        NOTE 11.43
<P>
        In the following example, each image synchronizes with its neighbor.
<P>
                  INTEGER :: ME, NE, STEP, NSTEPS
<P>
                  NE = NUM_IMAGES()
<P>
                  ME = THIS_IMAGE()
<P>
                  &#46;&#46;&#46; ! Initial calculation
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
DO STEP = 1, NSTEPS
<P>
<PRE>
                     IF (ME &gt; 1) SYNC IMAGES(ME-1)
<P>
                        &#46;&#46;&#46; ! Perform calculation
<P>
                     IF (ME &lt; NE) SYNC IMAGES(ME+1)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
The calculation starts on image 1 since all the others will be waiting on SYNC IMAGES (ME−1). When
<P>
this is done, image 2 can start and image 1 can perform its second calculation. This continues until they
<P>
are all executing different steps at the same time. Eventually, image 1 will finish and then the others will
<P>
finish one by one.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: finish one by one.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>11.6.5</B> </TD><TD valign=bottom>
SYNC MEMORY statement
<P>
1 Execution of a SYNC MEMORY statement ends one segment and begins another; those two segments can be
<P>
<PRE>
  ordered by a user-defined way with respect to segments on other images.
<P>
  R1168 sync-memory-stmt                  is  SYNC MEMORY [ ( [ sync-stat-list ] ) ]
<P>
</PRE>
2 If, by execution of statements on image P,
<P>
<PRE>
      • a variable X on image Q is defined, referenced, becomes undefined, or has its allocation status, pointer
<P>
         association status, array bounds, dynamic type, or type parameters changed or inquired about by execution
<P>
         of a statement,
<P>
      • that statement precedes a successful execution of a SYNC MEMORY statement, and
<P>
      • a variable Y on image Q is defined, referenced, becomes undefined, or has its allocation status, pointer
<P>
         association status, array bounds, dynamic type, or type parameters changed or inquired about by execution
<P>
         of a statement that succeeds execution of that SYNC MEMORY statement,
<P>
</PRE>
then the action regarding X on image Q precedes the action regarding Y on image Q.
<P>
3 User-defined ordering of segment Pi on image P to precede segment Qj on image Q occurs when
<P>
<PRE>
      • image P executes an image control statement that ends segment Pi , and then executes statements that
<P>
         initiate a cooperative synchronization between images P and Q, and
<P>
      • image Q executes statements that complete the cooperative synchronization between images P and Q and
<P>
         then executes an image control statement that begins segment Qj .
<P>
</PRE>
4 Execution of the cooperative synchronization between images P and Q shall include a dependency that forces
<P>
<PRE>
  execution on image P of the statements that initiate the synchronization to precede the execution on image Q of
<P>
  the statements that complete the synchronization. The mechanisms available for creating such a dependency are
<P>
  processor dependent.
<P>
  210                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 11.44
<P>
       SYNC MEMORY usually suppresses compiler optimizations that might reorder memory operations across
<P>
       the segment boundary defined by the SYNC MEMORY statement and ensures that all memory operations
<P>
       initiated in the preceding segments in its image complete before any memory operations in the subsequent
<P>
       segment in its image are initiated. It needs to do this unless it can establish that failure to do so could not
<P>
       alter processing on another image.
<P>
       NOTE 11.45
<P>
       SYNC MEMORY can be used to implement specialized schemes for segment ordering. For example, the user
<P>
       might have access to an external procedure that performs synchronization between images. That library
<P>
       procedure might not be aware of the mechanisms used by the processor to manage remote data references
<P>
       and definitions, and therefore not, by itself, be able to ensure the correct memory state before and after its
<P>
       reference. The SYNC MEMORY statement provides the needed memory ordering that enables the safe use
<P>
       of the external synchronization routine. For example:
<P>
                INTEGER :: IAM
<P>
                REAL      :: X[*]
<P>
                IAM = THIS_IMAGE ()
<P>
                IF (IAM == 1) X = 1.0
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; SYNC MEMORY</H4>
</A>
<BLOCKQUOTE>
<P>
CALL EXTERNAL_SYNC ()
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC MEMORY</H4>
</A>
<BLOCKQUOTE>
<P>
IF (IAM == 2) WRITE (*,*) X[1]
</BLOCKQUOTE>
<P>
where executing the subroutine EXTERNAL_SYNC has an image synchronization effect similar to execut-
<BLOCKQUOTE>
<P>
ing a SYNC ALL statement.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ing a SYNC ALL statement.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>11.6.6</B> </TD><TD valign=bottom>
SYNC TEAM statement
<TABLE width=100% cellpadding=3><!-- tsb: SYNC TEAM statement
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>R1169 sync-team-stmt</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
is   SYNC TEAM ( team-value [ , sync-stat-list ] )
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The team-value shall identify an ancestor team, the current team, or a team whose parent is the current team.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  The executing image shall be a member of the specified team.
<P>
</PRE>
2 Successful execution of a SYNC TEAM statement performs a synchronization of the team identified by team-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value. Execution on an image, M, of the segment following the SYNC TEAM statement is delayed until each
<P>
  other image of the specified team has executed a SYNC TEAM statement specifying the same team as many
<P>
  times as has image M in this team. The segments that executed before the SYNC TEAM statement on an image
<P>
  precede the segments that execute after the corresponding SYNC TEAM statement on another image.
<P>
       NOTE 11.46
<P>
       A SYNC TEAM statement synchronizes a particular team whereas a SYNC ALL statement synchronizes
<P>
       the current team.
<P>
  11.6.7      EVENT POST statement
<P>
</PRE>
1 The EVENT POST statement posts an event.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1170 event-post-stmt                 is   EVENT POST ( event-variable [ , sync-stat-list ] )
<P>
  R1171 event-variable                  is   scalar-variable
<P>
  C1175 (R1171) An event-variable shall be of type EVENT_TYPE from the intrinsic module ISO_FORTRAN_-
<P>
           ENV (16.10.2).
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            211
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The event-variable shall not depend on the value of stat-variable or errmsg-variable.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 Successful execution of an EVENT POST statement atomically increments the count of the event variable by
<P>
<PRE>
  one. If an error condition occurs during execution of an EVENT POST statement, the value of the count of the
<P>
  event variable is processor dependent. The completion of an EVENT POST statement does not depend on the
<P>
  execution of a corresponding EVENT WAIT statement.
<P>
  11.6.8      EVENT WAIT statement
<P>
</PRE>
1 The EVENT WAIT statement waits until an event is posted.
<P>
<PRE>
  R1172 event-wait-stmt                 is  EVENT WAIT ( event-variable [ , event-wait-spec-list ] )
<P>
  R1173 event-wait-spec                 is until-spec
<P>
                                        or sync-stat
<P>
  R1174 until-spec                      is  UNTIL_COUNT = scalar-int-expr
<P>
  C1176 (R1172) The event-variable in an event-wait-stmt shall not be coindexed.
<P>
  C1177 No specifier shall appear more than once in a given event-wait-spec-list.
<P>
</PRE>
2 The event-variable shall not depend on the value of stat-variable or errmsg-variable.
<P>
3 Execution of an EVENT WAIT statement consists of the following sequence of actions:
<TABLE width=100% cellpadding=3><!-- tsb: 3 Execution of an EVENT WAIT statement consists of the following sequence of actions:
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=4%>
1.
</TD><TD>
if the UNTIL_COUNT= specifier does not appear, the threshold value is set to one; otherwise, the threshold
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        value is set to the maximum of the value of the scalar-int-expr and one;
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=4%>
2.
</TD><TD>
the executing image waits until the count of the event variable is greater than or equal to the threshold
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        value or an error condition occurs;
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=4%>
3.
</TD><TD>
if no error condition occurs, the count of the event variable is atomically decremented by the threshold
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        value.
<P>
</PRE>
4 If an error condition occurs during execution of an EVENT WAIT statement, the value of the count of its event
<P>
<PRE>
  variable is processor dependent.
<P>
</PRE>
5 An EVENT POST statement execution is initially unsatisfied. Successful execution of an EVENT WAIT state-
<P>
<PRE>
  ment with a threshold of k satisfies the first k unsatisfied EVENT POST statement executions for that event
<P>
  variable. This EVENT WAIT statement execution causes the segment following the EVENT WAIT statement
<P>
  execution to succeed the segments preceding those k EVENT POST statement executions.
<P>
  11.6.9      FORM TEAM statement
<P>
</PRE>
1 The FORM TEAM statement creates new teams whose parent team is the current team.
<P>
<PRE>
  R1175 form-team-stmt                  is  FORM TEAM ( team-number, team-variable
<P>
                                               [ , form-team-spec-list ] )
<P>
  R1176 team-number                     is  scalar-int-expr
<P>
  R1177 team-variable                   is  scalar-variable
<P>
  C1178 A team-variable shall be of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
<P>
  R1178 form-team-spec                  is NEW_INDEX = scalar-int-expr
<P>
                                        or sync-stat
<P>
  C1179 No specifier shall appear more than once in a given form-team-spec-list.
<P>
  212                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 Successful execution of a FORM TEAM statement creates a new team for each unique team-number value specified
<P>
<PRE>
  by the active images of the current team. The value of team-number shall be positive. Each executing image will
<P>
  belong to the team whose team number is equal to the value of team-number on that image, and the team-variable
<P>
  becomes defined with a value that identifies that team.
<P>
</PRE>
3 The value of the scalar-int-expr in a NEW_INDEX= specifier specifies the image index that the executing image
<P>
<PRE>
  will have in its new team. It shall be positive, less than or equal to the number of images in the team, and
<P>
  different from the value specified by every other image that belongs to that team.
<P>
</PRE>
4 If the NEW_INDEX= specifier does not appear, the image index of the executing image in the new team is
<P>
<PRE>
  processor dependent. This image index will be positive, less than or equal to the number of images in the team,
<P>
  and different from that of every other image in the team.
<P>
</PRE>
5 If the FORM TEAM statement is executed on one image, the same statement shall be executed on all active
<P>
<PRE>
  images of the current team. When a FORM TEAM statement is executed, there is an implicit synchronization
<P>
  of all active images in the current team. On those images, execution of the segment following the statement is
<P>
  delayed until all other active images in the current team have executed the same statement the same number of
<P>
  times in this team. The segments that executed before the FORM TEAM statement on an active image of this
<P>
  team precede the segments that execute after the FORM TEAM statement on another active image of this team.
<P>
  If an error condition other than detection of a failed image occurs, the team variable becomes undefined.
<P>
</PRE>
6 If execution of a FORM TEAM statement assigns the value STAT_FAILED_IMAGE to the stat-variable, the
<P>
<PRE>
  effect is the same as for the successful execution of FORM TEAM except for the value assigned to stat-variable.
<P>
        NOTE 11.47
<P>
        Executing the statement
<P>
                 FORM TEAM ( 2 - MOD (THIS_IMAGE (), 2), ODD_EVEN )
<P>
        will create two subteams of the current team, with images whose image index is odd being in the team with
<P>
        number 1, and those with an even image index being in the team with number 2.
<P>
        NOTE 11.48
<P>
        If the current team consists of P 2 images, with corresponding coarrays on each image representing parts of
<P>
        a larger array spread over a P × P square, the following code will establish teams for the rows with image
<P>
        indices equal to the column indices.
<P>
                 USE, INTRINSIC :: ISO_FORTRAN_ENV
<P>
                 TYPE(TEAM_TYPE) :: ROW
<P>
                 REAL :: A [P, *]
<P>
                 INTEGER :: ME (2)
<P>
                 ME (:) = THIS_IMAGE (A)
<P>
                 FORM TEAM (ME(1), ROW, NEW_INDEX=ME(2))
<P>
  11.6.10       LOCK and UNLOCK statements
<P>
  R1179 lock-stmt                        is   LOCK ( lock-variable [ , lock-stat-list ] )
<P>
  R1180 lock-stat                        is ACQUIRED_LOCK = scalar-logical-variable
<P>
                                         or sync-stat
<P>
  C1180 No specifier shall appear more than once in a given lock-stat-list.
<P>
  R1181 unlock-stmt                      is   UNLOCK ( lock-variable [ , sync-stat-list ] )
<P>
  R1182 lock-variable                    is   scalar-variable
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        213
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1181 (R1182) A lock-variable shall be of type LOCK_TYPE from the intrinsic module ISO_FORTRAN_ENV
<P>
            (16.10.2.19).
<P>
</PRE>
1 The lock-variable shall not depend on the value of stat-variable, errmsg-variable, or the scalar-logical-variable in
<P>
<PRE>
  the ACQUIRED_LOCK= specifier. The scalar-logical-variable shall not depend on the value of the lock-variable,
<P>
  stat-variable, or errmsg-variable.
<P>
</PRE>
2 A lock variable is unlocked if and only if the value of each component is the same as its default value. If it has any
<P>
<PRE>
  other value, it is locked. A lock variable is locked by an image if it was locked by execution of a LOCK statement
<P>
  on that image, has not been subsequently unlocked by execution of an UNLOCK statement on the same image,
<P>
  and that image has not failed.
<P>
</PRE>
3 Successful execution of a LOCK statement without an ACQUIRED_LOCK= specifier causes the lock variable
<P>
<PRE>
  to become locked by that image. If the lock variable is already locked by another image, that LOCK statement
<P>
  causes the lock variable to become locked after the other image causes the lock variable to become unlocked.
<P>
</PRE>
4 If the lock variable is unlocked, successful execution of a LOCK statement with an ACQUIRED_LOCK= specifier
<P>
<PRE>
  causes the lock variable to become locked by that image and the scalar logical variable to become defined with the
<P>
  value true. If the lock variable is already locked by a different image, successful execution of a LOCK statement
<P>
  with an ACQUIRED_LOCK= specifier leaves the lock variable unchanged and causes the scalar logical variable
<P>
  to become defined with the value false.
<P>
</PRE>
5 Successful execution of an UNLOCK statement causes the lock variable to become unlocked. Failure of an image
<P>
<PRE>
  causes all lock variables that are locked by that image to become unlocked.
<P>
</PRE>
6 During execution of the program, the value of a lock variable changes through a sequence of locked and unlocked
<P>
<PRE>
  states due to the execution of LOCK and UNLOCK statements, and by failure of an image while it is locked by
<P>
  that image. If a lock variable becomes unlocked by execution of an UNLOCK statement on image M and next
<P>
  becomes locked by execution of a LOCK statement on image T, the segments preceding the UNLOCK statement
<P>
  on image M precede the segments following the LOCK statement on image T. Execution of a LOCK statement
<P>
  that does not cause the lock variable to become locked does not affect segment ordering.
<P>
</PRE>
7 An error condition occurs if the lock variable in a LOCK statement is already locked by the executing image.
<P>
<PRE>
  An error condition occurs if the lock variable in an UNLOCK statement is not already locked by the executing
<P>
  image. If an error condition occurs during execution of a LOCK or UNLOCK statement, the value of the lock
<P>
  variable is not changed and the value of the ACQUIRED_LOCK variable, if any, is not changed.
<P>
        NOTE 11.49
<P>
        A lock variable is effectively defined atomically by a LOCK or UNLOCK statement. If LOCK statements on
<P>
        two images both attempt to acquire a lock, one will succeed and the other will either fail if an ACQUIRED_-
<P>
        LOCK= specifier appears, or will wait until the lock is later released if an ACQUIRED_LOCK= specifier
<P>
        does not appear.
<P>
        NOTE 11.50
<P>
        An image might wait for a LOCK statement to successfully complete for a long period of time if other
<P>
        images frequently lock and unlock the same lock variable. This situation might result from executing
<P>
        LOCK statements with ACQUIRED_LOCK= specifiers inside a spin loop.
<P>
        NOTE 11.51
<P>
        The following example illustrates the use of LOCK and UNLOCK statements to manage a work queue:
<P>
        USE, INTRINSIC :: ISO_FORTRAN_ENV
<P>
        TYPE(LOCK_TYPE) :: queue_lock[*] ! Lock on each image to manage its work queue
<P>
        INTEGER :: work_queue_size[*]
<P>
        TYPE(Task) :: work_queue(100)[*] ! List of tasks to perform
<P>
  214                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 11.51 (cont.)
<P>
        TYPE(Task) :: job ! Current task working on
<P>
        INTEGER :: me
<P>
        me = THIS_IMAGE()
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; DO</H4>
</A>
<BLOCKQUOTE>
<P>
! Process the next item in your work queue
<P>
LOCK (queue_lock) ! New segment A starts
<P>
! This segment A is ordered with respect to
<P>
! segment B executed by image me-1 below because of lock exclusion
<P>
IF (work_queue_size&gt;0) THEN
<P>
<PRE>
               ! Fetch the next job from the queue
<P>
               job = work_queue(work_queue_size)
<P>
               work_queue_size = work_queue_size-1
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
UNLOCK (queue_lock) ! Segment ends
<P>
&#46;&#46;&#46; ! Actually process the task
<P>
! Add a new task on neighbors queue:
<P>
<B>LOCK</B>(queue_lock[me+1]) ! Starts segment B
<P>
! This segment B is ordered with respect to
<P>
! segment A executed by image me+1 above because of lock exclusion
<P>
IF (work_queue_size[me+1]&lt;SIZE (work_queue)) THEN
<P>
<PRE>
               work_queue_size[me+1] = work_queue_size[me+1]+1
<P>
               work_queue(work_queue_size[me+1])[me+1] = job
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
UNLOCK (queue_lock[me+1]) ! Ends segment B
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>11.6.11</B> </TD><TD valign=bottom>
STAT= and ERRMSG= specifiers in image control statements
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 In an image control statement, the stat-variable in a sync-stat shall not depend on the value of an errmsg-variable
<P>
<PRE>
  in a sync-stat, event-variable, lock-variable, team-variable, or the scalar-logical-variable in the ACQUIRED_-
<P>
  LOCK= specifier. The errmsg-variable in a sync-stat shall not depend on the value of a stat-variable in a
<P>
  sync-stat, event-variable, lock-variable, team-variable, or the scalar-logical-variable in the ACQUIRED_LOCK=
<P>
  specifier.
<P>
</PRE>
2 If a STAT= specifier appears in a sync-stat in an image control statement, the stat-variable is assigned the value
<P>
<PRE>
  zero if execution of the statement is successful.
<P>
</PRE>
3 If the STAT= specifier appears in a sync-stat in an EVENT WAIT or SYNC MEMORY statement and an error
<P>
<PRE>
  condition occurs, stat-variable is assigned a processor-dependent positive value that is different from the value
<P>
  of STAT_FAILED_IMAGE (16.10.2.26) and STAT_STOPPED_IMAGE (16.10.2.29) from the intrinsic module
<P>
  ISO_FORTRAN_ENV (16.10.2).
<P>
</PRE>
4 The images involved in execution of an END TEAM, FORM TEAM, or SYNC ALL statement are those in the
<P>
<PRE>
  current team. The images involved in execution of a CHANGE TEAM or SYNC TEAM statement are those of
<P>
  the specified team. The images involved in execution of a SYNC IMAGES statement are the images specified
<P>
  and the executing image. The images involved in execution of an EVENT POST statement are the image on
<P>
  which the event variable is located and the executing image.
<P>
</PRE>
5 If the STAT= specifier appears in a sync-stat in a CHANGE TEAM, END TEAM, EVENT POST, FORM
<P>
<PRE>
  TEAM, SYNC ALL, SYNC IMAGES, or SYNC TEAM statement,
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         215
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
       • if one of the images involved has stopped, stat-variable is assigned the value STAT_STOPPED_IMAGE
<P>
          (16.10.2.29) from the intrinsic module ISO_FORTRAN_ENV;
<P>
       • otherwise, if one of the images involved has failed and no other error condition occurs, the intended action
<P>
          is performed on the active images involved and stat-variable is assigned the value STAT_FAILED_IMAGE
<P>
          (16.10.2.26) from the intrinsic module ISO_FORTRAN_ENV;
<P>
       • otherwise, if any other error condition occurs, stat-variable is assigned a processor-dependent positive value
<P>
          that is different from the values of STAT_STOPPED_IMAGE and STAT_FAILED_IMAGE.
<P>
</PRE>
6 If the STAT= specifier appears in a sync-stat in a SYNC ALL, SYNC IMAGES, or SYNC TEAM statement
<P>
<PRE>
   and the error condition STAT_STOPPED_IMAGE occurs, the effect is the same as that of executing the SYNC
<P>
   MEMORY statement, except for defining the stat-variable.
<P>
</PRE>
7 If the STAT= specifier appears in a sync-stat in a LOCK statement,
<P>
<PRE>
       • if the image on which the lock variable is located has failed, the stat-variable becomes defined with the
<P>
          value STAT_FAILED_IMAGE;
<P>
       • otherwise, if the lock variable is locked by the executing image, the stat-variable becomes defined with the
<P>
          value of STAT_LOCKED (16.10.2.27) from the intrinsic module ISO_FORTRAN_ENV;
<P>
       • otherwise, if the lock variable is unlocked because of the failure of the image that locked it, stat-variable
<P>
          becomes defined with the value STAT_UNLOCKED_FAILED_IMAGE (16.10.2.31) from the intrinsic
<P>
          module ISO_FORTRAN_ENV.
<P>
</PRE>
8 If the STAT= specifier appears in a sync-stat in an UNLOCK statement,
<P>
<PRE>
       • if the image on which the lock variable is located has failed, the stat-variable becomes defined with the
<P>
          value STAT_FAILED_IMAGE;
<P>
       • otherwise, if the lock variable has the value unlocked, the stat-variable becomes defined with the value of
<P>
          STAT_UNLOCKED (16.10.2.30) from the intrinsic module ISO_FORTRAN_ENV;
<P>
       • otherwise, if the lock variable is locked by a different image, the stat-variable becomes defined with the
<P>
          value STAT_LOCKED_OTHER_IMAGE (16.10.2.28) from the intrinsic module ISO_FORTRAN_ENV.
<P>
</PRE>
9 If the STAT= specifier appears in a sync-stat in a LOCK or UNLOCK statement and any other error condi-
<P>
<PRE>
   tion occurs during execution of that statement, the stat-variable becomes defined with a processor-dependent
<P>
   positive integer value that is different from STAT_LOCKED, STAT_LOCKED_OTHER_IMAGE, STAT_UN-
<P>
   LOCKED, and STAT_UNLOCKED_FAILED_IMAGE.
<P>
</PRE>
10 If an image completes execution of a CRITICAL statement that has a sync-stat that is a STAT= specifier and the
<P>
<PRE>
   previous image to have entered the construct failed while executing it, the stat-variable becomes defined with the
<P>
   value STAT_FAILED_IMAGE and execution of the construct continues normally. If any other error condition
<P>
   occurs during execution of a CRITICAL statement that has a STAT= specifier, the stat-variable becomes defined
<P>
   with a processor-dependent value other than STAT_FAILED_IMAGE.
<P>
</PRE>
11 If an error condition occurs during execution of an image control statement that does not contain the STAT=
<P>
<PRE>
   specifier in a sync-stat, error termination is initiated.
<P>
</PRE>
12 If an ERRMSG= specifier appears in an image control statement and an error condition occurs, errmsg-variable
<P>
<PRE>
   is assigned an explanatory message, truncated or padded according to the rules of intrinsic assignment. If no
<P>
   such condition occurs, the definition status and value of errmsg-variable are unchanged.
<P>
</PRE>
13 The set of error conditions that can occur in an image control statement is processor dependent.
<P>
<PRE>
         NOTE 11.52
<P>
         A processor might detect communication failure between images and treat it as an error condition. A
<P>
         processor might also treat an invalid set of images in a SYNC IMAGES statement as an error condition.
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>216</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
12 Input/output statements
<TABLE cellpadding=3><!-- tsb: 12 Input/output statements
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.1</B> </TD><TD valign=bottom>
Input/output concepts
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 Input statements provide the means of transferring data from external media to internal storage or from an internal
<P>
<PRE>
  file to internal storage. This process is called reading. Output statements provide the means of transferring data
<P>
  from internal storage to external media or from internal storage to an internal file. This process is called writing.
<P>
  Some input/output statements specify that editing of the data is to be performed.
<P>
</PRE>
2 In addition to the statements that transfer data, there are auxiliary input/output statements to manipulate the
<P>
<PRE>
  external medium, or to describe or inquire about the properties of the connection to the external medium.
<P>
</PRE>
3 The input/output statements are the BACKSPACE, CLOSE, ENDFILE, FLUSH, INQUIRE, OPEN, PRINT,
<P>
<PRE>
  READ, REWIND, WAIT, and WRITE statements.
<P>
</PRE>
4 A file is composed of either a sequence of file storage units (12.3.5) or a sequence of records, which provide an
<P>
<PRE>
  extra level of organization to the file. A file composed of records is called a record file. A file composed of file
<P>
  storage units is called a stream file. A processor may allow a file to be viewed both as a record file and as a stream
<P>
  file; in this case the relationship between the file storage units when viewed as a stream file and the records when
<P>
  viewed as a record file is processor dependent.
<P>
</PRE>
5 A file is either an external file (12.3) or an internal file (12.4).
<P>
<PRE>
  12.2         Records
<P>
  12.2.1        Definition of a record
<P>
</PRE>
1 A record is a sequence of values or a sequence of characters. For example, a line on a terminal is usually considered
<P>
<PRE>
  to be a record. However, a record does not necessarily correspond to a physical entity. There are three kinds of
<P>
  records:
<P>
          (1)    formatted;
<P>
          (2)    unformatted;
<P>
          (3)    endfile.
<P>
         NOTE 12.1
<P>
         What is called a “record” in Fortran is commonly called a “logical record”. There is no concept in Fortran
<P>
         of a “physical record.”
<P>
  12.2.2        Formatted record
<P>
</PRE>
1 A formatted record consists of a sequence of characters that are representable in the processor; however, a
<P>
<PRE>
  processor may prohibit some control characters (6.1.1) from appearing in a formatted record. The length of a
<P>
  formatted record is measured in characters and depends primarily on the number of characters put into the record
<P>
  when it is written; however, it may depend on the processor and the external medium. The length may be zero.
<P>
  Formatted records shall be read or written only by formatted input/output statements.
<P>
  12.2.3        Unformatted record
<P>
</PRE>
1 An unformatted record consists of a sequence of values in a processor-dependent form and may contain data
<P>
<PRE>
  of any type or may contain no data. The length of an unformatted record is measured in file storage units
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             217
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  (12.3.5) and depends on the output list (12.6.3) used when it is written, as well as on the processor and the
<P>
  external medium. The length may be zero. Unformatted records may be read or written only by unformatted
<P>
  input/output statements.
<P>
  12.2.4       Endfile record
<P>
</PRE>
1 An endfile record is written explicitly by the ENDFILE statement; the file shall be connected for sequential
<P>
<PRE>
  access. An endfile record is written implicitly to a file connected for sequential access when the most recent data
<P>
  transfer statement referring to the file is an output statement, no intervening file positioning statement referring
<P>
  to the file has been executed, and
<P>
      • a REWIND or BACKSPACE statement references the unit to which the file is connected, or
<P>
      • the unit is closed, either explicitly by a CLOSE statement, implicitly by normal termination, or implicitly
<P>
         by another OPEN statement for the same unit.
<P>
</PRE>
2 An endfile record may occur only as the last record of a file. An endfile record does not have a length property.
<P>
<PRE>
        NOTE 12.2
<P>
        An endfile record does not necessarily have any physical embodiment. The processor can use a record count
<P>
        or any other means to register the position of the file at the time an ENDFILE statement is executed, so
<P>
        that it can take appropriate action when that position is reached again during a read operation. The endfile
<P>
        record, however it is implemented, is considered to exist for the BACKSPACE statement (12.8.2).
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.3</B> </TD><TD valign=bottom>
External files
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>12.3.1</B> </TD><TD valign=bottom>
External file concepts
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 An external file is any file that exists in a medium external to the program.
<TABLE cellpadding=3><!-- tsb: 1 An external file is any file that exists in a medium external to the program.
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 At any given time, there is a processor-dependent set of allowed access methods, a processor-dependent set of
<P>
<PRE>
  allowed forms, a processor-dependent set of allowed actions, and a processor-dependent set of allowed record
<P>
  lengths for a file.
<P>
        NOTE 12.3
<P>
        For example, the processor-dependent set of allowed actions for a printer would likely include the write
<P>
        action, but not the read action.
<P>
</PRE>
3 A file may have a name; a file that has a name is called a named file. The name of a named file is represented by
<P>
<PRE>
  a character string value. The set of allowable names for a file is processor dependent. Whether a named file on
<P>
  one image is the same as a file with the same name on another image is processor dependent.
<P>
        NOTE 12.4
<P>
        If different files are needed on each image, using a different file name on each image will improve portability
<P>
        of the code. One technique is to incorporate the image index as part of the name.
<P>
</PRE>
4 An external file that is connected to a unit has a position property (12.3.4).
<P>
<PRE>
        NOTE 12.5
<P>
        For more explanatory information on external files, see C.7.1.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.3.2</B> </TD><TD valign=bottom>
File existence
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 At any given time, there is a processor-dependent set of external files that exist for a program. A file may be
<P>
<PRE>
  known to the processor, yet not exist for a program at a particular time.
<P>
  218                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 To create a file means to cause a file to exist that did not exist previously. To delete a file means to terminate
<P>
<PRE>
  the existence of the file.
<P>
</PRE>
3 All input/output statements may refer to files that exist. A CLOSE, ENDFILE, FLUSH, INQUIRE, OPEN,
<P>
<PRE>
  PRINT, REWIND, or WRITE statement is permitted to refer to a file that does not exist. No other input/output
<P>
  statement shall refer to a file that does not exist. Execution of a WRITE, PRINT, or ENDFILE statement
<P>
  referring to a preconnected file that does not exist creates the file. This file is a different file from one preconnected
<P>
  on any other image.
<P>
  12.3.3      File access
<P>
  12.3.3.1    File access methods
<P>
</PRE>
1 There are three methods of accessing the data of an external file: sequential, direct, and stream. Some files may
<P>
<PRE>
  have more than one allowed access method; other files may be restricted to one access method.
<P>
       NOTE 12.6
<P>
       For example, a processor might provide only sequential access to a file on magnetic tape. Thus, the set of
<P>
       allowed access methods depends on the file and the processor.
<P>
</PRE>
2 The method of accessing a file is determined when the file is connected to a unit (12.5.4) or when the file is
<P>
<PRE>
  created if the file is preconnected (12.5.5).
<P>
  12.3.3.2    Sequential access
<P>
</PRE>
1 Sequential access is a method of accessing the records of an external record file in order.
<P>
2 While connected for sequential access, an external file has the following properties.
<P>
<PRE>
      • The order of the records is the order in which they were written if the direct access method is not a member
<P>
        of the set of allowed access methods for the file. If the direct access method is also a member of the set of
<P>
        allowed access methods for the file, the order of the records is the same as that specified for direct access.
<P>
        In this case, the first record accessible by sequential access is the record whose record number is 1 for direct
<P>
        access. The second record accessible by sequential access is the record whose record number is 2 for direct
<P>
        access, etc. A record that has not been written since the file was created shall not be read.
<P>
      • The records of the file are either all formatted or all unformatted, except that the last record of the file may
<P>
        be an endfile record. Unless the previous reference to the file was an output statement, the last record, if
<P>
        any, of the file shall be an endfile record.
<P>
      • The records of the file shall be read or written only by sequential access data transfer statements.
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.3.3.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Direct access
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 Direct access is a method of accessing the records of an external record file in arbitrary order.
<P>
2 While connected for direct access, an external file has the following properties.
<P>
<PRE>
      • Each record of the file is uniquely identified by a positive integer called the record number. The record
<P>
        number of a record is specified when the record is written. Once established, the record number of a record
<P>
        can never be changed. The order of the records is the order of their record numbers.
<P>
      • The records of the file are either all formatted or all unformatted. If the sequential access method is also a
<P>
        member of the set of allowed access methods for the file, its endfile record, if any, is not considered to be
<P>
        part of the file while it is connected for direct access. If the sequential access method is not a member of
<P>
        the set of allowed access methods for the file, the file shall not contain an endfile record.
<P>
      • The records of the file shall be read or written only by direct access data transfer statements.
<P>
      • All records of the file have the same length.
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
219
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
<P>
<P>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
      • Records need not be read or written in the order of their record numbers. Any record may be written
<P>
        into the file while it is connected to a unit. For example, it is permissible to write record 3, even though
<P>
        records 1 and 2 have not been written. Any record may be read from the file while it is connected to a
<P>
        unit, provided that the record has been written since the file was created, and if a READ statement for this
<P>
        connection is permitted.
<P>
      • The records of the file shall not be read or written using list-directed formatting (13.10), namelist formatting
<P>
        (13.11), or a nonadvancing data transfer statement (12.3.4.2).
<P>
       NOTE 12.7
<P>
       A record cannot be deleted; however, a record can be rewritten.
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.3.3.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Stream access
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 Stream access is a method of accessing the file storage units (12.3.5) of an external stream file.
<TABLE cellpadding=3><!-- tsb: 1 Stream access is a method of accessing the file storage units (12.3.5) of an external stream file.
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 The properties of an external file connected for stream access depend on whether the connection is for unformatted
<P>
<PRE>
  or formatted access. While connected for stream access, the file storage units of the file shall be read or written
<P>
  only by stream access data transfer statements.
<P>
</PRE>
3 While connected for unformatted stream access, an external file has the following properties.
<P>
<PRE>
      • Each file storage unit in the file is uniquely identified by a positive integer called the position. The first file
<P>
        storage unit in the file is at position 1. The position of each subsequent file storage unit is one greater than
<P>
        that of its preceding file storage unit.
<P>
      • If it is possible to position the file, the file storage units need not be read or written in order of their position.
<P>
        For example, it might be permissible to write the file storage unit at position 3, even though the file storage
<P>
        units at positions 1 and 2 have not been written. Any file storage unit may be read from the file while it is
<P>
        connected to a unit, provided that the file storage unit has been written since the file was created, and if a
<P>
        READ statement for this connection is permitted.
<P>
</PRE>
4 While connected for formatted stream access, an external file has the following properties.
<P>
<PRE>
      • Some file storage units of the file may contain record markers; this imposes a record structure on the file
<P>
        in addition to its stream structure. There might or might not be a record marker at the end of the file. If
<P>
        there is no record marker at the end of the file, the final record is incomplete.
<P>
      • No maximum length (12.5.6.15) is applicable to these records.
<P>
      • Writing an empty record with no record marker has no effect.
<P>
      • Each file storage unit in the file is uniquely identified by a positive integer called the position. The first file
<P>
        storage unit in the file is at position 1. The relationship between positions of successive file storage units is
<P>
        processor dependent; not all positive integers need correspond to valid positions.
<P>
      • If it is possible to position the file, the file position can be set to a position that was previously identified
<P>
        by the POS= specifier in an INQUIRE statement.
<P>
      • A processor may prohibit some control characters (6.1.1) from appearing in a formatted stream file.
<P>
       NOTE 12.8
<P>
       Because the record structure is determined from the record markers that are stored in the file itself, an
<P>
       incomplete record at the end of the file is necessarily not empty.
<P>
       NOTE 12.9
<P>
       There might be some character positions in the file that do not correspond to characters written; this is
<P>
       because on some processors a record marker could be written to the file as a carriage-return/line-feed or
<P>
       other sequence. The means of determining the position in a file connected for stream access is via the POS=
<P>
       specifier in an INQUIRE statement (12.10.2.22).
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>220</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                           c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>12.3.4</B> </TD><TD valign=bottom>
File position
</TD></TR>
<TR valign=top><TD colspan=2>
<B>12.3.4.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
General
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Execution of certain input/output statements affects the position of an external file. Certain circumstances can
</TD></TR>
<TR><TD colspan=2>
<PRE>
  cause the position of a file to become indeterminate.
<P>
</PRE>
2 The initial point of a file is the position just before the first record or file storage unit. The terminal point is the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  position just after the last record or file storage unit. If there are no records or file storage units in the file, the
<P>
  initial point and the terminal point are the same position.
<P>
</PRE>
3 If a record file is positioned within a record, that record is the current record; otherwise, there is no current
</TD></TR>
<TR><TD colspan=2>
<PRE>
  record.
<P>
</PRE>
4 Let n be the number of records in the file. If 1 &lt; i ≤ n and a file is positioned within the ith record or between
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the (i − 1)th record and the ith record, the (i − 1)th record is the preceding record. If n ≥ 1 and the file is
<P>
  positioned at its terminal point, the preceding record is the nth and last record. If n = 0 or if a file is positioned
<P>
  at its initial point or within the first record, there is no preceding record.
<P>
</PRE>
5 If 1 ≤ i &lt; n and a file is positioned within the ith record or between the ith and (i + 1)th record, the (i + 1)th
</TD></TR>
<TR><TD colspan=2>
<PRE>
  record is the next record. If n ≥ 1 and the file is positioned at its initial point, the first record is the next record.
<P>
  If n = 0 or if a file is positioned at its terminal point or within the nth (last) record, there is no next record.
<P>
</PRE>
6 For a file connected for stream access, the file position is either between two file storage units, at the initial point
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of the file, at the terminal point of the file, or undefined.
<P>
  12.3.4.2     Advancing and nonadvancing input/output
<P>
</PRE>
1 An advancing input/output statement always positions a record file after the last record read or written, unless
</TD></TR>
<TR><TD colspan=2>
<PRE>
  there is an error condition.
<P>
</PRE>
2 A nonadvancing input/output statement may position a record file at a character position within the current
</TD></TR>
<TR><TD colspan=2>
<PRE>
  record, or a subsequent record (13.8.2). Using nonadvancing input/output, it is possible to read or write a record
<P>
  of the file by a sequence of data transfer statements, each accessing a portion of the record. If a nonadvancing
<P>
  output statement leaves a file positioned within a current record and no further output statement is executed for
<P>
  the file before it is closed or a BACKSPACE, ENDFILE, or REWIND statement is executed for it, the effect is
<P>
  as if the output statement were the corresponding advancing output statement.
<P>
  12.3.4.3     File position prior to data transfer
<P>
</PRE>
1 The positioning of the file prior to data transfer depends on the method of access: sequential, direct, or stream.
</TD></TR>
<TR><TD colspan=2>
2 For sequential access on input, if there is a current record, the file position is not changed. Otherwise, the file is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  positioned at the beginning of the next record and this record becomes the current record. Input shall not occur
<P>
  if there is no next record or if there is a current record and the last data transfer statement accessing the file
<P>
  performed output.
<P>
</PRE>
3 If the file contains an endfile record, the file shall not be positioned after the endfile record prior to data transfer.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  However, a REWIND or BACKSPACE statement may be used to reposition the file.
<P>
</PRE>
4 For sequential access on output, if there is a current record, the file position is not changed and the current record
</TD></TR>
<TR><TD colspan=2>
<PRE>
  becomes the last record of the file. Otherwise, a new record is created as the next record of the file; this new
<P>
  record becomes the last and current record of the file and the file is positioned at the beginning of this record.
<P>
</PRE>
5 For direct access, the file is positioned at the beginning of the record specified by the REC= specifier. This record
</TD></TR>
<TR><TD colspan=2>
<PRE>
  becomes the current record.
<P>
</PRE>
6 For stream access, the file is positioned immediately before the file storage unit specified by the POS= specifier;
</TD></TR>
<TR><TD colspan=2>
<PRE>
  if there is no POS= specifier, the file position is not changed.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               221
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
7 File positioning for child data transfer statements is described in 12.6.4.8.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  12.3.4.4      File position after data transfer
<P>
</PRE>
1 If an error condition (12.11) occurred, the position of the file is indeterminate. If no error condition occurred,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  but an end-of-file condition (12.11) occurred as a result of reading an endfile record, the file is positioned after
<P>
  the endfile record.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>2 For unformatted stream input/output, if no error condition occurred, the file position is not changed.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
For
</TD></TR>
<TR><TD colspan=2>
<PRE>
  unformatted stream output, if the file position exceeds the previous terminal point of the file, the terminal point
<P>
  is set to the file position.
<P>
         NOTE 12.10
<P>
         An unformatted stream output statement with a POS= specifier and an empty output list can have the
<P>
         effect of extending the terminal point of a file without actually writing any data.
<P>
</PRE>
3 For formatted stream input, if an end-of-file condition occurred, the file position is not changed.
</TD></TR>
<TR><TD colspan=2>
4 For nonadvancing input, if no error condition or end-of-file condition occurred, but an end-of-record condition
</TD></TR>
<TR><TD colspan=2>
<PRE>
  (12.11) occurred, the file is positioned after the record just read. If no error condition, end-of-file condition, or
<P>
  end-of-record condition occurred in a nonadvancing input statement, the file position is not changed. If no error
<P>
  condition occurred in a nonadvancing output statement, the file position is not changed.
<P>
</PRE>
5 In all other cases, the file is positioned after the record just read or written and that record becomes the preceding
</TD></TR>
<TR><TD colspan=2>
<PRE>
  record.
<P>
</PRE>
6 For a formatted stream output statement, if no error condition occurred, the terminal point of the file is set to
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the next position after the highest-numbered position to which a datum was transferred by the statement.
<P>
         NOTE 12.11
<P>
         The highest-numbered position might not be the current one if the output involved a T, TL, TR, or X edit
<P>
         descriptor (13.8.1) and the statement is a nonadvancing output statement.
<P>
  12.3.5        File storage units
<P>
</PRE>
1 A file storage unit is the basic unit of storage in a stream file or an unformatted record file. It is the unit of file
</TD></TR>
<TR><TD colspan=2>
<PRE>
  position for stream access, the unit of record length for unformatted files, and the unit of file size for all external
<P>
  files.
<P>
</PRE>
2 Every value in a stream file or an unformatted record file shall occupy an integer number of file storage units; if
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the stream or record file is unformatted, this number shall be the same for all scalar values of the same type and
<P>
  type parameters. The number of file storage units required for an item of a given type and type parameters may
<P>
  be determined using the IOLENGTH= specifier of the INQUIRE statement (12.10.3).
<P>
</PRE>
3 For a file connected for unformatted stream access, the processor shall not have alignment restrictions that prevent
</TD></TR>
<TR><TD colspan=2>
<PRE>
  a value of any type from being stored at any positive integer file position.
<P>
</PRE>
4 The number of bits in a file storage unit is given by the constant FILE_STORAGE_SIZE (16.10.2.11) defined
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in the intrinsic module ISO_FORTRAN_ENV. It is recommended that the file storage unit be an 8-bit octet
<P>
  where this choice is practical.
<P>
         NOTE 12.12
<P>
         The requirement that every data value occupy an integer number of file storage units implies that data
<P>
         items inherently smaller than a file storage unit will require padding. This suggests that the file storage
<P>
         unit be small to avoid wasted space. Ideally, the file storage unit would be chosen such that padding is
<P>
         never required. A file storage unit of one bit would always meet this goal, but would likely be impractical
<P>
         because of the alignment requirements.
<P>
  222                                                                    ⃝
<P>
                                                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 12.12 (cont.)
<P>
       The prohibition on alignment restrictions prohibits the processor from requiring data alignments larger than
<P>
       the file storage unit.
<P>
       The 8-bit octet is recommended as a good compromise that is small enough to accommodate the require-
<P>
       ments of many applications, yet not so small that the data alignment requirements are likely to cause
<P>
       significant performance problems.
<P>
  12.4       Internal files
<P>
</PRE>
1 Internal files provide a means of transferring and converting data from internal storage to internal storage.
</TD></TR>
<TR><TD colspan=2>
2 An internal file is a record file with the following properties.
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • The file is a variable of default, ASCII, or ISO 10646 character kind that is not an array section with a
<P>
        vector subscript.
<P>
      • A record of an internal file is a scalar character variable.
<P>
      • If the file is a scalar character variable, it consists of a single record whose length is the same as the length
<P>
        of the scalar character variable. If the file is a character array, it is treated as a sequence of character array
<P>
        elements. Each array element, if any, is a record of the file. The ordering of the records of the file is the
<P>
        same as the ordering of the array elements in the array (9.5.3.2) or the array section (9.5.3.3). Every record
<P>
        of the file has the same length, which is the length of an array element in the array.
<P>
      • A record of the internal file becomes defined by writing the record. If the number of characters written in
<P>
        a record is less than the length of the record, the remaining portion of the record is filled with blanks. The
<P>
        number of characters to be written shall not exceed the length of the record.
<P>
      • A record may be read only if the record is defined.
<P>
      • A record of an internal file may become defined (or undefined) by means other than an output statement.
<P>
        For example, the character variable may become defined by a character assignment statement.
<P>
      • An internal file is always positioned at the beginning of the first record prior to data transfer, except for
<P>
        child data transfer statements (12.6.4.8). This record becomes the current record.
<P>
      • The initial value of a connection mode (12.5.2) is the value that would be implied by an initial OPEN
<P>
        statement without the corresponding keyword.
<P>
      • Reading and writing records shall be accomplished only by sequential access formatted data transfer state-
<P>
        ments.
<P>
      • An internal file shall not be specified as the unit in a CLOSE, INQUIRE, or OPEN statement.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.5</B> </TD><TD valign=bottom>
File connection
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>12.5.1</B> </TD><TD valign=bottom>
Referring to a file
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 A unit, specified by an io-unit, provides a means for referring to a file.
<P>
<PRE>
  R1201 io-unit                            is file-unit-number
<P>
                                           or *
<P>
                                           or internal-file-variable
<P>
  R1202 file-unit-number                   is  scalar-int-expr
<P>
  R1203 internal-file-variable             is  char-variable
<P>
  C1201 (R1203) The char-variable shall not be an array section with a vector subscript.
<P>
  C1202 (R1203) The char-variable shall be default character, ASCII character, or ISO 10646 character.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               223
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 A unit is either an external unit or an internal unit. An external unit is used to refer to an external file and
<P>
<PRE>
  is specified by an asterisk or a file-unit-number. The value of file-unit-number shall be nonnegative, equal to
<P>
  one of the named constants INPUT_UNIT, OUTPUT_UNIT, or ERROR_UNIT of the intrinsic module ISO_-
<P>
  FORTRAN_ENV (16.10.2), the unit argument of an active defined input/output procedure (12.6.4.8), or a
<P>
  NEWUNIT value (12.5.6.12). An internal unit is used to refer to an internal file and is specified by an internal-
<P>
  file-variable or a file-unit-number whose value is equal to the unit argument of an active defined input/output
<P>
  procedure. The value of a file-unit-number shall identify a valid unit.
<P>
</PRE>
3 On an image, the external unit identified by a particular value of a scalar-int-expr is the same external unit in
<P>
<PRE>
  all program units.
<P>
        NOTE 12.13
<P>
        In the example:
<P>
</PRE>
</BLOCKQUOTE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE A</H4>
</A>
<BLOCKQUOTE>
<P>
READ (6) X
<P>
<PRE>
                &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE B</H4>
</A>
<BLOCKQUOTE>
<P>
N = 6
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; REWIND N</H4>
</A>
<BLOCKQUOTE>
<P>
the value 6 used in both program units identifies the same external unit.
</BLOCKQUOTE>
<P>
4 In a READ statement, an io-unit that is an asterisk identifies an external unit that is preconnected for sequential
<P>
<PRE>
  formatted input on image 1 in the initial team only (12.6.4.3). This unit is also identified by the value of
<P>
  the named constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.13). In a WRITE
<P>
  statement, an io-unit that is an asterisk identifies an external unit that is preconnected for sequential formatted
<P>
  output. This unit is also identified by the value of the named constant OUTPUT_UNIT of the intrinsic module
<P>
  ISO_FORTRAN_ENV (16.10.2.22).
<P>
</PRE>
5 This document identifies a processor-dependent external unit for the purpose of error reporting. This unit shall
<P>
<PRE>
  be preconnected for sequential formatted output. The processor may define this to be the same as the output
<P>
  unit identified by an asterisk. This unit is also identified by a unit number defined by the named constant
<P>
  ERROR_UNIT of the intrinsic module ISO_FORTRAN_ENV.
<P>
        NOTE 12.14
<P>
        Even though OUTPUT_UNIT is connected to a separate file on each image, it is expected that the processor
<P>
        could merge the sequences of records from these files into a single sequence of records that is sent to the
<P>
        physical device associated with this unit, such as the user’s terminal. If ERROR_UNIT is associated with
<P>
        the same physical device, the sequences of records from files connected to ERROR_UNIT on each of the
<P>
        images could be merged into the same sequence generated from the OUTPUT_UNIT files. Otherwise, it
<P>
        is expected that the sequence of records in the files connected to ERROR_UNIT on each image could be
<P>
        merged into a single sequence of records that is sent to the physical device associated with ERROR_UNIT.
<P>
  12.5.2      Connection modes
<P>
</PRE>
1 A connection for formatted input/output has several changeable modes: these are the blank interpretation mode
<P>
<PRE>
  (13.8.6), delimiter mode (13.10.4, 13.11.4.2), sign mode (13.8.4), decimal edit mode (13.8.8), input/output round-
<P>
  ing mode (13.7.2.3.8), pad mode (12.6.4.5.3), and scale factor (13.8.5). A connection for unformatted input/output
<P>
  has no changeable modes.
<P>
</PRE>
2 Values for the modes of a connection are established when the connection is initiated. If the connection is initiated
<P>
<PRE>
  by an OPEN statement, the values are as specified, either explicitly or implicitly, by the OPEN statement. If the
<P>
  connection is initiated other than by an OPEN statement (that is, if the file is an internal file or preconnected file)
<P>
  the values established are those that would be implied by an initial OPEN statement without the corresponding
<P>
  keywords.
<P>
  224                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 The scale factor cannot be explicitly specified in an OPEN statement; it is implicitly 0.
<BLOCKQUOTE>
<P>
4 The modes of a connection to an external file may be changed by a subsequent OPEN statement that modifies
<P>
<PRE>
  the connection.
<P>
</PRE>
5 The modes of a connection may be temporarily changed by a corresponding keyword specifier in a data transfer
<P>
<PRE>
  statement or by an edit descriptor. Keyword specifiers take effect at the beginning of execution of the data
<P>
  transfer statement. Edit descriptors take effect when they are encountered in format processing. When a data
<P>
  transfer statement terminates, the values for the modes are reset to the values in effect immediately before the
<P>
  data transfer statement was executed.
<P>
  12.5.3       Unit existence
<P>
</PRE>
1 At any given time, there is a processor-dependent set of external units that exist for an image.
<P>
2 All input/output statements are permitted to refer to units that exist. The CLOSE, INQUIRE, and WAIT
<P>
<PRE>
  statements are also permitted to refer to units that do not exist. No other input/output statement shall refer to
<P>
  a unit that does not exist.
<P>
  12.5.4       Connection of a file to a unit
<P>
</PRE>
1 An external unit has a property of being connected or not connected. If connected, it refers to an external file. An
<P>
<PRE>
  external unit may become connected by preconnection or by the execution of an OPEN statement. The property
<P>
  of connection is symmetric; the unit is connected to a file if and only if the file is connected to the unit.
<P>
</PRE>
2 Every input/output statement except an OPEN, CLOSE, INQUIRE, or WAIT statement shall refer to a unit
<P>
<PRE>
  that is connected to a file and thereby make use of or affect that file.
<P>
</PRE>
3 A file may be connected and not exist (12.3.2).
<P>
<PRE>
         NOTE 12.15
<P>
         An example is a preconnected external file that has not yet been written.
<P>
</PRE>
4 A unit shall not be connected to more than one file at the same time. However, means are provided to change
<P>
<PRE>
  the status of an external unit and to connect a unit to a different file. It is processor dependent whether a file
<P>
  can be connected to more than one unit at the same time.
<P>
</PRE>
5 This document defines means of portable interoperation with C. C streams are described in 7.21.2 of ISO/IEC
<P>
<PRE>
  9899:2011. Whether a unit can be connected to a file that is also connected to a C stream is processor dependent.
<P>
  If a unit is connected to a file that is also connected to a C stream, the results of performing input/output
<P>
  operations on such a file are processor dependent. It is processor dependent whether the files connected to
<P>
  the units INPUT_UNIT, OUTPUT_UNIT, and ERROR_UNIT correspond to the predefined C text streams
<P>
  standard input, standard output, and standard error. If a main program or procedure defined by means of Fortran
<P>
  and a main program or procedure defined by means other than Fortran perform input/output operations on the
<P>
  same external file, the results are processor dependent. A main program or procedure defined by means of Fortran
<P>
  and a main program or procedure defined by means other than Fortran can perform input/output operations on
<P>
  different external files without interference.
<P>
</PRE>
6 If input/output operations are performed on more than one unit while they are connected to the same external
<P>
<PRE>
  file, the results are processor dependent.
<P>
</PRE>
7 After an external unit has been disconnected by the execution of a CLOSE statement, it may be connected again
<P>
<PRE>
  within the same program to the same file or to a different file. After an external file has been disconnected by
<P>
  the execution of a CLOSE statement, it may be connected again within the same program to the same unit or
<P>
  to a different unit.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           225
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 12.16
<P>
        The only means of referencing a file that has been disconnected is by the appearance of its name in an OPEN
<P>
        or INQUIRE statement. There might be no means of reconnecting an unnamed file once it is disconnected.
<P>
</PRE>
8 An internal unit is always connected to the internal file designated by the variable that identifies the unit.
<P>
<PRE>
        NOTE 12.17
<P>
        For more explanatory information on file connection properties, see C.7.4.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.5.5</B> </TD><TD valign=bottom>
Preconnection
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Preconnection means that the unit is connected to a file at the beginning of execution of the program and therefore
<P>
<PRE>
  it may be specified in input/output statements without the prior execution of an OPEN statement.
<P>
  12.5.6       OPEN statement
<P>
  12.5.6.1     General
<P>
</PRE>
1 An OPEN statement initiates or modifies the connection between an external file and a specified unit. The OPEN
<P>
<PRE>
  statement may be used to connect an existing file to a unit, create a file that is preconnected, create a file and
<P>
  connect it to a unit, or change certain modes of a connection between a file and a unit.
<P>
</PRE>
2 An external unit may be connected by an OPEN statement in the main program or any subprogram.
<P>
3 If the file to be connected to the unit does not exist but is the same as the file to which the unit is preconnected,
<P>
<PRE>
  the modes specified by an OPEN statement become a part of the connection.
<P>
</PRE>
4 If the file to be connected to the unit is not the same as the file to which the unit is connected, the effect is as
<P>
<PRE>
  if a CLOSE statement without a STATUS= specifier had been executed for the unit immediately prior to the
<P>
  execution of an OPEN statement.
<P>
</PRE>
5 If a unit is connected to a file that exists, execution of an OPEN statement for that unit is permitted. If the
<P>
<PRE>
  FILE= specifier is not included in such an OPEN statement, the file to be connected to the unit is the same as
<P>
  the file to which the unit is already connected.
<P>
</PRE>
6 If the file to be connected to the unit is the same as the file to which the unit is connected, a new connection is not
<P>
<PRE>
  established and values for any changeable modes (12.5.2) specified come into effect for the established connection;
<P>
  the current file position is unaffected. Before any effect on changeable modes, a wait operation is performed for
<P>
  any pending asynchronous data transfer operations for the specified unit. If the POSITION= specifier appears
<P>
  in such an OPEN statement, the value specified shall not disagree with the current position of the file. If the
<P>
  STATUS= specifier is included in such an OPEN statement, it shall be specified with the value OLD. Other than
<P>
  ERR=, IOSTAT=, and IOMSG=, and the changeable modes, the values of all other specifiers in such an OPEN
<P>
  statement shall not differ from those in effect for the established connection.
<P>
</PRE>
7 A STATUS= specifier with a value of OLD is always allowed when the file to be connected to the unit is the same
<P>
<PRE>
  as the file to which the unit is connected. In this case, if the status of the file was SCRATCH before execution of
<P>
  the OPEN statement, the file will still be deleted when the unit is closed, and the file is still considered to have
<P>
  a status of SCRATCH.
<P>
  12.5.6.2     Syntax of the OPEN statement
<P>
  R1204 open-stmt                          is  OPEN ( connect-spec-list )
<P>
  R1205 connect-spec                       is [ UNIT = ] file-unit-number
<P>
                                           or ACCESS = scalar-default-char-expr
<P>
                                           or ACTION = scalar-default-char-expr
<P>
  226                                                                   ⃝
<P>
                                                                        c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
                                          or  ASYNCHRONOUS = scalar-default-char-expr
<P>
                                          or  BLANK = scalar-default-char-expr
<P>
                                          or  DECIMAL = scalar-default-char-expr
<P>
                                          or  DELIM = scalar-default-char-expr
<P>
                                          or  ENCODING = scalar-default-char-expr
<P>
                                          or  ERR = label
<P>
                                          or  FILE = file-name-expr
<P>
                                          or  FORM = scalar-default-char-expr
<P>
                                          or  IOMSG = iomsg-variable
<P>
                                          or  IOSTAT = stat-variable
<P>
                                          or  NEWUNIT = scalar-int-variable
<P>
                                          or  PAD = scalar-default-char-expr
<P>
                                          or  POSITION = scalar-default-char-expr
<P>
                                          or  RECL = scalar-int-expr
<P>
                                          or  ROUND = scalar-default-char-expr
<P>
                                          or  SIGN = scalar-default-char-expr
<P>
                                          or  STATUS = scalar-default-char-expr
<P>
  R1206 file-name-expr                    is  scalar-default-char-expr
<P>
  R1207 iomsg-variable                    is  scalar-default-char-variable
<P>
  C1203 No specifier shall appear more than once in a given connect-spec-list.
<P>
  C1204 (R1204) If the NEWUNIT= specifier does not appear, a file-unit-number shall be specified; if the optional
<P>
           characters UNIT= are omitted, the file-unit-number shall be the first item in the connect-spec-list.
<P>
  C1205 (R1204) If a NEWUNIT= specifier appears, a file-unit-number shall not appear.
<P>
  C1206 (R1204) The label used in the ERR= specifier shall be the statement label of a branch target statement
<P>
           that appears in the same inclusive scope as the OPEN statement.
<P>
</PRE>
1 A specifier that requires a scalar-default-char-expr may have a limited list of character values. These values are
<P>
<PRE>
  listed for each such specifier. Any trailing blanks are ignored. The value specified is without regard to case. Some
<P>
  specifiers have a default value if the specifier is omitted.
<P>
</PRE>
2 The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
<P>
<PRE>
        NOTE 12.18
<P>
        An example of an OPEN statement is:
<P>
        OPEN (10, FILE = ’employee.names’, ACTION = ’READ’, PAD = ’YES’)
<P>
        NOTE 12.19
<P>
        For more explanatory information on the OPEN statement, see C.7.3.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.5.6.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ACCESS= specifier in the OPEN statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The scalar-default-char-expr shall evaluate to SEQUENTIAL, DIRECT, or STREAM. The ACCESS= specifier
<P>
<PRE>
  specifies the access method for the connection of the file as being sequential, direct, or stream. If this specifier is
<P>
  omitted, the default value is SEQUENTIAL. For an existing file, the specified access method shall be included in
<P>
  the set of allowed access methods for the file. For a new file, the processor creates the file with a set of allowed
<P>
  access methods that includes the specified method.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            227
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.5.6.4     ACTION= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to READ, WRITE, or READWRITE. READ specifies that the
<P>
<PRE>
  WRITE, PRINT, and ENDFILE statements shall not refer to this connection. WRITE specifies that READ
<P>
  statements shall not refer to this connection. READWRITE permits any input/output statements to refer to this
<P>
  connection. If this specifier is omitted, the default value is processor dependent. If READWRITE is included in
<P>
  the set of allowable actions for a file, both READ and WRITE also shall be included in the set of allowed actions
<P>
  for that file. For an existing file, the specified action shall be included in the set of allowed actions for the file.
<P>
  For a new file, the processor creates the file with a set of allowed actions that includes the specified action.
<P>
  12.5.6.5     ASYNCHRONOUS= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to YES or NO. If YES is specified, asynchronous input/output on
<P>
<PRE>
  the unit is allowed. If NO is specified, asynchronous input/output on the unit is not allowed. If this specifier is
<P>
  omitted, the default value is NO.
<P>
  12.5.6.6     BLANK= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to NULL or ZERO. The BLANK= specifier is permitted only for a
<P>
<PRE>
  connection for formatted input/output. It specifies the blank interpretation mode (13.8.6, 12.6.2.6) for input for
<P>
  this connection. This mode has no effect on output. It is a changeable mode (12.5.2). If this specifier is omitted
<P>
  in an OPEN statement that initiates a connection, the default value is NULL.
<P>
  12.5.6.7     DECIMAL= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to COMMA or POINT. The DECIMAL= specifier is permitted only
<P>
<PRE>
  for a connection for formatted input/output. It specifies the decimal edit mode (13.6, 13.8.8, 12.6.2.7) for this
<P>
  connection. It is a changeable mode (12.5.2). If this specifier is omitted in an OPEN statement that initiates a
<P>
  connection, the default value is POINT.
<P>
  12.5.6.8     DELIM= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= specifier is
<P>
<PRE>
  permitted only for a connection for formatted input/output. It specifies the delimiter mode (12.6.2.8) for list-
<P>
  directed (13.10.4) and namelist (13.11.4.2) output for the connection. This mode has no effect on input. It is
<P>
  a changeable mode (12.5.2). If this specifier is omitted in an OPEN statement that initiates a connection, the
<P>
  default value is NONE.
<P>
  12.5.6.9     ENCODING= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to UTF-8 or DEFAULT. The ENCODING= specifier is permitted
<P>
<PRE>
  only for a connection for formatted input/output. The value UTF-8 specifies that the encoding form of the file
<P>
  is UTF-8 as specified in ISO/IEC 10646. Such a file is called a Unicode file, and all characters therein are of ISO
<P>
  10646 character kind. The value UTF-8 shall not be specified if the processor does not support the ISO 10646
<P>
  character kind. The value DEFAULT specifies that the encoding form of the file is processor dependent. If this
<P>
  specifier is omitted in an OPEN statement that initiates a connection, the default value is DEFAULT.
<P>
  12.5.6.10     FILE= specifier in the OPEN statement
<P>
</PRE>
1 The value of the FILE= specifier is the name of the file to be connected to the specified unit. Any trailing blanks
<P>
<PRE>
  are ignored. The file-name-expr shall be a name that is allowed by the processor. The interpretation of case is
<P>
  processor dependent.
<P>
</PRE>
2 This specifier shall appear if the STATUS= specifier has the value NEW or REPLACE. This specifier shall not
<P>
<PRE>
  appear if the STATUS= specifier has the value SCRATCH. If the STATUS= specifier has the value OLD, this
<P>
  specifier shall appear unless the unit is connected and the file connected to the unit exists. If this specifier
<P>
  228                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  is omitted and the unit is not connected to a file, the STATUS= specifier shall be specified with a value of
<P>
  SCRATCH; in this case, the connection is made to a processor-dependent file.
<P>
  12.5.6.11     FORM= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to FORMATTED or UNFORMATTED. The FORM= specifier de-
<P>
<PRE>
  termines whether the file is being connected for formatted or unformatted input/output. If this specifier is
<P>
  omitted, the default value is UNFORMATTED if the file is being connected for direct access or stream access,
<P>
  and the default value is FORMATTED if the file is being connected for sequential access. For an existing file,
<P>
  the specified form shall be included in the set of allowed forms for the file. For a new file, the processor creates
<P>
  the file with a set of allowed forms that includes the specified form.
<P>
  12.5.6.12     NEWUNIT= specifier in the OPEN statement
<P>
</PRE>
1 If this specifier appears in an OPEN statement, either the FILE= specifier shall appear, or the STATUS= specifier
<P>
<PRE>
  shall appear with a value of SCRATCH.
<P>
</PRE>
2 The variable is defined with a processor determined NEWUNIT value if no error condition occurs during the
<P>
<PRE>
  execution of the OPEN statement. If an error condition occurs, the processor shall not change the value of the
<P>
  variable.
<P>
</PRE>
3 A NEWUNIT value is a negative number, and shall not be equal to −1, any of the named constants ER-
<P>
<PRE>
  ROR_UNIT, INPUT_UNIT, or OUTPUT_UNIT from the intrinsic module ISO_FORTRAN_ENV (16.10.2),
<P>
  any value used by the processor for the unit argument to a defined input/output procedure, nor any previous
<P>
  NEWUNIT value that identifies a file that is connected. The unit identified by a NEWUNIT value shall not be
<P>
  preconnected.
<P>
  12.5.6.13     PAD= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to YES or NO. The PAD= specifier is permitted only for a connection
<P>
<PRE>
  for formatted input/output. It specifies the pad mode (12.6.4.5.3, 12.6.2.10) for input for this connection. This
<P>
  mode has no effect on output. It is a changeable mode (12.5.2). If this specifier is omitted in an OPEN statement
<P>
  that initiates a connection, the default value is YES.
<P>
  12.5.6.14     POSITION= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to ASIS, REWIND, or APPEND. The connection shall be for sequen-
<P>
<PRE>
  tial or stream access. A new file is positioned at its initial point. REWIND positions an existing file at its initial
<P>
  point. APPEND positions an existing file such that the endfile record is the next record, if it has one. If an
<P>
  existing file does not have an endfile record, APPEND positions the file at its terminal point. ASIS leaves the
<P>
  position unchanged if the file exists and already is connected. If the file exists but is not connected, the position
<P>
  resulting from ASIS is processor dependent. If this specifier is omitted, the default value is ASIS.
<P>
  12.5.6.15     RECL= specifier in the OPEN statement
<P>
</PRE>
1 The value of the RECL= specifier shall be positive. It specifies the length of each record in a file being connected
<P>
<PRE>
  for direct access, or specifies the maximum length of a record in a file being connected for sequential access. This
<P>
  specifier shall not appear when a file is being connected for stream access. This specifier shall appear when a
<P>
  file is being connected for direct access. If this specifier is omitted when a file is being connected for sequential
<P>
  access, the default value is processor dependent. If the file is being connected for formatted input/output, the
<P>
  length is the number of characters for all records that contain only characters of default kind. When a record
<P>
  contains any nondefault characters, the effect of the RECL= specifier is processor dependent. If the file is being
<P>
  connected for unformatted input/output, the length is measured in file storage units. For an existing file, the
<P>
  value of the RECL= specifier shall be included in the set of allowed record lengths for the file. For a new file, the
<P>
  processor creates the file with a set of allowed record lengths that includes the specified value.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            229
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.5.6.16     ROUND= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PRO-
<P>
<PRE>
  CESSOR_DEFINED. The ROUND= specifier is permitted only for a connection for formatted input/output.
<P>
  It specifies the input/output rounding mode (13.7.2.3.8, 12.6.2.13) for this connection. It is a changeable mode
<P>
  (12.5.2). If this specifier is omitted in an OPEN statement that initiates a connection, the input/output rounding
<P>
  mode is processor dependent; it shall be one of the above modes.
<P>
        NOTE 12.20
<P>
        A processor is free to select any input/output rounding mode for the default mode. The mode might
<P>
        correspond to UP, DOWN, ZERO, NEAREST, or COMPATIBLE; or it might be a completely different
<P>
        input/output rounding mode.
<P>
  12.5.6.17     SIGN= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to one of PLUS, SUPPRESS, or PROCESSOR_DEFINED. The
<P>
<PRE>
  SIGN= specifier is permitted only for a connection for formatted input/output. It specifies the sign mode
<P>
  (13.8.4, 12.6.2.14) for this connection. It is a changeable mode (12.5.2). If this specifier is omitted in an OPEN
<P>
  statement that initiates a connection, the default value is PROCESSOR_DEFINED.
<P>
  12.5.6.18     STATUS= specifier in the OPEN statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to OLD, NEW, SCRATCH, REPLACE, or UNKNOWN. If OLD is
<P>
<PRE>
  specified, the file shall exist. If NEW is specified, the file shall not exist.
<P>
</PRE>
2 Successful execution of an OPEN statement with NEW specified creates the file and changes the status to OLD.
<P>
<PRE>
  If REPLACE is specified and the file does not already exist, the file is created and the status is changed to OLD.
<P>
  If REPLACE is specified and the file does exist, the file is deleted, a new file is created with the same name, and
<P>
  the status is changed to OLD. If SCRATCH is specified, the file is created and connected to the specified unit
<P>
  for use by the program but is deleted at the execution of a CLOSE statement referring to the same unit or at
<P>
  the normal termination of the program.
<P>
</PRE>
3 If UNKNOWN is specified, the status is processor dependent. If this specifier is omitted, the default value is
<P>
<PRE>
  UNKNOWN.
<P>
        NOTE 12.21
<P>
        SCRATCH cannot be specified if the FILE= specifier appears (12.5.6.10).
<P>
  12.5.7      CLOSE statement
<P>
  12.5.7.1    General
<P>
</PRE>
1 The CLOSE statement is used to terminate the connection of a specified unit to an external file.
<P>
2 Execution of a CLOSE statement for a unit may occur in any program unit of a program and need not occur in
<P>
<PRE>
  the same program unit as the execution of an OPEN statement referring to that unit.
<P>
</PRE>
3 Execution of a CLOSE statement performs a wait operation for any pending asynchronous data transfer operations
<P>
<PRE>
  for the specified unit.
<P>
</PRE>
4 Execution of a CLOSE statement specifying a unit that does not exist, exists but is connected to a file that does
<P>
<PRE>
  not exist, or has no file connected to it, is permitted and affects no file or unit.
<P>
</PRE>
5 After a unit has been disconnected by execution of a CLOSE statement, it may be connected again within the
<P>
<PRE>
  same program, either to the same file or to a different file. After a named file has been disconnected by execution
<P>
  of a CLOSE statement, it may be connected again within the same program, either to the same unit or to a
<P>
  different unit, provided that the file still exists.
<P>
  230                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 During the completion step (5.3.7) of normal termination, all units that are connected are closed. Each unit is
<P>
<PRE>
  closed with status KEEP unless the file status prior to termination of execution was SCRATCH, in which case
<P>
  the unit is closed with status DELETE.
<P>
        NOTE 12.22
<P>
       The effect is as though a CLOSE statement without a STATUS= specifier were executed on each connected
<P>
       unit.
<P>
  12.5.7.2    Syntax
<P>
  R1208 close-stmt                        is   CLOSE ( close-spec-list )
<P>
  R1209 close-spec                        is   [ UNIT = ] file-unit-number
<P>
                                          or   IOSTAT = stat-variable
<P>
                                          or   IOMSG = iomsg-variable
<P>
                                          or   ERR = label
<P>
                                          or   STATUS = scalar-default-char-expr
<P>
  C1207 No specifier shall appear more than once in a given close-spec-list.
<P>
  C1208 A file-unit-number shall be specified in a close-spec-list; if the optional characters UNIT= are omitted,
<P>
           the file-unit-number shall be the first item in the close-spec-list.
<P>
  C1209 (R1209) The label used in the ERR= specifier shall be the statement label of a branch target statement
<P>
           that appears in the same inclusive scope as the CLOSE statement.
<P>
</PRE>
1 The scalar-default-char-expr has a limited list of character values. Any trailing blanks are ignored. The value
<P>
<PRE>
  specified is without regard to case.
<P>
</PRE>
2 The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
<P>
<PRE>
        NOTE 12.23
<P>
</PRE>
An example of a CLOSE statement is:
<BLOCKQUOTE>
<P>
CLOSE (10, STATUS = ’KEEP’)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: CLOSE (10, STATUS = ’KEEP’)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>12.5.7.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STATUS= specifier in the CLOSE statement
</TD></TR>
<TR><TD colspan=2>
1 The scalar-default-char-expr shall evaluate to KEEP or DELETE. The STATUS= specifier determines the dis-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  position of the file that is connected to the specified unit. KEEP shall not be specified for a file whose status prior
<P>
  to execution of a CLOSE statement is SCRATCH. If KEEP is specified for a file that exists, the file continues
<P>
  to exist after the execution of a CLOSE statement. If KEEP is specified for a file that does not exist, the file
<P>
  will not exist after the execution of a CLOSE statement. If DELETE is specified, the file will not exist after the
<P>
  execution of a CLOSE statement. If this specifier is omitted, the default value is KEEP, unless the file status
<P>
  prior to execution of the CLOSE statement is SCRATCH, in which case the default value is DELETE.
<P>
  12.6       Data transfer statements
<P>
  12.6.1      Form of input and output statements
<P>
</PRE>
1 The READ statement is the data transfer input statement. The WRITE statement and the PRINT statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
  are the data transfer output statements.
<P>
  R1210 read-stmt                         is READ ( io-control-spec-list ) [ input-item-list ]
<P>
                                          or READ format [ , input-item-list ]
<P>
  R1211 write-stmt                        is   WRITE ( io-control-spec-list ) [ output-item-list ]
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             231
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1212 print-stmt                       is   PRINT format [ , output-item-list ]
<P>
       NOTE 12.24
<P>
       Examples of data transfer statements are:
<P>
           READ (6, *) SIZE
<P>
           READ 10, A, B
<P>
           WRITE (6, 10) A, S, J
<P>
           PRINT 10, A, S, J
<P>
       10 FORMAT (2E16.3, I5)
<P>
  12.6.2     Control information list
<P>
  12.6.2.1   Syntax
<P>
</PRE>
1 A control information list is an io-control-spec-list. It governs data transfer.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1213 io-control-spec                  is   [ UNIT = ] io-unit
<P>
                                         or   [ FMT = ] format
<P>
                                         or   [ NML = ] namelist-group-name
<P>
                                         or   ADVANCE = scalar-default-char-expr
<P>
                                         or   ASYNCHRONOUS = scalar-default-char-constant-expr
<P>
                                         or   BLANK = scalar-default-char-expr
<P>
                                         or   DECIMAL = scalar-default-char-expr
<P>
                                         or   DELIM = scalar-default-char-expr
<P>
                                         or   END = label
<P>
                                         or   EOR = label
<P>
                                         or   ERR = label
<P>
                                         or   ID = id-variable
<P>
                                         or   IOMSG = iomsg-variable
<P>
                                         or   IOSTAT = stat-variable
<P>
                                         or   PAD = scalar-default-char-expr
<P>
                                         or   POS = scalar-int-expr
<P>
                                         or   REC = scalar-int-expr
<P>
                                         or   ROUND = scalar-default-char-expr
<P>
                                         or   SIGN = scalar-default-char-expr
<P>
                                         or   SIZE = scalar-int-variable
<P>
  R1214 id-variable                      is   scalar-int-variable
<P>
  C1210 No specifier shall appear more than once in a given io-control-spec-list.
<P>
  C1211 An io-unit shall be specified in an io-control-spec-list; if the optional characters UNIT= are omitted, the
<P>
          io-unit shall be the first item in the io-control-spec-list.
<P>
  C1212 (R1213) A DELIM= or SIGN= specifier shall not appear in a read-stmt.
<P>
  C1213 (R1213) A BLANK=, PAD=, END=, EOR=, or SIZE= specifier shall not appear in a write-stmt.
<P>
  C1214 (R1213) The label in the ERR=, EOR=, or END= specifier shall be the statement label of a branch
<P>
          target statement that appears in the same inclusive scope as the data transfer statement.
<P>
  C1215 (R1213) A namelist-group-name shall be the name of a namelist group.
<P>
  C1216 (R1213) A namelist-group-name shall not appear if a REC= specifier, format, input-item-list, or an
<P>
          output-item-list appears in the data transfer statement.
<P>
  C1217 (R1213) If format appears without a preceding FMT=, it shall be the second item in the io-control-spec-
<P>
  232                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
           list and the first item shall be io-unit.
<P>
  C1218 (R1213) If namelist-group-name appears without a preceding NML=, it shall be the second item in the
<P>
           io-control-spec-list and the first item shall be io-unit.
<P>
  C1219 (R1213) If io-unit is not a file-unit-number, the io-control-spec-list shall not contain a REC= specifier or
<P>
           a POS= specifier.
<P>
  C1220 (R1213) If the REC= specifier appears, an END= specifier shall not appear, and the format, if any, shall
<P>
           not be an asterisk.
<P>
  C1221 (R1213) An ADVANCE= specifier may appear only in a formatted sequential or stream data transfer
<P>
           statement with explicit format specification (13.2) whose io-control-spec-list does not contain an internal-
<P>
           file-variable as the io-unit.
<P>
  C1222 (R1213) If an EOR= specifier appears, an ADVANCE= specifier also shall appear.
<P>
  C1223 (R1213) The scalar-default-char-constant-expr in an ASYNCHRONOUS= specifier shall have the value
<P>
           YES or NO.
<P>
  C1224 (R1213) An ASYNCHRONOUS= specifier with a value YES shall not appear unless io-unit is a file-
<P>
           unit-number.
<P>
  C1225 (R1213) If an ID= specifier appears, an ASYNCHRONOUS= specifier with the value YES shall also
<P>
           appear.
<P>
  C1226 (R1213) If a POS= specifier appears, the io-control-spec-list shall not contain a REC= specifier.
<P>
  C1227 (R1213) If a DECIMAL=, BLANK=, PAD=, SIGN=, or ROUND= specifier appears, a format or
<P>
           namelist-group-name shall also appear.
<P>
  C1228 (R1213) If a DELIM= specifier appears, either format shall be an asterisk or namelist-group-name shall
<P>
           appear.
<P>
  C1229 (R1214) The scalar-int-variable shall have a decimal exponent range no smaller than that of default
<P>
           integer.
<P>
</PRE>
2 If an EOR= specifier appears, an ADVANCE= specifier with the value NO shall also appear.
</TD></TR>
<TR><TD colspan=2>
3 If the data transfer statement contains a format or namelist-group-name, the statement is a formatted in-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  put/output statement; otherwise, it is an unformatted input/output statement.
<P>
</PRE>
4 The ADVANCE=, ASYNCHRONOUS=, DECIMAL=, BLANK=, DELIM=, PAD=, SIGN=, and ROUND=
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specifiers have a limited list of character values. Any trailing blanks are ignored. The values specified are without
<P>
  regard to case.
<P>
</PRE>
5 The IOSTAT=, ERR=, EOR=, END=, and IOMSG= specifiers are described in 12.11.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 12.25
<P>
       An example of a READ statement is:
<P>
       READ (IOSTAT = IOS, UNIT = 6, FMT = ’(10F8.2)’) A, B
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.6.2.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Format specification in a data transfer statement
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The format specifier supplies a format specification or specifies list-directed formatting for a formatted in-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  put/output statement.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            233
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1215 format                             is default-char-expr
<P>
                                           or label
<P>
                                           or *
<P>
  C1230 (R1215) The label shall be the label of a FORMAT statement that appears in the same inclusive scope
<P>
            as the statement containing the FMT= specifier.
<P>
</PRE>
2 The default-char-expr shall evaluate to a valid format specification (13.2.1 and 13.2.2).
</TD></TR>
<TR><TD colspan=2>
3 If default-char-expr is an array, it is treated as if all of the elements of the array were specified in array element
</TD></TR>
<TR><TD colspan=2>
<PRE>
  order and were concatenated.
<P>
</PRE>
4 If format is *, the statement is a list-directed input/output statement.
</TD></TR>
<TR><TD colspan=2>
<PRE>
        NOTE 12.26
<P>
        An example in which the format is a character expression is:
<P>
        READ (6, FMT = "(" // CHAR_FMT // ")" )              X, Y, Z
<P>
        where CHAR_FMT is a default character variable.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.6.2.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NML= specifier in a data transfer statement
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The NML= specifier supplies the namelist-group-name (8.9). This name identifies a particular collection of data
</TD></TR>
<TR><TD colspan=2>
<PRE>
  objects on which transfer is to be performed.
<P>
</PRE>
2 If a namelist-group-name appears, the statement is a namelist input/output statement.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  12.6.2.4     ADVANCE= specifier in a data transfer statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to YES or NO. The ADVANCE= specifier determines whether advan-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  cing input/output occurs for a nonchild data transfer statement. If YES is specified for a nonchild data transfer
<P>
  statement, advancing input/output occurs. If NO is specified, nonadvancing input/output occurs (12.3.4.2). If
<P>
  this specifier is omitted from a nonchild data transfer statement that allows the specifier, the default value is
<P>
  YES. A formatted child data transfer statement is a nonadvancing input/output statement, and any ADVANCE=
<P>
  specifier is ignored.
<P>
  12.6.2.5     ASYNCHRONOUS= specifier in a data transfer statement
<P>
</PRE>
1 The ASYNCHRONOUS= specifier determines whether this data transfer statement is synchronous or asynchron-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ous. If YES is specified, the statement and the input/output operation are asynchronous. If NO is specified or if
<P>
  the specifier is omitted, the statement and the input/output operation are synchronous.
<P>
</PRE>
2 Asynchronous input/output is permitted only for external files opened with an ASYNCHRONOUS= specifier
</TD></TR>
<TR><TD colspan=2>
<PRE>
  with the value YES in the OPEN statement.
<P>
        NOTE 12.27
<P>
        Both synchronous and asynchronous input/output are allowed for files opened with an ASYNCHRONOUS=
<P>
        specifier of YES. For other files, only synchronous input/output is allowed; this includes files opened with an
<P>
        ASYNCHRONOUS= specifier of NO, files opened without an ASYNCHRONOUS= specifier, preconnected
<P>
        files accessed without an OPEN statement, and internal files.
<P>
        The ASYNCHRONOUS= specifier value in a data transfer statement is a constant expression because it
<P>
        effects compiler optimizations and, therefore, needs to be known at compile time.
<P>
</PRE>
3 The processor may perform an asynchronous data transfer operation asynchronously, but it is not required to do
</TD></TR>
<TR><TD colspan=2>
<PRE>
  so. For each external file, records and file storage units read or written by asynchronous data transfer statements
<P>
  234                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
  are read, written, and processed in the same order as they would have been if the data transfer statements were
<P>
  synchronous. The documentation of the Fortran processor should describe when input/output will be performed
<P>
  asynchronously.
<P>
</PRE>
4 If a variable is used in an asynchronous data transfer statement as
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • an item in an input/output list,
<P>
      • a group object in a namelist, or
<P>
      • a SIZE= specifier,
<P>
</PRE>
the base object of the data-ref is implicitly given the ASYNCHRONOUS attribute in the scoping unit of the data
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
transfer statement. This attribute may be confirmed by explicit declaration.
</TD></TR>
<TR><TD colspan=2>
5 When an asynchronous input/output statement is executed, the set of storage units specified by the item list or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  NML= specifier, plus the storage units specified by the SIZE= specifier, is defined to be the pending input/output
<P>
  storage sequence for the data transfer operation.
<P>
        NOTE 12.28
<P>
        A pending input/output storage sequence is not necessarily a contiguous set of storage units.
<P>
</PRE>
6 A pending input/output storage sequence affector is a variable of which any part is associated with a storage unit
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in a pending input/output storage sequence.
<P>
  12.6.2.6    BLANK= specifier in a data transfer statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to NULL or ZERO. The BLANK= specifier temporarily changes
</TD></TR>
<TR><TD colspan=2>
<PRE>
  (12.5.2) the blank interpretation mode (13.8.6, 12.5.6.6) for the connection. If the specifier is omitted, the mode
<P>
  is not changed.
<P>
  12.6.2.7    DECIMAL= specifier in a data transfer statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to COMMA or POINT. The DECIMAL= specifier temporarily changes
</TD></TR>
<TR><TD colspan=2>
<PRE>
  (12.5.2) the decimal edit mode (13.6, 13.8.8, 12.5.6.7) for the connection. If the specifier is omitted, the mode is
<P>
  not changed.
<P>
  12.6.2.8    DELIM= specifier in a data transfer statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= specifier tem-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  porarily changes (12.5.2) the delimiter mode (13.10.4, 13.11.4.2, 12.5.6.8) for the connection. If the specifier is
<P>
  omitted, the mode is not changed.
<P>
  12.6.2.9    ID= specifier in a data transfer statement
<P>
</PRE>
1 Successful execution of an asynchronous data transfer statement containing an ID= specifier causes the variable
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specified in the ID= specifier to become defined with a processor determined value. If this value is zero, the
<P>
  data transfer operation has been completed. A nonzero value is referred to as the identifier of the data transfer
<P>
  operation. This identifier is different from the identifier of any other pending data transfer operation for this unit.
<P>
  It can be used in a subsequent WAIT or INQUIRE statement to identify the particular data transfer operation.
<P>
</PRE>
2 If an error condition occurs during the execution of a data transfer statement containing an ID= specifier, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  variable specified in the ID= specifier becomes undefined.
<P>
</PRE>
3 A child data transfer statement shall not specify the ID= specifier.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             235
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.6.2.10      PAD= specifier in a data transfer statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to YES or NO. The PAD= specifier temporarily changes (12.5.2) the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  pad mode (12.6.4.5.3, 12.5.6.13) for the connection. If the specifier is omitted, the mode is not changed.
<P>
  12.6.2.11      POS= specifier in a data transfer statement
<P>
</PRE>
1 The POS= specifier specifies the file position in file storage units. This specifier may appear in a data transfer
</TD></TR>
<TR><TD colspan=2>
<PRE>
  statement only if the statement specifies a unit connected for stream access. A child data transfer statement shall
<P>
  not specify this specifier.
<P>
</PRE>
2 A processor may prohibit the use of POS= with particular files that do not have the properties necessary to
</TD></TR>
<TR><TD colspan=2>
<PRE>
  support random positioning. A processor may also prohibit positioning a particular file to any position prior to
<P>
  its current file position if the file does not have the properties necessary to support such positioning.
<P>
        NOTE 12.29
<P>
        A unit that is connected to a device or data stream might not be positionable.
<P>
</PRE>
3 If the file is connected for formatted stream access, the file position specified by POS= shall be equal to either 1
</TD></TR>
<TR><TD colspan=2>
<PRE>
  (the beginning of the file) or a value previously returned by a POS= specifier in an INQUIRE statement for the
<P>
  file.
<P>
  12.6.2.12      REC= specifier in a data transfer statement
<P>
</PRE>
1 The REC= specifier specifies the number of the record that is to be read or written. This specifier may appear
</TD></TR>
<TR><TD colspan=2>
<PRE>
  only in a data transfer statement that specifies a unit connected for direct access; it shall not appear in a child
<P>
  data transfer statement. If the io-control-spec-list contains a REC= specifier, the statement is a direct access
<P>
  data transfer statement. A child data transfer statement is a direct access data transfer statement if the parent
<P>
  is a direct access data transfer statement. Any other data transfer statement is a sequential access data transfer
<P>
  statement or a stream access data transfer statement, depending on whether the file connection is for sequential
<P>
  access or stream access.
<P>
  12.6.2.13      ROUND= specifier in a data transfer statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE or PRO-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  CESSOR_DEFINED. The ROUND= specifier temporarily changes (12.5.2) the input/output rounding mode
<P>
  (13.7.2.3.8, 12.5.6.16) for the connection. If the specifier is omitted, the mode is not changed.
<P>
  12.6.2.14      SIGN= specifier in a data transfer statement
<P>
</PRE>
1 The scalar-default-char-expr shall evaluate to PLUS, SUPPRESS, or PROCESSOR_DEFINED. The SIGN=
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specifier temporarily changes (12.5.2) the sign mode (13.8.4, 12.5.6.17) for the connection. If the specifier is
<P>
  omitted, the mode is not changed.
<P>
  12.6.2.15      SIZE= specifier in a data transfer statement
<P>
</PRE>
1 The SIZE= specifier in an input statement causes the variable specified to become defined with the count of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the characters transferred from the file by data edit descriptors during the input operation. Blanks inserted as
<P>
  padding are not counted.
<P>
</PRE>
2 For a synchronous input statement, this definition occurs when execution of the statement completes. For an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  asynchronous input statement, this definition occurs when the corresponding wait operation is performed.
<P>
  12.6.3       Data transfer input/output list
<P>
</PRE>
1 An input/output list specifies the entities whose values are transferred by a data transfer statement.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  236                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1216 input-item                         is variable
<P>
                                           or io-implied-do
<P>
  R1217 output-item                        is expr
<P>
                                           or io-implied-do
<P>
  R1218 io-implied-do                      is  ( io-implied-do-object-list , io-implied-do-control )
<P>
  R1219 io-implied-do-object               is input-item
<P>
                                           or output-item
<P>
  R1220 io-implied-do-control              is  do-variable = scalar-int-expr ,
<P>
                                                  scalar-int-expr [ , scalar-int-expr ]
<P>
  C1231 (R1216) A variable that is an input-item shall not be a whole assumed-size array.
<P>
  C1232 (R1219) In an input-item-list, an io-implied-do-object shall be an input-item. In an output-item-list, an
<P>
            io-implied-do-object shall be an output-item.
<P>
  C1233 (R1217) An expression that is an output-item shall not have a value that is a procedure pointer.
<P>
</PRE>
2 An input-item shall not appear as, nor be associated with, the do-variable of any io-implied-do that contains the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  input-item.
<P>
        NOTE 12.30
<P>
        A constant, an expression involving operators or function references that does not have a pointer result, or
<P>
        an expression enclosed in parentheses shall not appear as an input list item.
<P>
</PRE>
3 If an input item is a pointer, it shall be associated with a definable target and data are transferred from the file to
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the associated target. If an output item is a pointer, it shall be associated with a target and data are transferred
<P>
  from the target to the file.
<P>
        NOTE 12.31
<P>
        Data transfers always involve the movement of values between a file and internal storage. A pointer as such
<P>
        cannot be read or written. Therefore, a pointer shall not appear as an item in an input/output list unless
<P>
        it is associated with a target that can receive a value (input) or can deliver a value (output).
<P>
</PRE>
4 If an input item or an output item is allocatable, it shall be allocated.
</TD></TR>
<TR><TD colspan=2>
5 A list item shall not be polymorphic unless it is processed by a defined input/output procedure (12.6.4.8).
</TD></TR>
<TR><TD colspan=2>
6 The do-variable of an io-implied-do that is in another io-implied-do shall not appear as, nor be associated with,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the do-variable of the containing io-implied-do.
<P>
</PRE>
7 The following rules describing whether to expand an input/output list item are re-applied to each expanded list
</TD></TR>
<TR><TD colspan=2>
<PRE>
  item until none of the rules apply.
<P>
      • If an array appears as an input/output list item, it is treated as if the elements, if any, were specified in
<P>
         array element order (9.5.3.2). However, no element of that array may affect the value of any expression in
<P>
         the input-item, nor may any element appear more than once in a given input-item.
<P>
        NOTE 12.32
<P>
        For example:
<P>
        INTEGER A (100), J (100)
<P>
             &#46;&#46;&#46;
<P>
        READ *, A (A)                                          ! Not allowed
<P>
        READ *, A (LBOUND (A, 1) : UBOUND (A, 1))              ! Allowed
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             237
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 12.32 (cont.)
<P>
        READ *, A (J)                                         ! Allowed if no two elements
<P>
                                                              !      of J have the same value
<P>
        A(1) = 1; A(10) = 10
<P>
        READ *, A (A (1) : A (10))                            ! Not allowed
<P>
       • If a list item of derived type in an unformatted input/output statement is not processed by a defined
<P>
         input/output procedure (12.6.4.8), and if any subobject of that list item would be processed by a defined
<P>
         input/output procedure, the list item is treated as if all of the components of the object were specified in
<P>
         the list in component order (7.5.4.7); those components shall be accessible in the scoping unit containing
<P>
         the data transfer statement and shall not be pointers or allocatable.
<P>
       • An effective item of derived type in an unformatted input/output statement is treated as a single value in a
<P>
         processor-dependent form unless the list item or a subobject thereof is processed by a defined input/output
<P>
         procedure (12.6.4.8).
<P>
        NOTE 12.33
<P>
        The appearance of a derived-type object as an input/output list item in an unformatted input/output
<P>
        statement is not equivalent to the list of its components.
<P>
        Unformatted input/output involving derived-type list items forms the single exception to the rule that the
<P>
        appearance of an aggregate list item (such as an array) is equivalent to the appearance of its expanded
<P>
        list of component parts. This exception permits the processor greater latitude in improving efficiency or
<P>
        in matching the processor-dependent sequence of values for a derived-type object to similar sequences for
<P>
        aggregate objects used by means other than Fortran. However, formatted input/output of all list items and
<P>
        unformatted input/output of list items other than those of derived types adhere to the above rule.
<P>
       • If a list item of derived type in a formatted input/output statement is not processed by a defined in-
<P>
         put/output procedure, that list item is treated as if all of the components of the list item were specified
<P>
         in the list in component order; those components shall be accessible in the scoping unit containing the
<P>
         input/output statement and shall not be pointers or allocatable.
<P>
       • If a derived-type list item is not processed by a defined input/output procedure and is not treated as a list
<P>
         of its individual components, all the subcomponents of that list item shall be accessible in the scoping unit
<P>
         containing the data transfer statement and shall not be pointers or allocatable.
<P>
       • For an io-implied-do, the loop initialization and execution are the same as for a DO construct (11.1.7.4).
<P>
        NOTE 12.34
<P>
        An example of an output list with an implied DO is:
<P>
        WRITE (LP, FMT = ’(10F8.2)’) (LOG (A (I)), I = 1, N + 9, K), G
<P>
</PRE>
8 The scalar objects resulting when a data transfer statement’s list items are expanded according to the rules in
</TD></TR>
<TR><TD colspan=2>
<PRE>
  this subclause for handling array and derived-type list items are called effective items. Zero-sized arrays and
<P>
  io-implied-dos with an iteration count of zero do not contribute to the list of effective items. A scalar character
<P>
  item of zero length is an effective item.
<P>
        NOTE 12.35
<P>
        In a formatted input/output statement, edit descriptors are associated with effective items, which are always
<P>
        scalar. The rules in 12.6.3 determine the set of effective items corresponding to each actual list item in the
<P>
        statement. These rules might have to be applied repetitively until all of the effective items are scalar items.
<P>
</PRE>
9 An input/output list shall not contain an effective item of nondefault character kind if the data transfer statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specifies an internal file of default character kind. An input/output list shall not contain an effective item that is
<P>
  nondefault character except for ISO 10646 or ASCII character if the data transfer statement specifies an internal
<P>
  file of ISO 10646 character kind. An input/output list shall not contain an effective item of type character of any
<P>
  kind other than ASCII if the data transfer statement specifies an ASCII character internal file.
<P>
  238                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.6.4     Execution of a data transfer input/output statement
<P>
  12.6.4.1    Data transfer sequence of operations
<P>
</PRE>
1 Execution of a WRITE or PRINT statement for a unit connected to a file that does not exist creates the file
</TD></TR>
<TR><TD colspan=2>
<PRE>
  unless an error condition occurs.
<P>
</PRE>
2 The effect of executing a synchronous data transfer statement shall be as if the following operations were performed
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in the order specified.
<P>
        (1)     Determine the direction of data transfer (12.6.4.2).
<P>
        (2)     Identify the unit (12.6.4.3).
<P>
        (3)     Perform a wait operation for all pending input/output operations for the unit. If an error, end-of-file,
<P>
                or end-of-record condition occurs during any of the wait operations, steps 4 through 8 are skipped.
<P>
        (4)     Establish the format if one is specified.
<P>
        (5)     If the statement is not a child data transfer statement (12.6.4.8),
<P>
                (a)     position the file prior to data transfer (12.3.4.3), and
<P>
                (b)     for formatted data transfer, set the left tab limit (13.8.1.2).
<P>
        (6)     Transfer data between the file and the entities specified by the input/output list (if any) or namelist,
<P>
                possibly mediated by defined input/output procedures (12.6.4.8).
<P>
        (7) Determine whether an error, end-of-file, or end-of-record condition has occurred.
<P>
        (8) Position the file after data transfer (12.3.4.4) unless the statement is a child data transfer statement
<P>
                (12.6.4.8).
<P>
        (9) Cause any variable specified in a SIZE= specifier to become defined.
<P>
        (10) If an error, end-of-file, or end-of-record condition occurred, processing continues as specified in 12.11;
<P>
                otherwise, any variable specified in an IOSTAT= specifier is assigned the value zero.
<P>
</PRE>
3 The effect of executing an asynchronous data transfer statement shall be as if the following operations were
</TD></TR>
<TR><TD colspan=2>
<PRE>
  performed in the order specified.
<P>
        (1)     Determine the direction of data transfer (12.6.4.2).
<P>
        (2)     Identify the unit (12.6.4.3).
<P>
        (3)     Optionally, perform wait operations for one or more pending input/output operations for the unit.
<P>
                If an error, end-of-file, or end-of-record condition occurs during any of the wait operations, steps 4
<P>
                through 9 are skipped.
<P>
        (4) Establish the format if one is specified.
<P>
        (5) Position the file prior to data transfer (12.3.4.3) and, for formatted data transfer, set the left tab
<P>
                limit (13.8.1.2).
<P>
        (6) Establish the set of storage units identified by the input/output list. For an input statement, this
<P>
                might require some or all of the data in the file to be read if an input variable is used as a scalar-
<P>
                int-expr in an io-implied-do-control in the input/output list, as a subscript, substring-range, stride,
<P>
                or is otherwise referenced.
<P>
        (7) Initiate an asynchronous data transfer between the file and the entities specified by the input/output
<P>
                list (if any) or namelist. The asynchronous data transfer may complete (and an error, end-of-file, or
<P>
                end-of-record condition may occur) during the execution of this data transfer statement or during a
<P>
                later wait operation.
<P>
        (8) Determine whether an error, end-of-file, or end-of-record condition has occurred. The conditions
<P>
                may occur during the execution of this data transfer statement or during the corresponding wait
<P>
                operation, but not both.
<P>
        (9) Position the file as if the data transfer had finished (12.3.4.4).
<P>
        (10) Cause any variable specified in a SIZE= specifier to become undefined.
<P>
        (11) If an error, end-of-file, or end-of-record condition occurred, processing continues as specified in 12.11;
<P>
                otherwise, any variable specified in an IOSTAT= specifier is assigned the value zero.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            239
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 For an asynchronous data transfer statement, the data transfers may occur during execution of the statement,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  during execution of the corresponding wait operation, or anywhere between. The data transfer operation is
<P>
  considered to be pending until a corresponding wait operation is performed.
<P>
</PRE>
5 For asynchronous output, a pending input/output storage sequence affector (12.6.2.5) shall not be redefined,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  become undefined, or have its pointer association status changed.
<P>
</PRE>
6 For asynchronous input, a pending input/output storage sequence affector shall not be referenced, become defined,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  become undefined, become associated with a dummy argument that has the VALUE attribute, or have its pointer
<P>
  association status changed.
<P>
</PRE>
7 Error, end-of-file, and end-of-record conditions in an asynchronous data transfer operation may occur during
</TD></TR>
<TR><TD colspan=2>
<PRE>
  execution of either the data transfer statement or the corresponding wait operation. If an ID= specifier does not
<P>
  appear in the initiating data transfer statement, the conditions may occur during the execution of any subsequent
<P>
  data transfer or wait operation for the same unit. When a condition occurs for a previously executed asynchronous
<P>
  data transfer statement, a wait operation is performed for all pending data transfer operations on that unit. When
<P>
  a condition occurs during a subsequent statement, any actions specified by IOSTAT=, IOMSG=, ERR=, END=,
<P>
  and EOR= specifiers for that statement are taken.
<P>
</PRE>
8 If execution of the program is terminated during execution of an output statement, the contents of the file become
</TD></TR>
<TR><TD colspan=2>
<PRE>
  undefined.
<P>
        NOTE 12.36
<P>
        Because end-of-file and error conditions for asynchronous data transfer statements without an ID= specifier
<P>
        can be reported by the processor during the execution of a subsequent data transfer statement, it might be
<P>
        impossible for the user to determine which data transfer statement caused the condition. Reliably detecting
<P>
        which input statement caused an end-of-file condition requires that all asynchronous input statements for
<P>
        the unit include an ID= specifier.
<P>
  12.6.4.2     Direction of data transfer
<P>
</PRE>
1 Execution of a READ statement causes values to be transferred from a file to the entities specified by the input
</TD></TR>
<TR><TD colspan=2>
<PRE>
  list, if any, or specified within the file itself for namelist input. Execution of a WRITE or PRINT statement
<P>
  causes values to be transferred to a file from the entities specified by the output list and format specification, if
<P>
  any, or by the namelist-group-name for namelist output.
<P>
  12.6.4.3     Identifying a unit
<P>
</PRE>
1 A data transfer statement that contains an input/output control list includes a UNIT= specifier that identifies
</TD></TR>
<TR><TD colspan=2>
<PRE>
  an external or internal unit. A READ statement that does not contain an input/output control list specifies a
<P>
  particular processor-dependent unit, which is the same as the unit identified by * in a READ statement that
<P>
  contains an input/output control list (12.5.1) and is the same as the unit identified by the value of the named
<P>
  constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.13). The PRINT statement
<P>
  specifies some other processor-dependent unit, which is the same as the unit identified by * in a WRITE statement
<P>
  and is the same as the unit identified by the value of the named constant OUTPUT_UNIT of the intrinsic module
<P>
  ISO_FORTRAN_ENV (16.10.2.22). Thus, each data transfer statement identifies an external or internal unit.
<P>
</PRE>
2 The unit identified by an unformatted data transfer statement shall be an external unit.
</TD></TR>
<TR><TD colspan=2>
3 The unit identified by a data transfer statement shall be connected to a file when execution of the statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
  begins.
<P>
        NOTE 12.37
<P>
        The unit could be preconnected.
<P>
  240                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
   12.6.4.4     Establishing a format
<P>
</PRE>
1 If the input/output control list contains * as a format, list-directed formatting is established. If namelist-group-
</TD></TR>
<TR><TD colspan=2>
<PRE>
   name appears, namelist formatting is established. If no format or namelist-group-name is specified, unformatted
<P>
   data transfer is established. Otherwise, the format specified by format is established.
<P>
</PRE>
2 For output to an internal file, a format specification that is in the file or is associated with the file shall not be
</TD></TR>
<TR><TD colspan=2>
<PRE>
   specified.
<P>
</PRE>
3 An input list item, or an entity associated with it, shall not contain any portion of an established format spe-
</TD></TR>
<TR><TD colspan=2>
<PRE>
   cification.
<P>
   12.6.4.5     Data transfer
<P>
   12.6.4.5.1     General
<P>
</PRE>
1 Data are transferred between the file and the entities specified by the input/output list or namelist. The list items
</TD></TR>
<TR><TD colspan=2>
<PRE>
   are processed in the order of the input/output list for all data transfer statements except namelist data transfer
<P>
   statements. The list items for a namelist input statement are processed in the order of the entities specified
<P>
   within the input records. The list items for a namelist output statement are processed in the order in which the
<P>
   variables are specified in the namelist-group-object-list. Effective items are derived from the input/output list
<P>
   items as described in 12.6.3.
<P>
</PRE>
2 All values needed to determine which entities are specified by an input/output list item are determined at the
</TD></TR>
<TR><TD colspan=2>
<PRE>
   beginning of the processing of that item.
<P>
</PRE>
3 All values are transmitted to or from the entities specified by a list item prior to the processing of any succeeding
</TD></TR>
<TR><TD colspan=2>
<PRE>
   list item for all data transfer statements.
<P>
          NOTE 12.38
<P>
          In the example
<P>
          READ (N) N, X (N)
<P>
          the old value of N identifies the unit, but the new value of N is the subscript of X.
<P>
</PRE>
4 All values following the name= part of the namelist entity (13.11) within the input records are transmitted to
</TD></TR>
<TR><TD colspan=2>
<PRE>
   the matching entity specified in the namelist-group-object-list prior to processing any succeeding entity within
<P>
   the input record for namelist input statements. If an entity is specified more than once within the input record
<P>
   during a namelist input statement, the last occurrence of the entity specifies the value or values to be used for
<P>
   that entity.
<P>
</PRE>
5 If the input/output item is a pointer, data are transferred between the file and the associated target.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
6 If an internal file has been specified, an input/output list item shall not be in the file or associated with the file.
<P>
7 During the execution of an output statement that specifies an internal file, no part of that internal file shall be
<P>
<PRE>
   referenced, defined, or become undefined as the result of evaluating any output list item.
<P>
</PRE>
8 During the execution of an input statement that specifies an internal file, no part of that internal file shall be
<P>
<PRE>
   defined or become undefined as the result of transferring a value to any input list item.
<P>
</PRE>
9 A DO variable becomes defined and its iteration count established at the beginning of processing of the io-implied-
<P>
<PRE>
   do-object-list an io-implied-do.
<P>
</PRE>
10 On output, every entity whose value is to be transferred shall be defined.
<P>
<PRE>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                             241
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.6.4.5.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Unformatted data transfer
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
1 If the file is not connected for unformatted input/output, unformatted data transfer is prohibited.
</TD></TR>
<TR><TD colspan=2>
2 During unformatted data transfer, data are transferred without editing between the file and the entities specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by the input/output list. If the file is connected for sequential or direct access, exactly one record is read or
<P>
  written.
<P>
</PRE>
3 A value in the file is stored in a contiguous sequence of file storage units, beginning with the file storage unit
</TD></TR>
<TR><TD colspan=2>
<PRE>
  immediately following the current file position.
<P>
</PRE>
4 After each value is transferred, the current file position is moved to a point immediately after the last file storage
</TD></TR>
<TR><TD colspan=2>
<PRE>
  unit of the value.
<P>
</PRE>
5 On input from a file connected for sequential or direct access, the number of file storage units required by the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  input list shall be less than or equal to the number of file storage units in the record.
<P>
</PRE>
6 On input, if the file storage units transferred do not contain a value with the same type and type parameters as
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the input list entity, then the resulting value of the entity is processor dependent except in the following cases.
<P>
       • A complex entity may correspond to two real values with the same kind type parameter as the complex
<P>
         entity.
<P>
       • A default character list entity of length n may correspond to n default characters stored in the file, regardless
<P>
         of the length parameters of the entities that were written to these storage units of the file. If the file is
<P>
         connected for stream input, the characters may have been written by formatted stream output.
<P>
</PRE>
7 On output to a file connected for unformatted direct access, the output list shall not specify more values than
</TD></TR>
<TR><TD colspan=2>
<PRE>
  can fit into the record. If the file is connected for direct access and the values specified by the output list do not
<P>
  fill the record, the remainder of the record is undefined.
<P>
</PRE>
8 If the file is connected for unformatted sequential access, the record is created with a length sufficient to hold
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the values from the output list. This length shall be one of the set of allowed record lengths for the file and
<P>
  shall not exceed the value specified in the RECL= specifier, if any, of the OPEN statement that established the
<P>
  connection.
<P>
  12.6.4.5.3      Formatted data transfer
<P>
</PRE>
1 If the file is not connected for formatted input/output, formatted data transfer is prohibited.
</TD></TR>
<TR><TD colspan=2>
2 During formatted data transfer, data are transferred with editing between the file and the entities specified by
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the input/output list or by the namelist-group-name. Format control is initiated and editing is performed as
<P>
  described in Clause 13.
<P>
</PRE>
3 The current record and possibly additional records are read or written.
</TD></TR>
<TR><TD colspan=2>
4 During advancing input when the pad mode has the value NO, the input list and format specification shall not
</TD></TR>
<TR><TD colspan=2>
<PRE>
  require more characters from the record than the record contains.
<P>
</PRE>
5 During advancing input when the pad mode has the value YES, blank characters are supplied by the processor
</TD></TR>
<TR><TD colspan=2>
<PRE>
  if the input list and format specification require more characters from the record than the record contains.
<P>
</PRE>
6 During nonadvancing input when the pad mode has the value NO, an end-of-record condition (12.11) occurs if
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the input list and format specification require more characters from the record than the record contains, and the
<P>
  record is complete (12.3.3.4). If the record is incomplete, an end-of-file condition occurs instead of an end-of-record
<P>
  condition.
<P>
</PRE>
7 During nonadvancing input when the pad mode has the value YES, blank characters are supplied by the processor
</TD></TR>
<TR><TD colspan=2>
<PRE>
  if an effective item and its corresponding data edit descriptors require more characters from the record than the
<P>
  record contains. If the record is incomplete, an end-of-file condition occurs; otherwise, an end-of-record condition
<P>
  occurs.
<P>
  242                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 If the file is connected for direct access, the record number is increased by one as each succeeding record is read
</TD></TR>
<TR><TD colspan=2>
<PRE>
   or written.
<P>
</PRE>
9 On output, if the file is connected for direct access or is an internal file and the characters specified by the output
</TD></TR>
<TR><TD colspan=2>
<PRE>
   list and format do not fill a record, blank characters are added to fill the record.
<P>
</PRE>
10 On output, the output list and format specification shall not specify more characters for a record than have been
</TD></TR>
<TR><TD colspan=2>
<PRE>
   specified by a RECL= specifier in the OPEN statement or the record length of an internal file.
<P>
   12.6.4.6     List-directed formatting
<P>
</PRE>
1 If list-directed formatting has been established, editing is performed as described in 13.10.
</TD></TR>
<TR><TD colspan=2>
<PRE>
   12.6.4.7     Namelist formatting
<P>
</PRE>
1 If namelist formatting has been established, editing is performed as described in 13.11.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 Every allocatable namelist-group-object in the namelist group shall be allocated and every namelist-group-object
<P>
<PRE>
   that is a pointer shall be associated with a target. If a namelist-group-object is polymorphic or has an ultimate
<P>
   component that is allocatable or a pointer, that object shall be processed by a defined input/output procedure
<P>
   (12.6.4.8).
<P>
   12.6.4.8     Defined input/output
<P>
   12.6.4.8.1      General
<P>
</PRE>
1 Defined input/output allows a program to override the default handling of derived-type objects and values in
<P>
<PRE>
   data transfer statements described in 12.6.3.
<P>
</PRE>
2 A defined input/output procedure is a procedure accessible by a defined-io-generic-spec (15.4.3.2). A particular
<P>
<PRE>
   defined input/output procedure is selected as described in 12.6.4.8.4.
<P>
   12.6.4.8.2      Defined input/output procedures
<P>
</PRE>
1 For a particular derived type and a particular set of kind type parameter values, there are four possible sets of
<P>
<PRE>
   characteristics for defined input/output procedures; one each for formatted input, formatted output, unformatted
<P>
   input, and unformatted output. The program need not supply all four procedures. The procedures are specified
<P>
   to be used for derived-type input/output by interface blocks (15.4.3.2) or by generic bindings (7.5.5), with a
<P>
   defined-io-generic-spec (R1509). The defined-io-generic-specs for these procedures are READ (FORMATTED),
<P>
   READ (UNFORMATTED), WRITE (FORMATTED), and WRITE (UNFORMATTED), for formatted input,
<P>
   unformatted input, formatted output, and unformatted output respectively.
<P>
</PRE>
2 In the four interfaces, which specify the characteristics of defined input/output procedures, the following syntax
<P>
<PRE>
   term is used:
<P>
   R1221 dtv-type-spec                     is TYPE( derived-type-spec )
<P>
                                           or CLASS( derived-type-spec )
<P>
   C1234 (R1221) If derived-type-spec specifies an extensible type, the CLASS keyword shall be used; otherwise,
<P>
             the TYPE keyword shall be used.
<P>
   C1235 (R1221) All length type parameters of derived-type-spec shall be assumed.
<P>
</PRE>
3 If the defined-io-generic-spec is READ (FORMATTED), the characteristics shall be the same as those specified
<P>
<PRE>
   by the following interface:
<P>
             SUBROUTINE my_read_routine_formatted (dtv,                            &
<P>
                                                             unit,                 &
<P>
                                                             iotype, v_list,       &
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                              243
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                                                   iostat, iomsg)
<P>
</PRE>
! the derived-type variable
<TABLE width=100% cellpadding=3><!-- tsb: ! the derived-type variable
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
dtv-type-spec , <B>INTENT</B>(INOUT) :: dtv
<P>
INTEGER, <B>INTENT</B>(IN) :: unit ! unit number
<P>
! the edit descriptor string
<P>
CHARACTER (LEN=*), <B>INTENT</B>(IN) :: iotype
<P>
INTEGER, <B>INTENT</B>(IN) :: <B>v_list</B>(:)
<P>
INTEGER, <B>INTENT</B>(OUT) :: iostat
<P>
CHARACTER (LEN=*), <B>INTENT</B>(INOUT) :: iomsg
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
4 If the defined-io-generic-spec is READ (UNFORMATTED), the characteristics shall be the same as those specified
<P>
<PRE>
  by the following interface:
<P>
            SUBROUTINE my_read_routine_unformatted (dtv,                &
<P>
                                                     unit,              &
<P>
                                                     iostat, iomsg)
<P>
              ! the derived-type variable
<P>
              dtv-type-spec , INTENT(INOUT) :: dtv
<P>
              INTEGER, INTENT(IN) :: unit
<P>
              INTEGER, INTENT(OUT) :: iostat
<P>
              CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
5 If the defined-io-generic-spec is WRITE (FORMATTED), the characteristics shall be the same as those specified
<P>
<PRE>
  by the following interface:
<P>
            SUBROUTINE my_write_routine_formatted (dtv,                 &
<P>
                                                    unit,               &
<P>
                                                    iotype, v_list, &
<P>
                                                    iostat, iomsg)
<P>
              ! the derived-type value/variable
<P>
              dtv-type-spec , INTENT(IN) :: dtv
<P>
              INTEGER, INTENT(IN) :: unit
<P>
              ! the edit descriptor string
<P>
              CHARACTER (LEN=*), INTENT(IN) :: iotype
<P>
              INTEGER, INTENT(IN) :: v_list(:)
<P>
              INTEGER, INTENT(OUT) :: iostat
<P>
              CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
6 If the defined-io-generic-spec is WRITE (UNFORMATTED), the characteristics shall be the same as those
<P>
<PRE>
  specified by the following interface:
<P>
            SUBROUTINE my_write_routine_unformatted (dtv,               &
<P>
                                                      unit,             &
<P>
                                                      iostat, iomsg)
<P>
              ! the derived-type value/variable
<P>
              dtv-type-spec , INTENT(IN) :: dtv
<P>
              INTEGER, INTENT(IN) :: unit
<P>
              INTEGER, INTENT(OUT) :: iostat
<P>
              CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>244</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
7 The actual specific procedure names (the my_&#46;&#46;&#46;_routine_... procedure names above) are not significant. In
<P>
<PRE>
  the discussion here and elsewhere, the dummy arguments in these interfaces are referred to by the names given
<P>
  above; the names are, however, arbitrary.
<P>
  12.6.4.8.3     Executing defined input/output data transfers
<P>
</PRE>
1 If a defined input/output procedure is selected for an effective item as specified in 12.6.4.8.4, the processor shall
<P>
<PRE>
  call the selected defined input/output procedure for that item. The defined input/output procedure controls the
<P>
  actual data transfer operations for the derived-type list item.
<P>
</PRE>
2 A data transfer statement that includes a derived-type list item and that causes a defined input/output procedure
<P>
<PRE>
  to be invoked is called a parent data transfer statement. A data transfer statement that is executed while a parent
<P>
  data transfer statement is being processed and that specifies the unit passed into a defined input/output procedure
<P>
  is called a child data transfer statement.
<P>
        NOTE 12.39
<P>
        A defined input/output procedure will usually contain child data transfer statements that read values
<P>
        from or write values to the current record or at the current file position. The effect of executing the
<P>
        defined input/output procedure is similar to that of substituting the list items from any child data transfer
<P>
        statements into the parent data transfer statement’s list items, along with similar substitutions in the format
<P>
        specification.
<P>
        NOTE 12.40
<P>
        A particular execution of a READ, WRITE or PRINT statement can be both a parent and a child data
<P>
        transfer statement. A defined input/output procedure can indirectly call itself or another defined in-
<P>
        put/output procedure by executing a child data transfer statement containing a list item of derived type,
<P>
        where a matching interface is accessible for that derived type. If a defined input/output procedure calls
<P>
        itself indirectly in this manner, it cannot be declared NON_RECURSIVE.
<P>
</PRE>
3 A child data transfer statement is processed differently from a nonchild data transfer statement in the following
<P>
<PRE>
  ways.
<P>
      • Executing a child data transfer statement does not position the file prior to data transfer.
<P>
      • An unformatted child data transfer statement does not position the file after data transfer is complete.
<P>
      • Any ADVANCE= specifier in a child input/output statement is ignored.
<P>
</PRE>
4 When a defined input/output procedure is invoked, the processor shall pass a unit argument that has a value as
<P>
<PRE>
  follows.
<P>
      • If the parent data transfer statement uses a file-unit-number, the value of the unit argument shall be that
<P>
         of the file-unit-number.
<P>
      • If the parent data transfer statement is a WRITE statement with an asterisk unit or a PRINT statement,
<P>
         the unit argument shall have the same value as the named constant OUTPUT_UNIT of the intrinsic
<P>
         module ISO_FORTRAN_ENV (16.10.2).
<P>
      • If the parent data transfer statement is a READ statement with an asterisk unit or a READ statement
<P>
         without an io-control-spec-list, the unit argument shall have the same value as the INPUT_UNIT named
<P>
         constant of the intrinsic module ISO_FORTRAN_ENV (16.10.2).
<P>
      • Otherwise the parent data transfer statement accesses an internal file, in which case the unit argument
<P>
         shall have a processor-dependent negative value.
<P>
        NOTE 12.41
<P>
        The unit argument passed to a defined input/output procedure will be negative when the parent data
<P>
        transfer statement specified an internal unit, or specified an external unit that is a NEWUNIT value.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             245
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
         NOTE 12.41 (cont.)
<P>
         When an internal unit is used with the INQUIRE statement, an error condition will occur, and any variable
<P>
         specified in an IOSTAT= specifier will be assigned the value IOSTAT_INQUIRE_INTERNAL_UNIT from
<P>
         the intrinsic module ISO_FORTRAN_ENV (16.10.2).
<P>
</PRE>
5 For formatted data transfer, the processor shall pass an iotype argument that has the value
<P>
<PRE>
       • “LISTDIRECTED” if the parent data transfer statement specified list directed formatting,
<P>
       • “NAMELIST” if the parent data transfer statement specified namelist formatting, or
<P>
       • “DT” concatenated with the char-literal-constant, if any, of the DT edit descriptor in the format specification
<P>
          of the parent data transfer statement.
<P>
</PRE>
6 If the parent data transfer statement is an input statement, the dtv dummy argument is argument associated
<P>
<PRE>
   with the effective item that caused the defined input procedure to be invoked, as if the effective item were an
<P>
   actual argument in this procedure reference (5.4.5).
<P>
</PRE>
7 If the parent data transfer statement is an output statement, the processor shall provide the value of the effective
<P>
<PRE>
   item in the dtv dummy argument.
<P>
</PRE>
8 If the v-list of the edit descriptor appears in the parent data transfer statement, the processor shall provide the
<P>
<PRE>
   values from it in the v_list dummy argument, with the same number of elements in the same order as v-list.
<P>
   If there is no v-list in the edit descriptor or if the data transfer statement specifies list-directed or namelist
<P>
   formatting, the processor shall provide v_list as a zero-sized array.
<P>
         NOTE 12.42
<P>
         The user’s procedure might choose to interpret an element of the v_list argument as a field width, but
<P>
         this is not required. If it does, it would be appropriate to fill an output field with “*”s if the width is too
<P>
         small.
<P>
</PRE>
9 The iostat argument is used to report whether an error, end-of-record, or end-of-file condition (12.11) occurs.
<P>
<PRE>
   If an error condition occurs, the defined input/output procedure shall assign a positive value to the iostat
<P>
   argument. Otherwise, if an end-of-file condition occurs, the defined input procedure shall assign the value of the
<P>
   named constant IOSTAT_END (16.10.2.16) to the iostat argument. Otherwise, if an end-of-record condition
<P>
   occurs, the defined input procedure shall assign the value of the named constant IOSTAT_EOR (16.10.2.17) to
<P>
   iostat. Otherwise, the defined input/output procedure shall assign the value zero to the iostat argument.
<P>
</PRE>
10 If the defined input/output procedure returns a nonzero value for the iostat argument, the procedure shall also
<P>
<PRE>
   return an explanatory message in the iomsg argument. Otherwise, the procedure shall not change the value of
<P>
   the iomsg argument.
<P>
         NOTE 12.43
<P>
         The values of the iostat and iomsg arguments set in a defined input/output procedure need not be passed
<P>
         to all of the parent data transfer statements.
<P>
</PRE>
11 If the iostat argument of the defined input/output procedure has a nonzero value when that procedure returns,
<P>
<PRE>
   and the processor therefore terminates execution of the program as described in 12.11, the processor shall make
<P>
   the value of the iomsg argument available in a processor-dependent manner.
<P>
</PRE>
12 While a parent READ statement is active, an input/output statement shall not read from any external unit other
<P>
<PRE>
   than the one specified by the unit dummy argument and shall not perform output to any external unit.
<P>
</PRE>
13 While a parent WRITE or PRINT statement is active, an input/output statement shall not perform output to
<P>
<PRE>
   any external unit other than the one specified by the unit dummy argument and shall not read from any external
<P>
   unit.
<P>
   246                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
14 While a parent data transfer statement is active, a data transfer statement that specifies an internal file is
<P>
<PRE>
   permitted.
<P>
</PRE>
15 OPEN, CLOSE, BACKSPACE, ENDFILE, and REWIND statements shall not be executed while a parent data
<P>
<PRE>
   transfer statement is active.
<P>
</PRE>
16 A defined input/output procedure may use a format specification with a DT edit descriptor for handling a
<P>
<PRE>
   component of the derived type that is itself of a derived type. A child data transfer statement that is a list
<P>
   directed or namelist input/output statement may contain a list item of derived type.
<P>
</PRE>
17 Because a child data transfer statement does not position the file prior to data transfer, the child data transfer
<P>
<PRE>
   statement starts transferring data from where the file was positioned by the parent data transfer statement’s
<P>
   most recently processed effective item or edit descriptor. This is not necessarily at the beginning of a record.
<P>
</PRE>
18 The edit descriptors T and TL used on unit by a child data transfer statement shall not cause the file to be
<P>
<PRE>
   positioned before the file position at the time the defined input/output procedure was invoked.
<P>
        NOTE 12.44
<P>
        A defined input/output procedure could use INQUIRE to determine the settings of BLANK=, PAD=,
<P>
        ROUND=, DECIMAL=, and DELIM= for an external unit. The INQUIRE statement provides values as
<P>
        specified in 12.10.
<P>
</PRE>
19 Neither a parent nor child data transfer statement shall be asynchronous.
<TABLE cellpadding=3><!-- tsb: 19 Neither a parent nor child data transfer statement shall be asynchronous.
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
20 A defined input/output procedure, and any procedures invoked therefrom, shall not define, nor cause to become
<P>
<PRE>
   undefined, any storage unit referenced by any input/output list item, the corresponding format, or any specifier
<P>
   in any active parent data transfer statement, except through the dtv argument.
<P>
        NOTE 12.45
<P>
        A data transfer statement with an ID=, POS=, or REC= specifier cannot be a child data transfer statement
<P>
        in a standard-conforming program.
<P>
        NOTE 12.46
<P>
        A simple example of derived type formatted output follows. The derived type variable chairman has two
<P>
        components. The type and an associated write formatted procedure are defined in a module so as to be
<P>
        accessible from wherever they might be needed. It would also be possible to check that iotype indeed has
<P>
        the value ’DT’ and to set iostat and iomsg accordingly.
<P>
        MODULE p
<P>
           TYPE :: person
<P>
             CHARACTER (LEN=20) :: name
<P>
             INTEGER :: age
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
PROCEDURE,PRIVATE :: pwf
<TABLE cellpadding=3><!-- tsb: PROCEDURE,PRIVATE :: pwf
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>GENERIC</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: <B>WRITE</B>(FORMATTED) =&gt; pwf
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
END TYPE person
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)
<P>
! argument definitions
<P>
<PRE>
             CLASS(person), INTENT(IN) :: dtv
<P>
             INTEGER, INTENT(IN) :: unit
<P>
             CHARACTER (LEN=*), INTENT(IN) :: iotype
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
247
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
<P>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
    NOTE 12.46 (cont.)
<P>
         INTEGER, INTENT(IN) :: vlist(:)
<P>
         INTEGER, INTENT(OUT) :: iostat
<P>
         CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
<P>
    ! local variable
<P>
         CHARACTER (LEN=9) :: pfmt
<P>
    !    vlist(1) and (2) are to be used as the field widths of the two
<P>
    !    components of the derived type variable. First set up the format to
<P>
    !    be used for output.
<P>
         WRITE(pfmt,’(A,I2,A,I2,A)’ ) ’(A’, vlist(1), ’,I’, vlist(2), ’)’
<P>
    !    now the basic output statement
<P>
         WRITE(unit, FMT=pfmt, IOSTAT=iostat) dtv%name, dtv%age
<P>
      END SUBROUTINE pwf
<P>
    END MODULE p
<P>
    PROGRAM committee
<P>
      USE p
<P>
      INTEGER id, members
<P>
      TYPE (person) :: chairman
<P>
      &#46;&#46;&#46;
<P>
      WRITE(6, FMT="(I2, DT (15,6), I5)" ) id, chairman, members
<P>
    ! this writes a record with four fields, with lengths 2, 15, 6, 5
<P>
    ! respectively
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM</H4>
</A>
<BLOCKQUOTE>
<P>
NOTE 12.47
<P>
In the following example, the variables of the derived type node form a linked list, with a single value at
<P>
each node. The subroutine pwf is used to write the values in the list, one per line.
<P>
MODULE p
<P>
<PRE>
      TYPE node
<P>
         INTEGER :: value = 0
<P>
         TYPE (NODE), POINTER :: next_node =&gt; NULL ( )
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
PROCEDURE,PRIVATE :: pwf
<TABLE cellpadding=3><!-- tsb: PROCEDURE,PRIVATE :: pwf
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>GENERIC</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: <B>WRITE</B>(FORMATTED) =&gt; pwf
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
END TYPE node
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)
<P>
! Write the chain of values, each on a separate line in I9 format.
<P>
<PRE>
         CLASS(node), INTENT(IN) :: dtv
<P>
         INTEGER, INTENT(IN) :: unit
<P>
         CHARACTER (LEN=*), INTENT(IN) :: iotype
<P>
         INTEGER, INTENT(IN) :: vlist(:)
<P>
         INTEGER, INTENT(OUT) :: iostat
<P>
         CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>248</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 12.47 (cont.)
<P>
<PRE>
              WRITE(unit,’(i9 /)’, IOSTAT = iostat) dtv%value
<P>
              IF(iostat/=0) RETURN
<P>
              IF(ASSOCIATED(dtv%next_node)) WRITE(unit,’(dt)’, IOSTAT=iostat) dtv%next_node
<P>
</PRE>
END SUBROUTINE pwf
<TABLE cellpadding=3><!-- tsb: END SUBROUTINE pwf
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
END MODULE p
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>12.6.4.8.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Resolving defined input/output procedure references
<P>
1 A suitable generic interface for defined input/output of an effective item is one that has a defined-io-generic-spec
<P>
<PRE>
  that is appropriate to the direction (read or write) and form (formatted or unformatted) of the data transfer
<P>
  as specified in 12.6.4.8.2, and has a specific interface whose dtv argument is compatible with the effective item
<P>
  according to the rules for argument association in 15.5.2.4.
<P>
</PRE>
2 When an effective item (12.6.3) that is of derived type is encountered during a data transfer, defined input/output
<P>
<PRE>
  occurs if both of the following conditions are true.
<P>
          (1)   The circumstances of the input/output are such that defined input/output is permitted; that is,
<P>
                either
<P>
                (a)    the transfer was initiated by a list-directed, namelist, or unformatted input/output statement,
<P>
                       or
<P>
                (b)    a format specification is supplied for the data transfer statement, and the edit descriptor
<P>
                       corresponding to the effective item is a DT edit descriptor.
<P>
          (2)   A suitable defined input/output procedure is available; that is, either
<P>
                (a)    the declared type of the effective item has a suitable generic type-bound procedure, or
<P>
                (b)    a suitable generic interface is accessible.
<P>
</PRE>
3 If (2a) is true, the procedure referenced is determined as for explicit type-bound procedure references (15.5); that
<P>
<PRE>
  is, the binding with the appropriate specific interface is located in the declared type of the effective item, and the
<P>
  corresponding binding in the dynamic type of the effective item is selected.
<P>
</PRE>
4 If (2a) is false and (2b) is true, the reference is to the procedure identified by the appropriate specific interface
<P>
<PRE>
  in the interface block.
<P>
  12.6.5       Termination of data transfer statements
<P>
</PRE>
1 Termination of a data transfer statement occurs when
<P>
<PRE>
       • format processing encounters a colon or data edit descriptor and there are no remaining elements in the
<P>
         input-item-list or output-item-list,
<P>
       • unformatted or list-directed data transfer exhausts the input-item-list or output-item-list,
<P>
       • namelist output exhausts the namelist-group-object-list,
<P>
       • an error condition occurs,
<P>
       • an end-of-file condition occurs,
<P>
       • a slash (/) is encountered as a value separator (13.10, 13.11) in the record being read during list-directed
<P>
         or namelist input, or
<P>
       • an end-of-record condition occurs during execution of a nonadvancing input statement (12.11).
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
249
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>12.7</B> </TD><TD valign=bottom>
Waiting on pending data transfer
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>12.7.1</B> </TD><TD valign=bottom>
Wait operation
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Execution of an asynchronous data transfer statement in which neither an error, end-of-record, nor end-of-file
<P>
<PRE>
  condition occurs initiates a pending data transfer operation. There may be multiple pending data transfer
<P>
  operations for the same or multiple units simultaneously. A pending data transfer operation remains pending
<P>
  until a corresponding wait operation is performed. A wait operation may be performed by a BACKSPACE,
<P>
  CLOSE, ENDFILE, FLUSH, INQUIRE, PRINT, READ, REWIND, WAIT, or WRITE statement.
<P>
</PRE>
2 A wait operation completes the processing of a pending data transfer operation. Each wait operation completes
<P>
<PRE>
  only a single data transfer operation, although a single statement may perform multiple wait operations.
<P>
</PRE>
3 If the actual data transfer is not yet complete, the wait operation first waits for its completion. If the data
<P>
<PRE>
  transfer operation is an input operation that completed without error, the storage units of the input/output
<P>
  storage sequence then become defined with the values as described in 12.6.2.15 and 12.6.4.5.
<P>
</PRE>
4 If any error, end-of-file, or end-of-record conditions occur, the applicable actions specified by the IOSTAT=,
<P>
<PRE>
  IOMSG=, ERR=, END=, and EOR= specifiers of the statement that performs the wait operation are taken.
<P>
</PRE>
5 If an error or end-of-file condition occurs during a wait operation for a unit, the processor performs a wait
<P>
<PRE>
  operation for all pending data transfer operations for that unit.
<P>
       NOTE 12.48
<P>
       Error, end-of-file, and end-of-record conditions can be raised either during the data transfer statement that
<P>
       initiates asynchronous input/output, a subsequent asynchronous data transfer statement for the same unit,
<P>
       or during the wait operation. If such conditions are raised during a data transfer statement, they trigger
<P>
       actions according to the IOSTAT=, ERR=, END=, and EOR= specifiers of that statement; if they are
<P>
       raised during the wait operation, the actions are in accordance with the specifiers of the statement that
<P>
       performs the wait operation.
<P>
</PRE>
6 After completion of the wait operation, the data transfer operation and its input/output storage sequence are no
<P>
<PRE>
  longer considered to be pending.
<P>
  12.7.2      WAIT statement
<P>
</PRE>
1 A WAIT statement performs a wait operation for specified pending asynchronous data transfer operations.
<P>
<PRE>
  R1222 wait-stmt                        is  WAIT (wait-spec-list)
<P>
  R1223 wait-spec                        is  [ UNIT = ] file-unit-number
<P>
                                         or  END = label
<P>
                                         or  EOR = label
<P>
                                         or  ERR = label
<P>
                                         or  ID = scalar-int-expr
<P>
                                         or  IOMSG = iomsg-variable
<P>
                                         or  IOSTAT = stat-variable
<P>
  C1236 No specifier shall appear more than once in a given wait-spec-list.
<P>
  C1237 A file-unit-number shall be specified in a wait-spec-list; if the optional characters UNIT= are omitted,
<P>
           the file-unit-number shall be the first item in the wait-spec-list.
<P>
  C1238 (R1223) The label in the ERR=, EOR=, or END= specifier shall be the statement label of a branch
<P>
           target statement that appears in the same inclusive scope as the WAIT statement.
<P>
</PRE>
2 The IOSTAT=, ERR=, EOR=, END=, and IOMSG= specifiers are described in 12.11.
<P>
<PRE>
  250                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 The value of the expression specified in the ID= specifier shall be zero or the identifier of a pending data transfer
<P>
<PRE>
  operation for the specified unit. If the ID= specifier appears, a wait operation for the specified data transfer
<P>
  operation, if any, is performed. If the ID= specifier is omitted, wait operations for all pending data transfers for
<P>
  the specified unit are performed.
<P>
</PRE>
4 Execution of a WAIT statement specifying a unit that does not exist, has no file connected to it, or is not open
<P>
<PRE>
  for asynchronous input/output is permitted, provided that the WAIT statement has no ID= specifier; such a
<P>
  WAIT statement does not cause an error or end-of-file condition to occur.
<P>
         NOTE 12.49
<P>
         An EOR= specifier has no effect if the pending data transfer operation is not a nonadvancing read. An
<P>
         END= specifier has no effect if the pending data transfer operation is not a READ.
<P>
  12.8         File positioning statements
<P>
  12.8.1       Syntax
<P>
  R1224 backspace-stmt                      is BACKSPACE file-unit-number
<P>
                                            or BACKSPACE ( position-spec-list )
<P>
  R1225 endfile-stmt                        is ENDFILE file-unit-number
<P>
                                            or ENDFILE ( position-spec-list )
<P>
  R1226 rewind-stmt                         is REWIND file-unit-number
<P>
                                            or REWIND ( position-spec-list )
<P>
</PRE>
1 A unit that is connected for direct access shall not be referred to by a BACKSPACE, ENDFILE, or REWIND
<P>
<PRE>
  statement. A unit that is connected for unformatted stream access shall not be referred to by a BACKSPACE
<P>
  statement. A unit that is connected with an ACTION= specifier having the value READ shall not be referred
<P>
  to by an ENDFILE statement.
<P>
  R1227 position-spec                       is   [ UNIT = ] file-unit-number
<P>
                                            or   IOMSG = iomsg-variable
<P>
                                            or   IOSTAT = stat-variable
<P>
                                            or   ERR = label
<P>
  C1239 No specifier shall appear more than once in a given position-spec-list.
<P>
  C1240 A file-unit-number shall be specified in a position-spec-list; if the optional characters UNIT= are omitted,
<P>
            the file-unit-number shall be the first item in the position-spec-list.
<P>
  C1241 (R1227) The label in the ERR= specifier shall be the statement label of a branch target statement that
<P>
            appears in the same inclusive scope as the file positioning statement.
<P>
</PRE>
2 The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
<BLOCKQUOTE>
<P>
3 Execution of a file positioning statement performs a wait operation for all pending asynchronous data transfer
<P>
<PRE>
  operations for the specified unit.
<P>
  12.8.2       BACKSPACE statement
<P>
</PRE>
1 Execution of a BACKSPACE statement causes the file connected to the specified unit to be positioned before
<P>
<PRE>
  the current record if there is a current record, or before the preceding record if there is no current record. If the
<P>
  file is at its initial point, the position of the file is not changed.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           251
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 12.50
<P>
       If the preceding record is an endfile record, the file is positioned before the endfile record.
<P>
</PRE>
2 If a BACKSPACE statement causes the implicit writing of an endfile record, the file is positioned before the
<P>
<PRE>
  record that precedes the endfile record.
<P>
</PRE>
3 Backspacing a file that is connected but does not exist is prohibited.
<P>
4 Backspacing over records written using list-directed or namelist formatting is prohibited.
<P>
<PRE>
       NOTE 12.51
<P>
       An example of a BACKSPACE statement is:
<P>
       BACKSPACE (10, IOSTAT = N)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.8.3</B> </TD><TD valign=bottom>
ENDFILE statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Execution of an ENDFILE statement for a file connected for sequential access writes an endfile record as the next
<P>
<PRE>
  record of the file. The file is then positioned after the endfile record, which becomes the last record of the file.
<P>
  If the file also may be connected for direct access, only those records before the endfile record are considered to
<P>
  have been written. Thus, only those records may be read during subsequent direct access connections to the file.
<P>
</PRE>
2 After execution of an ENDFILE statement for a file connected for sequential access, a BACKSPACE or REWIND
<P>
<PRE>
  statement shall be used to reposition the file prior to execution of any data transfer input/output statement or
<P>
  ENDFILE statement.
<P>
</PRE>
3 Execution of an ENDFILE statement for a file connected for stream access causes the terminal point of the file
<P>
<PRE>
  to become equal to the current file position. Only file storage units before the current position are considered
<P>
  to have been written; thus only those file storage units may be subsequently read. Subsequent stream output
<P>
  statements may be used to write further data to the file.
<P>
</PRE>
4 Execution of an ENDFILE statement for a file that is connected but does not exist creates the file; if the file is
<P>
<PRE>
  connected for sequential access, it is created prior to writing the endfile record.
<P>
       NOTE 12.52
<P>
       An example of an ENDFILE statement is:
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ENDFILE K</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.8.4</B> </TD><TD valign=bottom>
REWIND statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Execution of a REWIND statement causes the specified file to be positioned at its initial point.
<P>
<PRE>
       NOTE 12.53
<P>
       If the file is already positioned at its initial point, execution of this statement has no effect on the position
<P>
       of the file.
<P>
</PRE>
2 Execution of a REWIND statement for a file that is connected but does not exist is permitted and has no effect
<P>
<PRE>
  on any file.
<P>
       NOTE 12.54
<P>
       An example of a REWIND statement is:
<P>
       REWIND 10
<P>
  252                                                                   ⃝
<P>
                                                                        c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.9        FLUSH statement
<P>
  R1228 flush-stmt                        is FLUSH file-unit-number
<P>
                                          or FLUSH ( flush-spec-list )
<P>
  R1229 flush-spec                        is  [UNIT =] file-unit-number
<P>
                                          or  IOSTAT = stat-variable
<P>
                                          or  IOMSG = iomsg-variable
<P>
                                          or  ERR = label
<P>
  C1242 No specifier shall appear more than once in a given flush-spec-list.
<P>
  C1243 A file-unit-number shall be specified in a flush-spec-list; if the optional characters UNIT= are omitted
<P>
           from the unit specifier, the file-unit-number shall be the first item in the flush-spec-list.
<P>
  C1244 (R1229) The label in the ERR= specifier shall be the statement label of a branch target statement that
<P>
           appears in the same inclusive scope as the FLUSH statement.
<P>
</PRE>
1 The IOSTAT=, IOMSG= and ERR= specifiers are described in 12.11.
<BLOCKQUOTE>
<P>
2 Execution of a FLUSH statement causes data written to an external file to be available to other processes, or
<P>
<PRE>
  causes data placed in an external file by means other than Fortran to be available to a READ statement. These
<P>
  actions are processor dependent.
<P>
</PRE>
3 Execution of a FLUSH statement for a file that is connected but does not exist is permitted and has no effect on
<P>
<PRE>
  any file. A FLUSH statement has no effect on file position.
<P>
</PRE>
4 Execution of a FLUSH statement performs a wait operation for all pending asynchronous data transfer operations
<P>
<PRE>
  for the specified unit.
<P>
       NOTE 12.55
<P>
       Because this document does not specify the mechanism of file storage, the exact meaning of the flush
<P>
       operation is not precisely defined. It is expected that the flush operation will make all data written to a file
<P>
       available to other processes or devices, or make data recently added to a file by other processes or devices
<P>
       available to the program via a subsequent read operation. This is commonly called “flushing input/output
<P>
       buffers”.
<P>
       NOTE 12.56
<P>
       An example of a FLUSH statement is:
<P>
       FLUSH (10, IOSTAT = N)
<P>
  12.10        File inquiry statement
<P>
  12.10.1      Forms of the INQUIRE statement
<P>
</PRE>
1 The INQUIRE statement can be used to inquire about properties of a particular named file, of the connection
<P>
<PRE>
  to a particular unit, or the number of file storage units required for an output list. There are three forms of the
<P>
  INQUIRE statement: inquire by file, which uses the FILE= specifier, inquire by unit, which uses the UNIT=
<P>
  specifier, and inquire by output list, which uses only the IOLENGTH= specifier. Assignments to specifier variables
<P>
  are converted, truncated, or padded according to the rules of intrinsic assignment.
<P>
</PRE>
2 For inquiry by unit, the unit specified need not exist or be connected to a file. If it is connected to a file, the
<P>
<PRE>
  inquiry is being made about the connection and about the file connected.
<P>
</PRE>
3 For inquiry by file, the file specified need not exist or be connected to a unit. If it is connected to a unit, the
<P>
<PRE>
  inquiry is being made about the connection as well as about the file.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           253
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 An INQUIRE statement may be executed before, while, or after a file is connected to a unit. All values assigned
<P>
<PRE>
  by an INQUIRE statement are those that are current at the time the statement is executed.
<P>
  R1230 inquire-stmt                   is INQUIRE ( inquire-spec-list )
<P>
                                       or INQUIRE ( IOLENGTH = scalar-int-variable )
<P>
                                               output-item-list
<P>
       NOTE 12.57
<P>
      Examples of INQUIRE statements are:
<P>
                INQUIRE (IOLENGTH = IOL) A (1:N)
<P>
                INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &
<P>
                          FORM = CHAR_VAR, IOSTAT = IOS)
<P>
  12.10.2     Inquiry specifiers
<P>
  12.10.2.1   Syntax
<P>
</PRE>
1 Unless constrained, the following inquiry specifiers may be used in either of the inquire by file or inquire by unit
<P>
<PRE>
  forms of the INQUIRE statement.
<P>
  R1231 inquire-spec                   is   [ UNIT = ] file-unit-number
<P>
                                       or   FILE = file-name-expr
<P>
                                       or   ACCESS = scalar-default-char-variable
<P>
                                       or   ACTION = scalar-default-char-variable
<P>
                                       or   ASYNCHRONOUS = scalar-default-char-variable
<P>
                                       or   BLANK = scalar-default-char-variable
<P>
                                       or   DECIMAL = scalar-default-char-variable
<P>
                                       or   DELIM = scalar-default-char-variable
<P>
                                       or   DIRECT = scalar-default-char-variable
<P>
                                       or   ENCODING = scalar-default-char-variable
<P>
                                       or   ERR = label
<P>
                                       or   EXIST = scalar-logical-variable
<P>
                                       or   FORM = scalar-default-char-variable
<P>
                                       or   FORMATTED = scalar-default-char-variable
<P>
                                       or   ID = scalar-int-expr
<P>
                                       or   IOMSG = iomsg-variable
<P>
                                       or   IOSTAT = stat-variable
<P>
                                       or   NAME = scalar-default-char-variable
<P>
                                       or   NAMED = scalar-logical-variable
<P>
                                       or   NEXTREC = scalar-int-variable
<P>
                                       or   NUMBER = scalar-int-variable
<P>
                                       or   OPENED = scalar-logical-variable
<P>
                                       or   PAD = scalar-default-char-variable
<P>
                                       or   PENDING = scalar-logical-variable
<P>
                                       or   POS = scalar-int-variable
<P>
                                       or   POSITION = scalar-default-char-variable
<P>
                                       or   READ = scalar-default-char-variable
<P>
                                       or   READWRITE = scalar-default-char-variable
<P>
                                       or   RECL = scalar-int-variable
<P>
                                       or   ROUND = scalar-default-char-variable
<P>
                                       or   SEQUENTIAL = scalar-default-char-variable
<P>
                                       or   SIGN = scalar-default-char-variable
<P>
                                       or   SIZE = scalar-int-variable
<P>
                                       or   STREAM = scalar-default-char-variable
<P>
                                       or   UNFORMATTED = scalar-default-char-variable
<P>
                                       or   WRITE = scalar-default-char-variable
<P>
  254                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1245 No specifier shall appear more than once in a given inquire-spec-list.
<P>
  C1246 An inquire-spec-list shall contain one FILE= specifier or one file-unit-number, but not both.
<P>
  C1247 In the inquire by unit form of the INQUIRE statement, if the optional characters UNIT= are omitted,
<P>
            the file-unit-number shall be the first item in the inquire-spec-list.
<P>
  C1248 If an ID= specifier appears in an inquire-spec-list, a PENDING= specifier shall also appear.
<P>
  C1249 (R1229) The label in the ERR= specifier shall be the statement label of a branch target statement that
<P>
            appears in the same inclusive scope as the INQUIRE statement.
<P>
</PRE>
2 If file-unit-number identifies an internal unit (12.6.4.8.2), an error condition occurs.
<P>
3 When a returned value of a specifier other than the NAME= specifier is of type character, the value returned is
<P>
<PRE>
  in upper case.
<P>
</PRE>
4 If an error condition occurs during execution of an INQUIRE statement, all of the inquiry specifier variables
<P>
<PRE>
  become undefined, except for variables in the IOSTAT= and IOMSG= specifiers (if any).
<P>
</PRE>
5 The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
<P>
<PRE>
  12.10.2.2     FILE= specifier in the INQUIRE statement
<P>
</PRE>
1 The value of the file-name-expr in the FILE= specifier specifies the name of the file being inquired about. The
<P>
<PRE>
  named file need not exist or be connected to a unit. The value of the file-name-expr shall be of a form acceptable
<P>
  to the processor as a file name. Any trailing blanks are ignored. The interpretation of case is processor dependent.
<P>
  12.10.2.3     ACCESS= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the ACCESS= specifier is assigned the value SEQUENTIAL if the connection
<P>
<PRE>
  is for sequential access, DIRECT if the connection is for direct access, or STREAM if the connection is for stream
<P>
  access. If there is no connection, it is assigned the value UNDEFINED.
<P>
  12.10.2.4     ACTION= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the ACTION= specifier is assigned the value READ if the connection is for
<P>
<PRE>
  input only, WRITE if the connection is for output only, and READWRITE if the connection is for both input
<P>
  and output. If there is no connection, the scalar-default-char-variable is assigned the value UNDEFINED.
<P>
  12.10.2.5     ASYNCHRONOUS= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the ASYNCHRONOUS= specifier is assigned the value YES if the connection
<P>
<PRE>
  allows asynchronous input/output; it is assigned the value NO if the connection does not allow asynchronous
<P>
  input/output. If there is no connection, the scalar-default-char-variable is assigned the value UNDEFINED.
<P>
  12.10.2.6     BLANK= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the BLANK= specifier is assigned the value ZERO or NULL, corresponding
<P>
<PRE>
  to the blank interpretation mode in effect for a connection for formatted input/output. If there is no connection,
<P>
  or if the connection is not for formatted input/output, the scalar-default-char-variable is assigned the value
<P>
  UNDEFINED.
<P>
  12.10.2.7     DECIMAL= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the DECIMAL= specifier is assigned the value COMMA or POINT, corres-
<P>
<PRE>
  ponding to the decimal edit mode in effect for a connection for formatted input/output. If there is no connection,
<P>
  or if the connection is not for formatted input/output, the scalar-default-char-variable is assigned the value
<P>
  UNDEFINED.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          255
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.10.2.8     DELIM= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the DELIM= specifier is assigned the value APOSTROPHE, QUOTE, or
<P>
<PRE>
  NONE, corresponding to the delimiter mode in effect for a connection for formatted input/output. If there is no
<P>
  connection or if the connection is not for formatted input/output, the scalar-default-char-variable is assigned the
<P>
  value UNDEFINED.
<P>
  12.10.2.9     DIRECT= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the DIRECT= specifier is assigned the value YES if DIRECT is included in
<P>
<PRE>
  the set of allowed access methods for the file, NO if DIRECT is not included in the set of allowed access methods
<P>
  for the file, and UNKNOWN if the processor is unable to determine whether DIRECT is included in the set of
<P>
  allowed access methods for the file or if the unit identified by file-unit-number is not connected to a file.
<P>
  12.10.2.10     ENCODING= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the ENCODING= specifier is assigned the value UTF-8 if the connection is
<P>
<PRE>
  for formatted input/output with an encoding form of UTF-8, and is assigned the value UNDEFINED if the
<P>
  connection is for unformatted input/output. If there is no connection, it is assigned the value UTF-8 if the
<P>
  processor is able to determine that the encoding form of the file is UTF-8; if the processor is unable to determine
<P>
  the encoding form of the file or if the unit identified by file-unit-number is not connected to a file, the variable is
<P>
  assigned the value UNKNOWN.
<P>
        NOTE 12.58
<P>
        The value assigned could be something other than UTF-8, UNDEFINED, or UNKNOWN if the processor
<P>
        supports other specific encoding forms (e.g. UTF-16BE).
<P>
  12.10.2.11     EXIST= specifier in the INQUIRE statement
<P>
</PRE>
1 Execution of an INQUIRE by file statement causes the scalar-logical-variable in the EXIST= specifier to be
<P>
<PRE>
  assigned the value true if there exists a file with the specified name; otherwise, false is assigned. Execution of an
<P>
  INQUIRE by unit statement causes true to be assigned if the specified unit exists; otherwise, false is assigned.
<P>
  12.10.2.12     FORM= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the FORM= specifier is assigned the value FORMATTED if the connection
<P>
<PRE>
  is for formatted input/output, and is assigned the value UNFORMATTED if the connection is for unformatted
<P>
  input/output. If there is no connection, it is assigned the value UNDEFINED.
<P>
  12.10.2.13     FORMATTED= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the FORMATTED= specifier is assigned the value YES if FORMATTED is
<P>
<PRE>
  included in the set of allowed forms for the file, NO if FORMATTED is not included in the set of allowed forms
<P>
  for the file, and UNKNOWN if the processor is unable to determine whether FORMATTED is included in the
<P>
  set of allowed forms for the file or if the unit identified by file-unit-number is not connected to a file.
<P>
  12.10.2.14     ID= specifier in the INQUIRE statement
<P>
</PRE>
1 The value of the expression specified in the ID= specifier shall be the identifier of a pending data transfer operation
<P>
<PRE>
  for the specified unit. This specifier interacts with the PENDING= specifier (12.10.2.21).
<P>
  12.10.2.15     NAME= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the NAME= specifier is assigned the value of the name of the file if the file
<P>
<PRE>
  has a name; otherwise, it becomes undefined. The value assigned shall be suitable for use as the value of the
<P>
  file-name-expr in the FILE= specifier in an OPEN statement.
<P>
  256                                                                   ⃝
<P>
                                                                        c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 12.59
<P>
        If this specifier appears in an INQUIRE by file statement, its value is not necessarily the same as the name
<P>
        given in the FILE= specifier.
<P>
        The processor could assign a file name qualified by a user identification, device, directory, or other relevant
<P>
        information.
<P>
</PRE>
2 The case of the characters assigned to scalar-default-char-variable is processor dependent.
<P>
<PRE>
  12.10.2.16      NAMED= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-logical-variable in the NAMED= specifier is assigned the value true if the file has a name; otherwise,
<P>
<PRE>
  it is assigned the value false.
<P>
  12.10.2.17      NEXTREC= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-int-variable in the NEXTREC= specifier is assigned the value n + 1, where n is the record number of
<P>
<PRE>
  the last record read from or written to the connection for direct access. If there is a connection but no records have
<P>
  been read or written since the connection, the scalar-int-variable is assigned the value 1. If there is no connection,
<P>
  the connection is not for direct access, or the position is indeterminate because of a previous error condition, the
<P>
  scalar-int-variable becomes undefined. If there are pending data transfer operations for the specified unit, the
<P>
  value assigned is computed as if all the pending data transfers had already completed.
<P>
  12.10.2.18      NUMBER= specifier in the INQUIRE statement
<P>
</PRE>
1 Execution of an INQUIRE by file statement causes the scalar-int-variable in the NUMBER= specifier to be
<P>
<PRE>
  assigned the value of the external unit number of the unit that is connected to the file. If more than one unit
<P>
  on an image is connected to the file, which of the connected external unit numbers is assigned to the scalar-int-
<P>
  variable is processor dependent. If there is no unit connected to the file, the value −1 is assigned. Execution of
<P>
  an INQUIRE by unit statement causes the scalar-int-variable to be assigned the value of file-unit-number.
<P>
  12.10.2.19      OPENED= specifier in the INQUIRE statement
<P>
</PRE>
1 Execution of an INQUIRE by file statement causes the scalar-logical-variable in the OPENED= specifier to be
<P>
<PRE>
  assigned the value true if the file specified is connected to a unit; otherwise, false is assigned. Execution of an
<P>
  INQUIRE by unit statement causes the scalar-logical-variable to be assigned the value true if the specified unit
<P>
  is connected to a file; otherwise, false is assigned.
<P>
  12.10.2.20      PAD= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the PAD= specifier is assigned the value YES or NO, corresponding to the
<P>
<PRE>
  pad mode in effect for a connection for formatted input/output. If there is no connection or if the connection is
<P>
  not for formatted input/output, the scalar-default-char-variable is assigned the value UNDEFINED.
<P>
  12.10.2.21      PENDING= specifier in the INQUIRE statement
<P>
</PRE>
1 The PENDING= specifier is used to determine whether previously pending asynchronous data transfers are
<P>
<PRE>
  complete. A data transfer operation is previously pending if it is pending at the beginning of execution of the
<P>
  INQUIRE statement.
<P>
</PRE>
2 If an ID= specifier appears and the specified data transfer operation is complete, then the variable specified in
<P>
<PRE>
  the PENDING= specifier is assigned the value false and the INQUIRE statement performs the wait operation
<P>
  for the specified data transfer.
<P>
</PRE>
3 If the ID= specifier is omitted and all previously pending data transfer operations for the specified unit are
<P>
<PRE>
  complete, then the variable specified in the PENDING= specifier is assigned the value false and the INQUIRE
<P>
  statement performs wait operations for all previously pending data transfers for the specified unit.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             257
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 In all other cases, the variable specified in the PENDING= specifier is assigned the value true, no wait operations
<P>
<PRE>
  are performed, and the previously pending data transfers remain pending after the execution of the INQUIRE
<P>
  statement.
<P>
        NOTE 12.60
<P>
        The processor has considerable flexibility in defining when it considers a transfer to be complete. Any of
<P>
        the following approaches could be used:
<P>
            • The INQUIRE statement could consider an asynchronous data transfer to be incomplete until after
<P>
              the corresponding wait operation. In this case PENDING= would always return true unless there
<P>
              were no previously pending data transfers for the unit.
<P>
            • The INQUIRE statement could wait for all specified data transfers to complete and then always return
<P>
              false for PENDING=.
<P>
            • The INQUIRE statement could actually test the state of the specified data transfer operations.
<P>
  12.10.2.22      POS= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-int-variable in the POS= specifier is assigned the number of the file storage unit immediately following
<P>
<PRE>
  the current position of a file connected for stream access. If the file is positioned at its terminal position, the
<P>
  variable is assigned a value one greater than the number of the highest-numbered file storage unit in the file.
<P>
  If there are pending data transfer operations for the specified unit, the value assigned is computed as if all the
<P>
  pending data transfers had already completed. If there is no connection, the file is not connected for stream
<P>
  access, or if the position of the file is indeterminate because of previous error conditions, the variable becomes
<P>
  undefined.
<P>
  12.10.2.23      POSITION= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the POSITION= specifier is assigned the value REWIND if the connection
<P>
<PRE>
  was opened for positioning at its initial point, APPEND if the connection was opened for positioning before its
<P>
  endfile record or at its terminal point, and ASIS if the connection was opened without changing its position.
<P>
  If there is no connection or if the file is connected for direct access, the scalar-default-char-variable is assigned
<P>
  the value UNDEFINED. If the file has been repositioned since the connection, the scalar-default-char-variable
<P>
  is assigned a processor-dependent value, which shall not be REWIND unless the file is positioned at its initial
<P>
  point and shall not be APPEND unless the file is positioned so that its endfile record is the next record or at its
<P>
  terminal point if it has no endfile record.
<P>
  12.10.2.24      READ= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the READ= specifier is assigned the value YES if READ is included in the
<P>
<PRE>
  set of allowed actions for the file, NO if READ is not included in the set of allowed actions for the file, and
<P>
  UNKNOWN if the processor is unable to determine whether READ is included in the set of allowed actions for
<P>
  the file or if the unit identified by file-unit-number is not connected to a file.
<P>
  12.10.2.25      READWRITE= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the READWRITE= specifier is assigned the value YES if READWRITE is
<P>
<PRE>
  included in the set of allowed actions for the file, NO if READWRITE is not included in the set of allowed actions
<P>
  for the file, and UNKNOWN if the processor is unable to determine whether READWRITE is included in the
<P>
  set of allowed actions for the file or if the unit identified by file-unit-number is not connected to a file.
<P>
  12.10.2.26      RECL= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-int-variable in the RECL= specifier is assigned the value of the record length of a connection for direct
<P>
<PRE>
  access, or the value of the maximum record length of a connection for sequential access. If the connection is for
<P>
  formatted input/output, the length is the number of characters for all records that contain only characters of
<P>
  258                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
  default kind. If the connection is for unformatted input/output, the length is measured in file storage units. If
<P>
  there is no connection, the scalar-int-variable is assigned the value −1, and if the connection is for stream access,
<P>
  the scalar-int-variable is assigned the value −2.
<P>
  12.10.2.27     ROUND= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the ROUND= specifier is assigned the value UP, DOWN, ZERO, NEAREST,
<P>
<PRE>
  COMPATIBLE, or PROCESSOR_DEFINED, corresponding to the input/output rounding mode in effect for
<P>
  a connection for formatted input/output. If there is no connection or if the connection is not for formatted
<P>
  input/output, the scalar-default-char-variable is assigned the value UNDEFINED. The processor shall return the
<P>
  value PROCESSOR_DEFINED only if the behavior of the input/output rounding mode is different from that
<P>
  of the UP, DOWN, ZERO, NEAREST, and COMPATIBLE modes.
<P>
  12.10.2.28     SEQUENTIAL= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the SEQUENTIAL= specifier is assigned the value YES if SEQUENTIAL is
<P>
<PRE>
  included in the set of allowed access methods for the file, NO if SEQUENTIAL is not included in the set of allowed
<P>
  access methods for the file, and UNKNOWN if the processor is unable to determine whether SEQUENTIAL is
<P>
  included in the set of allowed access methods for the file or if the unit identified by file-unit-number is not
<P>
  connected to a file.
<P>
  12.10.2.29     SIGN= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the SIGN= specifier is assigned the value PLUS, SUPPRESS, or PRO-
<P>
<PRE>
  CESSOR_DEFINED, corresponding to the sign mode in effect for a connection for formatted input/output.
<P>
  If there is no connection, or if the connection is not for formatted input/output, the scalar-default-char-variable
<P>
  is assigned the value UNDEFINED.
<P>
  12.10.2.30     SIZE= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-int-variable in the SIZE= specifier is assigned the size of the file in file storage units. If the file size
<P>
<PRE>
  cannot be determined or if the unit identified by file-unit-number is not connected to a file, the variable is assigned
<P>
  the value −1.
<P>
</PRE>
2 For a file that may be connected for stream access, the file size is the number of the highest-numbered file storage
<P>
<PRE>
  unit in the file.
<P>
</PRE>
3 For a file that may be connected for sequential or direct access, the file size may be different from the number of
<P>
<PRE>
  storage units implied by the data in the records; the exact relationship is processor dependent.
<P>
</PRE>
4 If there are pending data transfer operations for the specified unit, the value assigned is computed as if all the
<P>
<PRE>
  pending data transfers had already completed.
<P>
  12.10.2.31     STREAM= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the STREAM= specifier is assigned the value YES if STREAM is included in
<P>
<PRE>
  the set of allowed access methods for the file, NO if STREAM is not included in the set of allowed access methods
<P>
  for the file, and UNKNOWN if the processor is unable to determine whether STREAM is included in the set of
<P>
  allowed access methods for the file or if the unit identified by file-unit-number is not connected to a file.
<P>
  12.10.2.32     UNFORMATTED= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the UNFORMATTED= specifier is assigned the value YES if UNFORMAT-
<P>
<PRE>
  TED is included in the set of allowed forms for the file, NO if UNFORMATTED is not included in the set of
<P>
  allowed forms for the file, and UNKNOWN if the processor is unable to determine whether UNFORMATTED is
<P>
  included in the set of allowed forms for the file or if the unit identified by file-unit-number is not connected to a
<P>
  file.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              259
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.10.2.33       WRITE= specifier in the INQUIRE statement
<P>
</PRE>
1 The scalar-default-char-variable in the WRITE= specifier is assigned the value YES if WRITE is included in the
<P>
<PRE>
  set of allowed actions for the file, NO if WRITE is not included in the set of allowed actions for the file, and
<P>
  UNKNOWN if the processor is unable to determine whether WRITE is included in the set of allowed actions for
<P>
  the file or if the unit identified by file-unit-number is not connected to a file.
<P>
  12.10.3        Inquire by output list
<P>
</PRE>
1 The scalar-int-variable in the IOLENGTH= specifier is assigned the processor-dependent number of file storage
<P>
<PRE>
  units that would be required to store the data of the output list in an unformatted file. The value shall be suitable
<P>
  as a RECL= specifier in an OPEN statement that connects a file for unformatted direct access if data will be
<P>
  read from or written to the file using data transfer statements with an input/output list that specifies transfer of
<P>
  a sequence of objects having the same types, type parameters, and extents, in the same order as the output list
<P>
  in the INQUIRE statement.
<P>
</PRE>
2 The output list in an INQUIRE statement shall not contain any derived-type list items that require a defined
<P>
<PRE>
  input/output procedure as described in subclause 12.6.3. If a derived-type list item appears in the output list, the
<P>
  value returned for the IOLENGTH= specifier assumes that no defined input/output procedure will be invoked.
<P>
  12.11         Error, end-of-record, and end-of-file conditions
<P>
  12.11.1        Occurrence of input/output conditions
<P>
</PRE>
1 The set of input/output error conditions is processor dependent. Except as otherwise specified, when an error
<P>
<PRE>
  condition occurs or is detected is processor dependent.
<P>
</PRE>
2 An end-of-record condition occurs when a nonadvancing input statement attempts to transfer data from a position
<P>
<PRE>
  beyond the end of the current record, unless the file is a stream file and the current record is at the end of the
<P>
  file (an end-of-file condition occurs instead).
<P>
</PRE>
3 An end-of-file condition occurs when
<P>
<PRE>
       • an endfile record is encountered during the reading of a file connected for sequential access,
<P>
       • an attempt is made to read a record beyond the end of an internal file, or
<P>
       • an attempt is made to read beyond the end of a stream file.
<P>
</PRE>
4 An end-of-file condition may occur at the beginning of execution of an input statement. An end-of-file condition
<P>
<PRE>
  also may occur during execution of a formatted input statement when more than one record is required by the
<P>
  interaction of the input list and the format. An end-of-file condition also may occur during execution of a stream
<P>
  input statement.
<P>
  12.11.2        Error conditions and the ERR= specifier
<P>
</PRE>
1 If an error condition occurs during execution of an input/output statement, the position of the file becomes
<P>
<PRE>
  indeterminate.
<P>
</PRE>
2 If an error condition occurs during execution of an input/output statement that contains neither an ERR= nor
<P>
<PRE>
  IOSTAT= specifier, error termination is initiated. If an error condition occurs during execution of an input/output
<P>
  statement that contains either an ERR= specifier or an IOSTAT= specifier then:
<P>
         (1)     processing of the input/output list, if any, terminates;
<P>
         (2)     if the statement is a data transfer statement or the error condition occurs during a wait operation,
<P>
                 all do-variables in the statement that initiated the transfer become undefined;
<P>
         (3)     if an IOSTAT= specifier appears, the stat-variable in the IOSTAT= specifier becomes defined as
<P>
                 specified in 12.11.5;
<P>
  260                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
         (4)   if an IOMSG= specifier appears, the iomsg-variable becomes defined as specified in 12.11.6;
<P>
         (5)   if the statement is a READ statement and it contains a SIZE= specifier, the scalar-int-variable in
<P>
               the SIZE= specifier becomes defined as specified in 12.6.2.15;
<P>
         (6)   if the statement is a READ statement or the error condition occurs in a wait operation for a transfer
<P>
               initiated by a READ statement, all input items or namelist group objects in the statement that
<P>
               initiated the transfer become undefined;
<P>
         (7)   if an ERR= specifier appears, a branch to the statement labeled by the label in the ERR= specifier
<P>
               occurs.
<P>
  12.11.3      End-of-file condition and the END= specifier
<P>
</PRE>
1 If an end-of-file condition occurs during execution of an input/output statement that contains neither an END=
<P>
<PRE>
  specifier nor an IOSTAT= specifier, error termination is initiated. If an end-of-file condition occurs during
<P>
  execution of an input/output statement that contains either an END= specifier or an IOSTAT= specifier, and
<P>
  an error condition does not occur then:
<P>
         (1)   processing of the input list, if any, terminates;
<P>
         (2)   if the statement is a data transfer statement or the end-of-file condition occurs during a wait operation,
<P>
               all do-variables in the statement that initiated the transfer become undefined;
<P>
         (3)   if the statement is an input statement or the end-of-file condition occurs during a wait operation
<P>
               for a transfer initiated by an input statement, all input list items or namelist group objects in the
<P>
               statement that initiated the transfer become undefined;
<P>
         (4)   if the file specified in the input statement is an external record file, it is positioned after the endfile
<P>
               record;
<P>
         (5)   if an IOSTAT= specifier appears, the stat-variable in the IOSTAT= specifier becomes defined as
<P>
               specified in 12.11.5;
<P>
         (6)   if an IOMSG= specifier appears, the iomsg-variable becomes defined as specified in 12.11.6;
<P>
         (7)   if an END= specifier appears, a branch to the statement labeled by the label in the END= specifier
<P>
               occurs.
<P>
  12.11.4      End-of-record condition and the EOR= specifier
<P>
</PRE>
1 If an end-of-record condition occurs during execution of an input/output statement that contains neither an
<P>
<PRE>
  EOR= specifier nor an IOSTAT= specifier, error termination is initiated. If an end-of-record condition occurs
<P>
  during execution of an input/output statement that contains either an EOR= specifier or an IOSTAT= specifier,
<P>
  and an error condition does not occur then:
<P>
         (1)   if the pad mode has the value
<P>
               (a)     YES, the record is padded with blanks to satisfy the effective item (12.6.4.5.3) and correspond-
<P>
                       ing data edit descriptors that require more characters than the record contains,
<P>
               (b)     NO, the input list item becomes undefined;
<P>
         (2)   processing of the input list, if any, terminates;
<P>
         (3)   if the statement is a data transfer statement or the end-of-record condition occurs during a wait
<P>
               operation, all do-variables in the statement that initiated the transfer become undefined;
<P>
         (4)   the file specified in the input statement is positioned after the current record;
<P>
         (5)   if an IOSTAT= specifier appears, the stat-variable in the IOSTAT= specifier becomes defined as
<P>
               specified in 12.11.5;
<P>
         (6)   if an IOMSG= specifier appears, the iomsg-variable becomes defined as specified in 12.11.6;
<P>
         (7)   if a SIZE= specifier appears, the scalar-int-variable in the SIZE= specifier becomes defined as spe-
<P>
               cified in (12.6.2.15);
<P>
         (8)   if an EOR= specifier appears, a branch to the statement labeled by the label in the EOR= specifier
<P>
               occurs.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              261
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  12.11.5      IOSTAT= specifier
<P>
</PRE>
1 Execution of an input/output statement containing the IOSTAT= specifier causes the stat-variable in the IO-
<P>
<PRE>
  STAT= specifier to become defined with
<P>
      • a zero value if neither an error condition, an end-of-file condition, nor an end-of-record condition occurs,
<P>
      • the processor-dependent positive integer value of the constant IOSTAT_INQUIRE_INTERNAL_UNIT
<P>
        from the intrinsic module ISO_FORTRAN_ENV (16.10.2) if a unit number in an INQUIRE statement
<P>
        identifies an internal file,
<P>
      • a processor-dependent positive integer value different from IOSTAT_INQUIRE_INTERNAL_UNIT if any
<P>
        other error condition occurs,
<P>
      • the processor-dependent negative integer value of the constant IOSTAT_END (16.10.2.16) from the intrinsic
<P>
        module ISO_FORTRAN_ENV if an end-of-file condition occurs and no error condition occurs,
<P>
      • the processor-dependent negative integer value of the constant IOSTAT_EOR (16.10.2.17) from the intrinsic
<P>
        module ISO_FORTRAN_ENV if an end-of-record condition occurs and no error condition or end-of-file
<P>
        condition occurs, or
<P>
      • a processor-dependent negative integer value different from IOSTAT_EOR and IOSTAT_END, if the IO-
<P>
        STAT= specifier appears in a FLUSH statement and the processor does not support the flush operation for
<P>
        the specified unit.
<P>
       NOTE 12.61
<P>
       An end-of-file condition can occur only for sequential or stream input and an end-of-record condition can
<P>
       occur only for nonadvancing input.
<P>
       For example,
<P>
       READ (FMT = "(E8.3)", UNIT = 3, IOSTAT = IOSS) X
<P>
       IF (IOSS &lt; 0) THEN
<P>
           ! Perform end-of-file processing on the file connected to unit 3.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL END_PROCESSING</H4>
</A>
<BLOCKQUOTE>
<P>
ELSE IF (IOSS &gt; 0) THEN
<P>
<PRE>
           ! Perform error processing
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL ERROR_PROCESSING</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>12.11.6</B> </TD><TD valign=bottom>
IOMSG= specifier
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 If an error, end-of-file, or end-of-record condition occurs during execution of an input/output statement, iomsg-
<P>
<PRE>
  variable is assigned an explanatory message, truncated or padded according to the rules of intrinsic assignment.
<P>
  If no such condition occurs, the definition status and value of iomsg-variable are unchanged.
<P>
  12.12        Restrictions on input/output statements
<P>
</PRE>
1 If a unit, or a file connected to a unit, does not have all of the properties required for the execution of certain
<P>
<PRE>
  input/output statements, those statements shall not refer to the unit.
<P>
</PRE>
2 An input/output statement that is executed while another input/output statement is being executed is a recursive
<P>
<PRE>
  input/output statement. A recursive input/output statement shall not identify an external unit that is identified
<P>
  by another input/output statement being executed except that a child data transfer statement may identify its
<P>
  parent data transfer statement external unit.
<P>
</PRE>
3 An input/output statement shall not cause the value of any established format specification to be modified.
<BLOCKQUOTE>
<P>
4 A recursive input/output statement shall not modify the value of any internal unit except that a recursive WRITE
<P>
<PRE>
  statement may modify the internal unit identified by that recursive WRITE statement.
<P>
  262                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 The value of a specifier in an input/output statement shall not depend on the definition or evaluation of any other
<P>
<PRE>
  specifier in the io-control-spec-list or inquire-spec-list in that statement. The value of an internal-file-variable or
<P>
  of a FMT=, ID=, IOMSG=, IOSTAT=, or SIZE= specifier shall not depend on the value of any input-item or
<P>
  io-implied-do do-variable in the same statement.
<P>
</PRE>
6 The value of any subscript or substring bound of a variable that appears in a specifier in an input/output
<P>
<PRE>
  statement shall not depend on any input-item, io-implied-do do-variable, or on the definition or evaluation of any
<P>
  other specifier in the io-control-spec-list or inquire-spec-list in that statement.
<P>
</PRE>
7 In a data transfer statement, the variable specified in an IOSTAT=, IOMSG=, or SIZE= specifier, if any, shall
<P>
<PRE>
  not be associated with any entity in the data transfer input/output list (12.6.3) or namelist-group-object-list, nor
<P>
  with a do-variable of an io-implied-do in the data transfer input/output list.
<P>
</PRE>
8 In a data transfer statement, if a variable specified in an IOSTAT=, IOMSG=, or SIZE= specifier is an array
<P>
<PRE>
  element reference, its subscript values shall not be affected by the data transfer, the io-implied-do processing, or
<P>
  the definition or evaluation of any other specifier in the io-control-spec-list.
<P>
</PRE>
9 A variable that may become defined or undefined as a result of its use in a specifier in an INQUIRE statement,
<P>
<PRE>
  or any associated entity, shall not appear in another specifier in the same INQUIRE statement.
<P>
       NOTE 12.62
<P>
       Restrictions on the evaluation of expressions (10.1.4) prohibit certain side effects.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             263
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>264</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
13 Input/output editing
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>13.1</B> </TD><TD valign=bottom>
Format specifications
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 A format used in conjunction with a data transfer statement provides information that directs the editing between
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the internal representation of data and the characters of a sequence of formatted records.
<P>
</PRE>
2 A format (12.6.2.2) in a data transfer statement may refer to a FORMAT statement or to a character expression
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that contains a format specification. A format specification provides explicit editing information. The format
<P>
  alternatively may be an asterisk (*), which indicates list-directed formatting (13.10). Namelist formatting (13.11)
<P>
  may be indicated by specifying a namelist-group-name instead of a format.
<P>
  13.2       Explicit format specification methods
<P>
  13.2.1      FORMAT statement
<P>
  R1301 format-stmt                        is  FORMAT format-specification
<P>
  R1302 format-specification               is ( [ format-items ] )
<P>
                                           or ( [ format-items, ] unlimited-format-item )
<P>
  C1301 (R1301) The format-stmt shall be labeled.
<P>
</PRE>
1 Blank characters may precede the initial left parenthesis of the format specification. Additional blank characters
</TD></TR>
<TR><TD colspan=2>
<PRE>
  may appear at any point within the format specification, with no effect on the interpretation of the format
<P>
  specification, except within a character string edit descriptor (13.9).
<P>
        NOTE 13.1
<P>
        Examples of FORMAT statements are:
<P>
        5      FORMAT (1PE12.4, I10)
<P>
        9      FORMAT (I12, /, ’ Dates: ’, 2 (2I3, I5))
<P>
  13.2.2      Character format specification
<P>
</PRE>
1 A character expression used as a format in a formatted input/output statement shall evaluate to a character
</TD></TR>
<TR><TD colspan=2>
<PRE>
  string whose leading part is a valid format specification.
<P>
        NOTE 13.2
<P>
        The format specification begins with a left parenthesis and ends with a right parenthesis.
<P>
</PRE>
2 All character positions up to and including the final right parenthesis of the format specification shall be defined
</TD></TR>
<TR><TD colspan=2>
<PRE>
  at the time the data transfer statement is executed, and shall not become redefined or undefined during the
<P>
  execution of the statement. Character positions, if any, following the right parenthesis that ends the format
<P>
  specification need not be defined and may contain any character data with no effect on the interpretation of the
<P>
  format specification.
<P>
</PRE>
3 If the format is a character array, it is treated as if all of the elements of the array were specified in array element
</TD></TR>
<TR><TD colspan=2>
<PRE>
  order and were concatenated. However, if a format is a character array element, the format specification shall be
<P>
  entirely within that array element.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               265
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 13.3
<P>
       If a character constant is used as a format in data transfer statement, care shall be taken that the value
<P>
       of the character constant is a valid format specification. In particular, if a format specification delimited
<P>
       by apostrophes contains a character constant edit descriptor delimited with apostrophes, two apostrophes
<P>
       shall be written to delimit the edit descriptor and four apostrophes shall be written for each apostrophe
<P>
       that occurs within the edit descriptor. For example, the text:
<P>
         2 ISN’T 3
<P>
       can be written by various combinations of output statements and format specifications:
<P>
            WRITE (6, 100) 2, 3
<P>
       100 FORMAT (1X, I1, 1X, ’ISN’’T’, 1X, I1)
<P>
            WRITE (6, ’(1X, I1, 1X, ’’ISN’’’’T’’, 1X, I1)’) 2, 3
<P>
            WRITE (6, ’(A)’) ’ 2 ISN’’T 3’
<P>
       Doubling of internal apostrophes usually can be avoided by using quotation marks to delimit the format
<P>
       specification and doubling of internal quotation marks usually can be avoided by using apostrophes as
<P>
       delimiters.
<P>
  13.3       Form of a format item list
<P>
  13.3.1      Syntax
<P>
  R1303 format-items                      is  format-item [ [ , ] format-item ] &#46;&#46;&#46;
<P>
  R1304 format-item                       is  [ r ] data-edit-desc
<P>
                                          or  control-edit-desc
<P>
                                          or  char-string-edit-desc
<P>
                                          or  [ r ] ( format-items )
<P>
  R1305 unlimited-format-item             is  * ( format-items )
<P>
  R1306 r                                 is  int-literal-constant
<P>
  C1302 (R1303) The optional comma shall not be omitted except
<P>
            • between a P edit descriptor and an immediately following F, E, EN, ES, D, or G edit descriptor
<P>
               (13.8.5), possibly preceded by a repeat specification,
<P>
            • before a slash edit descriptor when the optional repeat specification does not appear (13.8.2),
<P>
            • after a slash edit descriptor, or
<P>
            • before or after a colon edit descriptor (13.8.3)
<P>
  C1303 (R1305) An unlimited-format-item shall contain at least one data edit descriptor.
<P>
  C1304 (R1306) r shall be positive.
<P>
  C1305 (R1306) A kind parameter shall not be specified for r.
<P>
</PRE>
1 The integer literal constant r is called a repeat specification.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  13.3.2      Edit descriptors
<P>
</PRE>
1 An edit descriptor is a data edit descriptor (data-edit-desc), control edit descriptor (control-edit-desc), or character
</TD></TR>
<TR><TD colspan=2>
<PRE>
  string edit descriptor (char-string-edit-desc).
<P>
  266                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1307 data-edit-desc                    is   Iw[. m]
<P>
                                          or   Bw[. m]
<P>
                                          or   Ow[. m]
<P>
                                          or   Zw[. m]
<P>
                                          or   Fw. d
<P>
                                          or   Ew. d [Ee]
<P>
                                          or   EN w . d [ E e ]
<P>
                                          or   ES w . d [ E e ]
<P>
                                          or   EX w . d [ E e ]
<P>
                                          or   Gw[. d [Ee]]
<P>
                                          or   Lw
<P>
                                          or   A[w]
<P>
                                          or   Dw. d
<P>
                                          or   DT [ char-literal-constant ] [ ( v-list ) ]
<P>
  R1308 w                                 is   int-literal-constant
<P>
  R1309 m                                 is   int-literal-constant
<P>
  R1310 d                                 is   int-literal-constant
<P>
  R1311 e                                 is   int-literal-constant
<P>
  R1312 v                                 is   signed-int-literal-constant
<P>
  C1306 (R1308) w shall be zero or positive for the I, B, O, Z, D, E, EN, ES, EX, F, and G edit descriptors. w
<P>
           shall be positive for all other edit descriptors.
<P>
  C1307 (R1307) For the G edit descriptor, d shall be specified if w is not zero.
<P>
  C1308 (R1307) For the G edit descriptor, e shall not be specified if w is zero.
<P>
  C1309 (R1307) A kind parameter shall not be specified for the char-literal-constant in the DT edit descriptor,
<P>
           or for w, m, d, e, and v.
<P>
</PRE>
2 An I, B, O, Z, F, E, EN, ES, EX, G, L, A, D, or DT edit descriptor indicates the manner of editing.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1313 control-edit-desc                 is   position-edit-desc
<P>
                                          or   [r ]/
<P>
                                          or   :
<P>
                                          or   sign-edit-desc
<P>
                                          or   k P
<P>
                                          or   blank-interp-edit-desc
<P>
                                          or   round-edit-desc
<P>
                                          or   decimal-edit-desc
<P>
  R1314 k                                 is   signed-int-literal-constant
<P>
  C1310 (R1314) A kind parameter shall not be specified for k.
<P>
</PRE>
3 In k P, k is called the scale factor.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1315 position-edit-desc                is   Tn
<P>
                                          or   TL n
<P>
                                          or   TR n
<P>
                                          or   nX
<P>
  R1316 n                                 is   int-literal-constant
<P>
  C1311 (R1316) n shall be positive.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                    267
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1312 (R1316) A kind parameter shall not be specified for n.
<P>
  R1317 sign-edit-desc                   is SS
<P>
                                         or SP
<P>
                                         or S
<P>
  R1318 blank-interp-edit-desc           is BN
<P>
                                         or BZ
<P>
  R1319 round-edit-desc                  is  RU
<P>
                                         or  RD
<P>
                                         or  RZ
<P>
                                         or  RN
<P>
                                         or  RC
<P>
                                         or  RP
<P>
  R1320 decimal-edit-desc                is DC
<P>
                                         or DP
<P>
</PRE>
4 A T, TL, TR, X, slash, colon, SS, SP, S, P, BN, BZ, RU, RD, RZ, RN, RC, RP, DC, or DP edit descriptor
</TD></TR>
<TR><TD colspan=2>
<PRE>
  indicates the manner of editing.
<P>
  R1321 char-string-edit-desc            is  char-literal-constant
<P>
  C1313 (R1321) A kind parameter shall not be specified for the char-literal-constant.
<P>
</PRE>
5 Each rep-char in a character string edit descriptor shall be capable of representation by the processor.
</TD></TR>
<TR><TD colspan=2>
6 A character string edit descriptor provides constant data to be output, and is not valid for input.
</TD></TR>
<TR><TD colspan=2>
7 The edit descriptors are without regard to case except within a character string edit descriptor.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  13.3.3      Fields
<P>
</PRE>
1 A field is a part of a record that is read on input or written on output when format control encounters a data
</TD></TR>
<TR><TD colspan=2>
<PRE>
  edit descriptor or a character string edit descriptor. The field width is the size in characters of the field.
<P>
  13.4       Interaction between input/output list and format
<P>
</PRE>
1 The start of formatted data transfer using a format specification initiates format control (12.6.4.5.3). Each action
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of format control depends on information jointly provided by the next edit descriptor in the format specification
<P>
  and the next effective item in the input/output list, if one exists.
<P>
</PRE>
2 If an input/output list specifies at least one effective item, at least one data edit descriptor shall exist in the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  format specification.
<P>
        NOTE 13.4
<P>
        An empty format specification of the form ( ) can be used only if the input/output list has no effective item
<P>
        (12.6.4.5). A zero length character item is an effective item, but a zero sized array and an implied DO list
<P>
        with an iteration count of zero is not.
<P>
</PRE>
3 A format specification is interpreted from left to right. The exceptions are format items preceded by a repeat
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specification r, and format reversion (described below).
<P>
</PRE>
4 A format item preceded by a repeat specification is processed as a list of r items, each identical to the format
</TD></TR>
<TR><TD colspan=2>
<PRE>
  item but without the repeat specification and separated by commas.
<P>
  268                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 13.5
<P>
        An omitted repeat specification is treated in the same way as a repeat specification whose value is one.
<P>
</PRE>
5 To each data edit descriptor interpreted in a format specification, there corresponds one effective item specified by
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the input/output list (12.6.3), except that an input/output list item of type complex requires the interpretation
<P>
  of two F, E, EN, ES, D, or G edit descriptors. For each control edit descriptor or character edit descriptor,
<P>
  there is no corresponding item specified by the input/output list, and format control communicates information
<P>
  directly with the record.
<P>
</PRE>
6 Whenever format control encounters a data edit descriptor in a format specification, it determines whether
</TD></TR>
<TR><TD colspan=2>
<PRE>
  there is a corresponding effective item specified by the input/output list. If there is such an item, it transmits
<P>
  appropriately edited information between the item and the record, and then format control proceeds. If there is
<P>
  no such item, format control terminates.
<P>
</PRE>
7 If format control encounters a colon edit descriptor in a format specification and another effective item is not
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specified, format control terminates.
<P>
</PRE>
8 If format control encounters the rightmost parenthesis of an unlimited format item, control reverts to the leftmost
</TD></TR>
<TR><TD colspan=2>
<PRE>
  parenthesis of that unlimited format item. This reversion of format control has no effect on the changeable modes
<P>
  (12.5.2).
<P>
</PRE>
9 If format control encounters the rightmost parenthesis of a complete format specification and another effective
</TD></TR>
<TR><TD colspan=2>
<PRE>
  item is not specified, format control terminates. However, if another effective item is specified, format control
<P>
  then reverts to the beginning of the format item terminated by the last preceding right parenthesis that is not
<P>
  part of a DT edit descriptor. If there is no such preceding right parenthesis, format control reverts to the first
<P>
  left parenthesis of the format specification. If any reversion occurs, the reused portion of the format specification
<P>
  shall contain at least one data edit descriptor. If format control reverts to a parenthesis that is preceded by a
<P>
  repeat specification, the repeat specification is reused. Reversion of format control, of itself, has no effect on
<P>
  the changeable modes. The file is positioned in a manner identical to the way it is positioned when a slash edit
<P>
  descriptor is processed (13.8.2).
<P>
        NOTE 13.6
<P>
        Example: The format specification:
<P>
        10 FORMAT (1X, 2(F10.3, I5))
<P>
        with an output list of
<P>
        WRITE (10,10) 10.1, 3, 4.7, 1, 12.4, 5, 5.2, 6
<P>
        produces the same output as the format specification:
<P>
        10 FORMAT (1X, F10.3, I5, F10.3, I5/F10.3, I5, F10.3, I5)
<P>
        NOTE 13.7
<P>
        The effect of an unlimited-format-item is as if its enclosed list were preceded by a very large repeat count.
<P>
        There is no file positioning implied by unlimited-format-item reversion. This can be used to write what is
<P>
        commonly called a comma separated value record.
<P>
        For example,
<P>
        WRITE( 10, ’( "IARRAY =", *( I0, :, ","))’) IARRAY
<P>
        produces a single record with a header and a comma separated list of integer values.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            269
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  13.5       Positioning by format control
<P>
</PRE>
1 After each data edit descriptor or character string edit descriptor is processed, the file is positioned after the last
</TD></TR>
<TR><TD colspan=2>
<PRE>
  character read or written in the current record.
<P>
</PRE>
2 After each T, TL, TR, or X edit descriptor is processed, the file is positioned as described in 13.8.1.1. After each
</TD></TR>
<TR><TD colspan=2>
<PRE>
  slash edit descriptor is processed, the file is positioned as described in 13.8.2.
<P>
</PRE>
3 During formatted stream output, processing of an A edit descriptor can cause file positioning to occur (13.7.4).
</TD></TR>
<TR><TD colspan=2>
4 If format control reverts as described in 13.4, the file is positioned in a manner identical to the way it is positioned
</TD></TR>
<TR><TD colspan=2>
<PRE>
  when a slash edit descriptor is processed (13.8.2).
<P>
</PRE>
5 During a read operation, any unprocessed characters of the current record are skipped whenever the next record
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is read.
<P>
  13.6       Decimal symbol
<P>
</PRE>
1 The decimal symbol is the character that separates the whole and fractional parts in the decimal representation
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of a real number in an internal or external file. When the decimal edit mode is POINT, the decimal symbol is a
<P>
  decimal point. When the decimal edit mode is COMMA, the decimal symbol is a comma.
<P>
</PRE>
2 If the decimal edit mode is COMMA during list-directed input/output, the character used as a value separator
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is a semicolon in place of a comma.
<P>
  13.7       Data edit descriptors
<P>
  13.7.1      Purpose of data edit descriptors
<P>
</PRE>
1 Data edit descriptors cause the conversion of data to or from its internal representation; during formatted stream
</TD></TR>
<TR><TD colspan=2>
<PRE>
  output, the A data edit descriptor may also cause file positioning. On input, the specified variable becomes
<P>
  defined unless an error condition, an end-of-file condition, or an end-of-record condition occurs. On output, the
<P>
  specified expression is evaluated.
<P>
</PRE>
2 During input from a Unicode file,
</TD></TR>
<TR><TD colspan=2>
<PRE>
       • characters in the record that correspond to an ASCII character variable shall have a position in the ISO
<P>
         10646 character collating sequence of 127 or less, and
<P>
       • characters in the record that correspond to a default character variable shall be representable as default
<P>
         characters.
<P>
</PRE>
3 During input from a non-Unicode file,
</TD></TR>
<TR><TD colspan=2>
<PRE>
       • characters in the record that correspond to a character variable shall have the kind of the character variable,
<P>
         and
<P>
       • characters in the record that correspond to a numeric or logical variable shall be default characters.
<P>
</PRE>
4 During output to a Unicode file, all characters transmitted to the record are of ISO 10646 character kind. If a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  character input/output list item or character string edit descriptor contains a character that is not representable
<P>
  as an ISO 10646 character, the result is processor dependent.
<P>
</PRE>
5 During output to a non-Unicode file, characters transmitted to the record as a result of processing a character
</TD></TR>
<TR><TD colspan=2>
<PRE>
  string edit descriptor or as a result of evaluating a numeric, logical, or default character data entity, are of default
<P>
  kind.
<P>
  270                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
  13.7.2      Numeric editing
<P>
  13.7.2.1    General rules
<P>
</PRE>
1 The I, B, O, Z, F, E, EN, ES, EX, D, and G edit descriptors may be used to specify the input/output of integer,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  real, and complex data. The following general rules apply.
<P>
          (1)   On input, leading blanks are not significant. When the input field is not an IEEE exceptional
<P>
                specification or hexadecimal-significand number (13.7.2.3.2), the interpretation of blanks, other than
<P>
                leading blanks, is determined by the blank interpretation mode (13.8.6). Plus signs may be omitted.
<P>
                A field containing only blanks is considered to be zero.
<P>
          (2)   On input, with F, E, EN, ES, EX, D, and G editing, a decimal symbol appearing in the input field
<P>
                overrides the portion of an edit descriptor that specifies the decimal symbol location. The input field
<P>
                may have more digits than the processor uses to approximate the value of the datum.
<P>
          (3)   On output with I, F, E, EN, ES, EX, D, and G editing, the representation of a positive or zero
<P>
                internal value in the field may be prefixed with a plus sign, as controlled by the S, SP, and SS edit
<P>
                descriptors or the processor. The representation of a negative internal value in the field shall be
<P>
                prefixed with a minus sign.
<P>
          (4)   On output, the representation is right justified in the field. If the number of characters produced by
<P>
                the editing is smaller than the field width, leading blanks are inserted in the field.
<P>
          (5)   On output, if an exponent exceeds its specified or implied width using the E, EN, ES, EX, D, or G
<P>
                edit descriptor, or the number of characters produced exceeds the field width, the processor shall fill
<P>
                the entire field of width w with asterisks. However, the processor shall not produce asterisks if the
<P>
                field width is not exceeded when optional characters are omitted.
<P>
        NOTE 13.8
<P>
        When the sign mode is PLUS, a plus sign is not optional.
<P>
          (6)   On output, with I, B, O, Z, D, E, EN, ES, EX, F, and G editing, the specified value of the field width
<P>
                w may be zero. In such cases, the processor selects the smallest positive actual field width that does
<P>
                not result in a field filled with asterisks. The specified value of w shall not be zero on input.
<P>
          (7)   On output of a real zero value, the digits in the exponent field shall all be zero.
<P>
  13.7.2.2    Integer editing
<P>
</PRE>
1 The Iw and Iw.m edit descriptors indicate that the field to be edited occupies w positions, except when w is zero.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  When w is zero, the processor selects the field width. On input, w shall not be zero. The specified input/output
<P>
  list item shall be of type integer. The G, B, O, and Z edit descriptor also may be used to edit integer data
<P>
  (13.7.5.2.1, 13.7.2.4).
<P>
</PRE>
2 On input, m has no effect.
</TD></TR>
<TR><TD colspan=2>
3 In the standard form of the input field for the I edit descriptor, the character string is a signed-digit-string (R710),
</TD></TR>
<TR><TD colspan=2>
<PRE>
  except for the interpretation of blanks. If the input field does not have the standard form and is not acceptable
<P>
  to the processor, an error condition occurs.
<P>
</PRE>
4 The output field for the Iw edit descriptor consists of zero or more leading blanks followed by a minus sign if the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  internal value is negative, or an optional plus sign otherwise, followed by the magnitude of the internal value as
<P>
  a digit-string without leading zeros.
<P>
        NOTE 13.9
<P>
        A digit-string always consists of at least one digit.
<P>
</PRE>
5 The output field for the Iw.m edit descriptor is the same as for the Iw edit descriptor, except that the digit-string
</TD></TR>
<TR><TD colspan=2>
<PRE>
  consists of at least m digits. If necessary, sufficient leading zeros are included to achieve the minimum of m digits.
<P>
  The value of m shall not exceed the value of w, except when w is zero. If m is zero and the internal value is zero,
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              271
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  the output field consists of only blank characters, regardless of the sign control in effect. When m and w are both
<P>
  zero, and the internal value is zero, one blank character is produced.
<P>
  13.7.2.3     Real and complex editing
<P>
  13.7.2.3.1     General
<P>
</PRE>
1 The F, E, EN, ES, and D edit descriptors specify the editing of real and complex data. An input/output list
</TD></TR>
<TR><TD colspan=2>
<PRE>
  item corresponding to an F, E, EN, ES, or D edit descriptor shall be real or complex. The G, B, O, and Z edit
<P>
  descriptors also may be used to edit real and complex data (13.7.5.2.2, 13.7.2.4).
<P>
  13.7.2.3.2     F editing
<P>
</PRE>
1 The Fw.d edit descriptor indicates that the field occupies w positions, except when w is zero in which case the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  processor selects the field width. The fractional part of the field consists of d digits. On input, w shall not be
<P>
  zero.
<P>
</PRE>
2 A lower-case letter is equivalent to the corresponding upper-case letter in an IEEE exceptional specification or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the exponent in a numeric input field.
<P>
</PRE>
3 The standard form of the input field is an IEEE exceptional specification, a hexadecimal-significand number, or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  consists of a mantissa optionally followed by an exponent. The form of the mantissa is an optional sign, followed
<P>
  by a string of one or more digits optionally containing a decimal symbol, including any blanks interpreted as
<P>
  zeros. The d has no effect on input if the input field contains a decimal symbol. If the decimal symbol is omitted,
<P>
  the rightmost d digits of the string, with leading zeros assumed if necessary, are interpreted as the fractional part
<P>
  of the value represented. The string of digits may contain more digits than a processor uses to approximate the
<P>
  value. The form of the exponent is one of the following:
<P>
      • a sign followed by a digit-string;
<P>
      • the letter E followed by zero or more blanks, followed by a signed-digit-string;
<P>
      • the letter D followed by zero or more blanks, followed by a signed-digit-string.
<P>
</PRE>
4 An exponent containing a D is processed identically to an exponent containing an E.
</TD></TR>
<TR><TD colspan=2>
<PRE>
        NOTE 13.10
<P>
        If the input field does not contain an exponent, the effect is as if the basic form were followed by an exponent
<P>
        with a value of −k, where k is the established scale factor (13.8.5).
<P>
</PRE>
5 An input field that is an IEEE exceptional specification consists of optional blanks, followed by either
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • an optional sign, followed by the string ’INF’ or the string ’INFINITY’, or
<P>
      • an optional sign, followed by the string ’NAN’, optionally followed by zero or more alphanumeric characters
<P>
         enclosed in parentheses,
<P>
</PRE>
optionally followed by blanks.
</TD></TR>
<TR><TD colspan=2>
6 The value specified by ’INF’ or ’INFINITY’ is an IEEE infinity; this form shall not be used if the processor does
</TD></TR>
<TR><TD colspan=2>
<PRE>
  not support IEEE infinities for the input variable. The value specified by ’NAN’ is an IEEE NaN; this form shall
<P>
  not be used if the processor does not support IEEE NaNs for the input variable. The NaN value is a quiet NaN if
<P>
  the only nonblank characters in the field are ’NAN’ or ’NAN()’; otherwise, the NaN value is processor dependent.
<P>
  The interpretation of a sign in a NaN input field is processor dependent.
<P>
</PRE>
7 An input field that is a hexadecimal-significand number consists of an optional sign, followed by the hexadecimal
</TD></TR>
<TR><TD colspan=2>
<PRE>
  indicator which is the digit 0 immediately followed by the letter X, followed by a hexadecimal significand followed
<P>
  by a hexadecimal exponent. A hexadecimal significand is a string of one or more hexadecimal characters optionally
<P>
  containing a decimal symbol. The decimal symbol indicates the position of the hexadecimal point; if no decimal
<P>
  symbol appears, the hexadecimal point implicitly follows the last hexadecimal symbol. A hexadecimal exponent
<P>
  272                                                                   ⃝
<P>
                                                                        c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
<P>
   is the letter P followed by a (decimal) signed-digit-string. Embedded blanks are not permitted in a hexadecimal-
<P>
   significand number. The value is equal to the significand multiplied by two raised to the power of the exponent,
<P>
   negated if the optional sign is minus.
<P>
</PRE>
8 If the input field does not have one of the standard forms, and is not acceptable to the processor, an error
</TD></TR>
<TR><TD colspan=2>
<PRE>
   condition occurs.
<P>
</PRE>
9 For an internal value that is an IEEE infinity, the output field consists of blanks, if necessary, followed by a minus
</TD></TR>
<TR><TD colspan=2>
<PRE>
   sign for negative infinity or an optional plus sign otherwise, followed by the letters ’Inf’ or ’Infinity’, right justified
<P>
   within the field. The minimum field width required for output of the form ’Inf’ is 3 if no sign is produced, and
<P>
   4 otherwise. The minimum field width required for output of the form ’Infinity’ is 8 if no sign is produced, and
<P>
   9 otherwise. If w is greater than or equal to the minimum required for the form ’Infinity’, the form ’Infinity’ is
<P>
   output. If w is zero or w is less than the minimum required for the form ’Infinity’ and greater than or equal to
<P>
   the minimum required for the form ’Inf’, the form ’Inf’ is output. Otherwise (w is greater than zero but less than
<P>
   the minimum required for any form), the field is filled with asterisks.
<P>
</PRE>
10 For an internal value that is an IEEE NaN, the output field consists of blanks, if necessary, followed by the
</TD></TR>
<TR><TD colspan=2>
<PRE>
   letters ’NaN’ and optionally followed by one to w−5 alphanumeric processor-dependent characters enclosed in
<P>
   parentheses, right justified within the field. If w is greater than zero and less than 3, the field is filled with
<P>
   asterisks. If w is zero, the output field is ’NaN’.
<P>
         NOTE 13.11
<P>
         The processor-dependent characters following ’NaN’ might convey additional information about that par-
<P>
         ticular NaN.
<P>
</PRE>
11 For an internal value that is neither an IEEE infinity nor a NaN, the output field consists of blanks, if necessary,
</TD></TR>
<TR><TD colspan=2>
<PRE>
   followed by a minus sign if the internal value is negative, or an optional plus sign otherwise, followed by a string
<P>
   of digits that contains a decimal symbol and represents the magnitude of the internal value, as modified by the
<P>
   established scale factor and rounded (13.7.2.3.8) to d fractional digits. Leading zeros are not permitted except
<P>
   for an optional zero immediately to the left of the decimal symbol if the magnitude of the value in the output
<P>
   field is less than one. The optional zero shall appear if there would otherwise be no digits in the output field.
<P>
   13.7.2.3.3       E and D editing
<P>
</PRE>
1 The Ew.d, Dw.d, and Ew.d Ee edit descriptors indicate that the external field occupies w positions, except when
</TD></TR>
<TR><TD colspan=2>
<PRE>
   w is zero in which case the processor selects the field width. The fractional part of the field contains d digits,
<P>
   unless a scale factor greater than one is in effect. If e is positive the exponent part contains e digits, otherwise it
<P>
   contains the minimum number of digits required to represent the exponent value. The e has no effect on input.
<P>
</PRE>
2 The form and interpretation of the input field is the same as for Fw.d editing (13.7.2.3.2).
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for Fw.d.
<P>
4 For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field for a scale factor
<P>
<PRE>
   of zero is
<P>
        [ ± ] [0].x1 x2 . . . xd exp
<P>
   where:
<P>
       •  ± signifies a plus sign or a minus sign;
<P>
       •  . signifies a decimal symbol (13.6);
<P>
       •  x1 x2 . . . xd are the d most significant digits of the internal value after rounding (13.7.2.3.8);
<P>
       •  exp is a decimal exponent having one of the forms specified in table 13.1.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                                 273
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                                            Table 13.1: E and D exponent forms
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>Edit</B> </TD><TD valign=bottom>
Absolute Value            Form of
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Descriptor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
of Exponent            Exponent1
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                       Ew.d                |exp| ≤ 99         E±z1 z2 or ±0z1 z2
<P>
                                                       99 &lt; |exp| ≤ 999           ±z1 z2 z3
<P>
                                                                   e
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Ew.d Ee with e &gt; 0</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
|exp| ≤ 10 − 1          E±z1 z2 . . . ze
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                      Ew.d E0                 any               E±z1 z2 . . . zs
<P>
                                       Dw.d                |exp| ≤ 99         D±z1 z2 or E±z1 z2
<P>
                                                                                 or ±0z1 z2
<P>
                                                       99 &lt; |exp| ≤ 999           ±z1 z2 z3
<P>
</PRE>
(1) where each z is a digit, and s is the minimum number of digits
<P>
required to represent the exponent.
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
5 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
</TD></TR>
<TR><TD colspan=2>
6 The scale factor k controls the decimal normalization (13.3.2, 13.8.5). If −d &lt; k ≤ 0, the output field contains
</TD></TR>
<TR><TD colspan=2>
<PRE>
  exactly |k| leading zeros and d − |k| significant digits after the decimal symbol. If 0 &lt; k &lt; d + 2, the output field
<P>
  contains exactly k significant digits to the left of the decimal symbol and d − k + 1 significant digits to the right
<P>
  of the decimal symbol. Other values of k are not permitted.
<P>
  13.7.2.3.4      EN editing
<P>
</PRE>
1 The EN edit descriptor produces an output field in the form of a real number in engineering notation such that
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the decimal exponent is divisible by three and the absolute value of the significand (R715) is greater than or
<P>
  equal to 1 and less than 1000, except when the output value is zero. The scale factor has no effect on output.
<P>
</PRE>
2 The forms of the edit descriptor are ENw.d and ENw.d Ee indicating that the external field occupies w positions,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  except when w is zero in which case the processor selects the field width. The fractional part of the field contains
<P>
  d digits. If e is positive the exponent part contains e digits, otherwise it contains the minimum number of digits
<P>
  required to represent the exponent value.
<P>
</PRE>
3 The form and interpretation of the input field is the same as for Fw.d editing (13.7.2.3.2).
</TD></TR>
<TR><TD colspan=2>
4 For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for Fw.d.
</TD></TR>
<TR><TD colspan=2>
5 For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field is
</TD></TR>
<TR><TD colspan=2>
<PRE>
       [ ± ] yyy . x1 x2 . . . xd exp
<P>
</PRE>
where:
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • ± signifies a plus sign or a minus sign;
<P>
      • yyy are the 1 to 3 decimal digits representative of the most significant digits of the internal value after
<P>
         rounding (13.7.2.3.8);
<P>
      • yyy is an integer such that 1 ≤ yyy &lt; 1000 or, if the output value is zero, yyy = 0;
<P>
      • . signifies a decimal symbol (13.6);
<P>
      • x1 x2 . . . xd are the d next most significant digits of the internal value after rounding;
<P>
      • exp is a decimal exponent, divisible by three, having one of the forms specified in table 13.2.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>274</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
Table 13.2: EN exponent forms
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: Table 13.2: EN exponent forms
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>Edit</B> </TD><TD valign=bottom>
Absolute Value           Form of
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Descriptor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
of Exponent           Exponent1
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                      ENw.d                   |exp| ≤ 99      E±z1 z2 or ±0z1 z2
<P>
                                                         99 &lt; |exp| ≤ 999          ±z1 z2 z3
<P>
                                                                      e
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>ENw.d Ee with e &gt; 0</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
|exp| ≤ 10 − 1        E±z1 z2 . . . ze
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                     ENw.d E0                    any            E±z1 z2 . . . zs
<P>
</PRE>
(1) where each z is a digit, and s is the minimum number of digits
<P>
required to represent the exponent.
</TD></TR>
<TR><TD colspan=2>
6 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 13.12
<P>
       Examples:
<P>
                   Internal Value                    Output field using SS, EN12.3
<P>
                        6.421                            6.421E+00
<P>
                        -.5                          -500.000E-03
<P>
                        .00217                           2.170E-03
<P>
                   4721.3                                4.721E+03
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13.7.2.3.5</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ES editing
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The ES edit descriptor produces an output field in the form of a real number in scientific notation such that the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  absolute value of the significand (R715) is greater than or equal to 1 and less than 10, except when the output
<P>
  value is zero. The scale factor has no effect on output.
<P>
</PRE>
2 The forms of the edit descriptor are ESw.d and ESw.d Ee indicating that the external field occupies w positions,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  except when w is zero in which case the processor selects the field width. The fractional part of the field contains
<P>
  d digits. If e is positive the exponent part contains e digits, otherwise it contains the minimum number of digits
<P>
  required to represent the exponent value.
<P>
</PRE>
3 The form and interpretation of the input field is the same as for Fw.d editing (13.7.2.3.2).
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
4 For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for Fw.d.
<P>
5 For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field is
<P>
<PRE>
      [ ± ] y . x1 x2 . . . xd exp
<P>
</PRE>
where:
<P>
<PRE>
     •  ± signifies a plus sign or a minus sign;
<P>
     •  y is a decimal digit representative of the most significant digit of the internal value after rounding (13.7.2.3.8);
<P>
     •  . signifies a decimal symbol (13.6);
<P>
     •  x1 x2 . . . xd are the d next most significant digits of the internal value after rounding;
<P>
     •  exp is a decimal exponent having one of the forms specified in table 13.3.
<P>
                                               Table 13.3: ES exponent forms
<P>
                                       Edit              Absolute Value            Form of
<P>
                                    Descriptor             of Exponent            Exponent1
<P>
                                      ESw.d                  |exp| ≤ 99       E±z1 z2 or ±0z1 z2
<P>
                                                        99 &lt; |exp| ≤ 999           ±z1 z2 z3
<P>
                               ESw.d Ee with e &gt; 0       |exp| ≤ 10e − 1        E±z1 z2 . . . ze
<P>
                                     ESw.d E0                    any            E±z1 z2 . . . zs
<P>
                               (1) where each z is a digit, and s is the minimum number of digits
<P>
                               required to represent the exponent.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
275
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD colspan=2>
6 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
</TD></TR>
<TR><TD colspan=2>
<PRE>
        NOTE 13.13
<P>
        Examples:
<P>
                    Internal Value                    Output field Using SS, ES12.3
<P>
                       6.421                              6.421E+00
<P>
                         -.5                             -5.000E-01
<P>
                          .00217                          2.170E-03
<P>
                    4721.3                                4.721E+03
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13.7.2.3.6</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EX editing
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The EX edit descriptor produces an output field in the form of a hexadecimal-significand number.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 The EXw.d and EXw.dEe edit descriptors indicate that the external field occupies w positions, except when w
<P>
<PRE>
  is zero in which case the processor selects the field width. The fractional part of the field contains d hexadecimal
<P>
  digits, except when d is zero in which case the processor selects the number of hexadecimal digits to be the
<P>
  minimum required so that the output field is equal to the internal value; d shall not be zero if the radix of the
<P>
  internal value is not a power of two. The hexadecimal point, represented by a decimal symbol, appears after
<P>
  the first hexadecimal digit. For the form EXw.d, and for EXw.dE0, the exponent part contains the minimum
<P>
  number of digits needed to represent the exponent; otherwise the exponent contains e digits. The e has no effect
<P>
  on input. The scale factor has no effect on output.
<P>
</PRE>
3 The form and interpretation of the input field is the same as for Fw.d editing (13.7.2.3.2).
<P>
4 For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for Fw.d.
<P>
5 For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field is
<P>
<PRE>
       [ ± ] 0X x0 . x1 x2 . . . exp
<P>
</PRE>
where:
<P>
<PRE>
      • ± signifies a plus sign or a minus sign;
<P>
      • . signifies a decimal symbol (13.6);
<P>
      • x0 x1 x2 . . . are the most significant hexadecimal digits of the internal value, after rounding if d is not zero
<P>
         (13.7.2.3.8);
<P>
      • exp is a binary exponent expressed as a decimal integer; for EXw.d and EXw.dE0, the form is P ±z1 . . . zn ,
<P>
         where n is the minimum number of digits needed to represent exp, and for EXw.dEe with e greater than
<P>
         zero the form is P ±z1 . . . ze . The choice of binary exponent is processor dependent. If the most significant
<P>
         binary digits of the internal value are b0 b1 b2 . . ., the binary exponent might make the value of x0 be that of
<P>
         b0 , b0 b1 , b0 b1 b2 , or b0 b1 b2 b3 .
<P>
</PRE>
6 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
<P>
<PRE>
        NOTE 13.14
<P>
        Examples:
<P>
          Internal value          Edit descriptor Possible output with SS in effect
<P>
                1.375               EX0.1               0X1.6P+0
<P>
              −15.625               EX14.4E3            -0X1.F400P+003
<P>
             1048580.0              EX0.0               0X1.00004P+20
<P>
                2.375               EX0.1                      0X2.6P+0
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13.7.2.3.7</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Complex editing
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 A complex datum consists of a pair of separate real data. The editing of a scalar datum of complex type is
<P>
<PRE>
  specified by two edit descriptors each of which specifies the editing of real data. The first edit descriptor specifies
<P>
  276                                                                      ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  the editing for the real part; the second specifies it for the imaginary part. The two edit descriptors may be
<P>
  different. Control and character string edit descriptors may be processed between the edit descriptor for the real
<P>
  part and the edit descriptor for the imaginary part.
<P>
  13.7.2.3.8     Input/output rounding mode
<P>
</PRE>
1 The input/output rounding mode can be specified by an OPEN statement (12.5.2), a data transfer statement
<P>
<PRE>
  (12.6.2.13), or an edit descriptor (13.8.7).
<P>
</PRE>
2 In what follows, the term “decimal value” means the exact decimal number as given by the character string, while
<P>
<PRE>
  the term “internal value” means the number actually stored in the processor. For example, in dealing with the
<P>
  decimal constant 0.1, the decimal value is the mathematical quantity 1/10, which has no exact representation
<P>
  in binary form. Formatted output of real data involves conversion from an internal value to a decimal value;
<P>
  formatted input involves conversion from a decimal value to an internal value.
<P>
</PRE>
3 When the input/output rounding mode is UP, the value resulting from conversion shall be the smallest represent-
<P>
<PRE>
  able value that is greater than or equal to the original value. When the input/output rounding mode is DOWN,
<P>
  the value resulting from conversion shall be the largest representable value that is less than or equal to the original
<P>
  value. When the input/output rounding mode is ZERO, the value resulting from conversion shall be the value
<P>
  closest to the original value and no greater in magnitude than the original value. When the input/output rounding
<P>
  mode is NEAREST, the value resulting from conversion shall be the closer of the two nearest representable values
<P>
  if one is closer than the other. If the two nearest representable values are equidistant from the original value, it is
<P>
  processor dependent which one of them is chosen. When the input/output rounding mode is COMPATIBLE, the
<P>
  value resulting from conversion shall be the closer of the two nearest representable values or the value away from
<P>
  zero if halfway between them. When the input/output rounding mode is PROCESSOR_DEFINED, rounding
<P>
  during conversion shall be a processor-dependent default mode, which may correspond to one of the other modes.
<P>
</PRE>
4 On processors that support IEEE rounding on conversions (17.4), NEAREST shall correspond to round to nearest,
<P>
<PRE>
  as specified in ISO/IEC/IEEE 60559:2011.
<P>
        NOTE 13.15
<P>
        On processors that support IEEE rounding on conversions, the input/output rounding modes COMPAT-
<P>
        IBLE and NEAREST will produce the same results except when the datum is halfway between the two
<P>
        representable values. In that case, NEAREST will pick the even value, but COMPATIBLE will pick the
<P>
        value away from zero. The input/output rounding modes UP, DOWN, and ZERO have the same effect as
<P>
        those specified in ISO/IEC/IEEE 60559:2011 for round toward +∞, round toward −∞, and round toward
<P>
        0, respectively.
<P>
  13.7.2.4     B, O, and Z editing
<P>
</PRE>
1 The Bw, Bw.m, Ow, Ow.m, Zw, and Zw.m edit descriptors indicate that the field to be edited occupies w
<P>
<PRE>
  positions, except when w is zero. When w is zero, the processor selects the field width. On input, w shall not be
<P>
  zero. The corresponding input/output list item shall be of type integer, real, or complex.
<P>
</PRE>
2 On input, m has no effect.
<P>
3 In the standard form of the input field for the B, O, and Z edit descriptors the character string consists of binary,
<P>
<PRE>
  octal, or hexadecimal digits (as in R765, R766, R767) in the respective input field. The lower-case hexadecimal
<P>
  digits a through f in a hexadecimal input field are equivalent to the corresponding upper-case hexadecimal digits.
<P>
  If the input field does not have the standard form, and is not acceptable to the processor, an error condition
<P>
  occurs.
<P>
</PRE>
4 The value is INT (X) if the input list item is of type integer and REAL (X) if the input list item is of type real
<P>
<PRE>
  or complex, where X is a boz-literal-constant that specifies the same bit sequence as the digits of the input field.
<P>
</PRE>
5 The output field for the Bw, Ow, and Zw descriptors consists of zero or more leading blanks followed by the
<P>
<PRE>
  internal value in a form identical to the digits of a binary, octal, or hexadecimal constant, respectively, that
<P>
  specifies the same bit sequence but without leading zero bits.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             277
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
         NOTE 13.16
<P>
         A binary, octal, or hexadecimal constant always consists of at least one digit or hexadecimal digit.
<P>
  R1322 hex-digit-string                   is  hex-digit [ hex-digit ] &#46;&#46;&#46;
<P>
</PRE>
6 The output field for the Bw.m, Ow.m, and Zw.m edit descriptor is the same as for the Bw, Ow, and Zw edit
<P>
<PRE>
  descriptor, except that the digit-string or hex-digit-string consists of at least m digits. If necessary, sufficient
<P>
  leading zeros are included to achieve the minimum of m digits. The value of m shall not exceed the value of w,
<P>
  except when w is zero. If m is zero and the internal value consists of all zero bits, the output field consists of
<P>
  only blank characters. When m and w are both zero, and the internal value consists of all zero bits, one blank
<P>
  character is produced.
<P>
  13.7.3      Logical editing
<P>
</PRE>
1 The Lw edit descriptor indicates that the field occupies w positions. The specified input/output list item shall
<P>
<PRE>
  be of type logical. The G edit descriptor also may be used to edit logical data (13.7.5.3).
<P>
</PRE>
2 The standard form of the input field consists of optional blanks, optionally followed by a period, followed by a T
<P>
<PRE>
  for true or F for false. The T or F may be followed by additional characters in the field, which are ignored. If the
<P>
  input field does not have the standard form, and is not acceptable to the processor, an error condition occurs.
<P>
</PRE>
3 A lower-case letter is equivalent to the corresponding upper-case letter in a logical input field.
<P>
<PRE>
         NOTE 13.17
<P>
         The logical constants .TRUE. and .FALSE. are acceptable input forms.
<P>
</PRE>
4 The output field consists of w−1 blanks followed by a T or F, depending on whether the internal value is true or
<P>
<PRE>
  false, respectively.
<P>
  13.7.4      Character editing
<P>
</PRE>
1 The A[w] edit descriptor is used with an input/output list item of type character. The G edit descriptor also may
<P>
<PRE>
  be used to edit character data (13.7.5.4). The kind type parameter of all characters transferred and converted
<P>
  under control of one A or G edit descriptor is implied by the kind of the corresponding list item.
<P>
</PRE>
2 If a field width w is specified with the A edit descriptor, the field consists of w characters. If a field width w is
<P>
<PRE>
  not specified with the A edit descriptor, the number of characters in the field is the length of the corresponding
<P>
  list item, regardless of the value of the kind type parameter.
<P>
</PRE>
3 Let len be the length of the input/output list item. If the specified field width w for an A edit descriptor
<P>
<PRE>
  corresponding to an input item is greater than or equal to len, the rightmost len characters will be taken from the
<P>
  input field. If the specified field width w is less than len, the w characters will appear left justified with len−w
<P>
  trailing blanks in the internal value.
<P>
</PRE>
4 If the specified field width w for an A edit descriptor corresponding to an output item is greater than len, the
<P>
<PRE>
  output field will consist of w−len blanks followed by the len characters from the internal value. If the specified
<P>
  field width w is less than or equal to len, the output field will consist of the leftmost w characters from the internal
<P>
  value.
<P>
         NOTE 13.18
<P>
         For nondefault character kinds, the blank padding character is processor dependent.
<P>
</PRE>
5 If the file is connected for stream access, the output may be split across more than one record if it contains
<P>
<PRE>
  newline characters. A newline character is a nonblank character returned by the intrinsic function NEW_LINE.
<P>
  Beginning with the first character of the output field, each character that is not a newline is written to the current
<P>
  record in successive positions; each newline character causes file positioning at that point as if by slash editing
<P>
  278                                                                    ⃝ c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  (the current record is terminated at that point, a new empty record is created following the current record, this
<P>
  new record becomes the last and current record of the file, and the file is positioned at the beginning of this new
<P>
  record).
<P>
        NOTE 13.19
<P>
        If the intrinsic function NEW_LINE returns a blank character for a particular character kind, then the
<P>
        processor does not support using a character of that kind to cause record termination in a formatted stream
<P>
        file.
<P>
  13.7.5      Generalized editing
<P>
  13.7.5.1    Overview
<P>
</PRE>
1 The Gw, Gw.d and Gw.d Ee edit descriptors are used with an input/output list item of any intrinsic type. When
<P>
<PRE>
  w is nonzero, these edit descriptors indicate that the external field occupies w positions. For real or complex
<P>
  data the fractional part consists of a maximum of d digits and the exponent part consists of e digits. When these
<P>
  edit descriptors are used to specify the input/output of integer, logical, or character data, d and e have no effect.
<P>
  When w is zero the processor selects the field width. On input, w shall not be zero.
<P>
  13.7.5.2    Generalized numeric editing
<P>
</PRE>
1 When used to specify the input/output of integer, real, and complex data, the Gw, Gw.d and Gw.d Ee edit
<P>
<PRE>
  descriptors follow the general rules for numeric editing (13.7.2).
<P>
        NOTE 13.20
<P>
        The Gw.d Ee edit descriptor follows any additional rules for the Ew.d Ee edit descriptor.
<P>
  13.7.5.2.1     Generalized integer editing
<P>
</PRE>
1 When used to specify the input/output of integer data, the Gw, Gw.d, and Gw.d Ee edit descriptors follow the
<P>
<PRE>
  rules for the Iw edit descriptor (13.7.2.2). Note that w cannot be zero for input editing (13.7.5.1).
<P>
  13.7.5.2.2     Generalized real and complex editing
<P>
</PRE>
1 The form and interpretation of the input field for Gw.d and Gw.d Ee editing is the same as for Fw.d editing
<P>
<PRE>
  (13.7.2.3.2). The rest of this subclause applies only to output editing.
<P>
</PRE>
2 If w is nonzero and d is zero, kPEw.0 or kPEw.0Ee editing is used for Gw.0 editing or Gw.0Ee editing respectively.
<P>
3 When used to specify the output of real or complex data that is not an IEEE infinity or NaN, the G0 and G0.d
<P>
<PRE>
  edit descriptors follow the rules for the Gw.dEe edit descriptor, except that any leading or trailing blanks are
<P>
  removed. Reasonable processor-dependent values of w, d (if not specified), and e are used with each output value.
<P>
</PRE>
4 For an internal value that is an IEEE infinity or NaN, the form of the output field for the Gw.d and Gw.d Ee
<P>
<PRE>
  edit descriptors is the same as for Fw.d, and the form of the output field for the G0 and G0.d edit descriptors is
<P>
  the same as for F0.0.
<P>
</PRE>
5 Otherwise, the method of representation in the output field depends on the magnitude of the internal value
<P>
<PRE>
  being edited. If the internal value is zero, let s be one. If the internal value is a number other than zero, let N
<P>
  be the decimal value that is the result of converting the internal value to d significant digits according to the
<P>
  input/output rounding mode and let s be the integer such that 10s−1 ≤ |N | &lt; 10s . If s &lt; 0 or s &gt; d, kPEw.d or
<P>
  kPEw.dEe editing is used for Gw.d editing or Gw.dEe editing respectively, where k is the scale factor (13.8.5).
<P>
  If 0 ≤ s ≤ d, the scale factor has no effect and F(w − n).(d − s),n(’b’) editing is used where b is a blank and n is
<P>
  4 for Gw.d editing, e + 2 for Gw.dEe editing if e &gt; 0, and 4 for Gw.dE0 editing.
<P>
</PRE>
6 The value of w−n shall be positive.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           279
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 13.21
<P>
       The scale factor has no effect on output unless the magnitude of the datum to be edited is outside the range
<P>
       that permits effective use of F editing.
<P>
  13.7.5.3     Generalized logical editing
<P>
</PRE>
1 When used to specify the input/output of logical data, the Gw.d and Gw.d Ee edit descriptors with nonzero w
<P>
<PRE>
  follow the rules for the Lw edit descriptor (13.7.3). When used to specify the output of logical data, the G0 and
<P>
  G0.d edit descriptors follow the rules for the L1 edit descriptor.
<P>
  13.7.5.4     Generalized character editing
<P>
</PRE>
1 When used to specify the input/output of character data, the Gw.d and Gw.d Ee edit descriptors with nonzero
<P>
<PRE>
  w follow the rules for the Aw edit descriptor (13.7.4). When used to specify the output of character data, the G0
<P>
  and G0.d edit descriptors follow the rules for the A edit descriptor with no field width.
<P>
  13.7.6       User-defined derived-type editing
<P>
</PRE>
1 The DT edit descriptor specifies that a user-provided procedure shall be used instead of the processor’s default
<P>
<PRE>
  input/output formatting for processing a list item of derived type.
<P>
</PRE>
2 The DT edit descriptor may include a character literal constant. The character value “DT” concatenated with the
<P>
<PRE>
  character literal constant is passed to the defined input/output procedure as the iotype argument (12.6.4.8). The
<P>
  v values of the edit descriptor are passed to the defined input/output procedure as the v_list array argument.
<P>
        NOTE 13.22
<P>
       For the edit descriptor DT’Link List’(10, 4, 2), iotype is "DTLink List" and v_list is [10, 4, 2].
<P>
</PRE>
3 If a derived-type variable or value corresponds to a DT edit descriptor, there shall be an accessible interface to
<P>
<PRE>
  a corresponding defined input/output procedure for that derived type (12.6.4.8). A DT edit descriptor shall not
<P>
  correspond to a list item that is not of a derived type.
<P>
  13.8        Control edit descriptors
<P>
  13.8.1       Position edit descriptors
<P>
  13.8.1.1     Position editing
<P>
</PRE>
1 The position edit descriptors T, TL, TR, and X, specify the position at which the next character will be transmit-
<P>
<PRE>
  ted to or from the record. If any character skipped by a position edit descriptor is of type nondefault character,
<P>
  and the unit is a default character internal file or an external non-Unicode file, the result of that position editing
<P>
  is processor dependent.
<P>
</PRE>
2 On input, if the position specified by a position edit descriptor is before the current position, portions of a record
<P>
<PRE>
  can be processed more than once, possibly with different editing.
<P>
</PRE>
3 On input, a position beyond the last character of the record may be specified if no characters are transmitted
<P>
<PRE>
  from such positions.
<P>
</PRE>
4 On output, a position edit descriptor does not by itself cause characters to be transmitted and therefore does not
<P>
<PRE>
  by itself affect the length of the record. If characters are transmitted to positions at or after the position specified
<P>
  by a position edit descriptor, positions skipped and not previously filled are filled with blanks. The result is as if
<P>
  the entire record were initially filled with blanks.
<P>
</PRE>
5 On output, a character in the record can be replaced. A position edit descriptor never directly causes a character
<P>
<PRE>
  280                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  already placed in the record to be replaced, but it might result in positioning such that subsequent editing causes
<P>
  a replacement.
<P>
  13.8.1.2    T, TL, and TR editing
<P>
</PRE>
1 The left tab limit affects file positioning by the T and TL edit descriptors. Immediately prior to nonchild data
<P>
<PRE>
  transfer (12.6.4.8.3), the left tab limit becomes defined as the character position of the current record or the
<P>
  current position of the stream file. If, during data transfer, the file is positioned to another record, the left tab
<P>
  limit becomes defined as character position one of that record.
<P>
</PRE>
2 The Tn edit descriptor indicates that the transmission of the next character to or from a record is to occur at
<P>
<PRE>
  the nth character position of the record, relative to the left tab limit. This position can be in either direction
<P>
  from the current position.
<P>
</PRE>
3 The TLn edit descriptor indicates that the transmission of the next character to or from the record is to occur at
<P>
<PRE>
  the character position n characters backward from the current position. However, if n is greater than the difference
<P>
  between the current position and the left tab limit, the TLn edit descriptor indicates that the transmission of
<P>
  the next character to or from the record is to occur at the left tab limit.
<P>
</PRE>
4 The TRn edit descriptor indicates that the transmission of the next character to or from the record is to occur
<P>
<PRE>
  at the character position n characters forward from the current position.
<P>
  13.8.1.3    X editing
<P>
</PRE>
1 The nX edit descriptor indicates that the transmission of the next character to or from a record is to occur at
<P>
<PRE>
  the character position n characters forward from the current position.
<P>
       NOTE 13.23
<P>
       An nX edit descriptor has the same effect as a TRn edit descriptor.
<P>
  13.8.2     Slash editing
<P>
</PRE>
1 The slash edit descriptor indicates the end of data transfer to or from the current record.
<P>
2 On input from a file connected for sequential or stream access, the remaining portion of the current record is
<P>
<PRE>
  skipped and the file is positioned at the beginning of the next record. This record becomes the current record.
<P>
  On output to a file connected for sequential or stream access, a new empty record is created following the current
<P>
  record; this new record then becomes the last and current record of the file and the file is positioned at the
<P>
  beginning of this new record.
<P>
</PRE>
3 For a file connected for direct access, the record number is increased by one and the file is positioned at the
<P>
<PRE>
  beginning of the record that has that record number, if there is such a record, and this record becomes the
<P>
  current record.
<P>
       NOTE 13.24
<P>
       A record that contains no characters can be written on output. If the file is an internal file or a file connected
<P>
       for direct access, the record is filled with blank characters.
<P>
       An entire record can be skipped on input.
<P>
</PRE>
4 The repeat specification is optional in the slash edit descriptor. If it is not specified, the default value is one.
<P>
<PRE>
  13.8.3     Colon editing
<P>
</PRE>
1 The colon edit descriptor terminates format control if there are no more effective items in the input/output list
<P>
<PRE>
  (12.6.3). The colon edit descriptor has no effect if there are more effective items in the input/output list.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               281
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  13.8.4      SS, SP, and S editing
<P>
</PRE>
1 The SS, SP, and S edit descriptors temporarily change (12.5.2) the sign mode (12.5.6.17, 12.6.2.14) for the
<P>
<PRE>
  connection. The edit descriptors SS, SP, and S set the sign mode corresponding to the SIGN= specifier values
<P>
  SUPPRESS, PLUS, and PROCESSOR_DEFINED, respectively.
<P>
</PRE>
2 The sign mode controls optional plus characters in numeric output fields. When the sign mode is PLUS, the
<P>
<PRE>
  processor shall produce a plus sign in any position that normally contains an optional plus sign. When the
<P>
  sign mode is SUPPRESS, the processor shall not produce a plus sign in such positions. When the sign mode is
<P>
  PROCESSOR_DEFINED, the processor has the option of producing a plus sign or not in such positions, subject
<P>
  to 13.7.2(5).
<P>
</PRE>
3 The SS, SP, and S edit descriptors affect only I, F, E, EN, ES, D, and G editing during the execution of an output
<P>
<PRE>
  statement. The SS, SP, and S edit descriptors have no effect during the execution of an input statement.
<P>
  13.8.5      P editing
<P>
</PRE>
1 The kP edit descriptor temporarily changes (12.5.2) the scale factor for the connection to k. The scale factor
<P>
<PRE>
  affects the editing done by the F, E, EN, ES, EX, D, and G edit descriptors for real and complex quantities.
<P>
</PRE>
2 The scale factor k affects the appropriate editing in the following manner.
<P>
<PRE>
      • On input, with F, E, EN, ES, EX, D, and G editing (provided that no exponent exists in the field), the
<P>
        effect is that the externally represented number equals the internally represented number multiplied by 10k ;
<P>
        the scale factor is applied to the external decimal value and then this is converted using the input/output
<P>
        rounding mode.
<P>
      • On input, with F, E, EN, ES, EX, D, and G editing, the scale factor has no effect if there is an exponent
<P>
        in the field.
<P>
      • On output, with F output editing, the effect is that the externally represented number equals the internally
<P>
        represented number multiplied by 10k ; the internal value is converted using the input/output rounding
<P>
        mode and then the scale factor is applied to the converted decimal value.
<P>
      • On output, with E and D editing, the effect is that the significand (R715) part of the quantity to be
<P>
        produced is multiplied by 10k and the exponent is reduced by k.
<P>
      • On output, with G editing, the effect is suspended unless the magnitude of the datum to be edited is outside
<P>
        the range that permits the use of F editing. If the use of E editing is required, the scale factor has the same
<P>
        effect as with E output editing.
<P>
      • On output, with EN, ES, and EX editing, the scale factor has no effect.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>13.8.6</B> </TD><TD valign=bottom>
BN and BZ editing
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 The BN and BZ edit descriptors temporarily change (12.5.2) the blank interpretation mode (12.5.6.6, 12.6.2.6)
<P>
<PRE>
  for the connection. The edit descriptors BN and BZ set the blank interpretation mode corresponding to the
<P>
  BLANK= specifier values NULL and ZERO, respectively.
<P>
</PRE>
2 The blank interpretation mode controls the interpretation of nonleading blanks in numeric input fields. Such
<P>
<PRE>
  blank characters are interpreted as zeros when the blank interpretation mode has the value ZERO; they are
<P>
  ignored when the blank interpretation mode has the value NULL. The effect of ignoring blanks is to treat the
<P>
  input field as if blanks had been removed, the remaining portion of the field right justified, and the blanks replaced
<P>
  as leading blanks. However, a field containing only blanks has the value zero.
<P>
</PRE>
3 The blank interpretation mode affects only numeric editing (13.7.2) and generalized numeric editing (13.7.5.2)
<P>
<PRE>
  on input. It has no effect on output.
<P>
  13.8.7      RU, RD, RZ, RN, RC, and RP editing
<P>
</PRE>
1 The round edit descriptors temporarily change (12.5.2) the connection’s input/output rounding mode (12.5.6.16,
<P>
<PRE>
  12.6.2.13, 13.7.2.3.8). The round edit descriptors RU, RD, RZ, RN, RC, and RP set the input/output rounding
<P>
  282                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  mode corresponding to the ROUND= specifier values UP, DOWN, ZERO, NEAREST, COMPATIBLE, and
<P>
  PROCESSOR_DEFINED, respectively. The input/output rounding mode affects the conversion of real and
<P>
  complex values in formatted input/output. It affects only D, E, EN, ES, F, and G editing.
<P>
  13.8.8      DC and DP editing
<P>
</PRE>
1 The decimal edit descriptors temporarily change (12.5.2) the decimal edit mode (12.5.6.7, 12.6.2.7, 13.6) for
<P>
<PRE>
  the connection. The edit descriptors DC and DP set the decimal edit mode corresponding to the DECIMAL=
<P>
  specifier values COMMA and POINT, respectively.
<P>
</PRE>
2 The decimal edit mode controls the representation of the decimal symbol (13.6) during conversion of real and
<P>
<PRE>
  complex values in formatted input/output. The decimal edit mode affects only D, E, EN, ES, F, and G editing.
<P>
  13.9       Character string edit descriptors
<P>
</PRE>
1 A character string edit descriptor shall not be used on input.
<P>
2 The character string edit descriptor causes characters to be written from the enclosed characters of the edit
<P>
<PRE>
  descriptor itself, including blanks. For a character string edit descriptor, the width of the field is the number of
<P>
  characters between the delimiting characters. Within the field, two consecutive delimiting characters are counted
<P>
  as a single character.
<P>
        NOTE 13.25
<P>
        A delimiter for a character string edit descriptor is either an apostrophe or quote.
<P>
  13.10        List-directed formatting
<P>
  13.10.1      Purpose of list-directed formatting
<P>
</PRE>
1 List-directed input/output allows data editing according to the type of the list item instead of by a format
<P>
<PRE>
  specification. It also allows data to be free-field, that is, separated by commas (or semicolons) or blanks.
<P>
  13.10.2      Values and value separators
<P>
</PRE>
1 The characters in one or more list-directed records constitute a sequence of values and value separators. The end
<P>
<PRE>
  of a record has the same effect as a blank character, unless it is within a character constant. Any sequence of two
<P>
  or more consecutive blanks is treated as a single blank, unless it is within a character constant.
<P>
</PRE>
2 Each value is either a null value, c, r*c, or r*, where c is a literal constant, optionally signed if integer or real,
<P>
<PRE>
  or an undelimited character constant and r is an unsigned, nonzero, integer literal constant. Neither c nor r
<P>
  shall have kind type parameters specified. The constant c is interpreted as though it had the same kind type
<P>
  parameter as the corresponding list item. The r*c form is equivalent to r successive appearances of the constant
<P>
  c, and the r* form is equivalent to r successive appearances of the null value. Neither of these forms may contain
<P>
  embedded blanks, except where permitted within the constant c.
<P>
</PRE>
3 A value separator is
<P>
<PRE>
      • a comma optionally preceded by one or more contiguous blanks and optionally followed by one or more
<P>
        contiguous blanks, unless the decimal edit mode is COMMA, in which case a semicolon is used in place of
<P>
        the comma,
<P>
      • a slash optionally preceded by one or more contiguous blanks and optionally followed by one or more
<P>
        contiguous blanks, or
<P>
      • one or more contiguous blanks between two nonblank values or following the last nonblank value, where a
<P>
        nonblank value is a constant, an r*c form, or an r* form.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
283
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
        NOTE 13.26
<P>
        Although a slash encountered in an input record is referred to as a separator, it actually causes termination
<P>
        of list-directed and namelist input statements; it does not actually separate two values.
<P>
        NOTE 13.27
<P>
        If no list items are specified in a list-directed input/output statement, one input record is skipped or one
<P>
        empty output record is written.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>13.10.3</B> </TD><TD valign=bottom>
List-directed input
</TD></TR>
<TR valign=top><TD colspan=2>
<B>13.10.3.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
List-directed input forms
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Input forms acceptable to edit descriptors for a given type are acceptable for list-directed formatting, except as
</TD></TR>
<TR><TD colspan=2>
<PRE>
  noted below. If the form of the input value is not acceptable to the processor for the type of the next effective
<P>
  item in the list, an error condition occurs. Blanks are never used as zeros, and embedded blanks are not permitted
<P>
  in constants, except within character constants and complex constants as specified below.
<P>
</PRE>
2 For the r*c form of an input value, the constant c is interpreted as an undelimited character constant if the first
</TD></TR>
<TR><TD colspan=2>
<PRE>
  list item corresponding to this value is default, ASCII, or ISO 10646 character, there is a nonblank character
<P>
  immediately after r*, and that character is not an apostrophe or a quotation mark; otherwise, c is interpreted as
<P>
  a literal constant.
<P>
        NOTE 13.28
<P>
        The end of a record has the effect of a blank, except when it appears within a character constant.
<P>
</PRE>
3 When the next effective item is of type integer, the value in the input record is interpreted as if an Iw edit
</TD></TR>
<TR><TD colspan=2>
<PRE>
  descriptor with a suitable value of w were used.
<P>
</PRE>
4 When the next effective item is of type real, the input form is that of a numeric input field. A numeric input field
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is a field suitable for F editing (13.7.2.3.2) that is assumed to have no fractional digits unless a decimal symbol
<P>
  appears within the field.
<P>
</PRE>
5 When the next effective item is of type complex, the input form consists of a left parenthesis followed by an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ordered pair of numeric input fields separated by a comma (if the decimal edit mode is POINT) or semicolon
<P>
  (if the decimal edit mode is COMMA), and followed by a right parenthesis. The first numeric input field is the
<P>
  real part of the complex constant and the second is the imaginary part. Each of the numeric input fields may be
<P>
  preceded or followed by any number of blanks and ends of records. The end of a record may occur after the real
<P>
  part or before the imaginary part.
<P>
</PRE>
6 When the next effective item is of type logical, the input form shall not include value separators among the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  optional characters permitted for L editing.
<P>
</PRE>
7 When the next effective item is of type character, the input form consists of a possibly delimited sequence of zero
</TD></TR>
<TR><TD colspan=2>
<PRE>
  or more rep-chars whose kind type parameter is implied by the kind of the effective item. Character sequences
<P>
  may be continued from the end of one record to the beginning of the next record, but the end of record shall
<P>
  not occur between a doubled apostrophe in an apostrophe-delimited character sequence, nor between a doubled
<P>
  quote in a quote-delimited character sequence. The end of the record does not cause a blank or any other
<P>
  character to become part of the character sequence. The character sequence may be continued on as many
<P>
  records as needed. The characters blank, comma, semicolon, and slash may appear in default, ASCII, or ISO
<P>
  10646 character sequences.
<P>
</PRE>
8 If the next effective item is default, ASCII, or ISO 10646 character and
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • the character sequence does not contain value separators,
<P>
      • the character sequence does not cross a record boundary,
<P>
      • the first nonblank character is not a quotation mark or an apostrophe,
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>284</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
• the leading characters are not digits followed by an asterisk, and
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
• the character sequence contains at least one character,
</TD></TR>
<TR><TD colspan=2>
the delimiting apostrophes or quotation marks are not required. If the delimiters are omitted, the character
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
sequence is terminated by the first blank, comma (if the decimal edit mode is POINT), semicolon (if the decimal
<P>
edit mode is COMMA), slash, or end of record; in this case apostrophes and quotation marks within the datum
<P>
are not to be doubled.
</TD></TR>
<TR><TD colspan=2>
9 Let len be the current length of the next effective item, and let w be the length of the character sequence. If len
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is less than or equal to w, the leftmost len characters of the sequence are transmitted to the next effective item.
<P>
  If len is greater than w, the sequence is transmitted to the leftmost w characters of the next effective item and
<P>
  the remaining len−w characters of the next effective item are filled with blanks.
<P>
        NOTE 13.29
<P>
        An allocatable, deferred-length character effective item does not have its allocation status or allocated
<P>
        length changed as a result of list-directed input.
<P>
  13.10.3.2     Null values
<P>
</PRE>
1 A null value is specified by
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • the r* form,
<P>
      • no characters between consecutive value separators, or
<P>
      • no characters before the first value separator in the first record read by each execution of a list-directed
<P>
         input statement.
<P>
        NOTE 13.30
<P>
        The end of a record following any other value separator, with or without separating blanks, does not specify
<P>
        a null value in list-directed input.
<P>
</PRE>
2 A null value has no effect on the definition status of the next effective item. A null value shall not be used for
</TD></TR>
<TR><TD colspan=2>
<PRE>
  either the real or imaginary part of a complex constant, but a single null value may represent an entire complex
<P>
  constant.
<P>
</PRE>
3 A slash encountered as a value separator during execution of a list-directed input statement causes termination
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of execution of that input statement after the transference of the previous value. Any characters remaining in the
<P>
  current record are ignored. If there are additional items in the input list, the effect is as if null values had been
<P>
  supplied for them. Any do-variable in the input list becomes defined as if enough null values had been supplied
<P>
  for any remaining input list items.
<P>
        NOTE 13.31
<P>
        All blanks encountered during list-directed input are considered to be part of some value separator except
<P>
        for
<P>
            • blanks embedded in a character sequence,
<P>
            • embedded blanks surrounding the real or imaginary part of a complex constant, and
<P>
            • leading blanks in the first record read by each execution of a list-directed input statement, unless
<P>
              immediately followed by a slash or comma.
<P>
        NOTE 13.32
<P>
        List-directed input example:
<P>
                 INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z; LOGICAL G
<P>
                 &#46;&#46;&#46;
<P>
                 READ *, I, X, P, Z, G
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            285
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 13.32 (cont.)
<P>
        The input data records are:
<P>
        12345,12345,,2*1.5,4*
<P>
        ISN’T_BOB’S,(123,0),.TEXAS$
<P>
        The results are:
<P>
                 Variable                       Value
<P>
                 I                              12345
<P>
                 X (1)                          12345.0
<P>
                 X (2)                          unchanged
<P>
                 X (3)                          1.5
<P>
                 X (4)                          1.5
<P>
                 X (5) – X (8)                  unchanged
<P>
                 P                              ISN’T_BOB’S
<P>
                 Z                              (123.0,0.0)
<P>
                 G                              true
<P>
  13.10.4       List-directed output
<P>
</PRE>
1 The form of the values produced is the same as that required for input, except as noted otherwise. With the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  exception of adjacent undelimited character sequences, the values are separated by one or more blanks or by a
<P>
  comma, or a semicolon if the decimal edit mode is COMMA, optionally preceded by one or more blanks and
<P>
  optionally followed by one or more blanks. Two undelimited character sequences are considered adjacent when
<P>
  both were written using list-directed input/output, no intervening data transfer or file positioning operations on
<P>
  that unit occurred, and both were written either by a single data transfer statement, or during the execution of
<P>
  a parent data transfer statement along with its child data transfer statements. The form of the values produced
<P>
  by defined output (12.6.4.8) is determined by the defined output procedure; this form need not be compatible
<P>
  with list-directed input.
<P>
</PRE>
2 The processor may begin new records as necessary, but the end of record shall not occur within a constant except
</TD></TR>
<TR><TD colspan=2>
<PRE>
  as specified for complex constants and character sequences. The processor shall not insert blanks within character
<P>
  sequences or within constants, except as specified for complex constants.
<P>
</PRE>
3 Logical output values are T for the value true and F for the value false.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
4 Integer output constants are produced with the effect of an Iw edit descriptor.
<P>
5 Real constants are produced with the effect of either an F edit descriptor or an E edit descriptor, depending on
<P>
<PRE>
  the magnitude x of the value and a range 10d1 ≤ x &lt; 10d2 , where d1 and d2 are processor-dependent integers. If
<P>
  the magnitude x is within this range or is zero, the constant is produced using 0PFw.d; otherwise, 1PEw.d Ee is
<P>
  used.
<P>
</PRE>
6 For numeric output, reasonable processor-dependent values of w, d, and e are used for each of the numeric
<P>
<PRE>
  constants output.
<P>
</PRE>
7 Complex constants are enclosed in parentheses with a separator between the real and imaginary parts, each
<P>
<PRE>
  produced as defined above for real constants. The separator is a comma if the decimal edit mode is POINT; it
<P>
  is a semicolon if the decimal edit mode is COMMA. The end of a record may occur between the separator and
<P>
  the imaginary part only if the entire constant is as long as, or longer than, an entire record. The only embedded
<P>
  blanks permitted within a complex constant are between the separator and the end of a record and one blank at
<P>
  the beginning of the next record.
<P>
</PRE>
8 Character sequences produced when the delimiter mode has a value of NONE
<P>
<PRE>
      • are not delimited by apostrophes or quotation marks,
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>286</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
• are not separated from each other by value separators,
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
• have each internal apostrophe or quotation mark represented externally by one apostrophe or quotation
<P>
<PRE>
         mark, and
<P>
</PRE>
• have a blank character inserted by the processor at the beginning of any record that begins with the
<P>
<PRE>
         continuation of a character sequence from the preceding record.
<P>
</PRE>
9 Character sequences produced when the delimiter mode has a value of QUOTE are delimited by quotes, are
<P>
<PRE>
   preceded and followed by a value separator, and have each internal quote represented on the external medium by
<P>
   two contiguous quotes.
<P>
</PRE>
10 Character sequences produced when the delimiter mode has a value of APOSTROPHE are delimited by apo-
<P>
<PRE>
   strophes, are preceded and followed by a value separator, and have each internal apostrophe represented on the
<P>
   external medium by two contiguous apostrophes.
<P>
</PRE>
11 If two or more successive values in an output record have identical values, the processor has the option of producing
<P>
<PRE>
   a repeated constant of the form r*c instead of the sequence of identical values.
<P>
</PRE>
12 Slashes, as value separators, and null values are not produced as output by list-directed formatting.
</TD></TR>
<TR><TD colspan=2>
13 Except for new records created by explicit formatting within a defined output procedure or by continuation of
</TD></TR>
<TR><TD colspan=2>
<PRE>
   delimited character sequences, each output record begins with a blank character.
<P>
        NOTE 13.33
<P>
        The length of the output records is not specified and is processor dependent.
<P>
   13.11        Namelist formatting
<P>
   13.11.1      Purpose of namelist formatting
<P>
</PRE>
1 Namelist input/output allows data editing with name-value subsequences. This facilitates documentation of input
</TD></TR>
<TR><TD colspan=2>
<PRE>
   and output files and more flexibility on input.
<P>
   13.11.2      Name-value subsequences
<P>
</PRE>
1 The characters in one or more namelist records constitute a sequence of name-value subsequences, each of which
</TD></TR>
<TR><TD colspan=2>
<PRE>
   consists of an object designator followed by an equals and followed by one or more values and value separators.
<P>
   The equals may optionally be preceded or followed by one or more contiguous blanks. The end of a record has the
<P>
   same effect as a blank character, unless it is within a character constant. Any sequence of two or more consecutive
<P>
   blanks is treated as a single blank, unless it is within a character constant.
<P>
</PRE>
2 Each object designator shall begin with a name from the namelist-group-object-list (8.9) and shall follow the
</TD></TR>
<TR><TD colspan=2>
<PRE>
   syntax of designator (R901). It shall not contain a vector subscript or an image-selector and shall not designate a
<P>
   zero-sized array, a zero-sized array section, or a zero-length character string. Each subscript, stride, and substring
<P>
   range expression shall be an optionally signed integer literal constant with no kind type parameter specified. If
<P>
   a section subscript list appears, the number of section subscripts shall be equal to the rank of the object. If
<P>
   the namelist group object is of derived type, the designator in the input record may be either the name of the
<P>
   variable or the designator of one of its components, indicated by qualifying the variable name with the appropriate
<P>
   component name. Successive qualifications may be applied as appropriate to the shape and type of the variable
<P>
   represented. Each designator may be preceded and followed by one or more optional blanks but shall not contain
<P>
   embedded blanks.
<P>
</PRE>
3 A value separator for namelist formatting is the same as for list-directed formatting (13.10.2), or one or more
</TD></TR>
<TR><TD colspan=2>
<PRE>
   contiguous blanks between a nonblank value and the following object designator or namelist comment (13.11.3.6).
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                            287
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>13.11.3</B> </TD><TD valign=bottom>
Namelist input
</TD></TR>
<TR valign=top><TD colspan=2>
<B>13.11.3.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Overall syntax
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Input for a namelist input statement consists of
</TD></TR>
<TR><TD colspan=2>
<PRE>
         (1)    optional blanks and namelist comments,
<P>
         (2)    the character & followed immediately by the namelist-group-name as specified in the NAMELIST
<P>
                statement,
<P>
         (3)    one or more blanks,
<P>
         (4)    a sequence of zero or more name-value subsequences separated by value separators, and
<P>
         (5)    a slash to terminate the namelist input.
<P>
</PRE>
NOTE 13.34
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
A slash encountered in a namelist input record causes the input statement to terminate. A slash cannot be
<P>
used to separate two values in a namelist input statement.
</TD></TR>
<TR><TD colspan=2>
2 The order of the name-value subsequences in the input records need not match the order of the namelist-group-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  object-list. The input records need not specify all objects in the namelist-group-object-list. They may specify a
<P>
  part of an object more than once.
<P>
</PRE>
3 A group name or object name is without regard to case.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  13.11.3.2     Namelist input processing
<P>
</PRE>
1 The name-value subsequences are evaluated serially, in left-to-right order. A namelist group object designator
</TD></TR>
<TR><TD colspan=2>
<PRE>
  may appear in more than one name-value subsequence. The definition status of an object that is not a subobject
<P>
  of a designator in any name-value subsequence remains unchanged.
<P>
</PRE>
2 When the designator in the input record represents an array variable or a variable of derived type, the effect is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  as if the variable represented were expanded into a sequence of scalar list items, in the same way that formatted
<P>
  input/output list items are expanded (12.6.3). The number of values following the equals shall not exceed the
<P>
  number of list items in the expanded sequence, but may be less; in the latter case, the effect is as if sufficient
<P>
  null values had been appended to match any remaining list items in the expanded sequence. Except as noted
<P>
  elsewhere in this subclause, if an input value is not acceptable to the processor for the type of the list item in the
<P>
  corresponding position in the expanded sequence, an error condition occurs.
<P>
        NOTE 13.35
<P>
        For example, if the designator in the input record designates an integer array of size 100, at most 100
<P>
        values, each of which is either a digit string or a null value, can follow the equals; these values would then
<P>
        be assigned to the elements of the array in array element order.
<P>
</PRE>
3 A slash encountered as a value separator during the execution of a namelist input statement causes termination
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of execution of that input statement after transference of the previous value. If there are additional items in the
<P>
  namelist group object being transferred, the effect is as if null values had been supplied for them.
<P>
</PRE>
4 Successive namelist records are read by namelist input until a slash is encountered; the remainder of the record
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is ignored.
<P>
</PRE>
5 A namelist comment may appear after any value separator except a slash (which terminates namelist input). A
</TD></TR>
<TR><TD colspan=2>
<PRE>
  namelist comment is also permitted to start in the first nonblank position of an input record except within a
<P>
  character literal constant.
<P>
  13.11.3.3     Namelist input values
<P>
</PRE>
1 Each value is either a null value (13.11.3.4), c, r*c, or r*, where c is a literal constant, optionally signed if integer
</TD></TR>
<TR><TD colspan=2>
<PRE>
  or real, and r is an unsigned, nonzero, integer literal constant. A kind type parameter shall not be specified for c
<P>
  288                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
  or r. The constant c is interpreted as though it had the same kind type parameter as the corresponding effective
<P>
  item. The r*c form is equivalent to r successive appearances of the constant c, and the r* form is equivalent to r
<P>
  successive null values. Neither of these forms may contain embedded blanks, except where permitted within the
<P>
  constant c.
<P>
</PRE>
2 The datum c (13.11) is any input value acceptable to format specifications for a given type, except for a restriction
</TD></TR>
<TR><TD colspan=2>
<PRE>
  on the form of input values corresponding to list items of types logical, integer, and character as specified in this
<P>
  subclause. The form of a real or complex value is dependent on the decimal edit mode in effect (13.6). The form
<P>
  of an input value shall be acceptable for the type of the namelist group object list item. The number and forms
<P>
  of the input values that may follow the equals in a name-value subsequence depend on the shape and type of
<P>
  the object represented by the name in the input record. When the name in the input record is that of a scalar
<P>
  variable of an intrinsic type, the equals shall not be followed by more than one value. Blanks are never used
<P>
  as zeros, and embedded blanks are not permitted in constants except within character constants and complex
<P>
  constants as specified in this subclause.
<P>
</PRE>
3 When the next effective item is of type real, the input form of the input value is that of a numeric input field. A
</TD></TR>
<TR><TD colspan=2>
<PRE>
  numeric input field is a field suitable for F editing (13.7.2.3.2) that is assumed to have no fractional digits unless
<P>
  a decimal symbol appears within the field.
<P>
</PRE>
4 When the next effective item is of type complex, the input form of the input value consists of a left parenthesis
</TD></TR>
<TR><TD colspan=2>
<PRE>
  followed by an ordered pair of numeric input fields separated by a comma (if the decimal edit mode is POINT) or
<P>
  a semicolon (if the decimal edit mode is COMMA), and followed by a right parenthesis. The first numeric input
<P>
  field is the real part of the complex constant and the second field is the imaginary part. Each of the numeric
<P>
  input fields may be preceded or followed by any number of blanks and ends of records. The end of a record may
<P>
  occur between the real part and the comma or semicolon, or between the comma or semicolon and the imaginary
<P>
  part.
<P>
</PRE>
5 When the next effective item is of type logical, the input form of the input value shall not include equals or value
</TD></TR>
<TR><TD colspan=2>
<PRE>
  separators among the optional characters permitted for L editing (13.7.3).
<P>
</PRE>
6 When the next effective item is of type integer, the value in the input record is interpreted as if an Iw edit
</TD></TR>
<TR><TD colspan=2>
<PRE>
  descriptor with a suitable value of w were used.
<P>
</PRE>
7 When the next effective item is of type character, the input form consists of a sequence of zero or more rep-chars
</TD></TR>
<TR><TD colspan=2>
<PRE>
  whose kind type parameter is implied by the kind of the corresponding list item, delimited by apostrophes or
<P>
  quotes. Such a sequence may be continued from the end of one record to the beginning of the next record, but the
<P>
  end of record shall not occur between a doubled apostrophe in an apostrophe-delimited sequence, nor between a
<P>
  doubled quote in a quote-delimited sequence. The end of the record does not cause a blank or any other character
<P>
  to become part of the sequence. The sequence may be continued on as many records as needed. The characters
<P>
  blank, comma, semicolon, and slash may appear in such character sequences.
<P>
        NOTE 13.36
<P>
        The delimiters in the input form for a namelist input item of type character avoid the ambiguity that could
<P>
        arise between undelimited character sequences and object names. The value of the DELIM= specifier, if
<P>
        any, in the OPEN statement for an external file is ignored during namelist input (12.5.6.8).
<P>
</PRE>
8 Let len be the length of the next effective item, and let w be the length of the character sequence. If len is less
</TD></TR>
<TR><TD colspan=2>
<PRE>
  than or equal to w, the leftmost len characters of the sequence are transmitted to the next effective item. If len
<P>
  is greater than w, the constant is transmitted to the leftmost w characters of the next effective item and the
<P>
  remaining len−w characters of the next effective item are filled with blanks. The effect is as though the sequence
<P>
  were assigned to the next effective item in an intrinsic assignment statement (10.2.1.3).
<P>
  13.11.3.4     Null values
<P>
</PRE>
1 A null value is specified by
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • the r* form,
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
289
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
      • blanks between two consecutive nonblank value separators following an equals,
<P>
      • a value separator that is the first nonblank character following an equals, or
<P>
      • two consecutive nonblank value separators.
<P>
</PRE>
2 A null value has no effect on the definition status of the corresponding input list item. If the namelist group
<P>
<PRE>
  object list item is defined, it retains its previous value; if it is undefined, it remains undefined. A null value shall
<P>
  not be used as either the real or imaginary part of a complex constant, but a single null value may represent an
<P>
  entire complex constant.
<P>
       NOTE 13.37
<P>
       The end of a record following a value separator, with or without intervening blanks, does not specify a null
<P>
       value in namelist input.
<P>
  13.11.3.5     Blanks
<P>
</PRE>
1 All blanks in a namelist input record are considered to be part of some value separator except for
<P>
<PRE>
      • blanks embedded in a character constant,
<P>
      • embedded blanks surrounding the real or imaginary part of a complex constant,
<P>
      • leading blanks following the equals unless followed immediately by a slash or comma, or a semicolon if the
<P>
        decimal edit mode is COMMA, and
<P>
      • blanks between a name and the following equals.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13.11.3.6</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Namelist comments
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Except within a character literal constant, a “!” character after a value separator or in the first nonblank position
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of a namelist input record initiates a comment. The comment extends to the end of the record and may contain
<P>
  any graphic character in the processor-dependent character set. The comment is ignored. A slash within the
<P>
  namelist comment does not terminate execution of the namelist input statement. Namelist comments are not
<P>
  allowed in stream input because comments depend on record structure.
<P>
       NOTE 13.38
<P>
       Namelist input example:
<P>
       INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z; LOGICAL G
<P>
       NAMELIST / TODAY / G, I, P, Z, X
<P>
       READ (*, NML = TODAY)
<P>
       The input data records are:
<P>
       &TODAY I = 12345, X(1) = 12345, X(3:4) = 2*1.5, I=6, ! This is a comment.
<P>
       P = ’’ISN’T_BOB’S’’, Z = (123,0)/
<P>
       The results stored are:
<P>
                 Variable                          Value
<P>
                 I                                 6
<P>
                 X (1)                             12345.0
<P>
                 X (2)                             unchanged
<P>
                 X (3)                             1.5
<P>
                 X (4)                             1.5
<P>
                 X (5) – X (8)                     unchanged
<P>
                 P                                 ISN’T_BOB’S
<P>
                 Z                                 (123.0,0.0)
<P>
                 G                                 unchanged
<P>
  290                                                                    ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
  13.11.4      Namelist output
<P>
  13.11.4.1    Form of namelist output
<P>
</PRE>
1 The form of the output produced by intrinsic namelist output shall be suitable for input, except for character
</TD></TR>
<TR><TD colspan=2>
<PRE>
  output. The names in the output are in upper case. With the exception of adjacent undelimited character
<P>
  values, the values are separated by one or more blanks or by a comma, or a semicolon if the decimal edit mode is
<P>
  COMMA, optionally preceded by one or more blanks and optionally followed by one or more blanks. The form
<P>
  of the output produced by defined output (12.6.4.8) is determined by the defined output procedure; this form
<P>
  need not be compatible with namelist input.
<P>
</PRE>
2 Namelist output shall not include namelist comments.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 The processor may begin new records as necessary. However, except for complex constants and character values,
<P>
<PRE>
  the end of a record shall not occur within a constant, character value, or name, and blanks shall not appear
<P>
  within a constant, character value, or name.
<P>
       NOTE 13.39
<P>
       The length of the output records is not specified exactly and is processor dependent.
<P>
  13.11.4.2    Namelist output editing
<P>
</PRE>
1 Values in namelist output records are edited as for list-directed output (13.10.4).
<P>
<PRE>
       NOTE 13.40
<P>
       Namelist output records produced with a DELIM= specifier with a value of NONE and which contain a
<P>
       character sequence might not be acceptable as namelist input records.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>13.11.4.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Namelist output records
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 If two or more successive values for the same namelist group item in an output record produced have identical
<P>
<PRE>
  values, the processor has the option of producing a repeated constant of the form r*c instead of the sequence of
<P>
  identical values.
<P>
</PRE>
2 The name of each namelist group object list item is placed in the output record followed by an equals and a list
<P>
<PRE>
  of values of the namelist group object list item.
<P>
</PRE>
3 An ampersand character followed immediately by a namelist-group-name is placed at the start of the first output
<P>
<PRE>
  record to indicate which particular group of data objects is being output. A slash is placed in the output record
<P>
  to indicate the end of the namelist formatting.
<P>
</PRE>
4 A null value is not produced by namelist formatting.
<P>
5 Except for new records created by explicit formatting within a defined output procedure or by continuation of
<P>
<PRE>
  delimited character sequences, each output record begins with a blank character.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        291
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>292</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
14 Program units
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>14.1</B> </TD><TD valign=bottom>
Main program
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 A Fortran main program is a program unit that does not contain a SUBROUTINE, FUNCTION, MODULE,
<P>
<PRE>
  SUBMODULE, or BLOCK DATA statement as its first statement.
<P>
  R1401 main-program                     is  [ program-stmt ]
<P>
                                                  [ specification-part ]
<P>
                                                  [ execution-part ]
<P>
                                                  [ internal-subprogram-part ]
<P>
                                                  end-program-stmt
<P>
  R1402 program-stmt                     is  PROGRAM program-name
<P>
  R1403 end-program-stmt                 is  END [ PROGRAM [ program-name ] ]
<P>
  C1401 (R1401) The program-name may be included in the end-program-stmt only if the optional program-stmt
<P>
          is used and, if included, shall be identical to the program-name specified in the program-stmt.
<P>
       NOTE 14.1
<P>
       The program name is global to the program (19.2). For explanatory information about uses for the program
<P>
       name, see subclause C.9.1.
<P>
       NOTE 14.2
<P>
       An example of a main program is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; PROGRAM ANALYZE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>REAL A, B, C (10,10)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
!  Specification part
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CALL FIND</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
!  Execution part
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>SUBROUTINE FIND</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
!  Internal subprogram
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE FIND</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM ANALYZE</H4>
</A>
<BLOCKQUOTE>
<P>
2 The main program may be defined by means other than Fortran; in that case, the program shall not contain a
<P>
<PRE>
  main-program program unit.
<P>
</PRE>
3 A reference to a Fortran main-program shall not appear in any program unit in the program, including itself.
<P>
<PRE>
  14.2      Modules
<P>
  14.2.1     Module syntax and semantics
<P>
</PRE>
1 A module contains declarations, specifications, and definitions. Public identifiers of module entities are accessible
<P>
<PRE>
  to other program units by use association as specified in 14.2.2. A module that is provided as an inherent part
<P>
  of the processor is an intrinsic module. A nonintrinsic module is defined by a module program unit or a means
<P>
  other than Fortran.
<P>
</PRE>
2 Procedures and types defined in an intrinsic module are not themselves intrinsic.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           293
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1404 module                             is    module-stmt
<P>
                                                     [ specification-part ]
<P>
                                                     [ module-subprogram-part ]
<P>
                                                     end-module-stmt
<P>
  R1405 module-stmt                        is    MODULE module-name
<P>
  R1406 end-module-stmt                    is    END [ MODULE [ module-name ] ]
<P>
  R1407 module-subprogram-part             is    contains-stmt
<P>
                                                     [ module-subprogram ] &#46;&#46;&#46;
<P>
  R1408 module-subprogram                  is function-subprogram
<P>
                                           or subroutine-subprogram
<P>
                                           or separate-module-subprogram
<P>
  C1402 (R1404) If the module-name is specified in the end-module-stmt, it shall be identical to the module-name
<P>
            specified in the module-stmt.
<P>
  C1403 (R1404) A module specification-part shall not contain a stmt-function-stmt , an entry-stmt, or a format-stmt.
<P>
</PRE>
3 If a procedure declared in the scoping unit of a module has an implicit interface, it shall be given the EXTERNAL
<P>
<PRE>
  attribute in that scoping unit; if it is a function, its type and type parameters shall be explicitly declared in a
<P>
  type declaration statement in that scoping unit.
<P>
</PRE>
4 If an intrinsic procedure is declared in the scoping unit of a module, it shall explicitly be given the INTRINSIC
<P>
<PRE>
  attribute in that scoping unit or be used as an intrinsic procedure in that scoping unit.
<P>
        NOTE 14.3
<P>
        The module name is global to the program (19.2).
<P>
        NOTE 14.4
<P>
        Although statement function definitions, ENTRY statements, and FORMAT statements cannot appear in the spe-
<P>
        cification part of a module, they can appear in the specification part of a module subprogram in the module.
<P>
        NOTE 14.5
<P>
        For a discussion of the impact of modules on dependent compilation, see subclause C.9.2.
<P>
        NOTE 14.6
<P>
        For examples of the use of modules, see subclause C.9.3.
<P>
  14.2.2       The USE statement and use association
<P>
</PRE>
1 The USE statement specifies use association. A USE statement is a reference to the module it specifies. At the
<P>
<PRE>
  time a USE statement is processed, the public portions of the specified module shall be available. A module shall
<P>
  not reference itself, either directly or indirectly.
<P>
</PRE>
2 The USE statement provides the means by which a scoping unit accesses named data objects, derived types,
<P>
<PRE>
  procedures, abstract interfaces, generic identifiers, and namelist groups in a module. The entities in the scoping
<P>
  unit are use associated with the entities in the module. The accessed entities have the attributes specified
<P>
  in the module, except that an accessed entity may have a different accessibility attribute, it may have the
<P>
  ASYNCHRONOUS attribute even if the associated module entity does not, and if it is not a coarray it may have
<P>
  the VOLATILE attribute even if the associated module entity does not. The entities made accessible are identified
<P>
  by the names or generic identifiers used to identify them in the module. By default, the accessed entities are
<P>
  identified by the same identifiers in the scoping unit containing the USE statement, but it is possible to specify
<P>
  294                                                                     ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  that different identifiers are used. A use-associated variable is considered to have been previously declared; any
<P>
  other use-associated entity is considered to have been previously defined.
<P>
       NOTE 14.7
<P>
       The accessibility of module entities can be controlled by accessibility attributes (7.5.2.2, 8.5.2), and the
<P>
       ONLY option of the USE statement. Definability of module entities can be controlled by the PROTECTED
<P>
       attribute (8.5.15).
<P>
  R1409 use-stmt                         is USE [ [ , module-nature ] :: ] module-name [ , rename-list ]
<P>
                                         or USE [ [ , module-nature ] :: ] module-name ,
<P>
                                               ONLY : [ only-list ]
<P>
  R1410 module-nature                    is INTRINSIC
<P>
                                         or NON_INTRINSIC
<P>
  R1411 rename                           is local-name =&gt; use-name
<P>
                                         or OPERATOR (local-defined-operator) =&gt;
<P>
                                               OPERATOR (use-defined-operator)
<P>
  R1412 only                             is generic-spec
<P>
                                         or only-use-name
<P>
                                         or rename
<P>
  R1413 only-use-name                    is  use-name
<P>
  C1404 (R1409) If module-nature is INTRINSIC, module-name shall be the name of an intrinsic module.
<P>
  C1405 (R1409) If module-nature is NON_INTRINSIC, module-name shall be the name of a nonintrinsic module.
<P>
  C1406 (R1409) A scoping unit shall not directly reference an intrinsic module and a nonintrinsic module of the
<P>
           same name.
<P>
  C1407 (R1411) OPERATOR (use-defined-operator) shall not identify a type-bound generic interface.
<P>
  C1408 (R1412) The generic-spec shall not identify a type-bound generic interface.
<P>
       NOTE 14.8
<P>
       Constraints C1407 and C1408 do not prevent accessing a generic-spec that is declared by an interface block,
<P>
       even if a type-bound generic interface has the same generic-spec.
<P>
  C1409 Each generic-spec, use-name, and use-defined-operator in a USE statement shall be a public identifier of
<P>
           the module.
<P>
  C1410 An only-use-name shall be a nongeneric name.
<P>
  R1414 local-defined-operator           is defined-unary-op
<P>
                                         or defined-binary-op
<P>
  R1415 use-defined-operator             is defined-unary-op
<P>
                                         or defined-binary-op
<P>
</PRE>
3 A use-stmt without a module-nature provides access either to an intrinsic or to a nonintrinsic module. If the
<P>
<PRE>
  module-name is the name of both an intrinsic and a nonintrinsic module, the nonintrinsic module is accessed.
<P>
</PRE>
4 The USE statement without the ONLY option provides access to all public entities in the specified module.
<P>
5 A USE statement with the ONLY option provides access only to those entities that appear as generic-specs,
<P>
<PRE>
  use-names, or use-defined-operators in the only-list.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         295
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 More than one USE statement for a given module may appear in a specification part. If one of the USE statements
<P>
<PRE>
   is without an ONLY option, all public entities in the module are accessible. If all the USE statements have ONLY
<P>
   options, only those entities in one or more of the only-lists are accessible.
<P>
</PRE>
7 An accessible entity in the referenced module is associated with one or more accessed entities, each with its own
<P>
<PRE>
   identifier. These identifiers are
<P>
       • the identifier of the entity in the referenced module if that identifier appears as an only-use-name or as the
<P>
          defined-operator of a generic-spec in any only for that module,
<P>
       • each of the local-names or local-defined-operators that the entity is given in any rename for that module,
<P>
          and
<P>
       • the identifier of the entity in the referenced module if that identifier does not appear as a use-name or
<P>
          use-defined-operator in any rename for that module.
<P>
</PRE>
8 An ultimate entity is a module entity that is not accessed by use association. An accessed entity shall not be
<P>
<PRE>
   associated with two or more ultimate entities unless its identifier is not used, or the ultimate entities are generic
<P>
   interfaces. Generic interfaces are handled as described in 15.4.3.4.
<P>
         NOTE 14.9
<P>
         There is no prohibition against a use-name or use-defined-operator appearing multiple times in one USE
<P>
         statement or in multiple USE statements involving the same module. As a result, it is possible for one
<P>
         use-associated entity to be accessible by more than one local identifier.
<P>
</PRE>
9 The local identifier of an entity made accessible by a USE statement shall not appear in any other nonexecutable
<P>
<PRE>
   statement that would cause any attribute (8.5) of the entity to be specified in the scoping unit that contains the
<P>
   USE statement, except that it may appear in a PUBLIC or PRIVATE statement in the scoping unit of a module
<P>
   and it may be given the ASYNCHRONOUS or VOLATILE attribute.
<P>
</PRE>
10 An entity in a scoping unit that is accessed by use association through more than one use path, has the ASYN-
<P>
<PRE>
   CHRONOUS or VOLATILE attribute in any of those use paths, and is not given that attribute in that scoping
<P>
   unit, shall have that attribute in all use paths.
<P>
         NOTE 14.10
<P>
         The constraints in subclauses 8.10.1, 8.10.2, and 8.9 prohibit the local-name from appearing as a common-
<P>
         block-object in a COMMON statement, an equivalence-object in an EQUIVALENCE statement, or a namelist-group-name
<P>
         in a NAMELIST statement, respectively. There is no prohibition against the local-name appearing as a
<P>
         common-block-name or a namelist-group-object.
<P>
         NOTE 14.11
<P>
         For a discussion of the impact of the ONLY option and renaming on dependent compilation, see subclause
<P>
         C.9.2.1.
<P>
         NOTE 14.12
<P>
         Examples:
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE STATS_LIB</H4>
</A>
<BLOCKQUOTE>
<P>
provides access to all public entities in the module STATS_LIB.
<P>
USE MATH_LIB; USE STATS_LIB, SPROD =&gt; PROD
<P>
provides access to all public identifiers in both MATH_LIB and STATS_LIB. If MATH_LIB contains an
<P>
entity named PROD, it can be accessed by that name, while the entity PROD of STATS_LIB can be
<P>
accessed by the name SPROD.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: accessed by the name SPROD.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>296</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                           c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 14.12 (cont.)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
USE STATS_LIB, ONLY: YPROD; USE STATS_LIB, ONLY : PROD
<P>
provides access to YPROD and PROD in STAT_LIB.
<P>
USE STATS_LIB, ONLY : YPROD; USE STATS_LIB
<P>
provides access to all public identifiers in STAT_LIB.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>14.2.3</B> </TD><TD valign=bottom>
Submodules
<P>
1 A submodule is a program unit that extends a module or another submodule. The program unit that it extends
<P>
<PRE>
  is its host, and is specified by the parent-identifier in the submodule-stmt.
<P>
</PRE>
2 A module or submodule is an ancestor program unit of all of its descendants, which are its submodules and their
<P>
<PRE>
  descendants. The submodule identifier is the ordered pair whose first element is the ancestor module name and
<P>
  whose second element is the submodule name; the submodule name by itself is not a local or global identifier.
<P>
        NOTE 14.13
<P>
        A module and its submodules stand in a tree-like relationship one to another, with the module at the root.
<P>
        Therefore, a submodule has exactly one ancestor module and can have one or more ancestor submodules.
<P>
</PRE>
3 A submodule may provide implementations for separate module procedures (15.6.2.5), each of which is declared
<P>
<PRE>
  (15.4.3.2) within that submodule or one of its ancestors, and declarations and definitions of other entities that
<P>
  are accessible by host association in its descendants.
<P>
  R1416 submodule                              is   submodule-stmt
<P>
                                                           [ specification-part ]
<P>
                                                           [ module-subprogram-part ]
<P>
                                                          end-submodule-stmt
<P>
  R1417 submodule-stmt                         is   SUBMODULE ( parent-identifier ) submodule-name
<P>
  R1418 parent-identifier                      is   ancestor-module-name [ : parent-submodule-name ]
<P>
  R1419 end-submodule-stmt                     is   END [ SUBMODULE [ submodule-name ] ]
<P>
  C1411 (R1416) A submodule specification-part shall not contain a format-stmt, entry-stmt, or stmt-function-stmt .
<P>
  C1412 (R1418) The ancestor-module-name shall be the name of a nonintrinsic module that declares a separate
<P>
           module procedure; the parent-submodule-name shall be the name of a descendant of that module.
<P>
  C1413 (R1416) If a submodule-name appears in the end-submodule-stmt, it shall be identical to the one in the
<P>
           submodule-stmt.
<P>
  14.3        Block data program units
<P>
</PRE>
1 A block data program unit is used to provide initial values for data objects in named common blocks.
<P>
<PRE>
  R1420    block-data                          is   block-data-stmt
<P>
                                                          [ specification-part ]
<P>
                                                          end-block-data-stmt
<P>
  R1421    block-data-stmt                     is   BLOCK DATA [ block-data-name ]
<P>
  R1422    end-block-data-stmt                 is   END [ BLOCK DATA [ block-data-name ] ]
<P>
  C1414    (R1420) The block-data-name shall be included in the end-block-data-stmt only if it was provided in the block-data-stmt
<P>
           and, if included, shall be identical to the block-data-name in the block-data-stmt.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                      297
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1415     (R1420) A block-data specification-part shall contain only derived-type definitions and ASYNCHRONOUS, BIND, COM-
<P>
            MON, DATA, DIMENSION, EQUIVALENCE, IMPLICIT, INTRINSIC, PARAMETER, POINTER, SAVE, TARGET,
<P>
            USE, VOLATILE, and type declaration statements.
<P>
  C1416     (R1420) A type declaration statement in a block-data specification-part shall not contain ALLOCATABLE, EXTERNAL,
<P>
            or BIND attribute specifiers.
<P>
</PRE>
2 If an object in a named common block is initially defined, all storage units in the common block storage sequence shall be specified
<P>
<PRE>
  even if they are not all initially defined. More than one named common block may have objects initially defined in a single block
<P>
  data program unit.
<P>
</PRE>
3 Only an object in a named common block may be initially defined in a block data program unit.
<P>
4 The same named common block shall not be specified in more than one block data program unit in a program.
<P>
5 There shall not be more than one unnamed block data program unit in a program.
<P>
<PRE>
  298                                                                          ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  15 Procedures
<P>
  15.1       Concepts
<P>
</PRE>
1 The concept of a procedure was introduced in 5.2.3. This clause contains a complete description of procedures.
<P>
<PRE>
  The actions specified by a procedure are performed when the procedure is invoked by execution of a reference to
<P>
  it.
<P>
</PRE>
2 The sequence of actions encapsulated by a procedure has access to entities in the procedure reference by way of
<P>
<PRE>
  argument association (15.5.2). A name that appears as a dummy-arg-name in the SUBROUTINE, FUNCTION,
<P>
  or ENTRY    statement in the declaration of a procedure (R1536) is a dummy argument. Dummy arguments are
<P>
  also specified for intrinsic procedures and procedures in intrinsic modules in Clauses 16, 17, and 18.
<P>
  15.2       Procedure classifications
<P>
  15.2.1      Procedure classification by reference
<P>
</PRE>
1 The definition of a procedure specifies it to be a function or a subroutine. A reference to a function either appears
<P>
<PRE>
  explicitly as a primary within an expression, or is implied by a defined operation (10.1.6) within an expression.
<P>
  A reference to a subroutine is a CALL statement, a defined assignment statement (10.2.1.4), the appearance of
<P>
  an object processed by defined input/output (12.6.4.8) in an input/output list, or finalization (7.5.6).
<P>
</PRE>
2 A procedure is classified as elemental if it is a procedure that may be referenced elementally (15.8).
<P>
<PRE>
  15.2.2      Procedure classification by means of definition
<P>
  15.2.2.1     Intrinsic procedures
<P>
</PRE>
1 A procedure that is provided as an inherent part of the processor is an intrinsic procedure.
<P>
<PRE>
  15.2.2.2     External, internal, and module procedures
<P>
</PRE>
1 An external procedure is a procedure that is defined by an external subprogram or by a means other than Fortran.
<P>
2 An internal procedure is a procedure that is defined by an internal subprogram. Internal subprograms may
<P>
<PRE>
  appear in the main program, in an external subprogram, or in a module subprogram. Internal subprograms shall
<P>
  not appear in other internal subprograms. Internal subprograms are the same as external subprograms except
<P>
  that the name of the internal procedure is not a global identifier, an internal subprogram shall not contain an ENTRY
<P>
  statement, and the internal subprogram has access to host entities by host association.
<P>
</PRE>
3 A module procedure is a procedure that is defined by a module subprogram.
<P>
4 A subprogram defines a procedure for the SUBROUTINE or FUNCTION statement. If the subprogram has one or
<P>
<PRE>
  more ENTRY statements, it also defines a procedure for each of them.
<P>
  15.2.2.3     Dummy procedures
<P>
</PRE>
1 A dummy argument that is specified to be a procedure or appears as the procedure designator in a procedure
<P>
<PRE>
  reference is a dummy procedure. A dummy procedure with the POINTER attribute is a dummy procedure
<P>
  pointer.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             299
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  15.2.2.4     Procedure pointers
<P>
</PRE>
1 A procedure pointer is a procedure that has the EXTERNAL and POINTER attributes; it may be pointer
<P>
<PRE>
  associated with an external procedure, an internal procedure, an intrinsic procedure, a module procedure, or a
<P>
  dummy procedure that is not a procedure pointer.
<P>
  15.2.2.5     Statement functions
<P>
</PRE>
1 A function that is defined by a single statement is a statement function (15.6.4).
<P>
<PRE>
  15.3        Characteristics
<P>
  15.3.1       Characteristics of procedures
<P>
</PRE>
1 The characteristics of a procedure are the classification of the procedure as a function or subroutine, whether it
<P>
<PRE>
  is pure, whether it is elemental, whether it has the BIND attribute, the characteristics of its dummy arguments,
<P>
  and the characteristics of its function result if it is a function.
<P>
  15.3.2       Characteristics of dummy arguments
<P>
  15.3.2.1     General
<P>
</PRE>
1 Each dummy argument has the characteristic that it is a dummy data object, a dummy procedure, or an asterisk
<P>
<PRE>
  (alternate return indicator).
<P>
  15.3.2.2     Characteristics of dummy data objects
<P>
</PRE>
1 The characteristics of a dummy data object are its declared type, its type parameters, its shape (unless it is
<P>
<PRE>
  assumed-rank), its corank, its codimensions, its intent (8.5.10, 8.6.9), whether it is optional (8.5.12, 8.6.10),
<P>
  whether it is allocatable (8.5.3), whether it has the ASYNCHRONOUS (8.5.4), CONTIGUOUS (8.5.7), VALUE
<P>
  (8.5.18), or VOLATILE (8.5.19) attributes, whether it is polymorphic, and whether it is a pointer (8.5.14, 8.6.12)
<P>
  or a target (8.5.17, 8.6.15). If a type parameter of an object or a bound of an array is not a constant expression,
<P>
  the exact dependence on the entities in the expression is a characteristic. If a rank, shape, size, type, or type
<P>
  parameter is assumed or deferred, it is a characteristic.
<P>
  15.3.2.3     Characteristics of dummy procedures
<P>
</PRE>
1 The characteristics of a dummy procedure are the explicitness of its interface (15.4.2), its characteristics as a
<P>
<PRE>
  procedure if the interface is explicit, whether it is a pointer, and whether it is optional (8.5.12, 8.6.10).
<P>
  15.3.2.4     Characteristics of asterisk dummy arguments
<P>
</PRE>
1 A dummy argument that is an asterisk has no other characteristic.
<P>
<PRE>
  15.3.3       Characteristics of function results
<P>
</PRE>
1 The characteristics of a function result are its declared type, type parameters, rank, whether it is polymorphic,
<P>
<PRE>
  whether it is allocatable, whether it is a pointer, whether it has the CONTIGUOUS attribute, and whether it is a
<P>
  procedure pointer. If a function result is an array that is not allocatable or a pointer, its shape is a characteristic.
<P>
  If a type parameter of a function result or a bound of a function result array is not a constant expression, the
<P>
  exact dependence on the entities in the expression is a characteristic. If type parameters of a function result are
<P>
  deferred, which parameters are deferred is a characteristic. Whether the length of a character function result is assumed
<P>
  is a characteristic.
<P>
  300                                                                         ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
  15.4        Procedure interface
<P>
  15.4.1       Interface and abstract interface
<P>
</PRE>
1 The interface of a procedure determines the forms of reference through which it may be invoked. The procedure’s
<P>
<PRE>
  interface consists of its name, binding label, generic identifiers, characteristics, and the names of its dummy
<P>
  arguments. The characteristics and binding label of a procedure are fixed, but the remainder of the interface may
<P>
  differ in differing contexts, except that for a separate module procedure body (15.6.2.5), the dummy argument
<P>
  names and whether it has the NON_RECURSIVE attribute shall be the same as in its corresponding module
<P>
  procedure interface body (15.4.3.2).
<P>
</PRE>
2 An abstract interface is a set of procedure characteristics with the dummy argument names.
<P>
<PRE>
  15.4.2       Implicit and explicit interfaces
<P>
  15.4.2.1     Interfaces and scopes
<P>
</PRE>
1 The interface of a procedure is either explicit or implicit. It is explicit if it is
<P>
<PRE>
      • an internal procedure, module procedure, or intrinsic procedure,
<P>
      • a subroutine, or a function with a separate result name, within the scoping unit that defines it, or
<P>
      • a procedure declared by a procedure declaration statement that specifies an explicit interface, or by an
<P>
         interface body.
<P>
</PRE>
Otherwise, the interface of the identifier is implicit. The interface of a statement function is always implicit.
<P>
<PRE>
        NOTE 15.1
<P>
        For example, the subroutine LLS of C.9.3.4 has an explicit interface.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>15.4.2.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Explicit interface
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 Within the scope of a procedure identifier, the procedure shall have an explicit interface if it is not a statement
<P>
<PRE>
  function and
<P>
          (1)    a reference to the procedure appears with an argument keyword (15.5.2),
<P>
          (2)    the procedure is used in a context that requires it to be pure (15.7),
<P>
          (3)    the procedure has a dummy argument that
<P>
                 (a)    has the ALLOCATABLE, ASYNCHRONOUS, OPTIONAL, POINTER, TARGET, VALUE,
<P>
                        or VOLATILE attribute,
<P>
                 (b)    is an assumed-shape array,
<P>
                 (c)    is assumed-rank,
<P>
                 (d)    is a coarray,
<P>
                 (e)    is of a parameterized derived type, or
<P>
                 (f)    is polymorphic,
<P>
          (4)    the procedure has a result that
<P>
                 (a)    is an array,
<P>
                 (b)    is a pointer or is allocatable, or
<P>
                 (c)    has a nonassumed type parameter value that is not a constant expression,
<P>
          (5)    the procedure is elemental, or
<P>
          (6)    the procedure has the BIND attribute.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             301
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  15.4.3      Specification of the procedure interface
<P>
  15.4.3.1    General
<P>
</PRE>
1 The interface for an internal, external, module, or dummy procedure is specified by a FUNCTION, SUB-
<P>
<PRE>
  ROUTINE, or ENTRY statement and by specification statements for the dummy arguments and the result of
<P>
  a function. These statements may appear in the procedure definition, in an interface body, or both, except that
<P>
  the ENTRY statement shall not appear in an interface body.
<P>
       NOTE 15.2
<P>
       An interface body cannot be used to describe the interface of an internal procedure, a module procedure
<P>
       that is not a separate module procedure, or an intrinsic procedure because the interfaces of such procedures
<P>
       are already explicit. However, the name of a procedure can appear in a PROCEDURE statement in an
<P>
       interface block (15.4.3.2).
<P>
  15.4.3.2    Interface block
<P>
  R1501 interface-block                    is   interface-stmt
<P>
                                                     [ interface-specification ] &#46;&#46;&#46;
<P>
                                                     end-interface-stmt
<P>
  R1502 interface-specification            is interface-body
<P>
                                           or procedure-stmt
<P>
  R1503 interface-stmt                     is INTERFACE [ generic-spec ]
<P>
                                           or ABSTRACT INTERFACE
<P>
  R1504 end-interface-stmt                 is   END INTERFACE [ generic-spec ]
<P>
  R1505 interface-body                     is   function-stmt
<P>
                                                     [ specification-part ]
<P>
                                                     end-function-stmt
<P>
                                           or subroutine-stmt
<P>
                                                     [ specification-part ]
<P>
                                                     end-subroutine-stmt
<P>
  R1506 procedure-stmt                     is   [ MODULE ] PROCEDURE [ :: ] specific-procedure-list
<P>
  R1507 specific-procedure                 is   procedure-name
<P>
  R1508 generic-spec                       is   generic-name
<P>
                                           or   OPERATOR ( defined-operator )
<P>
                                           or   ASSIGNMENT ( = )
<P>
                                           or   defined-io-generic-spec
<P>
  R1509 defined-io-generic-spec            is   READ (FORMATTED)
<P>
                                           or   READ (UNFORMATTED)
<P>
                                           or   WRITE (FORMATTED)
<P>
                                           or   WRITE (UNFORMATTED)
<P>
  C1501 (R1501) An interface-block in a subprogram shall not contain an interface-body for a procedure defined
<P>
           by that subprogram.
<P>
  C1502 (R1501) If the end-interface-stmt includes a generic-spec, the interface-stmt shall specify the same
<P>
           generic-spec, except that if one generic-spec has a defined-operator that is .LT., .LE., .GT., .GE., .EQ.,
<P>
           or .NE., the other generic-spec may have a defined-operator that is the corresponding operator &lt;, &lt;=,
<P>
           &gt;, &gt;=, ==, or /=.
<P>
  302                                                                     ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1503 (R1503) If the interface-stmt is ABSTRACT INTERFACE, then the function-name in the function-stmt
<P>
            or the subroutine-name in the subroutine-stmt shall not be the same as a keyword that specifies an
<P>
            intrinsic type.
<P>
  C1504 (R1502) A procedure-stmt is allowed only in an interface block that has a generic-spec.
<P>
  C1505 (R1505) An interface-body of a pure procedure shall specify the intents of all dummy arguments except
<P>
            alternate return indicators, dummy procedures, and arguments with the POINTER or VALUE attribute.
<P>
  C1506 (R1505) An interface-body shall not contain a data-stmt, format-stmt, entry-stmt, or stmt-function-stmt .
<P>
  C1507 (R1506) If MODULE appears in a procedure-stmt, each procedure-name in that statement shall denote a
<P>
            module procedure.
<P>
  C1508 (R1507) A procedure-name shall denote a nonintrinsic procedure that has an explicit interface.
<P>
  C1509 (R1501) An interface-specification in a generic interface block shall not specify a procedure that was
<P>
            specified previously in any accessible interface with the same generic identifier.
<P>
</PRE>
1 An external or module subprogram specifies a specific interface for each procedure defined in that subprogram.
<P>
2 An interface block introduced by ABSTRACT INTERFACE is an abstract interface block. An interface body
<P>
<PRE>
  in an abstract interface block specifies an abstract interface. An interface block with a generic specification is
<P>
  a generic interface block. An interface block with neither ABSTRACT nor a generic specification is a specific
<P>
  interface block.
<P>
</PRE>
3 The name of the entity declared by an interface body is the function-name in the function-stmt or the subroutine-
<P>
<PRE>
  name in the subroutine-stmt that begins the interface body.
<P>
</PRE>
4 A module procedure interface body is an interface body whose initial statement contains the keyword MODULE.
<P>
<PRE>
  It specifies the interface for a separate module procedure (15.6.2.5). A separate module procedure is accessible
<P>
  by use association if and only if its interface body is declared in the specification part of a module and is public.
<P>
  If a corresponding (15.6.2.5) separate module procedure is not defined, the interface may be used to specify an
<P>
  explicit specific interface but the procedure shall not be used in any other way.
<P>
</PRE>
5 An interface body in a generic or specific interface block specifies the EXTERNAL attribute and an explicit
<P>
<PRE>
  specific interface for an external procedure, dummy procedure, or procedure pointer. If the name of the declared
<P>
  procedure is that of a dummy argument in the subprogram containing the interface body, the procedure is a
<P>
  dummy procedure. If the procedure has the POINTER attribute, it is a procedure pointer. If it is not a dummy
<P>
  procedure or procedure pointer, it is an external procedure.
<P>
</PRE>
6 An interface body specifies all of the characteristics of the explicit specific interface or abstract interface. The
<P>
<PRE>
  specification part of an interface body may specify attributes or define values for data entities that do not
<P>
  determine characteristics of the procedure. Such specifications have no effect.
<P>
</PRE>
7 If an explicit specific interface for an external procedure is specified by an interface body or a procedure declaration
<P>
<PRE>
  statement (15.4.3.6), the characteristics shall be consistent with those specified in the procedure definition, except
<P>
  that the interface may specify a procedure that is not pure even if the procedure is defined to be pure. An interface
<P>
  for a procedure defined by an ENTRY statement may be specified by using the entry name as the procedure name in the interface body.
<P>
  If an external procedure does not exist in the program, an interface body for it may be used to specify an explicit
<P>
  specific interface but the procedure shall not be used in any other way. A procedure shall not have more than
<P>
  one explicit specific interface in a given scoping unit, except that if the interface is accessed by use association,
<P>
  there may be more than one local name for the procedure. If a procedure is accessed by use association, each
<P>
  access shall be to the same procedure declaration or definition.
<P>
         NOTE 15.3
<P>
         The dummy argument names in an interface body can be different from the corresponding dummy argument
<P>
         names in the procedure definition because the name of a dummy argument is not a characteristic.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                         303
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 15.4
<P>
        An example of a specific interface block is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE EXT1 (X, Y, Z)
<P>
<PRE>
               REAL, DIMENSION (100, 100) :: X, Y, Z
<P>
</PRE>
END SUBROUTINE EXT1
<P>
SUBROUTINE EXT2 (X, Z)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; REAL X</H4>
</A>
<BLOCKQUOTE>
<P>
COMPLEX (KIND = 4) Z (2000)
</BLOCKQUOTE>
<P>
END SUBROUTINE EXT2
<BLOCKQUOTE>
<P>
FUNCTION EXT3 (P, Q)
<P>
<PRE>
               LOGICAL EXT3
<P>
               INTEGER P (1000)
<P>
               LOGICAL Q (1000)
<P>
</PRE>
END FUNCTION EXT3
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
This interface block specifies explicit interfaces for the three external procedures EXT1, EXT2, and EXT3.
<P>
Invocations of these procedures can use argument keywords (15.5.2); for example:
<P>
PRINT *, EXT3 (Q = P_MASK (N+1 : N+1000), P = ACTUAL_P)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: PRINT *, EXT3 (Q = P_MASK (N+1 : N+1000), P = ACTUAL_P)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>15.4.3.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
GENERIC statement
<P>
1 A GENERIC statement specifies a generic identifier for one or more specific procedures, in the same way as a
<P>
<PRE>
  generic interface block that does not contain interface bodies.
<P>
  R1510 generic-stmt                      is   GENERIC [ , access-spec ] :: generic-spec =&gt; specific-procedure-list
<P>
  C1510 (R1510) A specific-procedure in a GENERIC statement shall not specify a procedure that was specified
<P>
           previously in any accessible interface with the same generic identifier.
<P>
</PRE>
2 If access-spec appears, it specifies the accessibility (8.5.2) of generic-spec.
<P>
<PRE>
  15.4.3.4    Generic interfaces
<P>
  15.4.3.4.1    Generic identifiers
<P>
</PRE>
1 A generic interface block specifies a generic interface for each of the procedures in the interface block. The
<P>
<PRE>
  PROCEDURE statement lists procedure pointers, external procedures, dummy procedures, or module procedures
<P>
  that have this generic interface. A GENERIC statement specifies a generic interface for each of the procedures
<P>
  named in its specific-procedure-list. A generic interface is always explicit.
<P>
</PRE>
2 The generic-spec in an interface-stmt is a generic identifier for all the procedures in the interface block. The
<P>
<PRE>
  generic-spec in a GENERIC statement is a generic identifier for all of the procedures named in its specific-
<P>
  procedure-list. The rules specifying how any two procedures with the same generic identifier shall differ are given
<P>
  in 15.4.3.4.5. They ensure that any generic invocation applies to at most one specific procedure. If a specific
<P>
  procedure in a generic interface has a function dummy argument, that argument shall have its type and type
<P>
  parameters explicitly declared in the specific interface.
<P>
</PRE>
3 A generic name is a generic identifier that refers to all of the procedure names in the generic interface. A generic
<P>
<PRE>
  name may be the same as any one of the procedure names in the generic interface, or the same as any accessible
<P>
  generic name.
<P>
</PRE>
4 A generic name may be the same as a derived-type name, in which case all of the procedures in the generic
<P>
<PRE>
  interface shall be functions.
<P>
  304                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 An interface-stmt having a defined-io-generic-spec is an interface for a defined input/output procedure (12.6.4.8).
<P>
<PRE>
        NOTE 15.5
<P>
        An example of a generic procedure interface is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE SWITCH</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE INT_SWITCH (X, Y)
<P>
<PRE>
               INTEGER, INTENT (INOUT) ::        X, Y
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE INT_SWITCH</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE REAL_SWITCH (X, Y)
<P>
<PRE>
               REAL, INTENT (INOUT) :: X,        Y
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE REAL_SWITCH</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>SUBROUTINE COMPLEX_SWITCH (X,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Y)
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
               COMPLEX, INTENT (INOUT) ::        X, Y
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE COMPLEX_SWITCH</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE SWITCH</H4>
</A>
<BLOCKQUOTE>
<P>
Any of these three subroutines (INT_SWITCH, REAL_SWITCH, COMPLEX_SWITCH) can be ref-
<P>
erenced with the generic name SWITCH, as well as by its specific name. For example, a reference to
<P>
INT_SWITCH could take the form:
<P>
CALL SWITCH (MAX_VAL, LOC_VAL) ! MAX_VAL and LOC_VAL are of type INTEGER
<P>
NOTE 15.6
<P>
A type-bound-generic-stmt within a derived-type definition (7.5.5) specifies a generic identifier for a set of
<P>
type-bound procedures.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: type-bound procedures.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>15.4.3.4.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Defined operations
<P>
1 If OPERATOR is specified in a generic specification, all of the procedures specified in the generic interface shall
<P>
<PRE>
  be functions that may be referenced as defined operations (10.1.6, 15.5). In the case of functions of two arguments,
<P>
  infix binary operator notation is implied. In the case of functions of one argument, prefix operator notation is
<P>
  implied. OPERATOR shall not be specified for functions with no arguments or for functions with more than two
<P>
  arguments. The dummy arguments shall be nonoptional dummy data objects and shall have the INTENT (IN)
<P>
  or VALUE attribute. The function result shall not have assumed character length. If the operator is an intrinsic-operator
<P>
  (R608), the number of dummy arguments shall be consistent with the intrinsic uses of that operator, and the
<P>
  types, kind type parameters, or ranks of the dummy arguments shall differ from those required for the intrinsic
<P>
  operation (10.1.5).
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>2 A defined operation is treated as a reference to the function.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
For a unary defined operation, the operand
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
  corresponds to the function’s dummy argument; for a binary operation, the left-hand operand corresponds to the
<P>
  first dummy argument of the function and the right-hand operand corresponds to the second dummy argument.
<P>
  All restrictions and constraints that apply to actual arguments in a reference to the function also apply to the
<P>
  corresponding operands in the expression as if they were used as actual arguments.
<P>
</PRE>
3 A given defined operator may, as with generic names, apply to more than one function, in which case it is generic
<P>
<PRE>
  in exact analogy to generic procedure names. For intrinsic operator symbols, the generic properties include the
<P>
  intrinsic operations they represent. Because both forms of each relational operator have the same interpretation
<P>
  (10.1.6.2), extending one form (such as &lt;=) has the effect of defining both forms (&lt;= and .LE.).
<P>
        NOTE 15.7
<P>
        An example of the use of the OPERATOR generic specification is:
<P>
                INTERFACE OPERATOR ( * )
<P>
                    FUNCTION BOOLEAN_AND (B1, B2)
<P>
                        LOGICAL, INTENT (IN) :: B1 (:), B2 (SIZE (B1))
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               305
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 15.7 (cont.)
<P>
                        LOGICAL :: BOOLEAN_AND (SIZE (B1))
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END FUNCTION BOOLEAN_AND</H4>
</A>
<BLOCKQUOTE>
<P>
END INTERFACE OPERATOR ( * )
</BLOCKQUOTE>
<P>
This allows, for example
<P>
<PRE>
                 SENSOR (1:N) * ACTION (1:N)
<P>
</PRE>
as an alternative to the function reference
<P>
<PRE>
                 BOOLEAN_AND (SENSOR (1:N), ACTION (1:N))             ! SENSOR and ACTION are
<P>
                                                                      ! of type LOGICAL
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>15.4.3.4.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Defined assignments
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 If ASSIGNMENT ( = ) is specified in a generic specification, all the procedures in the generic interface shall
<P>
<PRE>
  be subroutines that may be referenced as defined assignments (10.2.1.4, 10.2.1.5). Defined assignment may, as
<P>
  with generic names, apply to more than one subroutine, in which case it is generic in exact analogy to generic
<P>
  procedure names.
<P>
</PRE>
2 Each of these subroutines shall have exactly two dummy arguments. The dummy arguments shall be nonoptional
<P>
<PRE>
  dummy data objects. The first argument shall have INTENT (OUT) or INTENT (INOUT) and the second
<P>
  argument shall have the INTENT (IN) or VALUE attribute. Either the second argument shall be an array whose
<P>
  rank differs from that of the first argument, the declared types and kind type parameters of the arguments shall
<P>
  not conform as specified in Table 10.8, or the first argument shall be of derived type. A defined assignment is
<P>
  treated as a reference to the subroutine, with the left-hand side as the first argument and the right-hand side
<P>
  enclosed in parentheses as the second argument. All restrictions and constraints that apply to actual arguments
<P>
  in a reference to the subroutine also apply to the left-hand-side and to the right-hand-side enclosed in parentheses
<P>
  as if they were used as actual arguments. The ASSIGNMENT generic specification specifies that assignment is
<P>
  extended or redefined.
<P>
        NOTE 15.8
<P>
        An example of the use of the ASSIGNMENT generic specification is:
<P>
                 INTERFACE ASSIGNMENT ( = )
<P>
                     SUBROUTINE LOGICAL_TO_NUMERIC (N, B)
<P>
                        INTEGER, INTENT (OUT) :: N
<P>
                        LOGICAL, INTENT (IN) :: B
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE LOGICAL_TO_NUMERIC</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE CHAR_TO_STRING (S, C)
<P>
<PRE>
                        USE STRING_MODULE             ! Contains definition of type STRING
<P>
                        TYPE (STRING), INTENT (OUT) :: S ! A variable-length string
<P>
                        CHARACTER (*), INTENT (IN) :: C
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE CHAR_TO_STRING</H4>
</A>
<BLOCKQUOTE>
<P>
END INTERFACE ASSIGNMENT ( = )
</BLOCKQUOTE>
<P>
Example assignments are:
<P>
<PRE>
                 KOUNT = SENSOR (J)        ! CALL LOGICAL_TO_NUMERIC (KOUNT, (SENSOR (J)))
<P>
                 NOTE = ’89AB’             ! CALL CHAR_TO_STRING (NOTE, (’89AB’))
<P>
</PRE>
NOTE 15.9
<BLOCKQUOTE>
<P>
A procedure which has a generic identifier of ASSIGNMENT ( = ) and whose second dummy argument
<P>
has the ALLOCATABLE or POINTER attribute cannot be directly invoked by defined assignment. This
<P>
is because the actual argument associated with that dummy argument is the right-hand side of the as-
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: is because the actual argument associated with that dummy argument is the right-hand side of the as-
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>306</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 15.9 (cont.)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
signment enclosed in parentheses, which makes the actual argument an expression that does not have the
<P>
ALLOCATABLE, POINTER, or TARGET attribute.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>15.4.3.4.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Defined input/output procedure interfaces
<P>
1 All of the procedures specified in an interface block for a defined input/output procedure shall be subroutines
<P>
<PRE>
  that have interfaces as described in 12.6.4.8.2.
<P>
  15.4.3.4.5     Restrictions on generic declarations
<P>
</PRE>
1 This subclause contains the rules that shall be satisfied by every pair of specific procedures that have the same
<P>
<PRE>
  generic identifier within the scope of the identifier. If a generic procedure is accessed from a module, the rules
<P>
  apply to all the specific versions even if some of them are inaccessible by their specific names.
<P>
       NOTE 15.10
<P>
       In most scoping units, the possible sources of procedures with a particular generic identifier are the accessible
<P>
       generic identifiers specified by generic interface blocks or GENERIC statements and the generic bindings
<P>
       other than names for the accessible objects in that scoping unit. In a type definition, they are the generic
<P>
       bindings, including those from a parent type.
<P>
</PRE>
2 A dummy argument is type, kind, and rank compatible, or TKR compatible, with another dummy argument if
<P>
<PRE>
  the first is type compatible with the second, the kind type parameters of the first have the same values as the
<P>
  corresponding kind type parameters of the second, and both have the same rank or either is assumed-rank.
<P>
</PRE>
3 Two dummy arguments are distinguishable if
<P>
<PRE>
     • one is a procedure and the other is a data object,
<P>
     • they are both data objects or known to be functions, and neither is TKR compatible with the other,
<P>
     • one has the ALLOCATABLE attribute and the other has the POINTER attribute and not the INTENT
<P>
        (IN) attribute, or
<P>
     • one is a function with nonzero rank and the other is not known to be a function.
<P>
</PRE>
C1511 Within the scope of a generic operator, if two procedures with that identifier have the same number of
<P>
<PRE>
           arguments, one shall have a dummy argument that corresponds by position in the argument list to a
<P>
           dummy argument of the other that is distinguishable from it.
<P>
</PRE>
C1512 Within the scope of the generic ASSIGNMENT (=) identifier, if two procedures have that identifier, one
<P>
<PRE>
           shall have a dummy argument that corresponds by position in the argument list to a dummy argument
<P>
           of the other that is distinguishable from it.
<P>
</PRE>
C1513 Within the scope of a defined-io-generic-spec, if two procedures have that generic identifier, their dtv
<P>
<PRE>
           arguments (12.6.4.8.2) shall be distinguishable.
<P>
</PRE>
C1514 Within the scope of a generic name, each pair of procedures identified by that name shall both be
<P>
<PRE>
           subroutines or both be functions, and
<P>
           (1)    there is a non-passed-object dummy data object in one or the other of them such that
<P>
                  (a)    the number of dummy data objects in one that are nonoptional, are not passed-object, and
<P>
                         with which that dummy data object is TKR compatible, possibly including that dummy
<P>
                         data object itself,
<P>
                  exceeds
<P>
                  (b)    the number of non-passed-object dummy data objects, both optional and nonoptional, in
<P>
                         the other that are not distinguishable from that dummy data object,
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
307
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
           (2)   the number of nonoptional dummy procedures in one of them exceeds the number of dummy
<P>
                 procedures in the other,
<P>
           (3)   both have passed-object dummy arguments and the passed-object dummy arguments are distin-
<P>
                 guishable, or
<P>
           (4)   at least one of them shall have both
<P>
                 (a)    a nonoptional non-passed-object dummy argument at an effective position such that either
<P>
                        the other procedure has no dummy argument at that effective position or the dummy argu-
<P>
                        ment at that position is distinguishable from it, and
<P>
                 (b)    a nonoptional non-passed-object dummy argument whose name is such that either the other
<P>
                        procedure has no dummy argument with that name or the dummy argument with that name
<P>
                        is distinguishable from it,
<P>
                 and the dummy argument that disambiguates by position shall either be the same as or occur
<P>
                 earlier in the argument list than the one that disambiguates by name.
<P>
</PRE>
4 The effective position of a dummy argument is its position in the argument list after any passed-object dummy
<P>
<PRE>
  argument has been removed.
<P>
</PRE>
5 Within the scope of a generic name that is the same as the generic name of an intrinsic procedure, the intrinsic
<P>
<PRE>
  procedure is not accessible by its generic name if the procedures in the interface and the intrinsic procedure are
<P>
  not all functions or not all subroutines. If a generic invocation is consistent with both a specific procedure from
<P>
  an interface and an accessible intrinsic procedure, it is the specific procedure from the interface that is referenced.
<P>
       NOTE 15.11
<P>
       An extensive explanation of the application of these rules is in C.10.6.
<P>
  15.4.3.5    EXTERNAL statement
<P>
</PRE>
1 An EXTERNAL statement specifies the EXTERNAL attribute (8.5.9) for a list of names.
<P>
<PRE>
  R1511 external-stmt                    is   EXTERNAL [ :: ] external-name-list
<P>
</PRE>
2 The appearance of the name of a block data program unit in an EXTERNAL statement confirms that the block
<P>
<PRE>
  data program unit is a part of the program.
<P>
       NOTE 15.12
<P>
       For explanatory information on potential portability problems with external procedures, see subclause
<P>
       C.10.1.
<P>
       NOTE 15.13
<P>
       An example of an EXTERNAL statement is:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; EXTERNAL FOCUS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>15.4.3.6</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Procedure declaration statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 A procedure declaration statement declares procedure pointers, dummy procedures, and external procedures. It
<P>
<PRE>
  specifies the EXTERNAL attribute (8.5.9) for all entities in the proc-decl-list.
<P>
  R1512 procedure-declaration-stmt       is   PROCEDURE ( [ proc-interface ] )
<P>
                                                [ [ , proc-attr-spec ] &#46;&#46;&#46; :: ] proc-decl-list
<P>
  R1513 proc-interface                   is interface-name
<P>
                                         or declaration-type-spec
<P>
  R1514 proc-attr-spec                   is access-spec
<P>
                                         or proc-language-binding-spec
<P>
  308                                                                    ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
                                                  or   INTENT ( intent-spec )
<P>
                                                  or   OPTIONAL
<P>
                                                  or   POINTER
<P>
                                                  or   PROTECTED
<P>
                                                  or   SAVE
<P>
  R1515 proc-decl                                 is   procedure-entity-name [ =&gt; proc-pointer-init ]
<P>
  R1516 interface-name                            is   name
<P>
  R1517 proc-pointer-init                         is null-init
<P>
                                                  or initial-proc-target
<P>
  R1518 initial-proc-target                       is   procedure-name
<P>
  C1515 (R1516) The name shall be the name of an abstract interface or of a procedure that has an explicit
<P>
             interface. If name is declared by a procedure-declaration-stmt it shall be previously declared. If name
<P>
             denotes an intrinsic procedure it shall be one that is listed in Table 16.2.
<P>
  C1516 (R1516) The name shall not be the same as a keyword that specifies an intrinsic type.
<P>
  C1517 (R1512) If a proc-interface describes an elemental procedure, each procedure-entity-name shall specify an
<P>
             external procedure.
<P>
  C1518 (R1515) If =&gt; appears in proc-decl, the procedure entity shall have the POINTER attribute.
<P>
  C1519 (R1518) The procedure-name shall be the name of a nonelemental external or module procedure, or a
<P>
             specific intrinsic function listed in Table 16.2.
<P>
  C1520 (R1512) If proc-language-binding-spec with NAME= is specified, then proc-decl-list shall contain exactly
<P>
             one proc-decl, which shall neither have the POINTER attribute nor be a dummy procedure.
<P>
  C1521 (R1512) If proc-language-binding-spec is specified, the proc-interface shall appear, it shall be an interface-
<P>
             name, and interface-name shall be declared with a proc-language-binding-spec.
<P>
</PRE>
2 If proc-interface appears and consists of interface-name, it specifies an explicit specific interface (15.4.3.2) for the
<P>
<PRE>
  declared procedure entities. The abstract interface (15.4) is that specified by the interface named by interface-
<P>
  name. The interface specified by interface-name shall not depend on any characteristic of a procedure identified
<P>
  by a procedure-entity-name in the proc-decl-list of the same procedure declaration statement.
<P>
</PRE>
3 If proc-interface appears and consists of declaration-type-spec, it specifies that the declared procedure entities are
<P>
<PRE>
  functions having implicit interfaces and the specified result type. If a type is specified for an external function,
<P>
  its function definition (15.6.2.2) shall specify the same result type and type parameters.
<P>
</PRE>
4 If proc-interface does not appear, the procedure declaration statement does not specify whether the declared
<P>
<PRE>
  procedure entities are subroutines or functions.
<P>
</PRE>
5 If a proc-attr-spec other than a proc-language-binding-spec appears, it specifies that the declared procedure entities
<P>
<PRE>
  have that attribute. These attributes are described in 8.5. If a proc-language-binding-spec with NAME= appears,
<P>
  it specifies a binding label or its absence, as described in 18.10.2. A proc-language-binding-spec without NAME=
<P>
  is allowed, but is redundant with the proc-interface required by C1521.
<P>
</PRE>
6 If =&gt; appears in a proc-decl in a procedure-declaration-stmt it specifies the initial association status of the
<P>
<PRE>
  corresponding procedure entity, and implies the SAVE attribute, which may be confirmed by explicit specification.
<P>
  If =&gt; null-init appears, the procedure entity is initially disassociated. If =&gt; initial-proc-target appears, the
<P>
  procedure entity is initially associated with the target.
<P>
</PRE>
7 If procedure-entity-name has an explicit interface, its characteristics shall be the same as initial-proc-target except
<P>
<PRE>
  that initial-proc-target may be pure even if procedure-entity-name is not pure and initial-proc-target may be an elemental
<P>
  intrinsic procedure.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                309
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 If the characteristics of procedure-entity-name or initial-proc-target are such that an explicit interface is required,
<P>
<PRE>
   both procedure-entity-name and initial-proc-target shall have an explicit interface.
<P>
</PRE>
9 If procedure-entity-name has an implicit interface and is explicitly typed or referenced as a function, initial-proc-
<P>
<PRE>
   target shall be a function. If procedure-entity-name has an implicit interface and is referenced as a subroutine,
<P>
   initial-proc-target shall be a subroutine.
<P>
</PRE>
10 If initial-proc-target and procedure-entity-name are functions, their results shall have the same characteristics.
<P>
<PRE>
         NOTE 15.14
<P>
         The following code illustrates procedure declaration statements. NOTE 10.47 illustrates the use of the P
<P>
         and BESSEL defined by this code.
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; ABSTRACT INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION REAL_FUNC (X)
<P>
<PRE>
               REAL, INTENT (IN) :: X
<P>
               REAL :: REAL_FUNC
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION REAL_FUNC</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE SUB (X)
<P>
<PRE>
               REAL, INTENT (IN) :: X
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
!-- Some external or dummy procedures with explicit interface.
<P>
PROCEDURE (REAL_FUNC) :: BESSEL, GFUN
<P>
PROCEDURE (SUB) :: PRINT_REAL
<P>
!-- Some procedure pointers with explicit interface,
<P>
!-- one initialized to <B>NULL</B>().
<P>
PROCEDURE (REAL_FUNC), POINTER :: P, R =&gt; NULL ()
<P>
PROCEDURE (REAL_FUNC), POINTER :: PTR_TO_GFUN
<P>
!-- A derived type with a procedure pointer component &#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE STRUCT_TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
PROCEDURE (REAL_FUNC), POINTER, NOPASS :: COMPONENT
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE STRUCT_TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
!-- &#46;&#46;&#46; and a variable of that type.
<P>
<B>TYPE</B>(STRUCT_TYPE) :: STRUCT
<P>
!-- An external or dummy function with implicit interface
<P>
PROCEDURE (REAL) :: PSI
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: PROCEDURE (REAL) :: PSI
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>15.4.3.7</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INTRINSIC statement
<P>
1 An INTRINSIC statement specifies the INTRINSIC attribute (8.5.11) for a list of names.
<P>
<PRE>
   R1519 intrinsic-stmt                    is   INTRINSIC [ :: ] intrinsic-procedure-name-list
<P>
   C1522 (R1519) Each intrinsic-procedure-name shall be the name of an intrinsic procedure.
<P>
   15.4.3.8     Implicit interface specification
<P>
</PRE>
1 If the interface of a function is implicit, the type and type parameters of the function result are specified by an
<P>
<PRE>
   implicit or explicit type specification of the function name. The type, type parameters, and shape of the dummy
<P>
   arguments of a procedure invoked from where the interface of the procedure is implicit shall be such that each
<P>
   actual argument is consistent with the characteristics of the corresponding dummy argument.
<P>
   310                                                                 ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>15.5</B> </TD><TD valign=bottom>
Procedure reference
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>15.5.1</B> </TD><TD valign=bottom>
Syntax of a procedure reference
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
1 The form of a procedure reference is dependent on the interface of the procedure or procedure pointer, but is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  independent of the means by which the procedure is defined. The forms of procedure references are as follows.
<P>
  R1520 function-reference                is   procedure-designator ( [ actual-arg-spec-list ] )
<P>
  C1523 (R1520) The procedure-designator shall designate a function.
<P>
  C1524 (R1520) The actual-arg-spec-list shall not contain an alt-return-spec.
<P>
  R1521 call-stmt                         is   CALL procedure-designator [ ( [ actual-arg-spec-list ] ) ]
<P>
  C1525 (R1521) The procedure-designator shall designate a subroutine.
<P>
  R1522 procedure-designator              is procedure-name
<P>
                                          or proc-component-ref
<P>
                                          or data-ref % binding-name
<P>
  C1526 (R1522) A procedure-name shall be a generic name or the name of a procedure.
<P>
  C1527 (R1522) A binding-name shall be a binding name (7.5.5) of the declared type of data-ref .
<P>
  C1528 (R1522) A data-ref shall not be a polymorphic subobject of a coindexed object.
<P>
  C1529 (R1522) If data-ref is an array, the referenced type-bound procedure shall have the PASS attribute.
<P>
</PRE>
2 The data-ref in a procedure-designator shall not be an unallocated allocatable variable or a pointer that is not
</TD></TR>
<TR><TD colspan=2>
<PRE>
  associated.
<P>
</PRE>
3 Resolving references to type-bound procedures is described in 15.5.6.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
4 A function may also be referenced as a defined operation (10.1.6). A subroutine may also be referenced as a
<P>
<PRE>
  defined assignment (10.2.1.4, 10.2.1.5), by defined input/output (12.6.4.8), or by finalization (7.5.6).
<P>
       NOTE 15.15
<P>
       When resolving type-bound procedure references, constraints on the use of coindexed objects ensure that
<P>
       the coindexed object (on the remote image) has the same dynamic type as the corresponding object on the
<P>
       local image. Thus a processor can resolve the type-bound procedure using the coarray variable on its own
<P>
       image and pass the coindexed object as the actual argument.
<P>
  R1523 actual-arg-spec                   is   [ keyword = ] actual-arg
<P>
  R1524 actual-arg                        is   expr
<P>
                                          or   variable
<P>
                                          or   procedure-name
<P>
                                          or   proc-component-ref
<P>
                                          or   alt-return-spec
<P>
  R1525   alt-return-spec                 is   * label
<P>
  C1530 (R1523) The keyword = shall not appear if the interface of the procedure is implicit.
<P>
  C1531 (R1523) The keyword = shall not be omitted from an actual-arg-spec unless it has been omitted from
<P>
          each preceding actual-arg-spec in the argument list.
<P>
  C1532 (R1523) Each keyword shall be the name of a dummy argument in the explicit interface of the procedure.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                       311
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
C1533 (R1524) A nonintrinsic elemental procedure shall not be used as an actual argument.
<P>
C1534 (R1524) A procedure-name shall be the name of an external, internal, module, or dummy procedure, a
<P>
<PRE>
        specific intrinsic function listed in Table 16.2, or a procedure pointer.
<P>
</PRE>
C1535 (R1524) expr shall not be a variable.
<P>
C1536 (R1525) The label shall be the statement label of a branch target statement that appears in the same inclusive scope as the
<P>
<PRE>
        call-stmt.
<P>
</PRE>
C1537 An actual argument that is a coindexed object shall not have a pointer ultimate component.
<P>
<PRE>
    NOTE 15.16
<P>
    Examples of procedure reference using procedure pointers:
<P>
               P =&gt; BESSEL
<P>
               WRITE (*, *) P(2.5)                 !-- BESSEL(2.5)
<P>
               S =&gt; PRINT_REAL
<P>
               CALL S(3.14)
<P>
    NOTE 15.17
<P>
    An internal procedure cannot be invoked using a procedure pointer from either Fortran or C after the host
<P>
    instance completes execution, because the pointer is then undefined. While the host instance is active,
<P>
    however, if an internal procedure was passed as an actual argument or is the target of a procedure pointer,
<P>
    it could be invoked from outside of the host subprogram.
<P>
                                                                                        Rb
<P>
    Assume there is a procedure with the following interface that calculates a f (x) dx.
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION <B>INTEGRATE</B>(F, A, B) <B>RESULT</B>(INTEGRAL) <B>BIND</B>(C)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE ISO_C_BINDING</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION <B>F</B>(X) <B>BIND</B>(C) ! Integrand
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE ISO_C_BINDING</H4>
</A>
<BLOCKQUOTE>
<P>
<B>REAL</B>(C_FLOAT), VALUE :: X
<P>
<B>REAL</B>(C_FLOAT) :: F
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>REAL</B>(C_FLOAT), VALUE :: A, B ! Bounds
<P>
<B>REAL</B>(C_FLOAT) :: INTEGRAL
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION INTEGRATE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
This procedure can be called from Fortran or C, and could be written in either Fortran or C. The argument F
<P>
representing the mathematical function f (x) can be written as an internal procedure; this internal procedure
<P>
will have access to any host instance local variables necessary to actually calculate f (x). For example:
<P>
<PRE>
               REAL FUNCTION MY_INTEGRATION(N, A, B) RESULT(INTEGRAL)
<P>
                   ! Integrate f(x)=x^n over [a,b]
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE ISO_C_BINDING</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER, <B>INTENT</B>(IN) :: N
<P>
REAL, <B>INTENT</B>(IN) :: A, B
<P>
INTEGRAL = <B>INTEGRATE</B>(MY_F, REAL (A, C_FLOAT), REAL (B, C_FLOAT))
<P>
<PRE>
                        ! This will call the internal function MY_F to calculate f(x).
<P>
                        ! The above interface of INTEGRATE needs to be explicit and available.
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>312</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><P>
<PRE>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 15.17 (cont.)
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<B>REAL</B>(C_FLOAT) FUNCTION <B>MY_F</B>(X) <B>BIND</B>(C) ! Integrand
<P>
<PRE>
                          REAL(C_FLOAT), VALUE :: X
<P>
                          MY_F = X**N ! N is taken from the host instance of MY_INTEGRATION.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION MY_INTEGRATION</H4>
</A>
<BLOCKQUOTE>
<P>
The function INTEGRATE cannot retain a function pointer to MY_F and use it after INTEGRATE has
<P>
finished execution, because the host instance of MY_F might no longer exist, making the pointer undefined.
<P>
If such a pointer is retained, then it can only be used to invoke MY_F during the execution of the instance
<P>
of MY_INTEGRATION that called INTEGRATE.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: of MY_INTEGRATION that called INTEGRATE.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>15.5.2</B> </TD><TD valign=bottom>
Actual arguments, dummy arguments, and argument association
<TABLE width=100% cellpadding=3><!-- tsb: Actual arguments, dummy arguments, and argument association
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>15.5.2.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Argument correspondence
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 In either a subroutine reference or a function reference, the actual argument list identifies the correspondence
<P>
<PRE>
  between the actual arguments and the dummy arguments of the procedure. This correspondence may be estab-
<P>
  lished either by keyword or by position. If an argument keyword appears, the actual argument corresponds to
<P>
  the dummy argument whose name is the same as the argument keyword (using the dummy argument names from
<P>
  the interface accessible by the procedure reference). In the absence of an argument keyword, an actual argument
<P>
  corresponds to the dummy argument occupying the corresponding position in the reduced dummy argument list;
<P>
  that is, the first actual argument corresponds to the first dummy argument in the reduced list, the second actual
<P>
  argument corresponds to the second dummy argument in the reduced list, etc. The reduced dummy argument
<P>
  list is either the full dummy argument list or, if there is a passed-object dummy argument (7.5.4.5), the dummy
<P>
  argument list with the passed-object dummy argument omitted. Exactly one actual argument shall correspond
<P>
  to each nonoptional dummy argument. At most one actual argument shall correspond to each optional dummy
<P>
  argument. Each actual argument shall correspond to a dummy argument.
<P>
         NOTE 15.18
<P>
        For example, the procedure defined by
<P>
        SUBROUTINE SOLVE (FUNCT, SOLUTION, METHOD, STRATEGY, PRINT)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION FUNCT (X)
<P>
<PRE>
                    REAL FUNCT, X
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION FUNCT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; REAL SOLUTION</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER, OPTIONAL :: METHOD, STRATEGY, PRINT
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
can be invoked with
<BLOCKQUOTE>
<P>
CALL SOLVE (FUN, SOL, PRINT = 6)
<P>
provided its interface is explicit, and if the interface is specified by an interface body, the name of the last
<P>
argument is PRINT.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: argument is PRINT.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>15.5.2.2</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The passed-object dummy argument and argument correspondence
<P>
1 In a reference to a type-bound procedure, or a procedure pointer component, that has a passed-object dummy
<P>
<PRE>
  argument (7.5.4.5), the data-ref of the function-reference or call-stmt corresponds, as an actual argument, with
<P>
  the passed-object dummy argument.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             313
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  15.5.2.3    Argument association
<P>
</PRE>
1 Except in references to intrinsic inquiry functions, a pointer actual argument that corresponds to a nonoptional
<P>
<PRE>
  nonpointer dummy argument shall be pointer associated with a target.
<P>
</PRE>
2 If a nonpointer dummy argument without the VALUE attribute corresponds to a pointer actual argument that
<P>
<PRE>
  is pointer associated with a target,
<P>
      • if the dummy argument is polymorphic, it becomes argument associated with that target;
<P>
      • if the dummy argument is nonpolymorphic, it becomes argument associated with the declared type part of
<P>
        that target.
<P>
</PRE>
3 If a present nonpointer dummy argument without the VALUE attribute corresponds to a nonpointer actual
<P>
<PRE>
  argument,
<P>
      • if the dummy argument is polymorphic, it becomes argument associated with that actual argument;
<P>
      • if the dummy argument is nonpolymorphic, it becomes argument associated with the declared type part of
<P>
        that actual argument.
<P>
</PRE>
4 A present dummy argument with the VALUE attribute becomes argument associated with a definable anonymous
<P>
<PRE>
  data object whose initial value is the value of the actual argument.
<P>
</PRE>
5 A present pointer dummy argument that corresponds to a pointer actual argument becomes argument associated
<P>
<PRE>
  with that actual argument. A present pointer dummy argument that does not correspond to a pointer actual
<P>
  argument is not argument associated.
<P>
</PRE>
6 The entity that is argument associated with a dummy argument is called its effective argument.
<P>
7 The ultimate argument is the effective argument if the effective argument is not a dummy argument or a subobject
<P>
<PRE>
  of a dummy argument. If the effective argument is a dummy argument, the ultimate argument is the ultimate
<P>
  argument of that dummy argument. If the effective argument is a subobject of a dummy argument, the ultimate
<P>
  argument is the corresponding subobject of the ultimate argument of that dummy argument.
<P>
        NOTE 15.19
<P>
       For the sequence of subroutine calls
<P>
               INTEGER :: X(100)
<P>
               CALL SUBA (X)
<P>
               &#46;&#46;&#46;
<P>
               SUBROUTINE SUBA(A)
<P>
               INTEGER :: A(:)
<P>
               CALL SUBB (A(1:5), A(5:1:-1))
<P>
               &#46;&#46;&#46;
<P>
               SUBROUTINE SUBB(B, C)
<P>
               INTEGER :: B(:), C(:)
<P>
       the ultimate argument of B is X(1:5). The ultimate argument of C is X(5:1:-1) and this is not the same
<P>
       object as the ultimate argument of B.
<P>
        NOTE 15.20
<P>
       Fortran argument association is usually similar to call by reference and call by value-result. If the VALUE
<P>
       attribute is specified, the effect is as if the actual argument were assigned to a temporary variable, and
<P>
       that variable were then argument associated with the dummy argument. Subsequent changes to the value
<P>
       or definition status of the dummy argument do not affect the actual argument. The actual mechanism by
<P>
       which this happens is determined by the processor.
<P>
  314                                                                ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
   15.5.2.4     Ordinary dummy variables
<P>
</PRE>
1 The requirements in this subclause apply to actual arguments that correspond to nonallocatable nonpointer
<P>
<PRE>
   dummy data objects.
<P>
</PRE>
2 The dummy argument shall be type compatible with the actual argument. If the actual argument is a polymorphic
<P>
<PRE>
   coindexed object, the dummy argument shall not be polymorphic. If the actual argument is a polymorphic
<P>
   assumed-size array, the dummy argument shall be polymorphic. If the actual argument is of a derived type that
<P>
   has type parameters, type-bound procedures, or final subroutines, the dummy argument shall not be assumed-
<P>
   type.
<P>
</PRE>
3 The kind type parameter values of the actual argument shall agree with the corresponding ones of the dummy
<P>
<PRE>
   argument. The length type parameter values of a present actual argument shall agree with the corresponding
<P>
   ones of the dummy argument that are not assumed, except for the case of the character length parameter of
<P>
   an actual argument of type character with default kind or C character kind (18.2.2) associated with a dummy
<P>
   argument that is not assumed-shape or assumed-rank.
<P>
</PRE>
4 If a present scalar dummy argument is of type character with default kind or C character kind, the length len of
<P>
<PRE>
   the dummy argument shall be less than or equal to the length of the actual argument. The dummy argument
<P>
   becomes associated with the leftmost len characters of the actual argument. If a present array dummy argument
<P>
   is of type character with default kind or C character kind and is not assumed-shape or assumed-rank, it becomes
<P>
   associated with the leftmost characters of the actual argument element sequence (15.5.2.11).
<P>
</PRE>
5 The values of assumed type parameters of a dummy argument are assumed from the corresponding type para-
<P>
<PRE>
   meters of its effective argument.
<P>
</PRE>
6 If the actual argument is a coindexed object with an allocatable ultimate component, the dummy argument shall
<P>
<PRE>
   have the INTENT (IN) or the VALUE attribute.
<P>
         NOTE 15.21
<P>
         If the actual argument is a coindexed object, a processor that uses distributed memory might create a copy
<P>
         on the executing image of the actual argument, including copies of any allocated allocatable subobjects,
<P>
         and associate the dummy argument with that copy. If necessary, on return from the procedure, the value
<P>
         of the copy would be copied back to the actual argument.
<P>
</PRE>
7 Except in references to intrinsic inquiry functions, if the dummy argument is nonoptional and the actual argument
<P>
<PRE>
   is allocatable, the corresponding actual argument shall be allocated.
<P>
</PRE>
8 If the dummy argument does not have the TARGET attribute, any pointers associated with the effective argument
<P>
<PRE>
   do not become associated with the corresponding dummy argument on invocation of the procedure. If such a
<P>
   dummy argument is used as an actual argument that corresponds to a dummy argument with the TARGET
<P>
   attribute, whether any pointers associated with the original effective argument become associated with the dummy
<P>
   argument with the TARGET attribute is processor dependent.
<P>
</PRE>
9 If the dummy argument has the TARGET attribute, does not have the VALUE attribute, and either the effective
<P>
<PRE>
   argument is simply contiguous or the dummy argument is scalar, assumed-rank, or assumed-shape, and does not
<P>
   have the CONTIGUOUS attribute, and the effective argument has the TARGET attribute but is not a coindexed
<P>
   object or an array section with a vector subscript then
<P>
       • any pointers associated with the effective argument become associated with the corresponding dummy
<P>
          argument on invocation of the procedure, and
<P>
       • when execution of the procedure completes, any pointers that do not become undefined (19.5.2.5) and are
<P>
          associated with the dummy argument remain associated with the effective argument.
<P>
</PRE>
10 If the dummy argument has the TARGET attribute and is an explicit-shape array, an assumed-shape array with
<P>
<PRE>
   the CONTIGUOUS attribute, an assumed-rank object with the CONTIGUOUS attribute, or an assumed-size
<P>
   array, and the effective argument has the TARGET attribute but is not simply contiguous and is not an array
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                        315
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
   section with a vector subscript then
<P>
       • on invocation of the procedure, whether any pointers associated with the effective argument become asso-
<P>
          ciated with the corresponding dummy argument is processor dependent, and
<P>
       • when execution of the procedure completes, the pointer association status of any pointer that is pointer
<P>
          associated with the dummy argument is processor dependent.
<P>
</PRE>
11 If the dummy argument has the TARGET attribute and the effective argument does not have the TARGET
<P>
<PRE>
   attribute or is an array section with a vector subscript, any pointers associated with the dummy argument
<P>
   become undefined when execution of the procedure completes.
<P>
</PRE>
12 If the dummy argument has the TARGET attribute and the VALUE attribute, any pointers associated with the
<P>
<PRE>
   dummy argument become undefined when execution of the procedure completes.
<P>
</PRE>
13 If the actual argument is a coindexed scalar, the corresponding dummy argument shall be scalar. If the actual
<P>
<PRE>
   argument is a noncoindexed scalar, the corresponding dummy argument shall be scalar unless the actual argument
<P>
   is default character, of type character with the C character kind (18.2.2), or is an element or substring of an element
<P>
   of an array that is not an assumed-shape, pointer, or polymorphic array. If the procedure is nonelemental and is
<P>
   referenced by a generic name or as a defined operator or defined assignment, the ranks of the actual arguments
<P>
   and corresponding dummy arguments shall agree.
<P>
</PRE>
14 If a dummy argument is an assumed-shape array, the rank of the actual argument shall be the same as the rank
<P>
<PRE>
   of the dummy argument, and the actual argument shall not be an assumed-size array.
<P>
</PRE>
15 An actual argument of any rank may correspond to an assumed-rank dummy argument. The rank and extents of
<P>
<PRE>
   the dummy argument are the rank and extents of the corresponding actual argument. The lower bound of each
<P>
   dimension of the dummy argument is equal to one. The upper bound is equal to the extent, except for the last
<P>
   dimension when the actual argument is assumed-size.
<P>
</PRE>
16 Except when a procedure reference is elemental (15.8), each element of an array actual argument or of a sequence
<P>
<PRE>
   in a sequence association (15.5.2.11) is associated with the element of the dummy array that has the same position
<P>
   in array element order (9.5.3.2).
<P>
         NOTE 15.22
<P>
         For default character sequence associations, the interpretation of element is provided in 15.5.2.11.
<P>
</PRE>
17 A scalar dummy argument of a nonelemental procedure shall correspond only to a scalar actual argument.
<P>
18 If a dummy argument has INTENT (OUT) or INTENT (INOUT), the actual argument shall be definable. If a
<P>
<PRE>
   dummy argument has INTENT (OUT), the effective argument becomes undefined at the time the association is
<P>
   established, except for direct components of an object of derived type for which default initialization has been
<P>
   specified.
<P>
</PRE>
19 If the procedure is nonelemental, the dummy argument does not have the VALUE attribute, and the actual
<P>
<PRE>
   argument is an array section having a vector subscript, the dummy argument is not definable and shall not have
<P>
   the ASYNCHRONOUS, INTENT (OUT), INTENT (INOUT), or VOLATILE attributes.
<P>
</PRE>
20 If the dummy argument has a coarray ultimate component, the corresponding actual argument shall have the
<P>
<PRE>
   VOLATILE attribute if and only if the dummy argument has the VOLATILE attribute.
<P>
         NOTE 15.23
<P>
         Argument intent specifications serve several purposes. See NOTE 8.18.
<P>
         NOTE 15.24
<P>
         For more explanatory information on targets as dummy arguments, see subclause C.10.4.
<P>
   316                                                                 ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
C1538 An actual argument that is a coindexed object with the ASYNCHRONOUS or VOLATILE attribute shall
<P>
<PRE>
            not correspond to a dummy argument that has either the ASYNCHRONOUS or VOLATILE attribute,
<P>
            unless the dummy argument has the VALUE attribute.
<P>
</PRE>
C1539 (R1524) If an actual argument is a nonpointer array that has the ASYNCHRONOUS or VOLATILE
<P>
<PRE>
            attribute but is not simply contiguous (9.5.4), and the corresponding dummy argument has either the
<P>
            ASYNCHRONOUS or VOLATILE attribute, but does not have the VALUE attribute, that dummy
<P>
            argument shall be assumed-shape or assumed-rank and shall not have the CONTIGUOUS attribute.
<P>
</PRE>
C1540 (R1524) If an actual argument is an array pointer that has the ASYNCHRONOUS or VOLATILE
<P>
<PRE>
            attribute but does not have the CONTIGUOUS attribute, and the corresponding dummy argument
<P>
            has either the ASYNCHRONOUS or VOLATILE attribute, but does not have the VALUE attribute,
<P>
            that dummy argument shall be an array pointer, an assumed-shape array without the CONTIGUOUS
<P>
            attribute, or an assumed-rank entity without the CONTIGUOUS attribute.
<P>
</PRE>
NOTE 15.25
<TABLE width=100% cellpadding=3><!-- tsb: NOTE 15.25
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
The constraints on an actual argument with the ASYNCHRONOUS or VOLATILE attribute that corres-
<P>
ponds to a dummy argument with either the ASYNCHRONOUS or VOLATILE attribute are designed to
<P>
avoid forcing a processor to use the so-called copy-in/copy-out argument passing mechanism. Making a
<P>
copy of an actual argument whose value is likely to change due to an asynchronous input/output operation
<P>
completing or in some unpredictable manner will cause the new value to be lost when a called procedure
<P>
returns and the copy-out overwrites the actual argument.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>15.5.2.5</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Allocatable and pointer dummy variables
</TD></TR>
<TR></TR></TABLE>1 The requirements in this subclause apply to an actual argument with the ALLOCATABLE or POINTER attribute
<P>
<PRE>
  that corresponds to a dummy argument with the same attribute.
<P>
</PRE>
2 The actual argument shall be polymorphic if and only if the associated dummy argument is polymorphic, and
<P>
<PRE>
  either both the actual and dummy arguments shall be unlimited polymorphic, or the declared type of the actual
<P>
  argument shall be the same as the declared type of the dummy argument.
<P>
        NOTE 15.26
<P>
        The dynamic type of a polymorphic allocatable or pointer dummy argument can change as a result of
<P>
        execution of an ALLOCATE statement or pointer assignment in the subprogram. Because of this the
<P>
        corresponding actual argument needs to be polymorphic and have a declared type that is the same as the
<P>
        declared type of the dummy argument or an extension of that type. However, type compatibility requires
<P>
        that the declared type of the dummy argument be the same as, or an extension of, the type of the actual
<P>
        argument. Therefore, the dummy and actual arguments need to have the same declared type.
<P>
        Dynamic type information is not maintained for a nonpolymorphic allocatable or pointer dummy argument.
<P>
        However, allocating or pointer-assigning such a dummy argument would require maintenance of this inform-
<P>
        ation if the corresponding actual argument is polymorphic. Therefore, the corresponding actual argument
<P>
        needs to be nonpolymorphic.
<P>
</PRE>
3 The rank of the actual argument shall be the same as that of the dummy argument, unless the dummy argument
<P>
<PRE>
  is assumed-rank. The type parameter values of the actual argument shall agree with the corresponding ones of
<P>
  the dummy argument that are not assumed or deferred. The values of assumed type parameters of the dummy
<P>
  argument are assumed from the corresponding type parameters of its effective argument.
<P>
</PRE>
4 The actual argument shall have deferred the same type parameters as the dummy argument.
<P>
<PRE>
  15.5.2.6     Allocatable dummy variables
<P>
</PRE>
1 The requirements in this subclause apply to actual arguments that correspond to allocatable dummy data objects.
<P>
2 The actual argument shall be allocatable. It is permissible for the actual argument to have an allocation status
<P>
<PRE>
  of unallocated.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                       317
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 The corank of the actual argument shall be the same as that of the dummy argument.
<P>
4 If the actual argument is a coindexed object, the dummy argument shall have the INTENT (IN) attribute.
<P>
5 If the dummy argument does not have the TARGET attribute, any pointers associated with the actual argument
<P>
<PRE>
  do not become associated with the corresponding dummy argument on invocation of the procedure. If such a
<P>
  dummy argument is used as an actual argument that is associated with a dummy argument with the TARGET
<P>
  attribute, whether any pointers associated with the original actual argument become associated with the dummy
<P>
  argument with the TARGET attribute is processor dependent.
<P>
</PRE>
6 If the dummy argument has the TARGET attribute, does not have the INTENT (OUT) or VALUE attribute,
<P>
<PRE>
  and the corresponding actual argument has the TARGET attribute then
<P>
      • any pointers associated with the actual argument become associated with the corresponding dummy argu-
<P>
         ment on invocation of the procedure, and
<P>
      • when execution of the procedure completes, any pointers that do not become undefined (19.5.2.5) and are
<P>
         associated with the dummy argument remain associated with the actual argument.
<P>
</PRE>
7 If a dummy argument has INTENT (OUT) or INTENT (INOUT), the actual argument shall be definable. If a
<P>
<PRE>
  dummy argument has INTENT (OUT) and its associated actual argument is allocated, the actual argument is
<P>
  deallocated on procedure invocation (9.7.3.2).
<P>
  15.5.2.7     Pointer dummy variables
<P>
</PRE>
1 The requirements in this subclause apply to actual arguments that correspond to dummy data pointers.
<P>
<PRE>
  C1541 The actual argument corresponding to a dummy pointer with the CONTIGUOUS attribute shall be
<P>
            simply contiguous (9.5.4).
<P>
  C1542 The actual argument corresponding to a dummy pointer shall not be a coindexed object.
<P>
        NOTE 15.27
<P>
        Constraint C1542 does not apply to any intrinsic procedure because an intrinsic procedure is defined in
<P>
        terms of its actual arguments.
<P>
</PRE>
2 If the dummy argument does not have INTENT (IN), the actual argument shall be a pointer. Otherwise, the
<P>
<PRE>
  actual argument shall be a pointer or a valid target for the dummy pointer in a pointer assignment statement. If
<P>
  the actual argument is not a pointer, the dummy pointer becomes pointer associated with the actual argument.
<P>
</PRE>
3 If the dummy argument has INTENT (OUT), the pointer association status of the actual argument becomes
<P>
<PRE>
  undefined on invocation of the procedure.
<P>
        NOTE 15.28
<P>
        For more explanatory information on pointers as dummy arguments, see subclause C.10.4.
<P>
  15.5.2.8     Coarray dummy variables
<P>
</PRE>
1 If the dummy argument is a coarray, the corresponding actual argument shall be a coarray and shall have the
<P>
<PRE>
  VOLATILE attribute if and only if the dummy argument has the VOLATILE attribute.
<P>
</PRE>
2 If the dummy argument is an array coarray that has the CONTIGUOUS attribute or is not of assumed shape,
<P>
<PRE>
  the corresponding actual argument shall be simply contiguous or an element of a simply contiguous array.
<P>
        NOTE 15.29
<P>
        Consider the invocation of a procedure on a particular image. Each dummy coarray is associated with its
<P>
        ultimate argument on the image. In addition, during this execution of the procedure, this image can access
<P>
        the coarray corresponding to the ultimate argument on any other image. For example, consider
<P>
  318                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 15.29 (cont.)
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>SUB</B>(X)
<P>
<PRE>
                          REAL :: X[*]
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
REAL :: <B>A</B>(1000)[*]
<P>
&#46;&#46;&#46;
<P>
CALL <B>SUB</B>(<B>A</B>(10))
</BLOCKQUOTE>
<P>
During execution of this invocation of SUB, the executing image has access through the syntax X[P] to
<BLOCKQUOTE>
<P>
<B>A</B>(10) on image P.
<P>
NOTE 15.30
<P>
Each invocation of a procedure with a nonallocatable coarray dummy argument establishes a dummy coarray
<P>
for the image with its own bounds and cobounds. During this execution of the procedure, this image can
<P>
use its own bounds and cobounds to access the coarray corresponding to the ultimate argument on any
<P>
other image. For example, consider
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>SUB</B>(X,N)
<P>
<PRE>
                          INTEGER :: N
<P>
                          REAL :: X(N,N)[N,*]
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
REAL :: <B>A</B>(1000)[*]
<P>
&#46;&#46;&#46;
<P>
CALL <B>SUB</B>(A,10)
</BLOCKQUOTE>
<P>
During execution of this invocation of SUB, the executing image has access through the syntax <B>X</B>(1,2)[3,4]
<BLOCKQUOTE>
<P>
to <B>A</B>(11) on the image with image index 33.
<P>
NOTE 15.31
<P>
The requirements on an actual argument that corresponds to a dummy coarray that is not of assumed-
<P>
shape or has the CONTIGUOUS attribute are designed to avoid forcing a processor to use the so-called
<P>
copy-in/copy-out argument passing mechanism.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: copy-in/copy-out argument passing mechanism.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>15.5.2.9</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Actual arguments associated with dummy procedure entities
<P>
1 If the interface of a dummy procedure is explicit, its characteristics as a procedure (15.3.1) shall be the same as
<P>
<PRE>
  those of its effective argument, except that a pure effective argument may be associated with a dummy argument
<P>
  that is not pure and an elemental intrinsic actual procedure may be associated with a dummy procedure (which cannot be
<P>
  elemental).
<P>
</PRE>
2 If the interface of a dummy procedure is implicit and either the dummy argument is explicitly typed or referenced
<P>
<PRE>
  as a function, it shall not be referenced as a subroutine and any corresponding actual argument shall be a function,
<P>
  function procedure pointer, or dummy procedure. If both the actual argument and dummy argument are known
<P>
  to be functions, they shall have the same type and type parameters. If only the dummy argument is known to
<P>
  be a function, the function that would be invoked by a reference to the dummy argument shall have the same
<P>
  type and type parameters, except that an external function with assumed character length may be associated with a dummy
<P>
  argument with explicit character length.
<P>
</PRE>
3 If the interface of a dummy procedure is implicit and a reference to it appears as a subroutine reference, any
<P>
<PRE>
  corresponding actual argument shall be a subroutine, subroutine procedure pointer, or dummy procedure.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               319
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 If a dummy argument is a dummy procedure without the POINTER attribute, its effective argument shall be an
<P>
<PRE>
  external, internal, module, or dummy procedure, or a specific intrinsic procedure listed in Table 16.2. If the specific name
<P>
  is also a generic name, only the specific procedure is associated with the dummy argument.
<P>
</PRE>
5 If a dummy argument is a procedure pointer, the corresponding actual argument shall be a procedure pointer, a
<P>
<PRE>
  reference to a function that returns a procedure pointer, a reference to the intrinsic function NULL, or a valid
<P>
  target for the dummy pointer in a pointer assignment statement. If the actual argument is not a pointer, the
<P>
  dummy argument shall have INTENT (IN) and becomes pointer associated with the actual argument.
<P>
</PRE>
6 When the actual argument is a procedure, the host instance of the dummy argument is the host instance of the
<P>
<PRE>
  actual argument (15.6.2.4).
<P>
</PRE>
7 If an external procedure or a dummy procedure is used as an actual argument, its interface shall be explicit or it
<P>
<PRE>
  shall be explicitly declared to have the EXTERNAL attribute.
<P>
  15.5.2.10      Actual arguments and alternate return indicators
<P>
</PRE>
1 If a dummy argument is an asterisk (15.6.2.3), the corresponding actual argument shall be an alternate return specifier (R1525).
<P>
<PRE>
  15.5.2.11      Sequence association
<P>
</PRE>
1 An actual argument represents an element sequence if it is an array expression, an array element designator, a
<P>
<PRE>
  default character scalar, or a scalar of type character with the C character kind (18.2.2). If the actual argument is
<P>
  an array expression, the element sequence consists of the elements in array element order. If the actual argument
<P>
  is an array element designator, the element sequence consists of that array element and each element that follows
<P>
  it in array element order.
<P>
</PRE>
2 If the actual argument is default character or of type character with the C character kind, and is an array
<P>
<PRE>
  expression, array element, or array element substring designator, the element sequence consists of the storage
<P>
  units beginning with the first storage unit of the actual argument and continuing to the end of the array. The
<P>
  storage units of an array element substring designator are viewed as array elements consisting of consecutive
<P>
  groups of storage units having the character length of the dummy array.
<P>
</PRE>
3 If the actual argument is default character or of type character with the C character kind, and is a scalar that is
<P>
<PRE>
  not an array element or array element substring designator, the element sequence consists of the storage units of
<P>
  the actual argument.
<P>
         NOTE 15.32
<P>
         Some of the elements in the element sequence might consist of storage units from different elements of the
<P>
         original array.
<P>
</PRE>
4 An actual argument that represents an element sequence and corresponds to a dummy argument that is an array
<P>
<PRE>
  is sequence associated with the dummy argument if the dummy argument is an explicit-shape or assumed-size
<P>
  array. The rank and shape of the actual argument need not agree with the rank and shape of the dummy
<P>
  argument, but the number of elements in the dummy argument shall not exceed the number of elements in the
<P>
  element sequence of the actual argument. If the dummy argument is assumed-size, the number of elements in the
<P>
  dummy argument is exactly the number of elements in the element sequence.
<P>
  15.5.2.12      Argument presence and restrictions on arguments not present
<P>
</PRE>
1 A dummy argument or an entity that is host associated with a dummy argument is not present if the dummy
<P>
<PRE>
  argument
<P>
       • does not correspond to an actual argument,
<P>
       • corresponds to an actual argument that is not present, or
<P>
       • does not have the ALLOCATABLE or POINTER attribute, and corresponds to an actual argument that
<P>
             – has the ALLOCATABLE attribute and is not allocated, or
<P>
  320                                                                          ⃝
<P>
                                                                               c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
          – has the POINTER attribute and is disassociated;
<P>
  otherwise, it is present.
<P>
</PRE>
2 A nonoptional dummy argument shall be present. If an optional nonpointer dummy argument corresponds to a
<P>
<PRE>
  present pointer actual argument, the pointer association status of the actual argument shall not be undefined.
<P>
</PRE>
3 An optional dummy argument that is not present is subject to the following restrictions.
<P>
<PRE>
        (1)    If it is a data object, it shall not be referenced or be defined. If it is of a type that has default
<P>
               initialization, the initialization has no effect.
<P>
        (2) It shall not be used as the data-target or proc-target of a pointer assignment.
<P>
        (3) If it is a procedure or procedure pointer, it shall not be invoked.
<P>
        (4) It shall not be supplied as an actual argument corresponding to a nonoptional dummy argument
<P>
               other than as the argument of the intrinsic function PRESENT or as an argument of a function
<P>
               reference that is a constant expression.
<P>
        (5) A designator with it as the base object and with one or more subobject selectors shall not be supplied
<P>
               as an actual argument.
<P>
        (6) If it is an array, it shall not be supplied as an actual argument to an elemental procedure unless an
<P>
               array of the same rank is supplied as an actual argument corresponding to a nonoptional dummy
<P>
               argument of that elemental procedure.
<P>
        (7) If it is a pointer, it shall not be allocated, deallocated, nullified, pointer-assigned, or supplied as an
<P>
               actual argument corresponding to an optional nonpointer dummy argument.
<P>
        (8) If it is allocatable, it shall not be allocated, deallocated, or supplied as an actual argument corres-
<P>
               ponding to an optional nonallocatable dummy argument.
<P>
        (9) If it has length type parameters, they shall not be the subject of an inquiry.
<P>
        (10) It shall not be used as the selector in an ASSOCIATE, SELECT RANK, or SELECT TYPE construct.
<P>
        (11) It shall not be supplied as the data-ref in a procedure-designator.
<P>
        (12) If shall not be supplied as the scalar-variable in a proc-component-ref .
<P>
</PRE>
4 Except as noted in the list above, it may be supplied as an actual argument corresponding to an optional dummy
<P>
<PRE>
  argument, which is then also considered not to be present.
<P>
  15.5.2.13    Restrictions on entities associated with dummy arguments
<P>
</PRE>
1 While an entity is associated with a dummy argument, the following restrictions hold.
<P>
<PRE>
        (1)    Action that affects the allocation status of the entity or a subobject thereof shall be taken through
<P>
               the dummy argument.
<P>
        (2)    If the allocation status of the entity or a subobject thereof is affected through the dummy argument,
<P>
               then at any time during the invocation and execution of the procedure, either before or after the
<P>
               allocation or deallocation, it shall be referenced only through the dummy argument.
<P>
        (3)    Action that affects the value of the entity or any subobject of it shall be taken only through the
<P>
               dummy argument unless
<P>
               (a)     the dummy argument has the POINTER attribute,
<P>
               (b)     the dummy argument is a scalar, assumed-shape, or assumed-rank object, and has the TAR-
<P>
                       GET attribute but not the INTENT (IN) or CONTIGUOUS attributes, and the actual argu-
<P>
                       ment is a target other than a coindexed object or an array section with a vector subscript,
<P>
               (c)     the dummy argument is an assumed-rank object with the TARGET attribute and not the
<P>
                       INTENT (IN) attribute, and the actual argument is a scalar target, or
<P>
               (d)     the dummy argument is a coarray and the action is a coindexed definition of the corresponding
<P>
                       ultimate argument coarray by a different image.
<P>
        (4)    If the value of the entity or any subobject of it is affected through the dummy argument, then at
<P>
               any time during the invocation and execution of the procedure, either before or after the definition,
<P>
               it may be referenced only through that dummy argument unless
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
321
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
            (a)  the dummy argument has the POINTER attribute,
<P>
            (b)  the dummy argument is a scalar, assumed-shape, or assumed-rank object, and has the TAR-
<P>
                 GET attribute but not the INTENT (IN) or CONTIGUOUS attributes, and the actual argu-
<P>
                 ment is a target other than a coindexed object or an array section with a vector subscript,
<P>
            (c)  the dummy argument is an assumed-rank object with the TARGET attribute and not the
<P>
                 INTENT (IN) attribute, and the actual argument is a scalar target, or
<P>
            (d)  the dummy argument is a coarray and the reference is a coindexed reference of its corresponding
<P>
                 ultimate argument coarray by a different image.
<P>
</PRE>
NOTE 15.33
<TABLE width=100% cellpadding=3><!-- tsb: NOTE 15.33
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
In
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE OUTER</H4>
</A>
<BLOCKQUOTE>
<P>
REAL, POINTER :: A (:)
<P>
&#46;&#46;&#46;
<P>
ALLOCATE (A (1:N))
<P>
&#46;&#46;&#46;
<P>
CALL INNER (A)
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE INNER (B)
<P>
<PRE>
                   REAL :: B (:)
<P>
                   &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE INNER</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE SET (C, D)
<P>
<PRE>
                   REAL, INTENT (OUT) :: C
<P>
                   REAL, INTENT (IN) :: D
<P>
                   C = D
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SET</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE OUTER</H4>
</A>
<BLOCKQUOTE>
<P>
an assignment statement such as
<P>
<PRE>
             A (1) = 1.0
<P>
</PRE>
would not be permitted during the execution of INNER because this would be changing A without using
<P>
B, but statements such as
<P>
<PRE>
             B (1) = 1.0
<P>
</PRE>
or
<P>
<PRE>
             CALL SET (B (1), 1.0)
<P>
</PRE>
would be allowed. Similarly,
<P>
<PRE>
             DEALLOCATE (A)
<P>
</PRE>
would not be allowed because this affects the allocation of B without using B. In this case,
<P>
<PRE>
             DEALLOCATE (B)
<P>
</PRE>
also would not be permitted. If B were declared with the POINTER attribute, either of the statements
<P>
<PRE>
             DEALLOCATE (A)
<P>
</PRE>
and
<P>
<PRE>
             DEALLOCATE (B)
<P>
</PRE>
would be permitted, but not both.
<TABLE cellpadding=3><!-- tsb: would be permitted, but not both.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>322</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 15.34
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
If there is a partial or complete overlap between the effective arguments of two different dummy arguments
<P>
of the same procedure and the dummy arguments have neither the POINTER nor TARGET attribute,
<P>
the overlapped portions cannot be defined, redefined, or become undefined during the execution of the
<P>
procedure. For example, in
<P>
<PRE>
             CALL SUB (A (1:5), A (3:9))
<P>
</PRE>
the array section A (3:5) cannot be defined, redefined, or become undefined through the first dummy
<P>
argument because it is part of the argument associated with the second dummy argument and cannot be
<P>
defined, redefined, or become undefined through the second dummy argument because it is part of the
<P>
argument associated with the first dummy argument. The array section A (1:2) remains definable through
<P>
the first dummy argument and A (6:9) remains definable through the second dummy argument.
<P>
This restriction applies equally to pointer targets. In
<P>
<PRE>
             REAL, DIMENSION (10), TARGET :: A
<P>
             REAL, DIMENSION (:), POINTER :: B, C
<P>
             B =&gt; A (1:5)
<P>
             C =&gt; A (3:9)
<P>
             CALL SUB (B, C) ! The dummy arguments of SUB are neither pointers nor targets.
<P>
</PRE>
the array section B (3:5) cannot be defined because it is part of the argument associated with the second
<P>
dummy argument. The array section C (1:3) cannot be defined because it is part of the argument associated
<P>
with the first dummy argument. The array section A (1:2), which is associated with B (1:2), remains
<P>
definable through the first dummy argument and A (6:9), which is associated with C (4:7), remains definable
<P>
through the second dummy argument.
<P>
NOTE 15.35
<P>
In
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE DATA</H4>
</A>
<BLOCKQUOTE>
<P>
REAL :: W, X, Y, Z
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE DATA</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM MAIN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE DATA</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
CALL INIT (X)
<P>
<PRE>
                    &#46;&#46;&#46;
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM MAIN</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE INIT (V)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE DATA</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
READ (*, *) V
<P>
<PRE>
                    &#46;&#46;&#46;
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE INIT</H4>
</A>
<BLOCKQUOTE>
<P>
variable X cannot be directly referenced at any time during the execution of INIT because it is being defined
<P>
through the dummy argument V. X can be (indirectly) referenced through V. W, Y, and Z can be directly
<P>
referenced. X can, of course, be directly referenced once execution of INIT is complete.
<P>
NOTE 15.36
<P>
The restrictions on entities associated with dummy arguments are intended to facilitate a variety of optim-
<P>
izations in the translation of the subprogram, including implementations of argument association in which
<P>
the value of an actual argument that is neither a pointer nor a target is maintained in a register or in local
<P>
storage.
</BLOCKQUOTE>
<P>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
323
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 15.37
<P>
        The exception to the aliasing restrictions for dummy coarrays enables cross-image access while the procedure
<P>
        is executing. Because nonatomic accesses from different images typically need to be separated by an image
<P>
        control statement, code optimization within segments is not unduly inhibited.
<P>
  15.5.3       Function reference
<P>
</PRE>
1 A function is invoked during expression evaluation by a function-reference or by a defined operation (10.1.6).
<P>
<PRE>
  When it is invoked, all actual argument expressions are evaluated, then the arguments are associated, and then
<P>
  the function is executed. When execution of the function is complete, the value of the function result is available
<P>
  for use in the expression that caused the function to be invoked. The characteristics of the function result (15.3.3)
<P>
  are determined by the interface of the function. If a reference to an elemental function (15.8) is an elemental
<P>
  reference, all array arguments shall have the same shape.
<P>
  15.5.4       Subroutine reference
<P>
</PRE>
1 A subroutine is invoked by execution of a CALL statement, execution of a defined assignment statement (10.2.1.4),
<P>
<PRE>
  defined input/output (12.6.4.8.3), or finalization(7.5.6). When a subroutine is invoked, all actual argument
<P>
  expressions are evaluated, then the arguments are associated, and then the subroutine is executed. When the
<P>
  actions specified by the subroutine are completed, the execution of the CALL statement, the execution of the
<P>
  defined assignment statement, the processing of an input or output list item, or finalization of an object is
<P>
  also completed. If a CALL statement includes one or more alternate return specifiers among its arguments, a branch to one
<P>
  of the statements indicated might occur, depending on the action specified by the subroutine. If a reference to an elemental
<P>
  subroutine (15.8) is an elemental reference, at least one actual argument shall correspond to an INTENT (OUT)
<P>
  or INTENT (INOUT) dummy argument, all such actual arguments shall be arrays, and all actual arguments
<P>
  shall be conformable.
<P>
  15.5.5       Resolving named procedure references
<P>
  15.5.5.1     Establishment of procedure names
<P>
</PRE>
1 The rules for interpreting a procedure reference depend on whether the procedure name in the reference is
<P>
<PRE>
  established by the available declarations and specifications to be generic in the scoping unit containing the
<P>
  reference, is established to be only specific in the scoping unit containing the reference, or is not established.
<P>
</PRE>
2 A procedure name is established to be generic in a scoping unit
<P>
<PRE>
          (1)   if that scoping unit contains an interface block with that name;
<P>
          (2)   if that scoping unit contains a GENERIC statement with a generic-spec that is that name;
<P>
          (3)   if that scoping unit contains an INTRINSIC attribute specification for that name and it is the generic
<P>
                name of an intrinsic procedure;
<P>
          (4)   if that scoping unit contains a USE statement that makes that procedure name accessible and the
<P>
                corresponding name in the module is established to be generic; or
<P>
          (5)   if that scoping unit contains no declarations of that name, that scoping unit has a host scoping unit,
<P>
                and that name is established to be generic in the host scoping unit.
<P>
</PRE>
3 A procedure name is established to be only specific in a scoping unit if it is established to be specific and not
<P>
<PRE>
  established to be generic. It is established to be specific
<P>
          (1)   if that scoping unit contains a module subprogram, internal subprogram, or statement function statement
<P>
                that defines a procedure with that name;
<P>
          (2)   if that scoping unit is of a subprogram that defines a procedure with that name;
<P>
          (3)   if that scoping unit contains an INTRINSIC attribute specification for that name and it is the name of a specific
<P>
                intrinsic procedure;
<P>
          (4)   if that scoping unit contains an explicit EXTERNAL attribute specification for that name;
<P>
  324                                                                       ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
         (5)    if that scoping unit contains a USE statement that makes that procedure name accessible and the
<P>
                corresponding name in the module is established to be specific; or
<P>
         (6)    if that scoping unit contains no declarations of that name, that scoping unit has a host scoping unit,
<P>
                and that name is established to be specific in the host scoping unit.
<P>
</PRE>
4 A procedure name is not established in a scoping unit if it is neither established to be generic nor established to
<P>
<PRE>
  be specific.
<P>
  15.5.5.2    Resolving procedure references to names established to be generic
<P>
</PRE>
1 If the reference is consistent with a nonelemental reference to one of the specific interfaces of a generic interface
<P>
<PRE>
  that has that name and either is defined in the scoping unit in which the reference appears or is made accessible
<P>
  by a USE statement in the scoping unit, the reference is to the specific procedure in the interface block that
<P>
  provides that interface. The rules in 15.4.3.4.5 ensure that there can be at most one such specific procedure.
<P>
</PRE>
2 Otherwise, if the reference is consistent with an elemental reference to one of the specific interfaces of a generic
<P>
<PRE>
  interface that has that name and either is defined in the scoping unit in which the reference appears or is made
<P>
  accessible by a USE statement in the scoping unit, the reference is to the specific elemental procedure in the
<P>
  interface block that provides that interface. The rules in 15.4.3.4.5 ensure that there can be at most one such
<P>
  specific elemental procedure.
<P>
</PRE>
3 Otherwise, if the scoping unit contains either an INTRINSIC attribute specification for that name or a USE
<P>
<PRE>
  statement that makes that name accessible from a module in which the corresponding name is specified to have
<P>
  the INTRINSIC attribute, and if the reference is consistent with the interface of that intrinsic procedure, the
<P>
  reference is to that intrinsic procedure.
<P>
</PRE>
4 Otherwise, if the scoping unit has a host scoping unit, the name is established to be generic in that host scoping
<P>
<PRE>
  unit, and there is agreement between the scoping unit and the host scoping unit as to whether the name is a
<P>
  function name or a subroutine name, the name is resolved by applying the rules in this subclause to the host
<P>
  scoping unit as if the reference appeared there.
<P>
</PRE>
5 Otherwise, if the name is that of an intrinsic procedure and the reference is consistent with that intrinsic procedure,
<P>
<PRE>
  the reference is to that intrinsic procedure.
<P>
       NOTE 15.38
<P>
       Because of the renaming facility of the USE statement, the name in the reference can be different from the
<P>
       usual name of the intrinsic procedure.
<P>
       NOTE 15.39
<P>
       These rules allow particular specific procedures with the same generic identifier to be used for particular
<P>
       array ranks and a general elemental version to be used for other ranks. For example, given an interface
<P>
       block such as
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE RANF</H4>
</A>
<BLOCKQUOTE>
<P>
ELEMENTAL FUNCTION <B>SCALAR_RANF</B>(X)
<P>
<PRE>
                         REAL, INTENT(IN) :: X
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION SCALAR_RANF</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION <B>VECTOR_RANDOM</B>(X)
<P>
<PRE>
                         REAL X(:)
<P>
                         REAL VECTOR_RANDOM(SIZE(X))
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION VECTOR_RANDOM</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE RANF</H4>
</A>
<BLOCKQUOTE>
<P>
and a declaration such as:
<P>
<PRE>
                 REAL A(10,10), AA(10,10)
<P>
</PRE>
then the statement
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: then the statement
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
325
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
        NOTE 15.39 (cont.)
<P>
                  A = RANF(AA)
<P>
        is an elemental reference to SCALAR_RANF. The statement
<P>
                  A(6:10,2) = RANF(AA(6:10,2))
<P>
        is a nonelemental reference to VECTOR_RANDOM.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>15.5.5.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Resolving procedure references to names established to be only specific
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 If the name has the EXTERNAL attribute,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • if it is a procedure pointer, the reference is to its target;
<P>
      • if it is a dummy procedure that is not a procedure pointer, the reference is to the effective argument
<P>
         corresponding to that name;
<P>
      • otherwise, the reference is to the external procedure with that name.
<P>
</PRE>
2 If the name is that of an accessible external procedure, internal procedure, module procedure, intrinsic procedure,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  or statement function, the reference is to that procedure.
<P>
        NOTE 15.40
<P>
        Because of the renaming facility of the USE statement, the name in the reference can be different from the
<P>
        original name of the procedure.
<P>
  15.5.5.4     Resolving procedure references to names not established
<P>
</PRE>
1 If the name is the name of a dummy argument of the scoping unit, the dummy argument is a dummy procedure
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and the reference is to that dummy procedure. That is, the procedure invoked by executing that reference is the
<P>
  effective argument corresponding to that dummy procedure.
<P>
</PRE>
2 Otherwise, if the name is the name of an intrinsic procedure, and if there is agreement between the reference and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the status of the intrinsic procedure as being a function or subroutine, the reference is to that intrinsic procedure.
<P>
</PRE>
3 Otherwise, the reference is to an external procedure with that name.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  15.5.6       Resolving type-bound procedure references
<P>
</PRE>
1 If the binding-name in a procedure-designator (R1522) is that of a specific type-bound procedure, the procedure
</TD></TR>
<TR><TD colspan=2>
<PRE>
  referenced is the one bound to that name in the dynamic type of the data-ref .
<P>
</PRE>
2 If the binding-name in a procedure-designator is that of a generic type bound procedure, the generic binding with
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that name in the declared type of the data-ref is used to select a specific binding using the following criteria.
<P>
      • If the reference is consistent with one of the specific bindings of that generic binding, that specific binding
<P>
         is selected.
<P>
      • Otherwise, the reference shall be consistent with an elemental reference to one of the specific bindings of
<P>
         that generic binding; that specific binding is selected.
<P>
</PRE>
3 The reference is to the procedure bound to the same name as the selected specific binding in the dynamic type
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of the data-ref .
<P>
  326                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
<P>
  15.6        Procedure definition
<P>
  15.6.1      Intrinsic procedure definition
<P>
</PRE>
1 Intrinsic procedures are defined as an inherent part of the processor. A standard-conforming processor shall
</TD></TR>
<TR><TD colspan=2>
<PRE>
  include the intrinsic procedures described in Clause 16, but may include others. However, a standard-conforming
<P>
  program shall not make use of intrinsic procedures other than those described in Clause 16.
<P>
  15.6.2      Procedures defined by subprograms
<P>
  15.6.2.1     General
<P>
</PRE>
1 A procedure is defined by the initial SUBROUTINE or FUNCTION statement of a subprogram, and each ENTRY
</TD></TR>
<TR><TD colspan=2>
<PRE>
  statement defines an additional procedure (15.6.2.6).
<P>
</PRE>
2 A subprogram is specified to have the NON_RECURSIVE attribute, or to be elemental (15.8), pure (15.7), or a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  separate module subprogram (15.6.2.5) by a prefix in its initial SUBROUTINE or FUNCTION statement.
<P>
  R1526 prefix                               is   prefix-spec [ prefix-spec ] &#46;&#46;&#46;
<P>
  R1527 prefix-spec                          is   declaration-type-spec
<P>
                                             or   ELEMENTAL
<P>
                                             or   IMPURE
<P>
                                             or   MODULE
<P>
                                             or   NON_RECURSIVE
<P>
                                             or   PURE
<P>
                                             or   RECURSIVE
<P>
  C1543 (R1526) A prefix shall contain at most one of each prefix-spec.
<P>
  C1544 (R1526) A prefix shall not specify both PURE and IMPURE.
<P>
  C1545 (R1526) A prefix shall not specify both NON_RECURSIVE and RECURSIVE.
<P>
  C1546 An elemental procedure shall not have the BIND attribute.
<P>
  C1547 (R1526) MODULE shall appear only in the function-stmt or subroutine-stmt of a module subprogram or
<P>
           of a nonabstract interface body that is declared in the scoping unit of a module or submodule.
<P>
  C1548 (R1526) If MODULE appears in the prefix of a module subprogram, it shall have been declared to be a
<P>
           separate module procedure in the containing program unit or an ancestor of that program unit.
<P>
  C1549 (R1526) If MODULE appears in the prefix of a module subprogram, the subprogram shall specify the
<P>
           same characteristics and dummy argument names as its corresponding module procedure interface body.
<P>
  C1550 (R1526) If MODULE appears in the prefix of a module subprogram and a binding label is specified, it
<P>
           shall be the same as the binding label specified in the corresponding module procedure interface body.
<P>
  C1551 (R1526) If MODULE appears in the prefix of a module subprogram, NON_RECURSIVE shall appear
<P>
           if and only if NON_RECURSIVE appears in the prefix in the corresponding module procedure interface
<P>
           body.
<P>
</PRE>
3 The NON_RECURSIVE prefix-spec shall not appear if any procedure defined by the subprogram directly or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  indirectly invokes itself or any other procedure defined by the subprogram. If a subprogram defines a function whose name is
<P>
  declared with an asterisk type-param-value, no procedure defined by the subprogram shall directly or indirectly invoke itself or any
<P>
  other procedure defined by the subprogram.
<P>
</PRE>
4 If the prefix-spec PURE appears, or the prefix-spec ELEMENTAL appears and IMPURE does not appear, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  subprogram is a pure subprogram and shall meet the additional constraints of 15.7.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                          327
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 If the prefix-spec ELEMENTAL appears, the subprogram is an elemental subprogram and shall meet the additional
</TD></TR>
<TR><TD colspan=2>
<PRE>
  constraints of 15.8.1.
<P>
  R1528 proc-language-binding-spec        is   language-binding-spec
<P>
</PRE>
6 A proc-language-binding-spec specifies that the procedure defined or declared by the statement is interoperable
</TD></TR>
<TR><TD colspan=2>
<PRE>
  (18.3.7).
<P>
  C1552 A proc-language-binding-spec with a NAME= specifier shall not be specified in the function-stmt or
<P>
            subroutine-stmt of an internal procedure, or of an interface body for an abstract interface or a dummy
<P>
            procedure.
<P>
  C1553 If proc-language-binding-spec is specified for a function, the function result shall be an interoperable scalar
<P>
            variable.
<P>
  C1554 If proc-language-binding-spec is specified for a procedure, each of its dummy arguments shall be an inter-
<P>
            operable procedure (18.3.7) or a variable that is interoperable (18.3.5, 18.3.6), assumed-shape, assumed-
<P>
            rank, assumed-type, of type CHARACTER with assumed length, or that has the ALLOCATABLE or
<P>
            POINTER attribute.
<P>
  C1555 A variable that is a dummy argument of a procedure that has a proc-language-binding-spec shall be
<P>
            assumed-type or of interoperable type and kind type parameters.
<P>
  C1556 If proc-language-binding-spec is specified for a procedure, it shall not have a default-initialized dummy
<P>
            argument with the ALLOCATABLE or POINTER attribute.
<P>
  C1557 If proc-language-binding-spec is specified for a procedure, it shall not have a dummy argument that is a
<P>
            coarray.
<P>
  C1558 If proc-language-binding-spec is specified for a procedure, it shall not have an array dummy argument
<P>
            with the VALUE attribute.
<P>
  15.6.2.2     Function subprogram
<P>
</PRE>
1 A function subprogram is a subprogram that has a FUNCTION statement as its first statement.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1529 function-subprogram               is   function-stmt
<P>
                                                     [ specification-part ]
<P>
                                                     [ execution-part ]
<P>
                                                     [ internal-subprogram-part ]
<P>
                                                     end-function-stmt
<P>
  R1530 function-stmt                     is   [ prefix ] FUNCTION function-name
<P>
                                                  ( [ dummy-arg-name-list ] ) [ suffix ]
<P>
  C1559 (R1530) If RESULT appears, result-name shall not be the same as function-name and shall not be the same
<P>
            as the entry-name in any ENTRY statement in the subprogram.
<P>
  C1560 (R1530) If RESULT appears, the function-name shall not appear in any specification statement in the
<P>
            scoping unit of the function subprogram.
<P>
  R1531 dummy-arg-name                    is   name
<P>
  C1561 (R1531) A dummy-arg-name shall be the name of a dummy argument.
<P>
  R1532 suffix                            is proc-language-binding-spec [ RESULT ( result-name ) ]
<P>
                                          or RESULT ( result-name ) [ proc-language-binding-spec ]
<P>
  R1533 end-function-stmt                 is   END [ FUNCTION [ function-name ] ]
<P>
  328                                                                     ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1562 (R1529) An internal function subprogram shall not contain an internal-subprogram-part.
<P>
  C1563 (R1533) If a function-name appears in the end-function-stmt, it shall be identical to the function-name
<P>
           specified in the function-stmt.
<P>
</PRE>
2 The name of the function is function-name.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 The type and type parameters (if any) of the result of the function defined by a function subprogram may be
<P>
<PRE>
  specified by a type specification in the FUNCTION statement or by the name of the function result appearing
<P>
  in a type declaration statement in the specification part of the function subprogram. They shall not be specified
<P>
  both ways. If they are not specified either way, they are determined by the implicit typing rules in effect within
<P>
  the function subprogram. If the function result is an array, allocatable, or a pointer, this shall be specified by
<P>
  specifications of the name of the function result within the function body. The specifications of the function
<P>
  result attributes, the specification of dummy argument attributes, and the information in the procedure heading
<P>
  collectively define the characteristics of the function (15.3.1).
<P>
</PRE>
4 If RESULT appears, the name of the function result of the function is result-name and all occurrences of the
<P>
<PRE>
  function name in execution-part statements in its scope refer to the function itself. If RESULT does not appear,
<P>
  the name of the function result is function-name and all occurrences of the function name in execution-part
<P>
  statements in its scope are references to the function result. On completion of execution of the function, the value
<P>
  returned is that of its function result. If the function result is a data pointer, the shape of the value returned by
<P>
  the function is determined by the shape of the function result when the execution of the function is completed. If
<P>
  the function result is not a pointer, its value shall be defined by the function. If the function result is a pointer,
<P>
  on return the pointer association status of the function result shall not be undefined.
<P>
        NOTE 15.41
<P>
       The function result is similar to any other entity (variable or procedure pointer) local to a function sub-
<P>
       program. Its existence begins when execution of the function is initiated and ends when execution of the
<P>
       function is terminated. However, because the final value of this entity is used subsequently in the evaluation
<P>
       of the expression that invoked the function, an implementation might defer releasing the storage occupied
<P>
       by that entity until after its value has been used in expression evaluation.
<P>
        NOTE 15.42
<P>
       The following is an example of the declaration of an interface body with the BIND attribute, and a reference
<P>
       to the procedure declared.
<P>
       USE, INTRINSIC :: ISO_C_BINDING
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION JOE (I, J, R) <B>BIND</B>(C,NAME="FrEd")
<P>
<PRE>
             USE, INTRINSIC :: ISO_C_BINDING
<P>
             INTEGER(C_INT) :: JOE
<P>
             INTEGER(C_INT), VALUE :: I, J
<P>
             REAL(C_FLOAT), VALUE :: R
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION JOE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
INT = <B>JOE</B>(1_C_INT, 3_C_INT, 4.0_C_FLOAT)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM</H4>
</A>
<BLOCKQUOTE>
<P>
The invocation of the function JOE results in a reference to a function with a binding label "FrEd". FrEd
<P>
could be a C function described by the C prototype
<P>
<PRE>
          int FrEd(int n, int m, float x);
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
329
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>15.6.2.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Subroutine subprogram
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 A subroutine subprogram is a subprogram that has a SUBROUTINE statement as its first statement.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  R1534 subroutine-subprogram               is   subroutine-stmt
<P>
                                                      [ specification-part ]
<P>
                                                      [ execution-part ]
<P>
                                                      [ internal-subprogram-part ]
<P>
                                                      end-subroutine-stmt
<P>
  R1535 subroutine-stmt                     is   [ prefix ] SUBROUTINE subroutine-name
<P>
                                                    [ ( [ dummy-arg-list ] ) [ proc-language-binding-spec ] ]
<P>
  C1564 (R1535) The prefix of a subroutine-stmt shall not contain a declaration-type-spec.
<P>
  R1536 dummy-arg                           is dummy-arg-name
<P>
                                            or *
<P>
  R1537 end-subroutine-stmt                 is   END [ SUBROUTINE [ subroutine-name ] ]
<P>
  C1565 (R1534) An internal subroutine subprogram shall not contain an internal-subprogram-part.
<P>
  C1566 (R1537) If a subroutine-name appears in the end-subroutine-stmt, it shall be identical to the subroutine-
<P>
           name specified in the subroutine-stmt.
<P>
</PRE>
2 The name of the subroutine is subroutine-name.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  15.6.2.4   Instances of a subprogram
<P>
</PRE>
1 When a procedure defined by a subprogram is invoked, an instance of that subprogram is created. Each instance
</TD></TR>
<TR><TD colspan=2>
<PRE>
  has an independent sequence of execution and an independent set of dummy arguments, unsaved local variables,
<P>
  and unsaved local procedure pointers. Saved local entities are shared by all instances of the subprogram.
<P>
</PRE>
2 When a statement function is invoked, an instance of that statement function is created.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 When execution of an instance completes it ceases to exist.
<P>
4 The caller of an instance of a procedure is the instance of the main program, subprogram, or statement function
<P>
<PRE>
  that invoked it. The call sequence of an instance of a procedure is its caller, followed by the call sequence of its
<P>
  caller. The call sequence of the main program is empty. The host instance of an instance of a statement function
<P>
  or an internal procedure that is invoked by its name is the first element of the call sequence that is an instance
<P>
  of the host of the statement function or internal subprogram. The host instance of an internal procedure that is
<P>
  invoked via a dummy procedure or procedure pointer is the host instance of the associating entity from when the
<P>
  argument association or pointer association was established (19.5.5). The host instance of a module procedure is
<P>
  the module or submodule in which it is defined. A main program or external subprogram has no host instance.
<P>
  15.6.2.5   Separate module procedures
<P>
</PRE>
1 A separate module procedure is a module procedure defined by a separate-module-subprogram, by a function-
<P>
<PRE>
  subprogram whose initial statement contains the keyword MODULE, or by a subroutine-subprogram whose initial
<P>
  statement contains the keyword MODULE.
<P>
  R1538 separate-module-subprogram is            mp-subprogram-stmt
<P>
                                                      [ specification-part ]
<P>
                                                      [ execution-part ]
<P>
                                                      [ internal-subprogram-part ]
<P>
                                                      end-mp-subprogram-stmt
<P>
  R1539 mp-subprogram-stmt                  is   MODULE PROCEDURE procedure-name
<P>
  330                                                                       ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
  R1540 end-mp-subprogram-stmt                is   END [PROCEDURE [procedure-name]]
<P>
  C1567 (R1538) The procedure-name shall have been declared to be a separate module procedure in the containing
<P>
            program unit or an ancestor of that program unit.
<P>
  C1568 (R1540) If a procedure-name appears in the end-mp-subprogram-stmt, it shall be identical to the procedure-
<P>
            name in the mp-subprogram-stmt.
<P>
</PRE>
2 A separate module procedure shall not be defined more than once.
<P>
3 The interface of a procedure defined by a separate-module-subprogram is explicitly declared by the mp-subprogram-
<P>
<PRE>
  stmt to be the same as its module procedure interface body. It has the NON_RECURSIVE attribute if and only
<P>
  if it was declared to have that attribute by the interface body. If it is a function its result name is determined
<P>
  by the FUNCTION statement in the interface body.
<P>
        NOTE 15.43
<P>
        A separate module procedure can be accessed by use association only if its interface body is declared in the
<P>
        specification part of a module and is public.
<P>
  15.6.2.6     ENTRY statement
<P>
</PRE>
1 An ENTRY statement permits a procedure reference to begin with a particular executable statement within the function or subroutine
<P>
<PRE>
  subprogram in which the ENTRY statement appears.
<P>
  R1541     entry-stmt                        is   ENTRY entry-name [ ( [ dummy-arg-list ] ) [ suffix ] ]
<P>
  C1569     (R1541) If RESULT appears, the entry-name shall not appear in any specification or type declaration statement in the
<P>
            scoping unit of the function program.
<P>
  C1570     (R1541) An entry-stmt shall appear only in an external-subprogram or a module-subprogram that does not define a separate
<P>
            module procedure. An entry-stmt shall not appear within an executable-construct.
<P>
  C1571     (R1541) RESULT shall appear only if the entry-stmt is in a function subprogram.
<P>
  C1572     (R1541) A dummy-arg shall not be an alternate return indicator if the ENTRY statement is in a function subprogram.
<P>
  C1573     (R1541) If RESULT appears, result-name shall not be the same as the function-name in the FUNCTION statement and
<P>
            shall not be the same as the entry-name in any ENTRY statement in the subprogram.
<P>
</PRE>
2 Optionally, a subprogram may have one or more ENTRY statements.
<P>
3 If the ENTRY statement is in a function subprogram, an additional function is defined by that subprogram. The name of the
<P>
<PRE>
  function is entry-name and the name of its result is result-name or is entry-name if no result-name is provided. The dummy
<P>
  arguments of the function are those specified in the ENTRY statement. If the characteristics of the result of the function named in
<P>
  the ENTRY statement are the same as the characteristics of the result of the function named in the FUNCTION statement, their
<P>
  result names identify the same entity, although their names need not be the same. Otherwise, they are storage associated and shall
<P>
  all be nonpointer, nonallocatable scalar variables that are default integer, default real, double precision real, default complex, or
<P>
  default logical.
<P>
</PRE>
4 If the ENTRY statement is in a subroutine subprogram, an additional subroutine is defined by that subprogram. The name of the
<P>
<PRE>
  subroutine is entry-name. The dummy arguments of the subroutine are those specified in the ENTRY statement.
<P>
</PRE>
5 The order, number, types, kind type parameters, and names of the dummy arguments in an ENTRY statement may differ from the
<P>
<PRE>
  order, number, types, kind type parameters, and names of the dummy arguments in the FUNCTION or SUBROUTINE statement
<P>
  in the containing subprogram.
<P>
</PRE>
6 Because an ENTRY statement defines an additional function or an additional subroutine, it is referenced in the same manner as any
<P>
<PRE>
  other function or subroutine (15.5).
<P>
</PRE>
7 In a subprogram, a dummy argument specified in an ENTRY statement shall not appear in an executable statement preceding that
<P>
<PRE>
  ENTRY statement, unless it also appears in a FUNCTION, SUBROUTINE, or ENTRY statement that precedes the executable
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                           331
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
   statement. A function result specified by a result-name in an ENTRY statement shall not appear in any executable statement that
<P>
   precedes the first RESULT clause with that name.
<P>
</PRE>
8 In a subprogram, a dummy argument specified in an ENTRY statement shall not appear in the expression of a statement function
<P>
<PRE>
   that precedes the first dummy-arg with that name in the subprogram. A function result specified by a result-name in an ENTRY
<P>
   statement shall not appear in the expression of a statement function that precedes the first RESULT clause with that name.
<P>
</PRE>
9 If a dummy argument appears in an executable statement, the execution of the executable statement is permitted during the
<P>
<PRE>
   execution of a reference to the function or subroutine only if the dummy argument appears in the dummy argument list of the
<P>
   referenced procedure.
<P>
</PRE>
10 If a dummy argument is used in a specification expression to specify an array bound or character length of an object, the appearance
<P>
<PRE>
   of the object in a statement that is executed during a procedure reference is permitted only if the dummy argument appears in the
<P>
   dummy argument list of the referenced procedure and it is present (15.5.2.12).
<P>
</PRE>
11 The NON_RECURSIVE and RECURSIVE keywords are not used in an ENTRY statement. Instead, the presence or absence of
<P>
<PRE>
   NON_RECURSIVE in the initial SUBROUTINE or FUNCTION statement controls whether the procedure defined by an ENTRY
<P>
   statement is permitted to reference itself or another procedure defined by the subprogram.
<P>
</PRE>
12 The keywords PURE and IMPURE are not used in an ENTRY statement. Instead, the procedure defined by an ENTRY statement
<P>
<PRE>
   is pure if and only if the subprogram is a pure subprogram.
<P>
</PRE>
13 The keyword ELEMENTAL is not used in an ENTRY statement. Instead, the procedure defined by an ENTRY statement is elemental
<P>
<PRE>
   if and only if ELEMENTAL is specified in the SUBROUTINE or FUNCTION statement.
<P>
   15.6.2.7      RETURN statement
<P>
   R1542 return-stmt                            is   RETURN [ scalar-int-expr ]
<P>
   C1574 (R1542) The return-stmt shall be in the inclusive scope of a function or subroutine subprogram.
<P>
   C1575 (R1542) The scalar-int-expr is allowed only in the inclusive scope of a subroutine subprogram.
<P>
</PRE>
1 Execution of the RETURN statement completes execution of the instance of the subprogram in which it appears.
<P>
<PRE>
   If the expression appears and has a value n between 1 and the number of asterisks in the dummy argument list, the CALL statement
<P>
   that invoked the subroutine branches (11.2) to the branch target statement identified by the nth alternate return specifier in the
<P>
   actual argument list of the referenced procedure. If the expression is omitted or has a value outside the required range, there is no
<P>
   transfer of control to an alternate return.
<P>
</PRE>
2 Execution of an end-function-stmt, end-mp-subprogram-stmt, or end-subroutine-stmt is equivalent to execution
<P>
<PRE>
   of a RETURN statement with no expression.
<P>
   15.6.2.8      CONTAINS statement
<P>
   R1543 contains-stmt                          is   CONTAINS
<P>
</PRE>
1 The CONTAINS statement separates the body of a main program, module, submodule, or subprogram from any
<P>
<PRE>
   internal or module subprograms it might contain, or it introduces the type-bound procedure part of a derived-type
<P>
   definition (7.5.5). The CONTAINS statement is not executable.
<P>
   15.6.3        Definition and invocation of procedures by means other than Fortran
<P>
</PRE>
1 A procedure may be defined by means other than Fortran. The interface of a procedure defined by means other
<P>
<PRE>
   than Fortran may be specified by an interface body or procedure declaration statement. A reference to such a
<P>
   procedure is made as though it were defined by an external subprogram.
<P>
</PRE>
2 A procedure defined by means other than Fortran that is invoked by a Fortran procedure and does not cause
<P>
<PRE>
   termination of execution shall return to its caller.
<P>
   332                                                                         ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
         NOTE 15.44
<P>
         Examples of code that might cause a transfer of control that bypasses the normal return mechanism of
<P>
         a Fortran procedure are setjmp and longjmp in C and exception handling in other languages. No such
<P>
         behavior is permitted by this document.
<P>
</PRE>
3 If the interface of a procedure has a proc-language-binding-spec, the procedure is interoperable (18.10).
<P>
4 Interoperation with C functions is described in 18.10.
<P>
<PRE>
         NOTE 15.45
<P>
         For explanatory information on definition of procedures by means other than Fortran, see subclause C.10.2.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>15.6.4</B> </TD><TD valign=bottom>
Statement function
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 A statement function is a function defined by a single statement.
<P>
<PRE>
  R1544      stmt-function-stmt                   is   function-name ( [ dummy-arg-name-list ] ) = scalar-expr
<P>
  C1576      (R1544) Each primary in scalar-expr shall be a constant (literal or named), a reference to a variable, a reference to a
<P>
             function, or an expression in parentheses. Each operation shall be intrinsic. If scalar-expr contains a reference to a
<P>
             function, the reference shall not require an explicit interface, the function shall not require an explicit interface unless it is
<P>
             an intrinsic function, the function shall not be a transformational intrinsic, and the result shall be scalar. If an argument to
<P>
             a function is an array, it shall be an array name. If a reference to a statement function appears in scalar-expr, its definition
<P>
             shall have been provided earlier in the scoping unit and shall not be the name of the statement function being defined.
<P>
  C1577      (R1544) Named constants in scalar-expr shall have been declared earlier in the scoping unit or made accessible by use
<P>
             or host association. If array elements appear in scalar-expr, the array shall have been declared as an array earlier in the
<P>
             scoping unit or made accessible by use or host association.
<P>
  C1578      (R1544) If a dummy-arg-name, variable, function reference, or dummy function reference is typed by the implicit typing
<P>
             rules, its appearance in any subsequent type declaration statement shall confirm this implied type and the values of any
<P>
             implied type parameters.
<P>
  C1579      (R1544) The function-name and each dummy-arg-name shall be specified, explicitly or implicitly, to be scalar.
<P>
  C1580      (R1544) A given dummy-arg-name shall not appear more than once in a given dummy-arg-name-list.
<P>
  C1581      A statement function shall not be of a parameterized derived type.
<P>
</PRE>
2 The definition of a statement function with the same name as an accessible entity from the host shall be preceded by the declaration
<P>
<PRE>
  of its type in a type declaration statement.
<P>
</PRE>
3 The dummy arguments have a scope of the statement function statement. Each dummy argument has the same type and type
<P>
<PRE>
  parameters as the entity of the same name in the scoping unit containing the statement function statement.
<P>
</PRE>
4 A statement function shall not be supplied as an actual argument.
<P>
5 Execution of a statement function consists of evaluating the expression using the values of the actual arguments for the values of the
<P>
<PRE>
  corresponding dummy arguments and, if necessary, converting the result to the declared type and type parameters of the function.
<P>
</PRE>
6 A function reference in the scalar expression shall not cause a dummy argument of the statement function to become redefined or
<P>
<PRE>
  undefined.
<P>
  15.7         Pure procedures
<P>
</PRE>
1 A pure procedure is
<P>
<PRE>
       • a pure intrinsic procedure (16.1),
<P>
       • a module procedure in an intrinsic module, if it is specified to be pure,
<P>
       • defined by a pure subprogram,
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
333
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
     • a dummy procedure that has been specified to be PURE, or
<P>
     • a statement function that references only pure functions and does not contain the designator of a variable with the VOLATILE
<P>
       attribute.
<P>
</PRE>
2 A pure subprogram is a subprogram that has the prefix-spec PURE or that has the prefix-spec ELEMENTAL
<P>
<PRE>
  and does not have the prefix-spec IMPURE. The following additional constraints apply to pure subprograms.
<P>
  C1582 The specification-part of a pure function subprogram shall specify that all its nonpointer dummy data
<P>
          objects have the INTENT (IN) or the VALUE attribute.
<P>
  C1583 The function result of a pure function shall not be such that finalization of a reference to the function
<P>
          would reference an impure procedure.
<P>
  C1584 The function result of a pure function shall not be both polymorphic and allocatable, or have a poly-
<P>
          morphic allocatable ultimate component.
<P>
  C1585 The specification-part of a pure subroutine subprogram shall specify the intents of all its nonpointer
<P>
          dummy data objects that do not have the VALUE attribute.
<P>
  C1586 An INTENT (OUT) dummy argument of a pure procedure shall not be such that finalization of the
<P>
          actual argument would reference an impure procedure.
<P>
  C1587 An INTENT (OUT) dummy argument of a pure procedure shall not be polymorphic or have a poly-
<P>
          morphic allocatable ultimate component.
<P>
  C1588 A local variable of a pure subprogram, or of a BLOCK construct within a pure subprogram, shall not
<P>
          have the SAVE or VOLATILE attribute.
<P>
      NOTE 15.46
<P>
      Variable initialization in a type-declaration-stmt or a data-stmt implies the SAVE attribute; therefore, such
<P>
      initialization is also disallowed.
<P>
  C1589 The specification-part of a pure subprogram shall specify that all its dummy procedures are pure.
<P>
  C1590 If a procedure that is neither an intrinsic procedure nor a statement function is used in a context that requires
<P>
          it to be pure, then its interface shall be explicit in the scope of that use. The interface shall specify that
<P>
          the procedure is pure.
<P>
  C1591 All internal subprograms in a pure subprogram shall be pure.
<P>
  C1592 A designator of a variable with the VOLATILE attribute shall not appear in a pure subprogram.
<P>
  C1593 In a pure subprogram any designator with a base object that is in common or accessed by host or use
<P>
          association, is a pointer dummy argument of a pure function, is a dummy argument with the INTENT
<P>
          (IN) attribute, is a coindexed object, or an object that is storage associated with any such variable, shall
<P>
          not be used
<P>
          (1)     in a variable definition context (19.6.7),
<P>
          (2)     in a pointer association context (19.6.8),
<P>
          (3)     as the data-target in a pointer-assignment-stmt,
<P>
          (4)     as the expr corresponding to a component in a structure-constructor if the component has the
<P>
                  POINTER attribute or has a pointer component at any level of component selection,
<P>
          (5)     as the expr of an intrinsic assignment statement in which the variable is of a derived type if the
<P>
                  derived type has a pointer component at any level of component selection,
<P>
          (6)     as the source-expr in a SOURCE= specifier if the designator is of a derived type that has a pointer
<P>
                  component at any level of component selection,
<P>
          (7)     as an actual argument corresponding to a dummy argument with the POINTER attribute, or
<P>
  334                                                                        ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
           (8)     as the actual argument to the function C_LOC from the intrinsic module ISO_C_BINDING.
<P>
       NOTE 15.47
<P>
       Item 5 requires that processors be able to determine if entities with the PRIVATE attribute or with private
<P>
       components have a pointer component.
<P>
  C1594 Any procedure referenced in a pure subprogram, including one referenced via a defined operation, defined
<P>
           assignment, defined input/output, or finalization, shall be pure.
<P>
  C1595 A statement that might result in the deallocation of a polymorphic entity is not permitted in a pure
<P>
           procedure.
<P>
       NOTE 15.48
<P>
       This includes intrinsic assignment to a variable that has a potential subobject component that is poly-
<P>
       morphic and allocatable.
<P>
  C1596 A pure subprogram shall not contain a print-stmt, open-stmt, close-stmt, backspace-stmt, endfile-stmt,
<P>
           rewind-stmt, flush-stmt, wait-stmt, or inquire-stmt.
<P>
  C1597 A pure subprogram shall not contain a read-stmt or write-stmt whose io-unit is a file-unit-number or *.
<P>
  C1598 A pure subprogram shall not contain an image control statement (11.6.1).
<P>
       NOTE 15.49
<P>
       The above constraints are designed to guarantee that a pure procedure is free from side effects (modifications
<P>
       of data visible outside the procedure), which means that it is safe to reference it in constructs such as DO
<P>
       CONCURRENT and FORALL, where there is no explicit order of evaluation.
<P>
       The constraints on pure subprograms appear to be complicated, but it is not necessary for a programmer
<P>
       to be intimately familiar with them. From the programmer’s point of view, these constraints can be
<P>
       summarized as follows: a pure subprogram cannot contain any operation that could conceivably result in
<P>
       an assignment or pointer assignment to a common variable, a variable accessed by use or host association, or an
<P>
       INTENT (IN) dummy argument; nor can a pure subprogram contain any operation that could conceivably
<P>
       perform any external file input/output or execute an image control statement (including a STOP statement).
<P>
       Note the use of the word conceivably; it is not sufficient for a pure subprogram merely to be side-effect
<P>
       free in practice. For example, a function that contains an assignment to a global variable but in a block
<P>
       that is not executed in any invocation of the function is nevertheless not a pure function. The exclusion of
<P>
       functions of this nature is required if strict compile-time checking is to be used.
<P>
       It is expected that most library procedures will conform to the constraints required of pure procedures, and
<P>
       so can be declared pure and referenced in DO CONCURRENT constructs, FORALL statements and constructs,
<P>
       and within user-defined pure procedures.
<P>
       NOTE 15.50
<P>
       Pure subroutines are included to allow subroutine calls from pure procedures in a safe way, and to allow
<P>
       forall-assignment-stmts to be defined assignments. The constraints for pure subroutines are based on the same
<P>
       principles as for pure functions, except that side effects to INTENT (OUT), INTENT (INOUT), and pointer
<P>
       dummy arguments are permitted.
<P>
  15.8        Elemental procedures
<P>
  15.8.1       Elemental procedure declaration and interface
<P>
</PRE>
1 An elemental procedure is an elemental intrinsic procedure or a procedure that is defined by an elemental sub-
<P>
<PRE>
  program. An elemental procedure has only scalar dummy arguments, but may have array actual arguments.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           335
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 An elemental subprogram has the prefix-spec ELEMENTAL. An elemental subprogram is a pure subprogram
<P>
<PRE>
  unless it has the prefix-spec IMPURE. The following additional constraints apply to elemental subprograms.
<P>
  C1599 All dummy arguments of an elemental procedure shall be scalar noncoarray dummy data objects and
<P>
            shall not have the POINTER or ALLOCATABLE attribute.
<P>
  C15100 The result of an elemental function shall be scalar, and shall not have the POINTER or ALLOCATABLE
<P>
            attribute.
<P>
  C15101 The specification-part of an elemental subprogram shall specify the intents of all of its dummy arguments
<P>
            that do not have the VALUE attribute.
<P>
  C15102 In the specification-expr that specifies a type parameter value of the result of an elemental function, an
<P>
            object designator with a dummy argument of the function as the base object shall appear only as the
<P>
            subject of a specification inquiry (10.1.11), and that specification inquiry shall not depend on a property
<P>
            that is deferred.
<P>
</PRE>
3 In a reference to an elemental procedure, if any argument is an array, each actual argument that corresponds to
<P>
<PRE>
  an INTENT (OUT) or INTENT (INOUT) dummy argument shall be an array. All actual arguments shall be
<P>
  conformable. An array actual argument is considered to be associated with the scalar dummy arguments of the
<P>
  procedure throughout the entire execution of the elemental reference; thus, the restrictions on actions specified
<P>
  in 15.5.2.13 apply to the entirety of the actual array argument.
<P>
  15.8.2      Elemental function actual arguments and results
<P>
</PRE>
1 If a generic name or a specific name is used to reference an elemental function, the shape of the result is the
<P>
<PRE>
  same as the shape of the actual argument with the greatest rank. If there are no actual arguments or the actual
<P>
  arguments are all scalar, the result is scalar. In the array case, the values of the elements, if any, of the result are
<P>
  the same as would have been obtained if the scalar function had been applied separately, in array element order,
<P>
  to corresponding elements of each array actual argument.
<P>
        NOTE 15.51
<P>
        An example of an elemental reference to the intrinsic function MAX:
<P>
        if X and Y are arrays of shape (M, N),
<P>
        MAX (X, 0.0, Y)
<P>
        is an array expression of shape (M, N) whose elements have values
<P>
        MAX (X(I, J),      0.0, Y(I, J)), I = 1, 2, &#46;&#46;&#46;, M, J = 1, 2, ..., N
<P>
  15.8.3      Elemental subroutine actual arguments
<P>
</PRE>
1 In a reference to an elemental subroutine, if the actual arguments corresponding to INTENT (OUT) and INTENT
<P>
<PRE>
  (INOUT) dummy arguments are arrays, the values of the elements, if any, of the results are the same as would
<P>
  be obtained if the subroutine had been applied separately, in array element order, to corresponding elements of
<P>
  each array actual argument.
<P>
  336                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
<P>
  16 Intrinsic procedures and modules
<P>
  16.1         Classes of intrinsic procedures
<P>
</PRE>
1 Intrinsic procedures are divided into eight classes: inquiry functions, elemental functions, transformational func-
<P>
<PRE>
  tions, elemental subroutines, pure subroutines, atomic subroutines, collective subroutines, and (impure) sub-
<P>
  routines.
<P>
</PRE>
2 An intrinsic inquiry function is one whose result depends on the properties of one or more of its arguments instead
<P>
<PRE>
  of their values; in fact, these argument values may be undefined. Unless the description of an intrinsic inquiry
<P>
  function states otherwise, these arguments are permitted to be unallocated allocatable variables or pointers that
<P>
  are undefined or disassociated. An elemental intrinsic function is one that is specified for scalar arguments,
<P>
  but may be applied to array arguments as described in 15.8. All other intrinsic functions are transformational
<P>
  functions; they almost all have one or more array arguments or an array result. All standard intrinsic functions
<P>
  are pure.
<P>
</PRE>
3 An atomic subroutine is an intrinsic subroutine that performs an atomic action. The semantics of atomic actions
<P>
<PRE>
  are described in 16.5.
<P>
</PRE>
4 A collective subroutine is an intrinsic subroutine that performs a cooperative calculation on a team of images
<P>
<PRE>
  without requiring synchronization. The semantics of collective subroutines are described in 16.6.
<P>
</PRE>
5 The subroutine MOVE_ALLOC with noncoarray argument FROM, and the elemental subroutine MVBITS, are
<P>
<PRE>
  pure. No other standard intrinsic subroutine is pure.
<P>
</PRE>
6 Generic names of standard intrinsic procedures are listed in 16.7. In most cases, generic functions accept argu-
<P>
<PRE>
  ments of more than one type and the type of the result is the same as the type of the arguments. Specific names of
<P>
  standard intrinsic functions with corresponding generic names are listed in 16.8.
<P>
</PRE>
7 If an intrinsic procedure is used as an actual argument to a procedure, its specific name shall be used and it may be referenced in
<P>
<PRE>
  the called procedure only with scalar arguments. If an intrinsic procedure does not have a specific name, it shall not be used as an
<P>
  actual argument (15.5.2.9).
<P>
</PRE>
8 Elemental intrinsic procedures behave as described in 15.8.
<P>
<PRE>
  16.2         Arguments to intrinsic procedures
<P>
  16.2.1        General rules
<P>
</PRE>
1 All intrinsic procedures may be invoked with either positional arguments or argument keywords (15.5). The
<P>
<PRE>
  descriptions in 16.7 through 16.9 give the argument keyword names and positional sequence for standard intrinsic
<P>
  procedures.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>2 Many of the intrinsic procedures have optional arguments.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
These arguments are identified by the notation
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
  “optional” in the argument descriptions. In addition, the names of the optional arguments are enclosed in square
<P>
  brackets in description headings and in lists of procedures. The valid forms of reference for procedures with
<P>
  optional arguments are described in 15.5.2.
<P>
        NOTE 16.1
<P>
        The text CMPLX (X [, Y, KIND]) indicates that Y and KIND are both optional arguments. Valid ref-
<P>
        erence forms include CMPLX(x), CMPLX(x, y), CMPLX(x, KIND=kind), CMPLX(x, y, kind), and CM-
<P>
        PLX(KIND=kind, X=x, Y=y).
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                          337
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 16.2
<P>
        Some intrinsic procedures impose additional requirements on their optional arguments. For example, SE-
<P>
        LECTED_REAL_KIND requires that at least one of its optional arguments be present, and RANDOM_-
<P>
        SEED requires that at most one of its optional arguments be present.
<P>
</PRE>
3 The dummy arguments of the specific intrinsic procedures in 16.8 have INTENT (IN). The dummy arguments of the intrinsic
<P>
<PRE>
  procedures in 16.9 have INTENT (IN) if the intent is not stated explicitly.
<P>
</PRE>
4 The actual argument corresponding to an intrinsic function dummy argument named KIND shall be a scalar
<P>
<PRE>
  integer constant expression and its value shall specify a representation method for the function result that exists
<P>
  on the processor.
<P>
</PRE>
5 Intrinsic subroutines that assign values to arguments of type character do so in accordance with the rules of
<P>
<PRE>
  intrinsic assignment (10.2.1.3).
<P>
</PRE>
6 In a reference to the intrinsic subroutine MVBITS, the actual arguments corresponding to the TO and FROM
<P>
<PRE>
  dummy arguments may be the same variable and may be associated scalar variables or associated array variables
<P>
  all of whose corresponding elements are associated. Apart from this, the actual arguments in a reference to an
<P>
  intrinsic subroutine shall be such that the execution of the intrinsic subroutine would satisfy the restrictions of
<P>
  15.5.2.13.
<P>
</PRE>
7 An argument to an intrinsic procedure other than ASSOCIATED, NULL, or PRESENT shall be a data object.
<P>
<PRE>
  16.2.2      The shape of array arguments
<P>
</PRE>
1 Unless otherwise specified, the intrinsic inquiry functions accept array arguments for which the shape need not
<P>
<PRE>
  be defined. The shape of array arguments to transformational and elemental intrinsic functions shall be defined.
<P>
  16.2.3      Mask arguments
<P>
</PRE>
1 Some array intrinsic functions have an optional MASK argument of type logical that is used by the function to
<P>
<PRE>
  select the elements of one or more arguments to be operated on by the function. Any element not selected by the
<P>
  mask need not be defined at the time the function is invoked.
<P>
</PRE>
2 The MASK affects only the value of the function, and does not affect the evaluation, prior to invoking the
<P>
<PRE>
  function, of arguments that are array expressions.
<P>
  16.2.4      DIM arguments and reduction functions
<P>
</PRE>
1 Some array intrinsic functions are “reduction” functions; that is, they reduce the rank of an array by collapsing
<P>
<PRE>
  one dimension (or all dimensions, usually producing a scalar result). These functions have a DIM argument that
<P>
  can specify the dimension to be reduced.
<P>
</PRE>
2 The process of reducing a dimension usually combines the selected elements with a simple operation such as
<P>
<PRE>
  addition or an intrinsic function such as MAX, but more sophisticated reductions are also provided, e.g. by
<P>
  COUNT and MAXLOC.
<P>
  16.3       Bit model
<P>
  16.3.1      General
<P>
</PRE>
1 The bit manipulation procedures are described in terms of a model for the representation and behavior of bits
<P>
<PRE>
  on a processor.
<P>
</PRE>
2 For the purposes of these procedures, a bit is defined to be a binary digit w located at position k of a nonnegative
<P>
<PRE>
  integer scalar object based on a model nonnegative integer defined by
<P>
  338                                                                      ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
                                                          z−1
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; X</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>j=</B> </TD><TD valign=bottom>
wk × 2k
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                          k=0
<P>
</PRE>
and for which wk may have the value 0 or 1. This defines a sequence of bits wz−1 . . . w0 , with wz−1 the leftmost
</BLOCKQUOTE>
<P>
bit and w0 the rightmost bit. The positions of bits in the sequence are numbered from right to left, with the
<BLOCKQUOTE>
<P>
position of the rightmost bit being zero. The length of a sequence of bits is z. An example of a model number
<P>
compatible with the examples used in 16.4 would have z = 32, thereby defining a 32-bit integer.
</BLOCKQUOTE>
<P>
3 The interpretation of a negative integer as a sequence of bits is processor dependent.
<BLOCKQUOTE>
<P>
4 The inquiry function BIT_SIZE provides the value of the parameter z of the model.
<P>
5 Effectively, this model defines an integer object to consist of z bits in sequence numbered from right to left from
<BLOCKQUOTE>
<P>
0 to z − 1. This model is valid only in the context of the use of such an object as the argument or result of an
<P>
intrinsic procedure that interprets that object as a sequence of bits. In all other contexts, the model defined for
<P>
an integer in 16.4 applies. In particular, whereas the models are identical for r = 2 and wz−1 = 0, they do not
<P>
correspond for r ̸= 2 or wz−1 = 1 and the interpretation of bits in such objects is processor dependent.
<TABLE cellpadding=3><!-- tsb: correspond for r ̸= 2 or wz−1 = 1 and the interpretation of bits in such objects is processor dependent.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>16.3.2</B> </TD><TD valign=bottom>
Bit sequence comparisons
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 When bit sequences of unequal length are compared, the shorter sequence is considered to be extended to the
<P>
<PRE>
  length of the longer sequence by padding with zero bits on the left.
<P>
</PRE>
2 Bit sequences are compared from left to right, one bit at a time, until unequal bits are found or all bits have been
<P>
<PRE>
  compared and found to be equal. If unequal bits are found, the sequence with zero in the unequal position is
<P>
  considered to be less than the sequence with one in the unequal position. Otherwise the sequences are considered
<P>
  to be equal.
<P>
  16.3.3      Bit sequences as arguments to INT and REAL
<P>
</PRE>
1 When a boz-literal-constant is the argument A of the intrinsic function INT or REAL,
<P>
<PRE>
      • if the length of the sequence of bits specified by A is less than the size in bits of a scalar variable of the
<P>
         same type and kind type parameter as the result, the boz-literal-constant is treated as if it were extended
<P>
         to a length equal to the size in bits of the result by padding on the left with zero bits, and
<P>
      • if the length of the sequence of bits specified by A is greater than the size in bits of a scalar variable of the
<P>
         same type and kind type parameter as the result, the boz-literal-constant is treated as if it were truncated
<P>
         from the left to a length equal to the size in bits of the result.
<P>
</PRE>
C1601 If a boz-literal-constant is truncated as an argument to the intrinsic function REAL, the discarded bits
<P>
<PRE>
            shall all be zero.
<P>
</PRE>
NOTE 16.3
<BLOCKQUOTE>
<P>
The result values of the intrinsic functions CMPLX and DBLE are defined by references to the intrinsic
<P>
function REAL with the same arguments. Therefore, the padding and truncation of boz-literal-constant
<P>
arguments to those intrinsic functions is the same as for the intrinsic function REAL.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: arguments to those intrinsic functions is the same as for the intrinsic function REAL.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>16.4</B> </TD><TD valign=bottom>
Numeric models
</TD></TR>
<TR></TR></TABLE>1 The numeric manipulation and inquiry functions are described in terms of a model for the representation and
<P>
<PRE>
  behavior of numbers on a processor. The model has parameters that are determined so as to make the model
<P>
  best fit the machine on which the program is executed.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             339
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The model set for integer i is defined by
<P>
<PRE>
                                                              q−1
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; X</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>i=s×</B> </TD><TD valign=bottom>
wk × rk
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                              k=0
<P>
</PRE>
where r is an integer exceeding one, q is a positive integer, each wk is a nonnegative integer less than r, and s is
</BLOCKQUOTE>
<P>
+1 or −1. The integer parameters r and q determine the set of model integers.
<BLOCKQUOTE>
<P>
3 The model set for real x is defined by
<BLOCKQUOTE>
<P>
0 or
</BLOCKQUOTE>
<P>

<BLOCKQUOTE>
<P>

<P>

<P>
<PRE>
                                                                    p
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>x=</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                      s×b ×
<P>
                                                            e
<P>
                                                                       fk × b−k
<P>
                                                                  k=1
<P>
</PRE>
where b and p are integers exceeding one; each fk is a nonnegative integer less than b, with f1 nonzero; s is
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
+1 or −1; and e is an integer that lies between some integer maximum emax and some integer minimum emin
<P>
inclusively. For x = 0, its exponent e and digits fk are defined to be zero. The integer parameters b, p, emin , and
<P>
emax determine the set of model floating-point numbers.
</TD></TR>
<TR><TD colspan=2>
4 The parameters of the integer and real models are available for each representation method of the integer and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  real types. The parameters characterize the set of available numbers in the definition of the model. Intrinsic
<P>
  functions provide the values of some parameters and other values related to the models.
<P>
</PRE>
5 There is also an extended model set for each kind of real x; this extended model is the same as the ordinary
</TD></TR>
<TR><TD colspan=2>
<PRE>
  model except that there are no limits on the range of the exponent e.
<P>
        NOTE 16.4
<P>
        Some of the function descriptions use the models
<P>
                                                                X30
<P>
                                                       i=s×           wk × 2k
<P>
                                                                k=0
<P>
        and
<P>
                                                              24
<P>
                                                                            !
<P>
                                                        1 X
<P>
                                                   e
<P>
                                    x = 0 or s × 2 ×      +      fk × 2−k     , −126 ≤ e ≤ 127
<P>
                                                        2
<P>
                                                             k=2
<P>
  16.5        Atomic subroutines
<P>
</PRE>
1 An atomic subroutine is an intrinsic subroutine that performs an action on its ATOM argument, and if it has an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  OLD argument, determination of the value to be assigned to that argument, atomically. Definition or evaluation
<P>
  of any argument other than ATOM is not performed atomically.
<P>
</PRE>
2 For any two executions in unordered segments of atomic subroutines whose ATOM argument is the same object,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the effect is as if one of the executions is performed completely before the other execution begins. Which execution
<P>
  is performed first is processor dependent. The sequence of atomic actions within ordered segments is specified in
<P>
  5.3.5. If successive atomic subroutine invocations on image P redefine a variable atomically in segments Pi and
<P>
  Pj , atomic references to that variable from image Q in a segment Qk that is unordered relative to Pi and Pj may
<P>
  observe the changes in the value of that variable in any order.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>3 Atomic operations shall make asynchronous progress.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
If a variable X on image P is defined by an atomic
</TD></TR>
<TR><TD colspan=2>
<PRE>
  subroutine on image Q, image R repeatedly references X [P ] by an atomic subroutine in an unordered segment,
<P>
  and no other image defines X [P ] in an unordered segment, image R shall eventually receive the value assigned
<P>
  340                                                                     ⃝
<P>
                                                                          c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  by image Q, even if none of the images P , Q, or R execute an image control statement until after the definition
<P>
  of X [P ] by image Q and the reception of that value by image R.
<P>
</PRE>
4 If the STAT argument is present in an invocation of an atomic subroutine and no error condition occurs, it is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  assigned the value zero.
<P>
</PRE>
5 If the STAT argument is present in an invocation of an atomic subroutine and an error condition occurs, any
</TD></TR>
<TR><TD colspan=2>
<PRE>
  other argument that is not INTENT (IN) becomes undefined. If the ATOM argument is on a failed image, an
<P>
  error condition occurs and the value STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_-
<P>
  ENV is assigned to the STAT argument. If any other error condition occurs, the STAT argument is assigned a
<P>
  processor-dependent positive value that is different from the value of STAT_FAILED_IMAGE.
<P>
</PRE>
6 If the STAT argument is not present in an invocation of an atomic subroutine and an error condition occurs,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  error termination is initiated.
<P>
        NOTE 16.5
<P>
        The properties of atomic subroutines are intended to support custom synchronization mechanisms. The
<P>
        program will need to handle all possible orderings of sequences of atomic subroutine executions that can
<P>
        arise as a consequence of the above rules; note that the orderings can appear to be different on different
<P>
        images even in the same program execution.
<P>
  16.6        Collective subroutines
<P>
</PRE>
1 Successful execution of a collective subroutine performs a calculation on all the images of the current team and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  assigns a computed value on one or all of them. If it is invoked by one image, it shall be invoked by the same
<P>
  statement on all active images of its current team in segments that are not ordered with respect to each other;
<P>
  corresponding references participate in the same collective computation.
<P>
</PRE>
2 Before execution of the first CHANGE TEAM statement on an image, in between executions of CHANGE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  TEAM and/or END TEAM statements, and after the last execution of an END TEAM statement, the sequence
<P>
  of invocations of collective subroutines shall be the same on all active images of a team. A collective subroutine
<P>
  shall not be referenced when an image control statement is not permitted to be executed (for example, in a
<P>
  procedure invoked from a CRITICAL construct).
<P>
  C1602 A reference to a collective subroutine shall not appear in a context where an image control statement is
<P>
            not permitted to appear.
<P>
</PRE>
3 If the A argument in a reference to a collective subroutine is a coarray, the corresponding ultimate arguments on
</TD></TR>
<TR><TD colspan=2>
<PRE>
  all active images of the current team shall be corresponding coarrays as described in 5.4.7.
<P>
</PRE>
4 If the STAT argument is present in a reference to a collective subroutine on one image, it shall be present on all
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the corresponding references.
<P>
</PRE>
5 If the STAT argument is present in a reference to a collective subroutine and its execution is successful, it is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  assigned the value zero.
<P>
</PRE>
6 If the STAT argument is present in a reference to a collective subroutine and an error condition occurs, it is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  assigned a positive value and the A argument becomes undefined.
<P>
</PRE>
7 If the STAT argument is present and the current team contains stopped images, an error condition occurs and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value STAT_STOPPED_IMAGE from the intrinsic module ISO_FORTRAN_ENV is assigned to the STAT
<P>
  argument. Otherwise, if the current team contained failed images, an error condition occurs and the value
<P>
  STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV is assigned to the STAT argument.
<P>
  If any other error condition occurs, the STAT argument is assigned a processor-dependent positive value that is
<P>
  different from the value of STAT_STOPPED_IMAGE or STAT_FAILED_IMAGE.
<P>
</PRE>
8 If the STAT argument is not present in a reference to a collective subroutine and an error condition occurs, error
</TD></TR>
<TR><TD colspan=2>
<PRE>
  termination is initiated.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        341
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
9 If the ERRMSG argument is present in a reference to a collective subroutine and an error condition occurs, it is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  assigned an explanatory message, truncated or padded with blanks if required. If no error condition occurs, the
<P>
  definition status and value of ERRMSG are unchanged.
<P>
         NOTE 16.6
<P>
         The argument A becomes undefined if an error condition occurs during execution of a collective subroutine
<P>
         because it is intended to allow the processor to use A for intermediate values during calculation.
<P>
         NOTE 16.7
<P>
         Although the calculations performed by a collective subroutine have some internal synchronizations, a
<P>
         reference to a collective subroutine is not an image control statement.
<P>
  16.7         Standard generic intrinsic procedures
<P>
</PRE>
1 For all of the standard intrinsic procedures, the arguments shown are the names that shall be used for argument
</TD></TR>
<TR><TD colspan=2>
<PRE>
  keywords if the keyword form is used for actual arguments.
<P>
         NOTE 16.8
<P>
         For example, a reference to CMPLX can be written in the form CMPLX (A, B, M) or in the form CM-
<P>
         PLX (Y = B, KIND = M, X = A).
<P>
         NOTE 16.9
<P>
         Many of the argument keywords have names that are indicative of their usage. For example:
<P>
              KIND                                         Describes the kind type parameter of the result
<P>
              STRING, STRING_A                             An arbitrary character string
<P>
              BACK                                         Controls the direction of string scan
<P>
                                                             (forward or backward)
<P>
              MASK                                         A mask to be applied to the arguments
<P>
              DIM                                          A selected dimension of an array argument
<P>
</PRE>
2 In the Class column of Table 16.1,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      A   indicates that the  procedure   is an atomic subroutine,
<P>
      C   indicates that the  procedure   is a collective subroutine,
<P>
      E   indicates that the  procedure   is an elemental function,
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>ES</B> </TD><TD valign=bottom>
indicates that the  procedure   is an elemental subroutine,
</TD></TR>
<TR><TD colspan=2>
<PRE>
       I  indicates that the  procedure   is an inquiry function,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PS</B> </TD><TD valign=bottom>
indicates that the  procedure   is a pure subroutine when the FROM argument is not a coarray,
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
      S   indicates that the  procedure   is an impure subroutine, and
<P>
      T   indicates that the  procedure   in a transformational function.
<P>
                             Table 16.1: Standard generic intrinsic procedure summary
<P>
        Procedure                   Arguments                         Class Description
<P>
        ABS                         (A)                                 E    Absolute value.
<P>
        ACHAR                       (I [, KIND])                        E    Character from ASCII code value.
<P>
        ACOS                        (X)                                 E    Arccosine (inverse cosine) function.
<P>
        ACOSH                       (X)                                 E    Inverse hyperbolic cosine function.
<P>
        ADJUSTL                     (STRING)                            E    Left-justified string value.
<P>
        ADJUSTR                     (STRING)                            E    Right-justified string value.
<P>
        AIMAG                       (Z)                                 E    Imaginary part of a complex number.
<P>
        AINT                        (A [, KIND])                        E    Truncation toward 0 to a whole number.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>342</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Table 16.1: Standard generic intrinsic procedure summary</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(cont.)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments                   Class Description
<TABLE width=100% cellpadding=3><!-- tsb: Arguments                   Class Description
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>ALL</B> </TD><TD valign=bottom>
(MASK) or (MASK, DIM)         T   Array reduced by .AND. operator.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ALLOCATED</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ARRAY) or (SCALAR)           I   Allocation status of allocatable variable.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ANINT</B> </TD><TD valign=bottom>
(A [, KIND])                  E   Nearest whole number.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ANY</B> </TD><TD valign=bottom>
(MASK) or (MASK, DIM)         T   Array reduced by .OR. operator.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ASIN</B> </TD><TD valign=bottom>
(X)                           E   Arcsine (inverse sine) function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ASINH</B> </TD><TD valign=bottom>
(X)                           E   Inverse hyperbolic sine function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ASSOCIATED</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(POINTER [, TARGET])          I   Pointer association status inquiry.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ATAN</B> </TD><TD valign=bottom>
(X) or (Y, X)                 E   Arctangent (inverse tangent) function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ATAN2</B> </TD><TD valign=bottom>
(Y, X)                        E   Arctangent (inverse tangent) function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ATANH</B> </TD><TD valign=bottom>
(X)                           E   Inverse hyperbolic tangent function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_ADD</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE [, STAT])        A   Atomic addition.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_AND</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE [, STAT])        A   Atomic bitwise AND.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_CAS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, OLD, COMPARE,          A   Atomic compare and swap.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      VALUE [, STAT])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_DEFINE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE [, STAT])        A   Define a variable atomically.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_FETCH_-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE, OLD             A   Atomic fetch and add.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ADD</B> </TD><TD valign=bottom>
[, STAT])
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_FETCH_-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE, OLD             A   Atomic fetch and bitwise AND.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>AND</B> </TD><TD valign=bottom>
[, STAT])
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_FETCH_-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE, OLD             A   Atomic fetch and bitwise OR.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>OR</B> </TD><TD valign=bottom>
[, STAT])
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_FETCH_-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE, OLD             A   Atomic fetch and bitwise exclusive OR.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>XOR</B> </TD><TD valign=bottom>
[, STAT])
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_OR</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE [, STAT])        A   Atomic bitwise OR.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_REF</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(VALUE, ATOM [, STAT])        A   Reference a variable atomically.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_XOR</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ATOM, VALUE [, STAT])        A   Atomic bitwise exclusive OR.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_J0</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Bessel function of the 1st kind, order 0.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_J1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Bessel function of the 1st kind, order 1.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_JN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(N, X)                        E   Bessel function of the 1st kind, order N.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_JN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(N1, N2, X)                   T   Bessel functions of the 1st kind.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_Y0</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Bessel function of the 2nd kind, order 0.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_Y1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Bessel function of the 2nd kind, order 1.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_YN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(N, X)                        E   Bessel function of the 2nd kind, order N.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BESSEL_YN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(N1, N2, X)                   T   Bessel functions of the 2nd kind.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>BGE</B> </TD><TD valign=bottom>
(I, J)                        E   Bitwise greater than or equal to.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>BGT</B> </TD><TD valign=bottom>
(I, J)                        E   Bitwise greater than.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BIT_SIZE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(I)                           I   Number of bits in integer model 16.3.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>BLE</B> </TD><TD valign=bottom>
(I, J)                        E   Bitwise less than or equal to.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>BLT</B> </TD><TD valign=bottom>
(I, J)                        E   Bitwise less than.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>BTEST</B> </TD><TD valign=bottom>
(I, POS)                      E   Test single bit in an integer.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CEILING</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A [, KIND])                  E   Least integer greater than or equal to A.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CHAR</B> </TD><TD valign=bottom>
(I [, KIND])                  E   Character from code value.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CMPLX</B> </TD><TD valign=bottom>
(X [, KIND]) or               E   Conversion to complex type.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      (X [, Y, KIND])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CO_BROADCAST</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, SOURCE_IMAGE [,           C   Broadcast value to images.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      STAT, ERRMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CO_MAX</B> </TD><TD valign=bottom>
(A [, RESULT_IMAGE,           C   Compute maximum value across images.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      STAT, ERRMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CO_MIN</B> </TD><TD valign=bottom>
(A [, RESULT_IMAGE,           C   Compute minimum value across images.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      STAT, ERRMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CO_REDUCE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, OPERATION [,              C   Generalized reduction across images.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                      RESULT_IMAGE, STAT,
<P>
                      ERRMSG])
<P>
</PRE>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
343
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
              Table 16.1: Standard generic intrinsic procedure summary                      (cont.)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments                   Class Description
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CO_SUM</B> </TD><TD valign=bottom>
(A [, RESULT_IMAGE,           C   Compute sum across images.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       STAT, ERRMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>COMMAND_ARGU- ( )</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
T   Number of command arguments.
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; MENT_COUNT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>CONJG</B> </TD><TD valign=bottom>
(Z)                           E   Conjugate of a complex number.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>COS</B> </TD><TD valign=bottom>
(X)                           E   Cosine function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>COSH</B> </TD><TD valign=bottom>
(X)                           E   Hyperbolic cosine function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>COSHAPE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(COARRAY [, KIND])            I   Sizes of codimensions of a coarray.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>COUNT</B> </TD><TD valign=bottom>
(MASK [, DIM, KIND])          T   Logical array reduced by counting true
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                         values.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CPU_TIME</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(TIME)                        S   Processor time used.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CSHIFT</B> </TD><TD valign=bottom>
(ARRAY, SHIFT [, DIM])        T   Circular shift of an array.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DATE_AND_TIME</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([DATE, TIME, ZONE,           S   Date and time.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       VALUES])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>DBLE</B> </TD><TD valign=bottom>
(A)                           E   Conversion to double precision real.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>DIGITS</B> </TD><TD valign=bottom>
(X)                           I   Significant digits in numeric model.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>DIM</B> </TD><TD valign=bottom>
(X, Y)                        E   Maximum of X − Y and zero.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DOT_PRODUCT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(VECTOR_A,                    T   Dot product of two vectors.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       VECTOR_B)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>DPROD</B> </TD><TD valign=bottom>
(X, Y)                        E   Double precision real product.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DSHIFTL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(I, J, SHIFT)                 E   Combined left shift.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DSHIFTR</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(I, J, SHIFT)                 E   Combined right shift.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EOSHIFT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ARRAY, SHIFT [,              T   End-off shift of the elements of an array.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       BOUNDARY, DIM])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EPSILON</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           I   Model number that is small compared
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                         to 1.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ERF</B> </TD><TD valign=bottom>
(X)                           E   Error function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ERFC</B> </TD><TD valign=bottom>
(X)                           E   Complementary error function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ERFC_SCALED</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Scaled complementary error function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EVENT_QUERY</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(EVENT, COUNT [, STAT])       S   Query event count.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EXECUTE_COM-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(COMMAND [, WAIT,             S   Execute a command line.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MAND_LINE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EXITSTAT, CMDSTAT,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       CMDMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>EXP</B> </TD><TD valign=bottom>
(X)                           E   Exponential function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EXPONENT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Exponent of floating-point number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EXTENDS_TYPE_- (A, MOLD)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
I   Dynamic type extension inquiry.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; OF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>FAILED_IMAGES</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([TEAM, KIND])                T   Indices of failed images.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FINDLOC</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ARRAY, VALUE, DIM [,         T   <B>Location</B>(s) of a specified value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       MASK, KIND, BACK]) or
<P>
                       (ARRAY, VALUE [, MASK,
<P>
                       KIND, BACK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>FLOOR</B> </TD><TD valign=bottom>
(A [, KIND])                  E   Greatest integer less than or equal to A.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FRACTION</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Fractional part of number.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>GAMMA</B> </TD><TD valign=bottom>
(X)                           E   Gamma function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>GET_COMMAND</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([COMMAND, LENGTH,            S   Get program invocation command.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       STATUS, ERRMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>GET_COMMAND_- (NUMBER [, VALUE,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
S   Get program invocation argument.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ARGUMENT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
LENGTH, STATUS,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       ERRMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>GET_ENVIRON-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(NAME [, VALUE,               S   Get environment variable.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MENT_VARIABLE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
LENGTH, STATUS,
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                       TRIM_NAME, ERRMSG])
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>344</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Table 16.1: Standard generic intrinsic procedure summary</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(cont.)
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments                   Class Description
<TABLE cellpadding=3><!-- tsb: Arguments                   Class Description
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>GET_TEAM</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([LEVEL])                     T   Team.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>HUGE</B> </TD><TD valign=bottom>
(X)                           I   Largest model number.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>HYPOT</B> </TD><TD valign=bottom>
(X, Y)                        E   Euclidean distance function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IACHAR</B> </TD><TD valign=bottom>
(C [, KIND])                  E   ASCII code value for character.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IALL</B> </TD><TD valign=bottom>
(ARRAY, DIM [, MASK]) or      T   Array reduced by IAND function.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      (ARRAY [, MASK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IAND</B> </TD><TD valign=bottom>
(I, J)                        E   Bitwise AND.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IANY</B> </TD><TD valign=bottom>
(ARRAY, DIM [, MASK]) or      T   Array reduced by IOR function.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      (ARRAY [, MASK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IBCLR</B> </TD><TD valign=bottom>
(I, POS)                      E   I with bit POS replaced by zero.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IBITS</B> </TD><TD valign=bottom>
(I, POS, LEN)                 E   Specified sequence of bits.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IBSET</B> </TD><TD valign=bottom>
(I, POS)                      E   I with bit POS replaced by one.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ICHAR</B> </TD><TD valign=bottom>
(C [, KIND])                  E   Code value for character.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IEOR</B> </TD><TD valign=bottom>
(I, J)                        E   Bitwise exclusive OR.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IMAGE_INDEX</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(COARRAY, SUB) or             I   Image index from cosubscripts.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      (COARRAY, SUB, TEAM)
<P>
                      or (COARRAY, SUB,
<P>
                      TEAM_NUMBER)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IMAGE_STATUS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(IMAGE [, TEAM])              T   Image execution state.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>INDEX</B> </TD><TD valign=bottom>
(STRING, SUBSTRING [,         E   Character string search.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      BACK, KIND])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>INT</B> </TD><TD valign=bottom>
(A [, KIND])                  E   Conversion to integer type.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>IOR</B> </TD><TD valign=bottom>
(I, J)                        E   Bitwise inclusive OR.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IPARITY</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ARRAY, DIM [, MASK]) or      T   Array reduced by IEOR function.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                      (ARRAY [, MASK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ISHFT</B> </TD><TD valign=bottom>
(I, SHIFT)                    E   Logical shift.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>ISHFTC</B> </TD><TD valign=bottom>
(I, SHIFT [, SIZE])           E   Circular shift of the rightmost bits.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IS_CONTIGUOUS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ARRAY)                       I   Array contiguity test (8.5.7).
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IS_IOSTAT_END</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(I)                           E   IOSTAT value test for end of file.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IS_IOSTAT_EOR</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(I)                           E   IOSTAT value test for end of record.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>KIND</B> </TD><TD valign=bottom>
(X)                           I   Value of the kind type parameter of X.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LBOUND</B> </TD><TD valign=bottom>
(ARRAY [, DIM, KIND])         I   Lower <B>bound</B>(s).
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LCOBOUND</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(COARRAY [, DIM, KIND])       I   Lower <B>cobound</B>(s) of a coarray.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LEADZ</B> </TD><TD valign=bottom>
(I)                           E   Number of leading zero bits.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LEN</B> </TD><TD valign=bottom>
(STRING [, KIND])             I   Length of a character entity.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LEN_TRIM</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(STRING [, KIND])             E   Length without trailing blanks.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LGE</B> </TD><TD valign=bottom>
(STRING_A, STRING_B)          E   ASCII greater than or equal.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LGT</B> </TD><TD valign=bottom>
(STRING_A, STRING_B)          E   ASCII greater than.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LLE</B> </TD><TD valign=bottom>
(STRING_A, STRING_B)          E   ASCII less than or equal.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LLT</B> </TD><TD valign=bottom>
(STRING_A, STRING_B)          E   ASCII less than.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LOG</B> </TD><TD valign=bottom>
(X)                           E   Natural logarithm.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LOG_GAMMA</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Logarithm of the absolute value of the
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                        gamma function.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>LOG10</B> </TD><TD valign=bottom>
(X)                           E   Common logarithm.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LOGICAL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(L [, KIND])                  E   Conversion between kinds of logical.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MASKL</B> </TD><TD valign=bottom>
(I [, KIND])                  E   Left justified mask.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MASKR</B> </TD><TD valign=bottom>
(I [, KIND])                  E   Right justified mask.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MATMUL</B> </TD><TD valign=bottom>
(MATRIX_A, MATRIX_B)          T   Matrix multiplication.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MAX</B> </TD><TD valign=bottom>
(A1, A2 [, A3, &#46;&#46;&#46;])          E   Maximum value.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MAXEXPONENT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           I   Maximum exponent of a real model.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MAXLOC</B> </TD><TD valign=bottom>
(ARRAY, DIM [, MASK,          T   <B>Location</B>(s) of maximum value.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                      KIND, BACK]) or (ARRAY
<P>
                      [, MASK, KIND, BACK])
<P>
</PRE>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
345
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
              Table 16.1: Standard generic intrinsic procedure summary                    (cont.)
<P>
</PRE>
<TABLE cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments                   Class Description
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MAXVAL</B> </TD><TD valign=bottom>
(ARRAY, DIM [, MASK]) or      T   Maximum <B>value</B>(s) of array.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       (ARRAY [, MASK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MERGE</B> </TD><TD valign=bottom>
(TSOURCE, FSOURCE,            E   Expression value selection.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       MASK)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MERGE_BITS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(I, J, MASK)                  E   Merge of bits under mask.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MIN</B> </TD><TD valign=bottom>
(A1, A2 [, A3, &#46;&#46;&#46;])          E   Minimum value.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MINEXPONENT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           I   Minimum exponent of a real model.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MINLOC</B> </TD><TD valign=bottom>
(ARRAY, DIM [, MASK,          T   <B>Location</B>(s) of minimum value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       KIND, BACK]) or (ARRAY
<P>
                       [, MASK, KIND, BACK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MINVAL</B> </TD><TD valign=bottom>
(ARRAY, DIM [, MASK]) or      T   Minimum <B>value</B>(s) of array.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       (ARRAY [, MASK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MOD</B> </TD><TD valign=bottom>
(A, P)                        E   Remainder function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MODULO</B> </TD><TD valign=bottom>
(A, P)                        E   Modulo function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MOVE_ALLOC</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(FROM, TO [, STAT,           PS Move an allocation.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       ERRMSG])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>MVBITS</B> </TD><TD valign=bottom>
(FROM, FROMPOS, LEN,         ES Copy a sequence of bits.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       TO, TOPOS)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>NEAREST</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, S)                        E   Adjacent machine number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>NEW_LINE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A)                           I   Newline character.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NINT</B> </TD><TD valign=bottom>
(A [, KIND])                  E   Nearest integer.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NORM2</B> </TD><TD valign=bottom>
(X) or (X, DIM)               T   L2 norm of an array.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NOT</B> </TD><TD valign=bottom>
(I)                           E   Bitwise complement.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>NULL</B> </TD><TD valign=bottom>
([MOLD])                      T   Disassociated pointer or unallocated al-
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                         locatable entity.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>NUM_IMAGES</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
( ) or (TEAM) or (TEAM_-      T   Number of images.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       NUMBER)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>OUT_OF_RANGE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, MOLD [, ROUND])           E   Whether a value cannot be converted
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                         safely.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PACK</B> </TD><TD valign=bottom>
(ARRAY, MASK [,               T   Array packed into a vector.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       VECTOR])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PARITY</B> </TD><TD valign=bottom>
(MASK) or (MASK, DIM)         T   Array reduced by .NEQV. operator.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>POPCNT</B> </TD><TD valign=bottom>
(I)                           E   Number of one bits.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>POPPAR</B> </TD><TD valign=bottom>
(I)                           E   Parity expressed as 0 or 1.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRECISION</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           I   Decimal precision of a real model.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRESENT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A)                           I   Presence of optional argument.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRODUCT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ARRAY, DIM [, MASK]) or      T   Array reduced by multiplication.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       (ARRAY [, MASK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RADIX</B> </TD><TD valign=bottom>
(X)                           I   Base of a numeric model.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RANDOM_INIT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(REPEATABLE, IMAGE_-          S   Initialise the pseudorandom number
</TD></TR>
<TR><TD colspan=2>
<PRE>
                       DISTINCT)                         generator.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RANDOM_NUMBER (HARVEST)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
S   Generate pseudorandom <B>number</B>(s).
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RANDOM_SEED</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([SIZE, PUT, GET])            S   Restart or query the pseudorandom
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                         number generator.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RANGE</B> </TD><TD valign=bottom>
(X)                           I   Decimal exponent range of a numeric
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                         model (16.4).
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RANK</B> </TD><TD valign=bottom>
(A)                           I   Rank of a data object.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>REAL</B> </TD><TD valign=bottom>
(A [, KIND])                  E   Conversion to real type.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>REDUCE</B> </TD><TD valign=bottom>
(ARRAY,       OPERATION,      T   General reduction of array
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                       DIM [, MASK, IDENTITY,
<P>
                       ORDERED]) or (ARRAY,
<P>
                       OPERATION [, MASK,
<P>
                       IDENTITY, ORDERED])
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>346</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                       ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Table 16.1: Standard generic intrinsic procedure summary</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(cont.)
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments                   Class Description
<TABLE width=100% cellpadding=3><!-- tsb: Arguments                   Class Description
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>REPEAT</B> </TD><TD valign=bottom>
(STRING, NCOPIES)             T   Repetitive string concatenation.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RESHAPE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(SOURCE, SHAPE [, PAD,        T   Arbitrary shape array construction.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                               ORDER])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RRSPACING</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Reciprocal of relative spacing of model
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                 numbers.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SAME_TYPE_AS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                        I   Dynamic type equality test.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SCALE</B> </TD><TD valign=bottom>
(X, I)                        E   Real number scaled by radix power.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SCAN</B> </TD><TD valign=bottom>
(STRING, SET [, BACK,         E   Character set membership search.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                               KIND])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SELECTED_CHAR_- (NAME)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
T   Character kind selection.
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; KIND</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>SELECTED_INT_-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(R)                           T   Integer kind selection.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; KIND</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>SELECTED_REAL_- ([P, R, RADIX])</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
T   Real kind selection.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; KIND</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>SET_EXPONENT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, I)                        E   Real value with specified exponent.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SHAPE</B> </TD><TD valign=bottom>
(SOURCE [, KIND])             I   Shape of an array or a scalar.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SHIFTA</B> </TD><TD valign=bottom>
(I, SHIFT)                    E   Right shift with fill.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SHIFTL</B> </TD><TD valign=bottom>
(I, SHIFT)                    E   Left shift.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SHIFTR</B> </TD><TD valign=bottom>
(I, SHIFT)                    E   Right shift.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SIGN</B> </TD><TD valign=bottom>
(A, B)                        E   Magnitude of A with the sign of B.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SIN</B> </TD><TD valign=bottom>
(X)                           E   Sine function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SINH</B> </TD><TD valign=bottom>
(X)                           E   Hyperbolic sine function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SIZE</B> </TD><TD valign=bottom>
(ARRAY [, DIM, KIND])         I   Size of an array or one extent.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SPACING</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                           E   Spacing of model numbers.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SPREAD</B> </TD><TD valign=bottom>
(SOURCE, DIM, NCOPIES)        T   Value replicated in a new dimension.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SQRT</B> </TD><TD valign=bottom>
(X)                           E   Square root.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>STOPPED_IMAGES ([TEAM, KIND])</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
T   Indices of stopped images.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>STORAGE_SIZE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A [, KIND])                  I   Storage size in bits.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SUM</B> </TD><TD valign=bottom>
(ARRAY, DIM [, MASK]) or      T   Array reduced by addition.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                               (ARRAY [, MASK])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SYSTEM_CLOCK</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([COUNT, COUNT_RATE,          S   Query system clock.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                               COUNT_MAX])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>TAN</B> </TD><TD valign=bottom>
(X)                           E   Tangent function.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>TANH</B> </TD><TD valign=bottom>
(X)                           E   Hyperbolic tangent function.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TEAM_NUMBER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([TEAM])                      T   Team number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>THIS_IMAGE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([TEAM])                      T   Index of the invoking image.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>THIS_IMAGE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(COARRAY [, TEAM]) or         T   <B>Cosubscript</B>(s) for this image.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                               (COARRAY, DIM [,
<P>
                               TEAM])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>TINY</B> </TD><TD valign=bottom>
(X)                           I   Smallest positive model number.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>TRAILZ</B> </TD><TD valign=bottom>
(I)                           E   Number of trailing zero bits.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TRANSFER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(SOURCE, MOLD [, SIZE])       T   Transfer physical representation.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TRANSPOSE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(MATRIX)                      T   Transpose of an array of rank two.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>TRIM</B> </TD><TD valign=bottom>
(STRING)                      T   String without trailing blanks.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>UBOUND</B> </TD><TD valign=bottom>
(ARRAY [, DIM, KIND])         I   Upper <B>bound</B>(s).
</TD></TR>
<TR valign=top><TD colspan=2>
<B>UCOBOUND</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(COARRAY [, DIM, KIND])       I   Upper <B>cobound</B>(s) of a coarray.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>UNPACK</B> </TD><TD valign=bottom>
(VECTOR, MASK, FIELD)         T   Vector unpacked into an array.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>VERIFY</B> </TD><TD valign=bottom>
(STRING, SET [, BACK,         E   Character set non-membership search.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                               KIND])
<P>
</PRE>
3 The effect of calling EXECUTE_COMMAND_LINE on any image other than image 1 in the initial team is
<P>
<PRE>
  processor dependent.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                    347
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 If RANDOM_INIT or RANDOM_SEED is called in a segment A, and RANDOM_INIT, RANDOM_SEED, or
<P>
<PRE>
  RANDOM_NUMBER is called in segment B, then segments A and B shall be ordered. It is processor dependent
<P>
  whether each image uses a separate random number generator, or if some or all images use common random
<P>
  number generators.
<P>
</PRE>
5 The use of all other standard intrinsic procedures in unordered segments is subject only to their argument use
<P>
<PRE>
  following the rules in 11.6.2.
<P>
  16.8        Specific names for standard intrinsic functions
<P>
</PRE>
1 Except for AMAX0, AMIN0, MAX1, and MIN1, the result type of the specific function is the same that the result type of the
<P>
<PRE>
  corresponding generic function reference would be if it were invoked with the same arguments as the specific function.
<P>
</PRE>
2 A function listed in Table 16.3 is not permitted to be used as an actual argument (15.5.1, C1534), as a target in a procedure
<P>
<PRE>
  pointer assignment statement (10.2.2.2, C1030), as an initial target in a procedure declaration statement (15.4.3.6, C1519), or to
<P>
  specify an interface (15.4.3.6, C1515).
<P>
                                         Table 16.2: Unrestricted specific intrinsic functions
<P>
                                        Specific name   Generic name    Argument type and kind
<P>
                                        ABS             ABS             default real
<P>
                                        ACOS            ACOS            default real
<P>
                                        AIMAG           AIMAG           default complex
<P>
                                        AINT            AINT            default real
<P>
                                        ALOG            LOG             default real
<P>
                                        ALOG10          LOG10           default real
<P>
                                        AMOD            MOD             default real
<P>
                                        ANINT           ANINT           default real
<P>
                                        ASIN            ASIN            default real
<P>
                                        ATAN            ATAN (X)        default real
<P>
                                        ATAN2           ATAN2           default real
<P>
                                        CABS            ABS             default complex
<P>
                                        CCOS            COS             default complex
<P>
                                        CEXP            EXP             default complex
<P>
                                        CLOG            LOG             default complex
<P>
                                        CONJG           CONJG           default complex
<P>
                                        COS             COS             default real
<P>
                                        COSH            COSH            default real
<P>
                                        CSIN            SIN             default complex
<P>
                                        CSQRT           SQRT            default complex
<P>
                                        DABS            ABS             double precision real
<P>
                                        DACOS           ACOS            double precision real
<P>
                                        DASIN           ASIN            double precision real
<P>
                                        DATAN           ATAN            double precision real
<P>
                                        DATAN2          ATAN2           double precision real
<P>
                                        DCOS            COS             double precision real
<P>
                                        DCOSH           COSH            double precision real
<P>
                                        DDIM            DIM             double precision real
<P>
                                        DEXP            EXP             double precision real
<P>
                                        DIM             DIM             default real
<P>
                                        DINT            AINT            double precision real
<P>
                                        DLOG            LOG             double precision real
<P>
                                        DLOG10          LOG10           double precision real
<P>
                                        DMOD            MOD             double precision real
<P>
                                        DNINT           ANINT           double precision real
<P>
                                        DPROD           DPROD           default real
<P>
                                        DSIGN           SIGN            double precision real
<P>
                                        DSIN            SIN             double precision real
<P>
                                        DSINH           SINH            double precision real
<P>
                                        DSQRT           SQRT            double precision real
<P>
                                        DTAN            TAN             double precision real
<P>
                                        DTANH           TANH            double precision real
<P>
                                        EXP             EXP             default real
<P>
                                        IABS            ABS             default integer
<P>
                                        IDIM            DIM             default integer
<P>
                                        IDNINT          NINT            double precision real
<P>
                                        INDEX           INDEX           default character
<P>
  348                                                                         ⃝
<P>
                                                                              c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
<P>
                                      Unrestricted specific intrinsic functions         (cont.)
<P>
                                   Specific name   Generic name      Argument type and kind
<P>
                                   ISIGN           SIGN              default integer
<P>
                                   LEN             LEN               default character
<P>
                                   MOD             MOD               default integer
<P>
                                   NINT            NINT              default real
<P>
                                   SIGN            SIGN              default real
<P>
                                   SIN             SIN               default real
<P>
                                   SINH            SINH              default real
<P>
                                   SQRT            SQRT              default real
<P>
                                   TAN             TAN               default real
<P>
                                   TANH            TANH              default real
<P>
                                     Table 16.3: Restricted specific intrinsic functions
<P>
                                Specific name    Generic name           Argument type and kind
<P>
                                AMAX0 (. . . )   REAL (MAX (. . . ))    default integer
<P>
                                AMAX1            MAX                    default real
<P>
                                AMIN0 (. . . )   REAL (MIN (. . . ))    default integer
<P>
                                AMIN1            MIN                    default real
<P>
                                CHAR             CHAR                   default integer
<P>
                                DMAX1            MAX                    double precision real
<P>
                                DMIN1            MIN                    double precision real
<P>
                                FLOAT            REAL                   default integer
<P>
                                ICHAR            ICHAR                  default character
<P>
                                IDINT            INT                    double precision real
<P>
                                IFIX             INT                    default real
<P>
                                INT              INT                    default real
<P>
                                LGE              LGE                    default character
<P>
                                LGT              LGT                    default character
<P>
                                LLE              LLE                    default character
<P>
                                LLT              LLT                    default character
<P>
                                MAX0             MAX                    default integer
<P>
                                MAX1 (. . . )    INT (MAX (. . . ))     default real
<P>
                                MIN0             MIN                    default integer
<P>
                                MIN1 (. . . )    INT (MIN (. . . ))     default real
<P>
                                REAL             REAL                   default integer
<P>
                                SNGL             REAL                   double precision real
<P>
  16.9       Specifications of the standard intrinsic procedures
<P>
  16.9.1      General
<P>
</PRE>
1 Detailed specifications of the standard generic intrinsic procedures are provided in 16.9 in alphabetical order.
</BLOCKQUOTE>
<P>
2 The types and type parameters of standard intrinsic procedure arguments and function results are determined
<P>
<PRE>
  by these specifications. The “Argument(s)” paragraphs specify requirements on the actual arguments of the
<P>
  procedures. The result characteristics are sometimes specified in terms of the characteristics of the arguments. A
<P>
  program shall not invoke an intrinsic procedure under circumstances where a value to be assigned to a subroutine
<P>
  argument or returned as a function result is not representable by objects of the specified type and type parameters.
<P>
</PRE>
3 If an IEEE infinity is assigned or returned by an intrinsic procedure, the intrinsic module IEEE_ARITHMETIC
<P>
<PRE>
  is accessible, and the actual arguments were finite numbers, the flag IEEE_OVERFLOW or IEEE_DIVIDE_-
<P>
  BY_ZERO shall signal. If an IEEE NaN is assigned or returned, the actual arguments were finite numbers, the
<P>
  intrinsic module IEEE_ARITHMETIC is accessible, and the exception IEEE_INVALID is supported, the flag
<P>
  IEEE_INVALID shall signal. If no IEEE infinity or NaN is assigned or returned, these flags shall have the same
<P>
  status as when the intrinsic procedure was invoked.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          349
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.2        ABS (A)
<P>
</PRE>
1 Description. Absolute value.
<BLOCKQUOTE>
<P>
2 Class. Elemental function.
<P>
3 Argument. A shall be of type integer, real, or complex.
<P>
4 Result Characteristics. The same as A except that if A is complex, the result is real.
<TABLE cellpadding=3><!-- tsb: 4 Result Characteristics. The same as A except that if A is complex, the result is real.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>5 Result Value. If A is of type integer or real, the value of thep</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
result is |A|; if A is complex with value (x, y),
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the result is equal to a processor-dependent approximation to      x2 + y 2 computed without undue overflow or
<P>
  underflow.
<P>
</PRE>
6 Example. ABS ((3.0, 4.0)) has the value 5.0 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.3        ACHAR (I [, KIND])
<P>
</PRE>
1 Description. Character from ASCII code value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  I              shall be of type integer.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Character of length one. If KIND is present, the kind type parameter is that specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by the value of KIND; otherwise, the kind type parameter is that of default character.
<P>
</PRE>
5 Result Value. If I has a value in the range 0 ≤ I ≤ 127, the result is the character in position I of the ASCII
</TD></TR>
<TR><TD colspan=2>
<PRE>
  collating sequence, provided the processor is capable of representing that character in the character kind of the
<P>
  result; otherwise, the result is processor dependent. ACHAR (IACHAR (C)) shall have the value C for any
<P>
  character C capable of representation as a default character.
<P>
</PRE>
6 Example. ACHAR (88) has the value ’X’.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.4        ACOS (X)
<P>
</PRE>
1 Description. Arccosine (inverse cosine) function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real with a value that satisfies the inequality |X| ≤ 1, or of type complex.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>arccos</B>(X). If it is real
</TD></TR>
<TR><TD colspan=2>
<PRE>
  it is expressed in radians and lies in the range 0 ≤ ACOS (X) ≤ π. If it is complex the real part is expressed in
<P>
  radians and lies in the range 0 ≤ REAL (ACOS (X)) ≤ π.
<P>
</PRE>
6 Example. ACOS (0.54030231) has the value 1.0 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.5        ACOSH (X)
<P>
</PRE>
1 Description. Inverse hyperbolic cosine function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real or complex.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  350                                                              ⃝
<P>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
</TD></TR>
<TR><TD colspan=2>
<PRE>
  cosine function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
<P>
  0 ≤ AIMAG (ACOSH (X)) ≤ π
<P>
</PRE>
6 Example. ACOSH (1.5430806) has the value 1.0 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.6        ADJUSTL (STRING)
<P>
</PRE>
1 Description. Left-justified string value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. STRING shall be of type character.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Character of the same length and kind type parameter as STRING.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The value of the result is the same as STRING except that any leading blanks have been deleted
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and the same number of trailing blanks have been inserted.
<P>
</PRE>
6 Example. ADJUSTL (’ WORD’) has the value ’WORD ’.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.7        ADJUSTR (STRING)
<P>
</PRE>
1 Description. Right-justified string value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. STRING shall be of type character.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Character of the same length and kind type parameter as STRING.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The value of the result is the same as STRING except that any trailing blanks have been deleted
</TD></TR>
<TR><TD colspan=2>
<PRE>
  and the same number of leading blanks have been inserted.
<P>
</PRE>
6 Example. ADJUSTR (’WORD ’) has the value ’ WORD’.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.8        AIMAG (Z)
<P>
</PRE>
1 Description. Imaginary part of a complex number.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. Z shall be of type complex.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Real with the same kind type parameter as Z.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. If Z has the value (x, y), the result has the value y.
</TD></TR>
<TR><TD colspan=2>
6 Example. AIMAG ((2.0, 3.0)) has the value 3.0.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.9        AINT (A [, KIND])
<P>
</PRE>
1 Description. Truncation toward 0 to a whole number.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A             shall be of type real.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                      351
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. The result is of type real. If KIND is present, the kind type parameter is that specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by the value of KIND; otherwise, the kind type parameter is that of A.
<P>
</PRE>
5 Result Value. If |A| &lt; 1, AINT (A) has the value 0; if |A| ≥ 1, AINT (A) has a value equal to the integer
</TD></TR>
<TR><TD colspan=2>
<PRE>
  whose magnitude is the largest integer that does not exceed the magnitude of A and whose sign is the same as
<P>
  the sign of A.
<P>
</PRE>
6 Examples. AINT (2.783) has the value 2.0. AINT (−2.783) has the value −2.0.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.10          ALL (MASK) or ALL (MASK, DIM)
<P>
</PRE>
1 Description. Array reduced by .AND. operator.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  MASK             shall be a logical array.
<P>
  DIM              shall be an integer scalar with value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
<P>
</PRE>
4 Result Characteristics. The result is of type logical with the same kind type parameter as MASK. It is scalar
</TD></TR>
<TR><TD colspan=2>
<PRE>
  if DIM does not appear or n = 1; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 ,
<P>
  . . . , dn ] where [d1 , d2 , . . . , dn ] is the shape of MASK.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):        The result of ALL (MASK) has the value true if all elements of MASK are true or if MASK has
<P>
                   size zero, and the result has value false if any element of MASK is false.
<P>
  Case (ii):       If MASK has rank one, ALL (MASK, DIM) is equal to ALL (MASK). Otherwise, the value of
<P>
                   element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of ALL (MASK, DIM) is equal to ALL (MASK (s1 ,
<P>
                   s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )).
<P>
</PRE>
6 Examples.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):        The value of ALL ([.TRUE., .FALSE., .TRUE.]) is false.
<P>
                                                                                      
<P>
                                                1 3 5                              0 3 5
<P>
  Case (ii):       If B is the array                         and C is the array             then ALL (B /= C, DIM = 1) is
<P>
                                                2 4 6                              7 4 8
<P>
                   [true, false, false] and ALL (B /= C, DIM = 2) is [false, false].
<P>
  16.9.11          ALLOCATED (ARRAY) or ALLOCATED (SCALAR)
<P>
</PRE>
1 Description. Allocation status of allocatable variable.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ARRAY            shall be an allocatable array.
<P>
  SCALAR           shall be an allocatable scalar.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has the value true if the argument (ARRAY or SCALAR) is allocated and has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false if the argument is unallocated.
<P>
  16.9.12          ANINT (A [, KIND])
<P>
</PRE>
1 Description. Nearest whole number.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  352                                                                            ⃝
<P>
                                                                                 c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A                shall be of type real.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. The result is of type real. If KIND is present, the kind type parameter is that specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by the value of KIND; otherwise, the kind type parameter is that of A.
<P>
</PRE>
5 Result Value. The result is the integer nearest A, or if there are two integers equally near A, the result is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  whichever such integer has the greater magnitude.
<P>
</PRE>
6 Examples. ANINT (2.783) has the value 3.0. ANINT (−2.783) has the value −3.0.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.13          ANY (MASK) or ANY (MASK, DIM)
<P>
</PRE>
1 Description. Array reduced by .OR. operator.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  MASK             shall be a logical array.
<P>
  DIM              shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
<P>
</PRE>
4 Result Characteristics. The result is of type logical with the same kind type parameter as MASK. It is scalar
</TD></TR>
<TR><TD colspan=2>
<PRE>
  if DIM does not appear or n = 1; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 ,
<P>
  . . . , dn ] where [d1 , d2 , . . . , dn ] is the shape of MASK.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):        The result of ANY (MASK) has the value true if any element of MASK is true and has the value
<P>
                   false if no elements are true or if MASK has size zero.
<P>
  Case (ii):       If MASK has rank one, ANY (MASK, DIM) is equal to ANY (MASK). Otherwise, the value of
<P>
                   element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of ANY (MASK, DIM) is equal to ANY (MASK (s1 ,
<P>
                   s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )).
<P>
</PRE>
6 Examples.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):        The value of ANY ([.TRUE., .FALSE., .TRUE.]) is true.
<P>
                                                                                      
<P>
                                                1 3 5                              0 3 5
<P>
  Case (ii):       If B is the array                        and C is the array             then ANY (B /= C, DIM = 1) is
<P>
                                                2 4 6                              7 4 8
<P>
                   [true, false, true] and ANY (B /= C, DIM = 2) is [true, true].
<P>
  16.9.14          ASIN (X)
<P>
</PRE>
1 Description. Arcsine (inverse sine) function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real with a value that satisfies the inequality |X| ≤ 1, or of type complex.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>arcsin</B>(X). If it is real it
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is expressed in radians and lies in the range −π/2 ≤ ASIN (X) ≤ π/2. If it is complex the real part is expressed
<P>
  in radians and lies in the range −π/2 ≤ REAL (ASIN (X)) ≤ π/2.
<P>
</PRE>
6 Example. ASIN (0.84147098) has the value 1.0 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              353
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.15      ASINH (X)
<P>
</PRE>
1 Description. Inverse hyperbolic sine function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real or complex.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
</TD></TR>
<TR><TD colspan=2>
<PRE>
  sine function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
<P>
  −π/2 ≤ AIMAG (ASINH (X)) ≤ π/2.
<P>
</PRE>
6 Example. ASINH (1.1752012) has the value 1.0 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.16      ASSOCIATED (POINTER [, TARGET])
<P>
</PRE>
1 Description. Pointer association status inquiry.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  POINTER      shall be a pointer. It may be of any type or may be a procedure pointer. Its pointer association
<P>
               status shall not be undefined.
<P>
  TARGET (optional) shall be allowable as the data-target or proc-target in a pointer assignment statement (10.2.2)
<P>
               in which POINTER is data-pointer-object or proc-pointer-object. If TARGET is a pointer then its
<P>
               pointer association status shall not be undefined.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):    If TARGET is absent, the result is true if and only if POINTER is associated with a target.
<P>
  Case (ii):   If TARGET is present and is a procedure, the result is true if and only if POINTER is associated
<P>
               with TARGET and, if TARGET is an internal procedure, they have the same host instance.
<P>
  Case (iii):  If TARGET is present and is a procedure pointer, the result is true if and only if POINTER and
<P>
               TARGET are associated with the same procedure and, if the procedure is an internal procedure,
<P>
               they have the same host instance.
<P>
  Case (iv):   If TARGET is present and is a scalar target, the result is true if and only if TARGET is not a zero-
<P>
               sized storage sequence and POINTER is associated with a target that occupies the same storage
<P>
               units as TARGET.
<P>
  Case (v):    If TARGET is present and is an array target, the result is true if and only if POINTER is associated
<P>
               with a target that has the same shape as TARGET, is neither of size zero nor an array whose elements
<P>
               are zero-sized storage sequences, and occupies the same storage units as TARGET in array element
<P>
               order.
<P>
  Case (vi):   If TARGET is present and is a scalar pointer, the result is true if and only if POINTER and
<P>
               TARGET are associated, the targets are not zero-sized storage sequences, and they occupy the
<P>
               same storage units.
<P>
  Case (vii):  If TARGET is present and is an array pointer, the result is true if and only if POINTER and
<P>
               TARGET are both associated, have the same shape, are neither of size zero nor arrays whose
<P>
               elements are zero-sized storage sequences, and occupy the same storage units in array element
<P>
               order.
<P>
  354                                                              ⃝
<P>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 16.10
<P>
       The references to TARGET in the above cases are referring to properties that might be possessed by the
<P>
       actual argument, so the case of TARGET being a disassociated pointer will be covered by case (iii), (vi),
<P>
       or (vii).
<P>
</PRE>
6 Examples. ASSOCIATED (CURRENT, HEAD) is true if CURRENT is associated with the target HEAD.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  After the execution of
<P>
       A_PART =&gt; A (:N)
<P>
  ASSOCIATED (A_PART, A) is true if N is equal to UBOUND (A, DIM = 1). After the execution of
<P>
       NULLIFY (CUR); NULLIFY (TOP)
<P>
  ASSOCIATED (CUR, TOP) is false.
<P>
  16.9.17        ATAN (X) or ATAN (Y, X)
<P>
</PRE>
1 Description. Arctangent (inverse tangent) function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Y              shall be of type real.
<P>
  X              If Y appears, X shall be of type real with the same kind type parameter as Y. If Y has the value
<P>
                 zero, X shall not have the value zero. If Y does not appear, X shall be of type real or complex.
<P>
</PRE>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. If Y appears, the result is the same as the result of ATAN2 (Y,X). If Y does not appear, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  result has a value equal to a processor-dependent approximation to arctan(X) whose real part is expressed in
<P>
  radians and lies in the range −π/2 ≤ ATAN (X) ≤ π/2.
<P>
</PRE>
6 Example. ATAN (1.5574077) has the value 1.0 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.18        ATAN2 (Y, X)
<P>
</PRE>
1 Description. Arctangent (inverse tangent) function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Y              shall be of type real.
<P>
  X              shall be of the same type and kind type parameter as Y. If Y has the value zero, X shall not have
<P>
                 the value zero.
<P>
</PRE>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to the principal value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the argument of the complex number (X, Y), expressed in radians. It lies in the range −π ≤ ATAN2 (Y,X)
<P>
  ≤ π and is equal to a processor-dependent approximation to a value of arctan(Y/X) if X ̸= 0. If Y &gt; 0, the
<P>
  result is positive. If Y = 0 and X &gt; 0, the result is Y. If Y = 0 and X &lt; 0, then the result is approximately
<P>
  π if Y is positive real zero or the processor does not distinguish between positive and negative real zero, and
<P>
  approximately −π if Y is negative real zero. If Y &lt; 0, the result is negative. If X = 0, the absolute value of the
<P>
  result is approximately π/2.
<P>
                                                                                                           
<P>
                                                                                                    1     1
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>6 Examples. ATAN2 (1.5574077, 1.0) has the value 1.0 (approximately). If Y has the value</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
and X
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                                                   −1 −1
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
                                                                
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                    −1 1                                                       3π/4     π/4
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>has the value</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
, the value of ATAN2 (Y, X) is approximately                      .
</TD></TR>
<TR><TD colspan=2>
<PRE>
                    −1 1                                                      −3π/4 −π/4
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
355
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>16.9.19</B> </TD><TD valign=bottom>
ATANH (X)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Description. Inverse hyperbolic tangent function.
<BLOCKQUOTE>
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
<P>
<PRE>
  tangent function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
<P>
  −π/2 ≤ AIMAG (ATANH (X)) ≤ π/2.
<P>
</PRE>
6 Example. ATANH (0.76159416) has the value 1.0 (approximately).
<P>
<PRE>
  16.9.20        ATOMIC_ADD (ATOM, VALUE [, STAT])
<P>
</PRE>
1 Description. Atomic addition.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM           shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                 KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                 an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                 of ATOM + VALUE.
<P>
  VALUE          shall be an integer scalar. It is an INTENT (IN) argument. The values of VALUE and ATOM +
<P>
                 VALUE shall be representable in kind ATOMIC_INT_KIND.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                 and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_ADD (I [3], 42) will cause I on image 3 to become defined with the value 46 if the
<P>
<PRE>
  value of I [3] is 4 when the atomic operation is executed.
<P>
  16.9.21        ATOMIC_AND (ATOM, VALUE [, STAT])
<P>
</PRE>
1 Description. Atomic bitwise AND.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM           shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                 KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                 an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                 of IAND (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
<P>
  VALUE          shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
<P>
                 entable in kind ATOMIC_INT_KIND.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                 and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_AND (I [3], 6) will cause I on image 3 to become defined with the value 4 if the
<P>
<PRE>
  value of I [3] is 5 when the atomic operation is executed.
<P>
  356                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.22      ATOMIC_CAS (ATOM, OLD, COMPARE, NEW [, STAT])
<P>
</PRE>
1 Description. Atomic compare and swap.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM         shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
               KIND from the intrinsic module ISO_FORTRAN_ENV, or of type logical with kind ATOMIC_-
<P>
               LOGICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT)
<P>
               argument. If an error condition occurs, ATOM becomes undefined; otherwise, if ATOM is of type
<P>
               integer and equal to COMPARE, or of type logical and equivalent to COMPARE, it becomes defined
<P>
               with the value of NEW.
<P>
  OLD          shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
<P>
               an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
<P>
               ATOM had at the start of the atomic operation.
<P>
  COMPARE shall be scalar and of the same type and kind as ATOM. It is an INTENT (IN) argument.
<P>
  NEW          shall be scalar and of the same type and kind as ATOM. It is an INTENT (IN) argument.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
               INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
               and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. If the value of I on image 3 is equal to 13 at the beginning of the atomic operation performed by
<P>
<PRE>
  CALL ATOMIC_CAS (I [3], OLD, 0, 1), the value of I on image 3 will be unchanged, and OLD will become
<P>
  defined with the value 13. If the value of I on image 3 is equal to 0 at the beginning of the atomic operation
<P>
  performed by CALL ATOMIC_CAS (I [3], OLD, 0, 1), I on image 3 will become defined with the value 1, and
<P>
  OLD will become defined with the value 0.
<P>
  16.9.23      ATOMIC_DEFINE (ATOM, VALUE [, STAT])
<P>
</PRE>
1 Description. Define a variable atomically.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM         shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
               KIND from the intrinsic module ISO_FORTRAN_ENV, or of type logical with kind ATOMIC_-
<P>
               LOGICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (OUT)
<P>
               argument. On successful execution, it becomes defined with the value of VALUE. If an error
<P>
               condition occurs, it becomes undefined.
<P>
  VALUE        shall be scalar and of the same type as ATOM. It is an INTENT (IN) argument.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
               INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
               and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_DEFINE (I [3], 4) causes I on image 3 to become defined with the value 4.
<P>
<PRE>
  16.9.24      ATOMIC_FETCH_ADD (ATOM, VALUE, OLD [, STAT])
<P>
</PRE>
1 Description. Atomic fetch and add.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM         shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                      357
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                of ATOM + VALUE.
<P>
  VALUE         shall be an integer scalar. It is an INTENT (IN) argument. The values of VALUE and ATOM +
<P>
                VALUE shall be representable in kind ATOMIC_INT_KIND.
<P>
  OLD           shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
<P>
                an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
<P>
                ATOM had at the start of the atomic operation.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_FETCH_ADD (I [3], 7, J) will cause I on image 3 to become defined with the value
<P>
<PRE>
  12, and J to become defined with the value 5, if the value of I [3] is 5 when the atomic operation is executed.
<P>
  16.9.25      ATOMIC_FETCH_AND (ATOM, VALUE, OLD [, STAT])
<P>
</PRE>
1 Description. Atomic fetch and bitwise AND.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM          shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                of IAND (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
<P>
  VALUE         shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
<P>
                entable in kind ATOMIC_INT_KIND.
<P>
  OLD           shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
<P>
                an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
<P>
                ATOM had at the start of the atomic operation.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_FETCH_AND (I [3], 6, J) will cause I on image 3 to become defined with the value
<P>
<PRE>
  4, and J to become defined with the value 5, if the value of I [3] is 5 when the atomic operation is executed.
<P>
  16.9.26      ATOMIC_FETCH_OR (ATOM, VALUE, OLD [, STAT])
<P>
</PRE>
1 Description. Atomic fetch and bitwise OR.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM          shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                of IOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
<P>
  VALUE         shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
<P>
                entable in kind ATOMIC_INT_KIND.
<P>
  OLD           shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
<P>
                an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
<P>
                ATOM had at the start of the atomic operation.
<P>
  358                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                 and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_FETCH_OR (I [3], 1, J) will cause I on image 3 to become defined with the value
<P>
<PRE>
  3, and J to become defined with the value 2, if the value of I [3] is 2 when the atomic operation is executed.
<P>
  16.9.27        ATOMIC_FETCH_XOR (ATOM, VALUE, OLD [, STAT])
<P>
</PRE>
1 Description. Atomic fetch and bitwise exclusive OR.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM           shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                 KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                 an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                 of IEOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
<P>
  VALUE          shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
<P>
                 entable in kind ATOMIC_INT_KIND.
<P>
  OLD            shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
<P>
                 an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
<P>
                 ATOM had at the start of the atomic operation.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                 and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_FETCH_XOR (I [3], 1, J) will cause I on image 3 to become defined with the value
<P>
<PRE>
  2, and J to become defined with the value 3, if the value of I [3] is 3 when the atomic operation is executed.
<P>
  16.9.28        ATOMIC_OR (ATOM, VALUE [, STAT])
<P>
</PRE>
1 Description. Atomic bitwise OR.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM           shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                 KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                 an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                 of IOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
<P>
  VALUE          shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
<P>
                 entable in kind ATOMIC_INT_KIND.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                 and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_OR (I [3], 1) will cause I on image 3 to become defined with the value 3 if the value
<P>
<PRE>
  of I [3] is 2 when the atomic operation is executed.
<P>
  16.9.29        ATOMIC_REF (VALUE, ATOM [, STAT])
<P>
</PRE>
1 Description. Reference a variable atomically.
<P>
2 Class. Atomic subroutine.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        359
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  VALUE          shall be scalar and of the same type as ATOM. It is an INTENT (OUT) argument. On successful
<P>
                 execution, it becomes defined with the value of ATOM. If an error condition occurs, it becomes
<P>
                 undefined.
<P>
  ATOM           shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                 KIND from the intrinsic module ISO_FORTRAN_ENV, or of type logical with kind ATOMIC_LO-
<P>
                 GICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (IN) argument.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                 and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_REF (VAL, I [3]) causes VAL to become defined with the value of I on image 3.
<P>
<PRE>
  16.9.30        ATOMIC_XOR (ATOM, VALUE [, STAT])
<P>
</PRE>
1 Description. Atomic bitwise exclusive OR.
<P>
2 Class. Atomic subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ATOM           shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
<P>
                 KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
<P>
                 an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
<P>
                 of IEOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
<P>
  VALUE          shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
<P>
                 entable in kind ATOMIC_INT_KIND.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
<P>
                 and STAT is not present, error termination is initiated.
<P>
</PRE>
4 Example. CALL ATOMIC_XOR (I [3], 1) will cause I on image 3 to become defined with the value 2 if the
<P>
<PRE>
  value of I [3] is 3 when the atomic operation is executed.
<P>
  16.9.31        BESSEL_J0 (X)
<P>
</PRE>
1 Description. Bessel function of the 1st kind, order 0.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
<P>
<PRE>
  the first kind and order zero of X.
<P>
</PRE>
6 Example. BESSEL_J0 (1.0) has the value 0.765 (approximately).
<P>
<PRE>
  16.9.32        BESSEL_J1 (X)
<P>
</PRE>
1 Description. Bessel function of the 1st kind, order 1.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Same as X.
<P>
<PRE>
  360                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
<P>
<PRE>
  the first kind and order one of X.
<P>
</PRE>
6 Example. BESSEL_J1 (1.0) has the value 0.440 (approximately).
<P>
<PRE>
  16.9.33       BESSEL_JN (N, X) or BESSEL_JN (N1, N2, X)
<P>
</PRE>
1 Description. Bessel functions of the 1st kind.
<P>
2 Class.
<P>
<PRE>
  Case (i):      BESSEL_JN (N,X) is an elemental function.
<P>
  Case (ii):     BESSEL_JN (N1,N2,X) is a transformational function.
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  N              shall be of type integer and nonnegative.
<P>
  N1             shall be an integer scalar with a nonnegative value.
<P>
  N2             shall be an integer scalar with a nonnegative value.
<P>
  X              shall be of type real; if the function is transformational, X shall be scalar.
<P>
</PRE>
4 Result Characteristics. Same type and kind as X. The result of BESSEL_JN (N1, N2, X) is a rank-one array
<P>
<PRE>
  with extent MAX (N2−N1+1, 0).
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):      The result value of BESSEL_JN (N, X) is a processor-dependent approximation to the Bessel
<P>
                 function of the first kind and order N of X.
<P>
  Case (ii):     Element i of the result value of BESSEL_JN (N1, N2, X) is a processor-dependent approximation
<P>
                 to the Bessel function of the first kind and order N1+i − 1 of X.
<P>
</PRE>
6 Example. BESSEL_JN (2, 1.0) has the value 0.115 (approximately).
<P>
<PRE>
  16.9.34       BESSEL_Y0 (X)
<P>
</PRE>
1 Description. Bessel function of the 2nd kind, order 0.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real. Its value shall be greater than zero.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
<P>
<PRE>
  the second kind and order zero of X.
<P>
</PRE>
6 Example. BESSEL_Y0 (1.0) has the value 0.088 (approximately).
<P>
<PRE>
  16.9.35       BESSEL_Y1 (X)
<P>
</PRE>
1 Description. Bessel function of the 2nd kind, order 1.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real. Its value shall be greater than zero.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
<P>
<PRE>
  the second kind and order one of X.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                  361
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Example. BESSEL_Y1 (1.0) has the value −0.781 (approximately).
<P>
<PRE>
  16.9.36       BESSEL_YN (N, X) or BESSEL_YN (N1, N2, X)
<P>
</PRE>
1 Description. Bessel functions of the 2nd kind.
<P>
2 Class.
<P>
<PRE>
  Case (i):     BESSEL_YN (N, X) is an elemental function.
<P>
  Case (ii):    BESSEL_YN (N1, N2, X) is a transformational function.
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  N             shall be of type integer and nonnegative.
<P>
  N1            shall be an integer scalar with a nonnegative value.
<P>
  N2            shall be an integer scalar with a nonnegative value.
<P>
  X             shall be of type real; if the function is transformational, X shall be scalar. Its value shall be greater
<P>
                than zero.
<P>
</PRE>
4 Result Characteristics. Same type and kind as X. The result of BESSEL_YN (N1, N2, X) is a rank-one array
<P>
<PRE>
  with extent MAX (N2−N1+1, 0).
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     The result value of BESSEL_YN (N, X) is a processor-dependent approximation to the Bessel
<P>
                function of the second kind and order N of X.
<P>
  Case (ii):    Element i of the result value of BESSEL_YN (N1, N2, X) is a processor-dependent approximation
<P>
                to the Bessel function of the second kind and order N1+i − 1 of X.
<P>
</PRE>
6 Example. BESSEL_YN (2, 1.0) has the value −1.651 (approximately).
<P>
<PRE>
  16.9.37       BGE (I, J)
<P>
</PRE>
1 Description. Bitwise greater than or equal to.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer or a boz-literal-constant.
<P>
  J             shall be of type integer or a boz-literal-constant.
<P>
</PRE>
4 Result Characteristics. Default logical.
<P>
5 Result Value. The result is true if the sequence of bits represented by I is greater than or equal to the sequence
<P>
<PRE>
  of bits represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is
<P>
  false.
<P>
</PRE>
6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
<P>
<PRE>
  integer value as a sequence of bits is described in 16.3.
<P>
</PRE>
7 Example. If BIT_SIZE (J) has the value 8, BGE (Z’FF’, J) has the value true for any value of J. BGE (0, −1)
<P>
<PRE>
  has the value false.
<P>
  16.9.38       BGT (I, J)
<P>
</PRE>
1 Description. Bitwise greater than.
<P>
2 Class. Elemental function.
<P>
<PRE>
  362                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer or a boz-literal-constant.
<P>
  J             shall be of type integer or a boz-literal-constant.
<P>
</PRE>
4 Result Characteristics. Default logical.
<P>
5 Result Value. The result is true if the sequence of bits represented by I is greater than the sequence of bits
<P>
<PRE>
  represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
<P>
</PRE>
6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
<P>
<PRE>
  integer value as a sequence of bits is described in 16.3.
<P>
</PRE>
7 Example. BGT (Z’FF’, Z’FC’) has the value true. BGT (0, −1) has the value false.
<P>
<PRE>
  16.9.39       BIT_SIZE (I)
<P>
</PRE>
1 Description. Number of bits in integer model 16.3.
<P>
2 Class. Inquiry function.
<P>
3 Argument. I shall be of type integer. It may be a scalar or an array.
<P>
4 Result Characteristics. Scalar integer with the same kind type parameter as I.
<P>
5 Result Value. The result has the value of the number of bits z of the model integer defined for bit manipulation
<P>
<PRE>
  contexts in 16.3.
<P>
</PRE>
6 Example. BIT_SIZE (1) has the value 32 if z of the model is 32.
<P>
<PRE>
  16.9.40       BLE (I, J)
<P>
</PRE>
1 Description. Bitwise less than or equal to.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer or a boz-literal-constant.
<P>
  J             shall be of type integer or a boz-literal-constant.
<P>
</PRE>
4 Result Characteristics. Default logical.
<P>
5 Result Value. The result is true if the sequence of bits represented by I is less than or equal to the sequence of
<P>
<PRE>
  bits represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
<P>
</PRE>
6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
<P>
<PRE>
  integer value as a sequence of bits is described in 16.3.
<P>
</PRE>
7 Example. BLE (0, J) has the value true for any value of J. BLE (−1, 0) has the value false.
<P>
<PRE>
  16.9.41       BLT (I, J)
<P>
</PRE>
1 Description. Bitwise less than.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer or a boz-literal-constant.
<P>
  J             shall be of type integer or a boz-literal-constant.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         363
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Default logical.
<P>
5 Result Value. The result is true if the sequence of bits represented by I is less than the sequence of bits
<P>
<PRE>
  represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
<P>
</PRE>
6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
<P>
<PRE>
  integer value as a sequence of bits is described in 16.3.
<P>
</PRE>
7 Example. BLT (0, −1) has the value true. BLT (Z’FF’, Z’FC’) has the value false.
<P>
<PRE>
  16.9.42       BTEST (I, POS)
<P>
</PRE>
1 Description. Test single bit in an integer.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I              shall be of type integer.
<P>
  POS            shall be of type integer. It shall be nonnegative and be less than BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Default logical.
<P>
5 Result Value. The result has the value true if bit POS of I has the value 1 and has the value false if bit POS
<P>
<PRE>
  of I has the value 0. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
                                                                                   
<P>
                                                                              1 2
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>6 Examples. BTEST (8, 3) has the value true. If A has the value</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
, the value of BTEST (A, 2) is
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                          3 4
<P>
     false false                                           true false
<P>
                    and the value of BTEST (2, A) is                     .
<P>
     false true                                            false false
<P>
  16.9.43       CEILING (A [, KIND])
<P>
</PRE>
1 Description. Least integer greater than or equal to A.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A              shall be of type real.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result has a value equal to the least integer greater than or equal to A.
</TD></TR>
<TR><TD colspan=2>
6 Examples. CEILING (3.7) has the value 4. CEILING (−3.7) has the value −3.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.44       CHAR (I [, KIND])
<P>
</PRE>
1 Description. Character from code value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  I              shall be of type integer with a value in the range 0 ≤ I ≤ n − 1, where n is the number of characters
<P>
                 in the collating sequence associated with the specified kind type parameter.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
  364                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Character of length one. If KIND is present, the kind type parameter is that specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by the value of KIND; otherwise, the kind type parameter is that of default character.
<P>
</PRE>
5 Result Value. The result is the character in position I of the collating sequence associated with the spe-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  cified kind type parameter. ICHAR (CHAR (I, KIND (C))) shall have the value I for 0 ≤ I ≤ n − 1 and
<P>
  CHAR (ICHAR (C), KIND (C)) shall have the value C for any character C capable of representation in the
<P>
  processor.
<P>
</PRE>
6 Example. CHAR (88) has the value ’X’ on a processor using the ASCII collating sequence for default characters.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.45        CMPLX (X [, KIND]) or CMPLX (X [, Y, KIND])
<P>
</PRE>
1 Description. Conversion to complex type.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments for <B>CMPLX</B>(X [, KIND]).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  X              shall be of type complex.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Arguments for <B>CMPLX</B>(X [, Y, KIND]).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  X              shall be of type integer or real, or a boz-literal-constant.
<P>
  Y (optional) shall be of type integer or real, or a boz-literal-constant.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
5 Result Characteristics. The result is of type complex. If KIND is present, the kind type parameter is that
</TD></TR>
<TR><TD colspan=2>
<PRE>
  specified by the value of KIND; otherwise, the kind type parameter is that of default real kind.
<P>
</PRE>
6 Result Value. If Y is absent and X is not complex, it is as if Y were present with the value zero. If KIND is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  absent, it is as if KIND were present with the value KIND (0.0). If X is complex, the result is the same as that
<P>
  of CMPLX (REAL (X), AIMAG (X), KIND). The result of CMPLX (X, Y, KIND) has the complex value whose
<P>
  real part is REAL (X, KIND) and whose imaginary part is REAL (Y, KIND).
<P>
</PRE>
7 Example. CMPLX (−3) has the value (−3.0, 0.0).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.46        CO_BROADCAST (A, SOURCE_IMAGE [, STAT, ERRMSG])
<P>
</PRE>
1 Description. Broadcast value to images.
</TD></TR>
<TR><TD colspan=2>
2 Class. Collective subroutine.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A              shall have the same shape, dynamic type, and type parameter values, in corresponding references.
<P>
                 It shall not be a coindexed object. It is an INTENT (INOUT) argument. If no error condition
<P>
                 occurs, A becomes defined, as if by intrinsic assignment, on all images in the current team with the
<P>
                 value of A on image SOURCE_IMAGE.
<P>
  SOURCE_IMAGE shall be an integer scalar. It is an INTENT (IN) argument. Its value shall be that of an
<P>
                 image index of an image in the current team. The value shall be the same in all corresponding
<P>
                 references.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument.
<P>
  ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
<P>
</PRE>
4 The semantics of STAT and ERRMSG are described in 16.6.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         365
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Example. If A is the array [1, 5, 3] on image one, after execution of
</TD></TR>
<TR><TD colspan=2>
<PRE>
           CALL CO_BROADCAST (A, 1)
<P>
</PRE>
the value of A on all images of the current team is [1, 5, 3].
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>16.9.47</B> </TD><TD valign=bottom>
CO_MAX (A [, RESULT_IMAGE, STAT, ERRMSG])
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 Description. Compute maximum value across images.
<P>
2 Class. Collective subroutine.
<P>
3 Arguments.
<P>
<PRE>
  A             shall be of type integer, real, or character. It shall have the same shape, type, and type parameter
<P>
                values, in corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT)
<P>
                argument. If it is scalar, the computed value is equal to the maximum value of A in all corresponding
<P>
                references. If it is an array each element of the computed value is equal to the maximum value of
<P>
                all corresponding elements of A in all corresponding references.
<P>
                The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
<P>
                absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
<P>
                undefined.
<P>
  RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
<P>
                if present, shall be the same in all corresponding references. If it is present, its value shall be that
<P>
                of an image index in the current team.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                INTENT (OUT) argument.
<P>
  ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
<P>
</PRE>
4 The semantics of STAT and ERRMSG are described in 16.6.
<P>
5 Example. If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
<P>
<PRE>
  1, 6] on the other image, the value of A after executing the statement CALL CO_MAX (A) is [4, 5, 6] on both
<P>
  images.
<P>
  16.9.48       CO_MIN (A [, RESULT_IMAGE, STAT, ERRMSG])
<P>
</PRE>
1 Description. Compute minimum value across images.
<P>
2 Class. Collective subroutine.
<P>
3 Arguments.
<P>
<PRE>
  A             shall be of type integer, real, or character. It shall have the same shape, type, and type parameter
<P>
                values, in corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT)
<P>
                argument. If it is scalar, the computed value is equal to the minimum value of A in all corresponding
<P>
                references. If it is an array each element of the computed value is equal to the minimum value of
<P>
                all corresponding elements of A in all corresponding references.
<P>
                The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
<P>
                absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
<P>
                undefined.
<P>
  RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
<P>
                if present, shall be the same in all corresponding references. If it is present, its value shall be that
<P>
                of an image index in the current team.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                INTENT (OUT) argument.
<P>
  ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
<P>
  366                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 The semantics of STAT and ERRMSG are described in 16.6.
<P>
5 Example. If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
<P>
<PRE>
  1, 6] on the other image, the value of A after executing the statement CALL CO_MIN (A) is [1, 1, 3] on both
<P>
  images.
<P>
  16.9.49        CO_REDUCE (A, OPERATION [, RESULT_IMAGE, STAT, ERRMSG])
<P>
</PRE>
1 Description. Generalized reduction across images.
<P>
2 Class. Collective subroutine.
<P>
3 Arguments.
<P>
<PRE>
  A              shall not be polymorphic. It shall have the same shape, type, and type parameter values, in
<P>
                 corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT) argument.
<P>
                 If A is scalar, the computed value is the result of the reduction operation of applying OPERATION
<P>
                 to the values of A in all corresponding references. If A is an array, each element of the computed
<P>
                 value is equal to the result of the reduction operation of applying OPERATION to corresponding
<P>
                 elements of A in all corresponding references.
<P>
                 The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
<P>
                 absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
<P>
                 undefined.
<P>
  OPERATION shall be a pure function with exactly two arguments; the result and each argument shall be
<P>
                 a scalar, nonallocatable, nonpointer, nonpolymorphic data object with the same type and type
<P>
                 parameters as A. The arguments shall not be optional. If one argument has the ASYNCHRONOUS,
<P>
                 TARGET, or VALUE attribute, the other shall have that attribute. OPERATION shall implement
<P>
                 a mathematically associative operation. OPERATION shall be the same function on all images in
<P>
                 corresponding references.
<P>
                 The computed value of a reduction operation over a set of values is the result of an iterative process.
<P>
                 Each iteration involves the evaluation of OPERATION (x, y) for x and y in the set, the removal of
<P>
                 x and y from the set, and the addition of the value of OPERATION (x, y) to the set. The process
<P>
                 terminates when the set has only one element; this is the computed value.
<P>
  RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
<P>
                 if present, shall be the same in all corresponding references. If it is present, its value shall be that
<P>
                 of an image index in the current team.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument.
<P>
  ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
<P>
</PRE>
4 The semantics of STAT and ERRMSG are described in 16.6.
<P>
5 Example. The subroutine below demonstrates how to use CO_REDUCE to create a collective counterpart to
<P>
<PRE>
  the intrinsic function ALL:
<P>
     SUBROUTINE co_all(boolean)
<P>
       LOGICAL, INTENT(INOUT) :: boolean
<P>
       CALL CO_REDUCE(boolean,both)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
PURE FUNCTION <B>both</B>(lhs,rhs) <B>RESULT</B>(lhs_and_rhs)
<P>
<PRE>
          LOGICAL, INTENT(IN) :: lhs,rhs
<P>
          LOGICAL :: lhs_and_rhs
<P>
          lhs_and_rhs = lhs .AND. rhs
<P>
</PRE>
END FUNCTION both
</BLOCKQUOTE>
<P>
END SUBROUTINE co_all
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END SUBROUTINE co_all
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
367
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
        NOTE 16.11
<P>
        If the OPERATION function is not mathematically commutative, the result of calling CO_REDUCE can
<P>
        depend on the order of evaluations.
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>16.9.50</B> </TD><TD valign=bottom>
CO_SUM (A [, RESULT_IMAGE, STAT, ERRMSG])
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Description. Compute sum across images.
<BLOCKQUOTE>
<P>
2 Class. Collective subroutine.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be of numeric type. It shall have the same shape, type, and type parameter values, in cor-
<P>
                 responding references. It shall not be a coindexed object. It is an INTENT (INOUT) argument.
<P>
                 If it is scalar, the computed value is equal to a processor-dependent approximation to the sum of
<P>
                 the values of A in corresponding references. If it is an array, each element of the computed value
<P>
                 is equal to a processor-dependent approximation to the sum of all corresponding elements of A in
<P>
                 corresponding references.
<P>
                 The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
<P>
                 absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
<P>
                 undefined.
<P>
  RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
<P>
                 if present, shall be the same in all corresponding references. If it is present, its value shall be that
<P>
                 of an image index in the current team.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument.
<P>
  ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
<P>
</PRE>
4 The semantics of STAT and ERRMSG are described in 16.6.
<P>
5 Example. If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
<P>
<PRE>
  1, 6] on the other image, the value of A after executing the statement CALL CO_SUM(A) is [5, 6, 9] on both
<P>
  images.
<P>
  16.9.51       COMMAND_ARGUMENT_COUNT ( )
<P>
</PRE>
1 Description. Number of command arguments.
<P>
2 Class. Transformational function.
<P>
3 Argument. None.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The result value is equal to the number of command arguments available. If there are no
<P>
<PRE>
  command arguments available or if the processor does not support command arguments, then the result has the
<P>
  value zero. If the processor has a concept of a command name, the command name does not count as one of the
<P>
  command arguments.
<P>
</PRE>
6 Example. See 16.9.83.
<P>
<PRE>
  16.9.52       CONJG (Z)
<P>
</PRE>
1 Description. Conjugate of a complex number.
<P>
2 Class. Elemental function.
<P>
<PRE>
  368                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Argument. Z shall be of type complex.
<P>
4 Result Characteristics. Same as Z.
<P>
5 Result Value. If Z has the value (x, y), the result has the value (x, −y).
<P>
6 Example. CONJG ((2.0, 3.0)) has the value (2.0, −3.0).
<P>
<PRE>
  16.9.53         COS (X)
<P>
</PRE>
1 Description. Cosine function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>cos</B>(X). If X is of type
<P>
<PRE>
  real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
<P>
</PRE>
6 Example. COS (1.0) has the value 0.54030231 (approximately).
<P>
<PRE>
  16.9.54         COSH (X)
<P>
</PRE>
1 Description. Hyperbolic cosine function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>cosh</B>(X). If X is of type
<P>
<PRE>
  complex its imaginary part is regarded as a value in radians.
<P>
</PRE>
6 Example. COSH (1.0) has the value 1.5430806 (approximately).
<P>
<PRE>
  16.9.55         COSHAPE (COARRAY [, KIND])
<P>
</PRE>
1 Description. Sizes of codimensions of a coarray.
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  COARRAY shall be a coarray of any type. It shall not be an unallocated allocatable coarray. If its designator
<P>
                  has more than one part-ref , the rightmost part-ref shall have nonzero corank.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value
<P>
<PRE>
  of KIND; otherwise the kind type parameter is that of default integer type. The result is an array of rank one
<P>
  whose size is equal to the corank of COARRAY.
<P>
</PRE>
5 Result Value. The result has a value whose ith element is equal to the size of the ith codimension of COARRAY,
<P>
<PRE>
  as given by UCOBOUND (COARRAY, i) − LCOBOUND (COARRAY, i) +1.
<P>
</PRE>
6 Example.
<P>
<PRE>
  The following code allocates the coarray D with the same size in each codimension as that of the coarray C, with
<P>
  the lower cobound 1.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            369
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
      REAL, ALLOCATABLE :: C[:,:], D[:,:]
<P>
      INTEGER, ALLOCATABLE :: COSHAPE_C(:)
<P>
      &#46;&#46;&#46;
<P>
      COSHAPE_C = COSHAPE(C)
<P>
      ALLOCATE ( D[COSHAPE_C(1),*] )
<P>
  16.9.56       COUNT (MASK [, DIM, KIND])
<P>
</PRE>
1 Description. Logical array reduced by counting true values.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  MASK          shall be a logical array.
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
<P>
                The corresponding actual argument shall not be an optional dummy argument, a disassociated
<P>
                pointer, or an unallocated allocatable.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is absent or
<P>
  n = 1; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where [d1 , d2 , . . . , dn ]
<P>
  is the shape of MASK.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     If DIM is absent or MASK has rank one, the result has a value equal to the number of true elements
<P>
                of MASK or has the value zero if MASK has size zero.
<P>
  Case (ii):    If DIM is present and MASK has rank n &gt; 1, the value of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . ,
<P>
                sn ) of the result is equal to the number of true elements of MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 ,
<P>
                . . . , sn ).
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):     The value of COUNT ([.TRUE., .FALSE., .TRUE.]) is 2.
<P>
                                                                                   
<P>
                                       1 3 5                                 0 3    5
<P>
  Case (ii):    If B is the array                 and C is the array                   , COUNT (B /= C, DIM = 1) is
<P>
                                       2 4 6                                 7 4    8
<P>
                [2, 0, 1] and COUNT (B /= C, DIM = 2) is [1, 2].
<P>
  16.9.57       CPU_TIME (TIME)
<P>
</PRE>
1 Description. Processor time used.
<P>
2 Class. Subroutine.
<P>
3 Argument. TIME shall be a real scalar. It is an INTENT (OUT) argument. If the processor cannot provide
<P>
<PRE>
  a meaningful value for the time, it is assigned a processor-dependent negative value; otherwise, it is assigned a
<P>
  processor-dependent approximation to the processor time in seconds. Whether the value assigned is an approx-
<P>
  imation to the amount of time used by the invoking image, or the amount of time used by the whole program, is
<P>
  processor dependent.
<P>
</PRE>
4 Example.
<P>
<PRE>
             REAL T1, T2
<P>
             &#46;&#46;&#46;
<P>
             CALL CPU_TIME(T1)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>370</B> </TD><TD valign=bottom>
⃝ c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>&#46;&#46;&#46;</B> </TD><TD valign=bottom>
! Code to be timed.
</TD></TR>
<TR></TR></TABLE>CALL <B>CPU_TIME</B>(T2)
<P>
WRITE (*,*) ’Time taken by code was ’, T2-T1, ’ seconds’
</BLOCKQUOTE>
<P>
writes the processor time taken by a piece of code.
<P>
<PRE>
       NOTE 16.12
<P>
       A processor for which a single result is inadequate (for example, a parallel processor) might choose to
<P>
       provide an additional version for which time is an array.
<P>
       The exact definition of time is left imprecise because of the variability in what different processors are able
<P>
       to provide. The primary purpose is to compare different algorithms on the same processor or discover which
<P>
       parts of a calculation are the most expensive.
<P>
       The start time is left imprecise because the purpose is to time sections of code, as in the example.
<P>
       Most computer systems have multiple concepts of time. One common concept is that of time expended by
<P>
       the processor for a given program. This might or might not include system overhead, and has no obvious
<P>
       connection to elapsed “wall clock” time.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>16.9.58</B> </TD><TD valign=bottom>
CSHIFT (ARRAY, SHIFT [, DIM])
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Description. Circular shift of an array.
<BLOCKQUOTE>
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY         may be of any type. It shall be an array.
<P>
  SHIFT         shall be of type integer and shall be scalar if ARRAY has rank one; otherwise, it shall be scalar or
<P>
                of rank n − 1 and of shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where [d1 , d2 , . . . , dn ] is the shape
<P>
                of ARRAY.
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
                If DIM is absent, it is as if it were present with the value 1.
<P>
</PRE>
4 Result Characteristics. The result is of the type and type parameters of ARRAY, and has the shape of
<P>
<PRE>
  ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     If ARRAY has rank one, element i of the result is ARRAY (1 + MODULO (i + SHIFT − 1, SIZE
<P>
                (ARRAY))).
<P>
  Case (ii):    If ARRAY has rank greater than one, section (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . ., sn ) of the result
<P>
                has a value equal to CSHIFT (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . ., sn ), sh, 1), where sh is
<P>
                SHIFT or SHIFT (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ).
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):     If V is the array [1, 2, 3, 4, 5, 6], the effect of shifting V circularly to the left by two positions is
<P>
                achieved by CSHIFT (V, SHIFT = 2) which has the value [3, 4, 5, 6, 1, 2]; CSHIFT (V, SHIFT =
<P>
                −2) achieves a circular shift to the right by two positions and has the value [5, 6, 1, 2, 3, 4].
<P>
  Case (ii):    The rows of an array
<P>
                                   of ranktwo may all be shifted by the same amount or by different amounts.
<P>
                                     1 2 3
<P>
                If M is the array  4 5 6 , the value of
<P>
                                     7 8 9
<P>
                                                                            
<P>
                                                                  3 1 2
<P>
                CSHIFT (M, SHIFT = −1, DIM = 2) is  6 4 5 , and the value of
<P>
                                                                  9 7 8
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                            371
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                                                                              
<P>
                                                                      3   1  2
<P>
                CSHIFT (M, SHIFT = [−1, 1, 0], DIM = 2) is  5            6  4 .
<P>
                                                                      7   8  9
<P>
  16.9.59       DATE_AND_TIME ([DATE, TIME, ZONE, VALUES])
<P>
</PRE>
1 Description. Date and time.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  DATE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value
<P>
                of the form YYYYMMDD, where YYYY is the year in the Gregorian calendar, MM is the month
<P>
                within the year, and DD is the day within the month. The characters of this value shall all be
<P>
                decimal digits. If there is no date available, DATE is assigned all blanks.
<P>
  TIME (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value
<P>
                of the form hhmmss.sss, where hh is the hour of the day, mm is the minutes of the hour, and ss.sss
<P>
                is the seconds and milliseconds of the minute. Except for the decimal point, the characters of this
<P>
                value shall all be decimal digits. If there is no clock available, TIME is assigned all blanks.
<P>
  ZONE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value of
<P>
                the form +hhmm or -hhmm, where hh and mm are the time difference with respect to Coordinated
<P>
                Universal Time (UTC) in hours and minutes, respectively. The characters of this value following
<P>
                the sign character shall all be decimal digits. If this information is not available, ZONE is assigned
<P>
                all blanks.
<P>
  VALUES (optional) shall be a rank-one array of type integer with a decimal exponent range of at least four. It
<P>
                is an INTENT (OUT) argument. Its size shall be at least 8. The values assigned to VALUES are
<P>
                as follows:
<P>
    VALUES (1) the year, including the century (for example, 2008), or −HUGE (VALUES) if there is no date
<P>
                available;
<P>
    VALUES (2) the month of the year, or −HUGE (VALUES) if there is no date available;
<P>
    VALUES (3) the day of the month, or −HUGE (VALUES) if there is no date available;
<P>
    VALUES (4) the time difference from Coordinated Universal Time (UTC) in minutes, or −HUGE (VALUES)
<P>
                if this information is not available;
<P>
    VALUES (5) the hour of the day, in the range of 0 to 23, or −HUGE (VALUES) if there is no clock;
<P>
    VALUES (6) the minutes of the hour, in the range 0 to 59, or −HUGE (VALUES) if there is no clock;
<P>
    VALUES (7) the seconds of the minute, in the range 0 to 60, or −HUGE (VALUES) if there is no clock;
<P>
    VALUES (8) the milliseconds of the second, in the range 0 to 999, or −HUGE (VALUES) if there is no clock.
<P>
</PRE>
4 The date, clock, and time zone information might be available on some images and not others. If the date, clock,
<P>
<PRE>
  or time zone information is available on more than one image, it is processor dependent whether or not those
<P>
  images share the same information.
<P>
</PRE>
5 Example. If run in Geneva, Switzerland on April 12, 2008 at 15:27:35.5 with a system configured for the
<P>
<PRE>
  local time zone, this example would have assigned the value 20080412 to BIG_BEN (1), the value 152735.500 to
<P>
  BIG_BEN (2), the value +0100 to BIG_BEN (3), and the value [2008, 4, 12, 60, 15, 27, 35, 500] to DATE_TIME.
<P>
           INTEGER DATE_TIME (8)
<P>
           CHARACTER (LEN = 10) BIG_BEN (3)
<P>
           CALL DATE_AND_TIME (BIG_BEN (1), BIG_BEN (2), BIG_BEN (3), DATE_TIME)
<P>
  372                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 16.13
<P>
       These forms are compatible with the representations defined in ISO 8601:2004. UTC is established by the
<P>
       International Bureau of Weights and Measures (BIPM, i.e. Bureau International des Poids et Mesures) and
<P>
       the International Earth Rotation Service (IERS).
<P>
  16.9.60       DBLE (A)
<P>
</PRE>
1 Description. Conversion to double precision real.
<P>
2 Class. Elemental function.
<P>
3 Argument. A shall be of type integer, real, complex, or a boz-literal-constant.
<P>
4 Result Characteristics. Double precision real.
<P>
5 Result Value. The result has the value REAL (A, KIND (0.0D0)).
<P>
6 Example. DBLE (−3) has the value −3.0D0.
<P>
<PRE>
  16.9.61       DIGITS (X)
<P>
</PRE>
1 Description. Significant digits in numeric model.
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be of type integer or real. It may be a scalar or an array.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The result has the value q if X is of type integer and p if X is of type real, where q and p are as
<P>
<PRE>
  defined in 16.4 for the model representing numbers of the same type and kind type parameter as X.
<P>
</PRE>
6 Example. DIGITS (X) has the value 24 for real X whose model is as in NOTE 16.4.
<P>
<PRE>
  16.9.62       DIM (X, Y)
<P>
</PRE>
1 Description. Maximum of X − Y and zero.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be of type integer or real.
<P>
  Y             shall be of the same type and kind type parameter as X.
<P>
</PRE>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The value of the result is the maximum of X − Y and zero.
<P>
6 Example. DIM (−3.0, 2.0) has the value 0.0.
<P>
<PRE>
  16.9.63       DOT_PRODUCT (VECTOR_A, VECTOR_B)
<P>
</PRE>
1 Description. Dot product of two vectors.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  VECTOR_A shall be of numeric type (integer, real, or complex) or of logical type. It shall be a rank-one array.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                       373
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  VECTOR_B shall be of numeric type if VECTOR_A is of numeric type or of type logical if VECTOR_A is of
<P>
                type logical. It shall be a rank-one array. It shall be of the same size as VECTOR_A.
<P>
</PRE>
4 Result Characteristics. If the arguments are of numeric type, the type and kind type parameter of the result
<P>
<PRE>
  are those of the expression VECTOR_A * VECTOR_B determined by the types and kinds of the arguments
<P>
  according to 10.1.9.3. If the arguments are of type logical, the result is of type logical with the kind type parameter
<P>
  of the expression VECTOR_A .AND. VECTOR_B according to 10.1.9.3. The result is scalar.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     If VECTOR_A is of type integer or real, the result has the value SUM (VECTOR_A*VECTOR_-
<P>
                B). If the vectors have size zero, the result has the value zero.
<P>
  Case (ii):    If VECTOR_A is of type complex, the result has the value SUM (CONJG (VECTOR_A)*VECT-
<P>
                OR_B). If the vectors have size zero, the result has the value zero.
<P>
  Case (iii):   If VECTOR_A is of type logical, the result has the value ANY (VECTOR_A .AND. VECTOR_B).
<P>
                If the vectors have size zero, the result has the value false.
<P>
</PRE>
6 Example. DOT_PRODUCT ([1, 2, 3], [2, 3, 4]) has the value 20.
<P>
<PRE>
  16.9.64       DPROD (X, Y)
<P>
</PRE>
1 Description. Double precision real product.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be default real.
<P>
  Y             shall be default real.
<P>
</PRE>
4 Result Characteristics. Double precision real.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the product of X and
<P>
<PRE>
  Y. DPROD (X, Y) should have the same value as DBLE (X) * DBLE (Y).
<P>
</PRE>
6 Example. DPROD (−3.0, 2.0) has the value −6.0D0.
<P>
<PRE>
  16.9.65       DSHIFTL (I, J, SHIFT)
<P>
</PRE>
1 Description. Combined left shift.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer or a boz-literal-constant.
<P>
  J             shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
<P>
                the same kind type parameter. I and J shall not both be boz-literal-constants.
<P>
  SHIFT         shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I) if I is of
<P>
                type integer; otherwise, it shall be less than or equal to BIT_SIZE (J).
<P>
</PRE>
4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
<P>
5 Result Value. If either I or J is a boz-literal-constant, it is first converted as if by the intrinsic function INT to
<P>
<PRE>
  type integer with the kind type parameter of the other. The rightmost SHIFT bits of the result value are the same
<P>
  as the leftmost bits of J, and the remaining bits of the result value are the same as the rightmost bits of I. This
<P>
  is equal to IOR (SHIFTL (I, SHIFT), SHIFTR (J, BIT_SIZE (J)−SHIFT)). The model for the interpretation of
<P>
  an integer value as a sequence of bits is in 16.3.
<P>
  374                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Examples. DSHIFTL (1, 2**30, 2) has the value 5 if default integer has 32 bits. DSHIFTL (I, I, SHIFT) has
<P>
<PRE>
  the same result value as ISHFTC (I, SHIFT).
<P>
  16.9.66       DSHIFTR (I, J, SHIFT)
<P>
</PRE>
1 Description. Combined right shift.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer or a boz-literal-constant.
<P>
  J             shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
<P>
                the same kind type parameter. I and J shall not both be boz-literal-constants.
<P>
  SHIFT         shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I) if I is of
<P>
                type integer; otherwise, it shall be less than or equal to BIT_SIZE (J).
<P>
</PRE>
4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
<P>
5 Result Value. If either I or J is a boz-literal-constant, it is first converted as if by the intrinsic function INT to
<P>
<PRE>
  type integer with the kind type parameter of the other. The leftmost SHIFT bits of the result value are the same
<P>
  as the rightmost bits of I, and the remaining bits of the result value are the same as the leftmost bits of J. This
<P>
  is equal to IOR (SHIFTL (I, BIT_SIZE (I)−SHIFT), SHIFTR (J, SHIFT)). The model for the interpretation of
<P>
  an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Examples. DSHIFTR (1, 16, 3) has the value 229 + 2 if default integer has 32 bits. DSHIFTR (I, I, SHIFT) has
<P>
<PRE>
  the same result value as ISHFTC (I,−SHIFT).
<P>
  16.9.67       EOSHIFT (ARRAY, SHIFT [, BOUNDARY, DIM])
<P>
</PRE>
1 Description. End-off shift of the elements of an array.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY         shall be an array be of any type.
<P>
  SHIFT         shall be of type integer and shall be scalar if ARRAY has rank one; otherwise, it shall be scalar or
<P>
                of rank n − 1 and of shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where [d1 , d2 , . . . , dn ] is the shape
<P>
                of ARRAY.
<P>
  BOUNDARY (optional) shall be of the same type and type parameters as ARRAY and shall be scalar if ARRAY
<P>
                has rank one; otherwise, it shall be either scalar or of rank n − 1 and of shape [d1 , d2 , . . . , dDIM−1 ,
<P>
                dDIM+1 , . . . , dn ]. BOUNDARY is permitted to be absent only for the types in Table 16.4, and in
<P>
                this case it is as if it were present with the scalar value shown, converted if necessary to the kind
<P>
                type parameter value of ARRAY.
<P>
                               Table 16.4: Default BOUNDARY values for EOSHIFT
<P>
                                         Type of ARRAY          Value of BOUNDARY
<P>
                                             Integer                       0
<P>
                                               Real                       0.0
<P>
                                            Complex                    (0.0, 0.0)
<P>
                                             Logical                   .FALSE.
<P>
                                         Character (len)              len blanks
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
                If DIM is absent, it is as if it were present with the value 1.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                            375
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. The result has the type, type parameters, and shape of ARRAY.
<P>
5 Result Value. Element (s1 , s2 , . . . , sn ) of the result has the value ARRAY (s1 , s2 , . . . , sDIM−1 , sDIM + sh,
<P>
<PRE>
  sDIM+1 , . . . , sn ) where sh is SHIFT or SHIFT (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) provided the inequality
<P>
  LBOUND (ARRAY, DIM) ≤ sDIM + sh ≤ UBOUND (ARRAY, DIM) holds and is otherwise BOUNDARY or
<P>
  BOUNDARY (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ).
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):        If V is the array [1, 2, 3, 4, 5, 6], the effect of shifting V end-off to the left by 3 positions is achieved
<P>
                   by EOSHIFT (V, SHIFT = 3), which has the value [4, 5, 6, 0, 0, 0]; EOSHIFT (V, SHIFT = −2,
<P>
                   BOUNDARY = 99) achieves an end-off shift to the right by 2 positions with the boundary value of
<P>
                   99 and has the value [99, 99, 1, 2, 3, 4].
<P>
  Case (ii):       The rows of an array of rank two may all be shifted by the same amountor by different            amounts
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; A B C</H4>
</A>
<BLOCKQUOTE>
<P>
and the boundary elements can be the same or different. If M is the array  D E F , then the
<P>
<PRE>
                                                                                                        G H I
<P>
                                                                                                    * A B
<P>
</PRE>
value of EOSHIFT (M, SHIFT = −1, BOUNDARY = ’*’, DIM = 2) is  * D E , and the value
<P>
<PRE>
                                                                                                    ∗ G H
<P>
                                                                                                                            
<P>
                                                                                                                 * A B
<P>
</PRE>
of EOSHIFT (M, SHIFT = [−1, 1, 0], BOUNDARY = [’*’, ’/’, ’?’], DIM = 2) is  E F / .
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; G H I</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>16.9.68</B> </TD><TD valign=bottom>
EPSILON (X)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Description. Model number that is small compared to 1.
<BLOCKQUOTE>
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be of type real. It may be a scalar or an array.
<P>
4 Result Characteristics. Scalar of the same type and kind type parameter as X.
<P>
5 Result Value. The result has the value b1−p where b and p are as defined in 16.4 for the model representing
<P>
<PRE>
  numbers of the same type and kind type parameter as X.
<P>
</PRE>
6 Example. EPSILON (X) has the value 2−23 for real X whose model is as in NOTE 16.4.
<P>
<PRE>
  16.9.69          ERF (X)
<P>
</PRE>
1 Description. Error function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the error function of X,
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; RX</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>√2</B> </TD><TD valign=bottom>
<B>exp</B>(−t2 ) dt.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
    π  0
<P>
</PRE>
6 Example. ERF (1.0) has the value 0.843 (approximately).
<P>
<PRE>
  16.9.70          ERFC (X)
<P>
</PRE>
1 Description. Complementary error function.
</BLOCKQUOTE>
<P>
2 Class. Elemental function.
<P>
<PRE>
  376                                                                        ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Argument. X shall be of type real.
<BLOCKQUOTE>
<P>
4 Result Characteristics. Same as X.
<TABLE cellpadding=3><!-- tsb: 4 Result Characteristics. Same as X.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>5 Result Value. The result has a value equal to a processor-dependent</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
approximation to the complementary error
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                           ∞
<P>
</PRE>
√2
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; R</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>function of X, 1 − ERF (X); this is equivalent to</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
π   X
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                             exp(−t2 )dt.
<P>
</PRE>
6 Example. ERFC (1.0) has the value 0.157 (approximately).
<P>
<PRE>
  16.9.71       ERFC_SCALED (X)
<P>
</PRE>
1 Description. Scaled complementary error function.
</BLOCKQUOTE>
<P>
2 Class. Elemental function.
<BLOCKQUOTE>
<P>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to aR processor-dependent approximation to the exponentially-scaled
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: 5 Result Value. The result has a value equal to aR processor-dependent approximation to the exponentially-scaled
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>2 2</B> </TD><TD valign=bottom>
∞         2
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>complementary error function of X, </B><B>exp</B>(X ) √π <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                        exp(−t ) dt.
<P>
</PRE>
6 Example. ERFC_SCALED (20.0) has the value 0.02817434874 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 16.14
<P>
                                                                             √
<P>
       The complementary error function is asymptotic to exp(−X 2 )/(X π). As such it underflows for X &gt;≈ 9
<P>
       when using ISO/IEC/IEEE 60559:2011 single √     precision arithmetic. The exponentially-scaled complement-
<P>
                                                                                                            √
<P>
       ary error function is asymptotic to 1/(X π). As such it does not underflow until X &gt; HUGE (X)/ π.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>16.9.72</B> </TD><TD valign=bottom>
EVENT_QUERY (EVENT, COUNT [, STAT])
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 Description. Query event count.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  EVENT         shall be an event variable (16.10.2.10). It shall not be coindexed. It is an INTENT (IN) argument.
<P>
                The EVENT argument is accessed atomically with respect to the execution of EVENT POST
<P>
                statements in unordered segments, in exact analogy to atomic subroutines.
<P>
  COUNT         shall be an integer scalar with a decimal exponent range no smaller than that of default integer. It
<P>
                is an INTENT (OUT) argument. If no error condition occurs, COUNT is assigned the value of the
<P>
                count of EVENT; otherwise, it is assigned the value −1.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                INTENT (OUT) argument. If the STAT argument is present, it is assigned a processor-dependent
<P>
                positive value if an error condition occurs; otherwise it is assigned the value zero. If the STAT
<P>
                argument is not present and an error condition occurs, error termination is initiated.
<P>
</PRE>
4 Example. If EVENT is an event variable for which there have been no successful posts or waits in preceding
<P>
<PRE>
  segments, and for which there are no posts or waits in an unordered segment, after execution of
<P>
           CALL EVENT_QUERY (EVENT, COUNT)
<P>
  the integer variable COUNT will have the value zero. If there have been ten successful posts to EVENT and two
<P>
  successful waits without an UNTIL_COUNT= specifier in preceding segments, and for which there are no posts
<P>
  or waits in an unordered segment, after execution of
<P>
           CALL EVENT_QUERY (EVENT, COUNT)
<P>
  the variable COUNT will have the value eight.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        377
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 16.15
<P>
        Execution of EVENT_QUERY does not imply any synchronization.
<P>
  16.9.73       EXECUTE_COMMAND_LINE (COMMAND [, WAIT, EXITSTAT,
<P>
                CMDSTAT, CMDMSG ])
<P>
</PRE>
1 Description. Execute a command line.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  COMMAND shall be a default character scalar. It is an INTENT (IN) argument. Its value is the command line
<P>
                to be executed. The interpretation is processor dependent.
<P>
  WAIT (optional) shall be a logical scalar. It is an INTENT (IN) argument. If WAIT is present with the value
<P>
                false, and the processor supports asynchronous execution of the command, the command is executed
<P>
                asynchronously; otherwise it is executed synchronously.
<P>
  EXITSTAT (optional) shall be a scalar of type integer with a decimal exponent range of at least nine. It is an
<P>
                INTENT (INOUT) argument. If the command is executed synchronously, it is assigned the value
<P>
                of the processor-dependent exit status. Otherwise, the value of EXITSTAT is unchanged.
<P>
  CMDSTAT (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
<P>
                INTENT (OUT) argument. It is assigned the value −1 if the processor does not support command
<P>
                line execution, a processor-dependent positive value if an error condition occurs, or the value −2
<P>
                if no error condition occurs but WAIT is present with the value false and the processor does not
<P>
                support asynchronous execution. Otherwise it is assigned the value 0.
<P>
  CMDMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. If an error condi-
<P>
                tion occurs, it is assigned a processor-dependent explanatory message. Otherwise, it is unchanged.
<P>
</PRE>
4 If the processor supports command line execution, it shall support synchronous and may support asynchronous
<P>
<PRE>
  execution of the command line.
<P>
</PRE>
5 When the command is executed synchronously, EXECUTE_COMMAND_LINE returns after the command line
<P>
<PRE>
  has completed execution. Otherwise, EXECUTE_COMMAND_LINE returns without waiting.
<P>
</PRE>
6 If a condition occurs that would assign a nonzero value to CMDSTAT but the CMDSTAT variable is not present,
<P>
<PRE>
  error termination is initiated.
<P>
  16.9.74       EXP (X)
<P>
</PRE>
1 Description. Exponential function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to eX . If X is of type
<P>
<PRE>
  complex, its imaginary part is regarded as a value in radians.
<P>
</PRE>
6 Example. EXP (1.0) has the value 2.7182818 (approximately).
<P>
<PRE>
  16.9.75       EXPONENT (X)
<P>
</PRE>
1 Description. Exponent of floating-point number.
<P>
2 Class. Elemental function.
<P>
<PRE>
  378                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Default integer.
<P>
5 Result Value. The result has a value equal to the exponent e of the representation for the value of X in the
<P>
<PRE>
  extended real model for the kind of X (16.4), provided X is nonzero and e is within the range for default integers.
<P>
  If X has the value zero, the result has the value zero. If X is an IEEE infinity or NaN, the result has the value
<P>
  HUGE (0).
<P>
</PRE>
6 Examples. EXPONENT (1.0) has the value 1 and EXPONENT (4.1) has the value 3 for reals whose model is
<P>
<PRE>
  as in NOTE 16.4.
<P>
  16.9.76        EXTENDS_TYPE_OF (A, MOLD)
<P>
</PRE>
1 Description. Dynamic type extension inquiry.
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
<P>
                 pointer, it shall not have an undefined association status.
<P>
  MOLD           shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
<P>
                 pointer, it shall not have an undefined association status.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
<P>
5 Result Value. If MOLD is unlimited polymorphic and is either a disassociated pointer or unallocated allocatable
<P>
<PRE>
  variable, the result is true; otherwise if A is unlimited polymorphic and is either a disassociated pointer or
<P>
  unallocated allocatable variable, the result is false; otherwise if the dynamic type of A or MOLD is extensible, the
<P>
  result is true if and only if the dynamic type of A is an extension type of the dynamic type of MOLD; otherwise
<P>
  the result is processor dependent.
<P>
       NOTE 16.16
<P>
       The dynamic type of a disassociated pointer or unallocated allocatable variable is its declared type.
<P>
       NOTE 16.17
<P>
       The test performed by EXTENDS_TYPE_OF is not the same as the test performed by the type guard
<P>
       CLASS IS. The test performed by EXTENDS_TYPE_OF does not consider kind type parameters.
<P>
</PRE>
6 Example. Given the declarations and assignments
<P>
<PRE>
            TYPE T1
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; REAL C</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE, <B>EXTENDS</B>(T1) :: T2
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>CLASS</B>(T1), POINTER :: P, Q
<P>
ALLOCATE (P)
<P>
ALLOCATE (T2 :: Q)
</BLOCKQUOTE>
<P>
the result of EXTENDS_TYPE_OF (P, Q) will be false, and the result of EXTENDS_TYPE_OF (Q, P) will
<BLOCKQUOTE>
<P>
be true.
<TABLE cellpadding=3><!-- tsb: be true.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
379
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>16.9.77</B> </TD><TD valign=bottom>
FAILED_IMAGES ([TEAM, KIND])
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Description. Indices of failed images.
<BLOCKQUOTE>
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV. Its
<P>
                      value shall be that of the current or an ancestor team. If TEAM is absent, the team specified is the
<P>
                      current team.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value
<P>
<PRE>
  of KIND; otherwise, the kind type parameter is that of default integer type. The result is an array of rank one
<P>
  whose size is equal to the number of images in the specified team that are known by the invoking image to have
<P>
  failed.
<P>
</PRE>
5 Result Value. The elements of the result are the values of the image indices of the known failed images in the
<P>
<PRE>
  specified team, in numerically increasing order. If the executing image has previously executed an image control
<P>
  statement whose STAT= specifier assigned the value STAT_FAILED_IMAGE from the intrinsic module ISO_-
<P>
  FORTRAN_ENV, or referenced a collective subroutine whose STAT argument was set to STAT_FAILED_-
<P>
  IMAGE, at least one image in the set of images participating in that image control statement or collective
<P>
  subroutine reference shall be known to have failed.
<P>
</PRE>
6 Examples. If image 3 is the only image in the current team that is known by the invoking image to have failed,
<P>
<PRE>
  FAILED_IMAGES() will have the value [3]. If there are no images in the current team that are known by the
<P>
  invoking image to have failed, the value of FAILED_IMAGES() will be a zero-sized array.
<P>
  16.9.78             FINDLOC (ARRAY, VALUE, DIM [, MASK, KIND, BACK]) or
<P>
                      FINDLOC (ARRAY, VALUE [, MASK, KIND, BACK])
<P>
</PRE>
1 Description. <B>Location</B>(s) of a specified value.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY               shall be an array of intrinsic type.
<P>
  VALUE               shall be scalar and in type conformance with ARRAY, as specified in Table 10.2 for the operator
<P>
                      == or the operator .EQV..
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
  BACK (optional) shall be a logical scalar.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
<P>
  an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank n − 1 and shape
<P>
  [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ], where [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):           The result of FINDLOC (ARRAY, VALUE) is a rank-one array whose element values are the values
<P>
                      of the subscripts of an element of ARRAY whose value matches VALUE. If there is such a value,
<P>
                      the ith element value is in the range 1 to ei , where ei is the extent of the ith dimension of ARRAY.
<P>
                      If no elements match VALUE or ARRAY has size zero, all elements of the result are zero.
<P>
  380                                                                                  ⃝
<P>
                                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
<P>
  Case (ii):     The result of FINDLOC (ARRAY, VALUE, MASK = MASK) is a rank-one array whose element
<P>
                 values are the values of the subscripts of an element of ARRAY, corresponding to a true element
<P>
                 of MASK, whose value matches VALUE. If there is such a value, the ith element value is in the
<P>
                 range 1 to ei , where ei is the extent of the ith dimension of ARRAY. If no elements match VALUE,
<P>
                 ARRAY has size zero, or every element of MASK has the value false, all elements of the result are
<P>
                 zero.
<P>
  Case (iii):    If ARRAY has rank one, the result of
<P>
                 FINDLOC (ARRAY, VALUE, DIM=DIM [, MASK = MASK]) is a scalar whose value is equal to
<P>
                 that of the first element of FINDLOC (ARRAY, VALUE [, MASK = MASK]). Otherwise, the value
<P>
                 of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to FINDLOC (ARRAY (s1 ,
<P>
                 s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ), VALUE, DIM=1 [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :,
<P>
                 sDIM+1 , . . . , sn )]).
<P>
</PRE>
6 If both ARRAY and VALUE are of type logical, the comparison is performed with the .EQV. operator; otherwise,
<P>
<PRE>
  the comparison is performed with the == operator. If the value of the comparison is true, that element of ARRAY
<P>
  matches VALUE.
<P>
</PRE>
7 If DIM is not present, more than one element matches VALUE, and BACK is absent or present with the value
<P>
<PRE>
  false, the value returned indicates the first such element, taken in array element order. If DIM is not present and
<P>
  BACK is present with the value true, the value returned indicates the last such element, taken in array element
<P>
  order.
<P>
</PRE>
8 Examples.
<P>
<PRE>
  Case (i):      The value of FINDLOC ([2, 6, 4, 6], VALUE = 6) is [2], and the value of FINDLOC ([2, 6, 4, 6],
<P>
                 VALUE = 6, BACK = .TRUE.) is [4].
<P>
                                                                                                         
<P>
                                            0 −5 7 7                                          T T F T
<P>
  Case (ii):     If A has the value  3 4 −1 2 , and M has the value  T T F T , FINDLOC (A, 7,
<P>
                                            1 5         6 7                                   T T F T
<P>
                 MASK = M) has the value [1, 4] and FINDLOC (A, 7, MASK = M, BACK = .TRUE.) has the
<P>
                 value [3, 4]. This is independent of the declared lower bounds for A.
<P>
  Case (iii):    The
<P>
                       value of FINDLOC
<P>
                                               ([2, 6, 4], VALUE = 6, DIM = 1) is 2. If B has the value
<P>
                    1 2 −9
<P>
                                   , FINDLOC (B, VALUE = 2, DIM = 1) has the value [2, 1, 0] and FINDLOC (B,
<P>
                    2 2 6
<P>
                 VALUE = 2, DIM = 2) has the value [2, 1]. This is independent of the declared lower bounds for B.
<P>
  16.9.79        FLOOR (A [, KIND])
<P>
</PRE>
1 Description. Greatest integer less than or equal to A.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be of type real.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result has a value equal to the greatest integer less than or equal to A.
<P>
6 Examples. FLOOR (3.7) has the value 3. FLOOR (−3.7) has the value −4.
<P>
<PRE>
  16.9.80        FRACTION (X)
<P>
</PRE>
1 Description. Fractional part of number.
<P>
2 Class. Elemental function.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               381
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has the value X × b−e , where b and e are as defined in 16.4 for the representation of
<P>
<PRE>
  X in the extended real model for the kind of X. If X has the value zero, the result is zero. If X is an IEEE NaN,
<P>
  the result is that NaN. If X is an IEEE infinity, the result is an IEEE NaN.
<P>
</PRE>
6 Example. FRACTION (3.0) has the value 0.75 for reals whose model is as in NOTE 16.4.
<P>
<PRE>
  16.9.81        GAMMA (X)
<P>
</PRE>
1 Description. Gamma function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real. Its value shall not be a negative integer or zero.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the gamma function of
<P>
<PRE>
  X,
<P>
                   R ∞ X−1
<P>
                   0 t
<P>
                              exp(−t) dt                       X&gt;0
<P>
        Γ(X) =                                         
<P>
                   ∞ tX−1 exp(−t) − Pn
<P>
                      R                           (−t)k
<P>
                                                          dt    −n − 1 &lt; X &lt; −n, n an integer ≥ 0
<P>
                  
<P>
                        0                     k=0   k!
<P>
</PRE>
6 Example. GAMMA (1.0) has the value 1.000 (approximately).
<P>
<PRE>
  16.9.82        GET_COMMAND ([COMMAND, LENGTH, STATUS, ERRMSG])
<P>
</PRE>
1 Description. Get program invocation command.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  COMMAND (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned
<P>
                 the entire command by which the program was invoked. If the command cannot be determined,
<P>
                 COMMAND is assigned all blanks.
<P>
  LENGTH (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned the significant length of the command by which the
<P>
                 program was invoked. The significant length may include trailing blanks if the processor allows
<P>
                 commands with significant trailing blanks. This length does not consider any possible truncation or
<P>
                 padding in assigning the command to the COMMAND argument; in fact the COMMAND argument
<P>
                 need not even be present. If the command length cannot be determined, a length of 0 is assigned.
<P>
  STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. It is assigned the value −1 if the COMMAND argument is present and
<P>
                 has a length less than the significant length of the command. It is assigned a processor-dependent
<P>
                 positive value if the command retrieval fails. Otherwise it is assigned the value 0.
<P>
  ERRMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned a
<P>
                 processor-dependent explanatory message if the command retrieval fails. Otherwise, it is unchanged.
<P>
</PRE>
4 Example. If the program below is invoked with the command “example” on a processor that supports command
<P>
<PRE>
  retrieval, it will display “Hello example”.
<P>
  382                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
          PROGRAM hello
<P>
            CHARACTER(:), ALLOCATABLE :: cmd
<P>
            INTEGER :: cmdlen
<P>
            CALL GET_COMMAND(LENGTH=cmdlen)
<P>
            IF (cmdlen&gt;0) THEN
<P>
              ALLOCATE(CHARACTER(cmdlen) :: cmd)
<P>
              CALL GET_COMMAND(cmd)
<P>
              PRINT *, ’Hello ’, cmd
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>16.9.83</B> </TD><TD valign=bottom>
GET_COMMAND_ARGUMENT (NUMBER [, VALUE, LENGTH,
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
              STATUS, ERRMSG])
<P>
</PRE>
1 Description. Get program invocation argument.
</BLOCKQUOTE>
<P>
2 Class. Subroutine.
<BLOCKQUOTE>
<P>
3 Arguments.
<P>
<PRE>
  NUMBER      shall be an integer scalar. It is an INTENT (IN) argument that specifies the number of the command
<P>
              argument that the other arguments give information about.
<P>
              Command argument 0 always exists, and is the command name by which the program was invoked
<P>
              if the processor has such a concept; otherwise, the value of command argument 0 is processor
<P>
              dependent. The remaining command arguments are numbered consecutively from 1 to the argument
<P>
              count in an order determined by the processor.
<P>
  VALUE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. If the command
<P>
              argument specified by NUMBER exists, its value is assigned to VALUE; otherwise, VALUE is
<P>
              assigned all blanks.
<P>
  LENGTH (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
<P>
              INTENT (OUT) argument. If the command argument specified by NUMBER exists, its significant
<P>
              length is assigned to LENGTH; otherwise, LENGTH is assigned the value zero. It is processor
<P>
              dependent whether the significant length includes trailing blanks. This length does not consider any
<P>
              possible truncation or padding in assigning the command argument value to the VALUE argument;
<P>
              in fact the VALUE argument need not even be present.
<P>
  STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
<P>
              INTENT (OUT) argument. If NUMBER is less than zero or greater than the argument count that
<P>
              would be returned by the intrinsic function COMMAND_ARGUMENT_COUNT, or command
<P>
              retrieval fails, STATUS is assigned a processor-dependent positive value. Otherwise, if VALUE is
<P>
              present and has a length less than the significant length of the specified command argument, it is
<P>
              assigned the value −1. Otherwise it is assigned the value 0.
<P>
  ERRMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned
<P>
              a processor-dependent explanatory message if the optional argument STATUS is, or would be if
<P>
              present, assigned a positive value. Otherwise, it is unchanged.
<P>
</PRE>
4 Example. On a processor that supports command arguments, the following program displays the arguments of
<P>
<PRE>
  the command by which it was invoked.
<P>
          PROGRAM show_arguments
<P>
            INTEGER :: i
<P>
            CHARACTER :: command*32, arg*128
<P>
            CALL get_command_argument(0, command)
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                       383
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
              WRITE (*,*) "Command name is: ", command
<P>
              DO i = 1, command_argument_count()
<P>
                CALL get_command_argument(i, arg)
<P>
                WRITE (*,*) "Argument ", i, " is ", arg
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
END PROGRAM show_arguments
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END PROGRAM show_arguments
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>16.9.84</B> </TD><TD valign=bottom>
GET_ENVIRONMENT_VARIABLE (NAME [, VALUE, LENGTH,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                STATUS, TRIM_NAME, ERRMSG])
<P>
</PRE>
1 Description. Get environment variable.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  NAME           shall be a default character scalar. It is an INTENT (IN) argument. The interpretation of case is
<P>
                 processor dependent.
<P>
  VALUE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned the value
<P>
                 of the environment variable specified by NAME. VALUE is assigned all blanks if the environment
<P>
                 variable does not exist or does not have a value or if the processor does not support environment
<P>
                 variables.
<P>
  LENGTH (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. If the specified environment variable exists and has a value, LENGTH
<P>
                 is assigned the value of its length. Otherwise LENGTH is assigned the value zero.
<P>
  STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
<P>
                 INTENT (OUT) argument. If the environment variable exists and either has no value, its value is
<P>
                 successfully assigned to VALUE, or the VALUE argument is not present, STATUS is assigned the
<P>
                 value zero. STATUS is assigned the value −1 if the VALUE argument is present and has a length
<P>
                 less than the significant length of the environment variable. It is assigned the value 1 if the specified
<P>
                 environment variable does not exist, or 2 if the processor does not support environment variables.
<P>
                 Processor-dependent values greater than 2 may be assigned for other error conditions.
<P>
  TRIM_NAME (optional) shall be a logical scalar. It is an INTENT (IN) argument. If TRIM_NAME is present
<P>
                 with the value false then trailing blanks in NAME are considered significant if the processor sup-
<P>
                 ports trailing blanks in environment variable names. Otherwise trailing blanks in NAME are not
<P>
                 considered part of the environment variable’s name.
<P>
  ERRMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned
<P>
                 a processor-dependent explanatory message if the optional argument STATUS is, or would be if
<P>
                 present, assigned a positive value. Otherwise, it is unchanged.
<P>
</PRE>
4 It is processor dependent whether an environment variable that exists on an image also exists on another image,
<P>
<PRE>
  and if it does exist on both images, whether the values are the same or different.
<P>
</PRE>
5 Example. If the value of the environment variable DATAFILE is datafile.dat, executing the statement sequence
<P>
<PRE>
  below will assign the value ’datafile.dat’ to FILENAME.
<P>
           CHARACTER(:),ALLOCATABLE :: FILENAME
<P>
           INTEGER :: NAMELEN
<P>
           CALL GET_ENVIRONMENT_VARIABLE ("DATAFILE", LENGTH=NAMELEN)
<P>
           IF (LENGTH&gt;0) THEN
<P>
              ALLOCATE(CHARACTER(LENGTH) :: FILENAME)
<P>
              CALL GET_ENVIRONMENT_VARIABLE("DATAFILE", FILENAME)
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>384</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>16.9.85</B> </TD><TD valign=bottom>
GET_TEAM ([LEVEL])
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Description. Team.
<BLOCKQUOTE>
<P>
2 Class. Transformational function.
<P>
3 Argument. LEVEL (optional) shall be a scalar integer whose value is equal to one of the named constants
<P>
<PRE>
  INITIAL_TEAM, PARENT_TEAM, or CURRENT_TEAM from the intrinsic module ISO_FORTRAN_ENV.
<P>
</PRE>
4 Result Characteristics. Scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
<P>
5 Result Value. The result is a TEAM_TYPE value that identifies the current team if LEVEL is not present,
<P>
<PRE>
  present with the value CURRENT_TEAM, or if the current team is the initial team. Otherwise, the result
<P>
  identifies the parent team if LEVEL is present with the value PARENT_TEAM, and identifies the initial team
<P>
  if LEVEL is present with the value INITIAL_TEAM.
<P>
</PRE>
6 Examples.
<P>
<PRE>
            PROGRAM EXAMPLE1
<P>
               USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
<P>
               TYPE(TEAM_TYPE) :: WORLD_TEAM, TEAM2
<P>
               ! Define a team variable representing the initial team
<P>
               WORLD_TEAM = GET_TEAM()
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE EXAMPLE2 (A)
<P>
<PRE>
               USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
<P>
               REAL A[*]
<P>
               TYPE(TEAM_TYPE) :: NEW_TEAM, PARENT_TEAM
<P>
               &#46;&#46;&#46; ! Form NEW_TEAM
<P>
               PARENT_TEAM = GET_TEAM ()
<P>
               CHANGE TEAM (NEW_TEAM)
<P>
                   ! Reference image 1 in parent’s team
<P>
                   A [1,TEAM=PARENT_TEAM] = 4.2
<P>
                   ! Reference image 1 in current team
<P>
                   A [1] = 9.0
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TEAM</H4>
</A>
<BLOCKQUOTE>
<P>
END SUBROUTINE EXAMPLE2
</BLOCKQUOTE>
<P>
NOTE 16.18
<BLOCKQUOTE>
<P>
Because the result of GET_TEAM is of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_-
<P>
ENV, a program unit that assigns the result of a reference to GET_TEAM to a local variable will also
<P>
need access to the definition of TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: need access to the definition of TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
385
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>16.9.86</B> </TD><TD valign=bottom>
HUGE (X)
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Description. Largest model number.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be of type integer or real. It may be a scalar or an array.
<P>
4 Result Characteristics. Scalar of the same type and kind type parameter as X.
<P>
5 Result Value. The result has the value r q − 1 if X is of type integer and (1 − b−p )bemax if X is of type real,
<P>
<PRE>
  where r, q, b, p, and emax are as defined in 16.4 for the model representing numbers of the same type and kind
<P>
  type parameter as X.
<P>
</PRE>
6 Example. HUGE (X) has the value (1 − 2−24 ) × 2127 for real X whose model is as in NOTE 16.4.
<P>
<PRE>
  16.9.87       HYPOT (X, Y)
<P>
</PRE>
1 Description. Euclidean distance function.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be of type real.
<P>
  Y             shall be of type real with the same kind type parameter as X.
<P>
</PRE>
4 Result Characteristics. Same as X.
<P>
5 Result
<P>
<PRE>
  p       Value. The result has a value equal to a processor-dependent approximation to the Euclidean distance,
<P>
    X2 + Y2 , without undue overflow or underflow.
<P>
</PRE>
6 Example. HYPOT (3.0, 4.0) has the value 5.0 (approximately).
<P>
<PRE>
  16.9.88       IACHAR (C [, KIND])
<P>
</PRE>
1 Description. ASCII code value for character.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  C             shall be of type character and of length one.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. If C is in the collating sequence defined by the codes specified in ISO/IEC 646:1991 (International
<P>
<PRE>
  Reference Version), the result is the position of C in that sequence; it is nonnegative and less than or equal to
<P>
  127. The value of the result is processor dependent if C is not in the ASCII collating sequence. The results
<P>
  are consistent with the LGE, LGT, LLE, and LLT comparison functions. For example, if LLE (C, D) is true,
<P>
  IACHAR (C) &lt;= IACHAR (D) is true where C and D are any two characters representable by the processor.
<P>
</PRE>
6 Example. IACHAR (’X’) has the value 88.
<P>
<PRE>
  16.9.89       IALL (ARRAY, DIM [, MASK]) or IALL (ARRAY [, MASK])
<P>
</PRE>
1 Description. Array reduced by IAND function.
<P>
2 Class. Transformational function.
<P>
<PRE>
  386                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  ARRAY            shall be an array of type integer.
<P>
  DIM              shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
<P>
<PRE>
  DIM does not appear or if ARRAY has rank one; otherwise, the result is an array of rank n − 1 and shape [d1 ,
<P>
  d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):        If ARRAY has size zero the result value is equal to NOT (INT (0, KIND (ARRAY))). Otherwise,
<P>
                   the result of IALL (ARRAY) has a value equal to the bitwise AND of all the elements of ARRAY.
<P>
  Case (ii):       The result of IALL (ARRAY, MASK=MASK) has a value equal to
<P>
                   IALL (PACK (ARRAY, MASK)).
<P>
  Case (iii):      The result of IALL (ARRAY, DIM=DIM [ , MASK=MASK]) has a value equal to that of IALL (AR-
<P>
                   RAY [ , MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element (s1 , s2 , . . . ,
<P>
                   sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to IALL (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 ,
<P>
                   . . . , sn ) [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )]).
<P>
</PRE>
6 Examples. IALL ([14, 13, 11]) has the value 8. IALL ([14, 13, 11], MASK=[.true., .false., .true]) has the value
<P>
<PRE>
  10.
<P>
  16.9.90          IAND (I, J)
<P>
</PRE>
1 Description. Bitwise AND.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I                shall be of type integer or a boz-literal-constant.
<P>
  J                shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
<P>
                   the same kind type parameter. I and J shall not both be boz-literal-constants.
<P>
</PRE>
4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
<P>
5 Result Value. If either I or J is a boz-literal-constant, it is first converted as if by the intrinsic function INT to
<P>
<PRE>
  type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
<P>
  bit-by-bit according to the following table:
<P>
                                                           I       J    IAND (I, J)
<P>
                                                           1       1            1
<P>
                                                           1       0            0
<P>
                                                           0       1            0
<P>
                                                           0       0            0
<P>
</PRE>
6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
7 Example. IAND (1, 3) has the value 1.
<P>
<PRE>
  16.9.91          IANY (ARRAY, DIM [, MASK]) or IANY (ARRAY [, MASK])
<P>
</PRE>
1 Description. Reduce array with bitwise OR operation.
<P>
2 Class. Transformational function.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                   387
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  ARRAY            shall be of type integer. It shall be an array.
<P>
  DIM              shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
<P>
<PRE>
  DIM does not appear or if ARRAY has rank one; otherwise, the result is an array of rank n − 1 and shape [d1 ,
<P>
  d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):        The result of IANY (ARRAY) is the bitwise OR of all the elements of ARRAY. If ARRAY has size
<P>
                   zero the result value is equal to zero.
<P>
  Case (ii):       The result of IANY (ARRAY, MASK=MASK) has a value equal to
<P>
                   IANY (PACK (ARRAY, MASK)).
<P>
  Case (iii):      The result of IANY (ARRAY, DIM=DIM [, MASK=MASK]) has a value equal to that of IANY (AR-
<P>
                   RAY [, MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element (s1 , s2 , . . . ,
<P>
                   sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to IANY (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 ,
<P>
                   . . . , sn ) [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )]).
<P>
</PRE>
6 Examples. IANY ([14, 13, 8]) has the value 15. IANY ([14, 13, 8], MASK=[.true., .false., .true]) has the value
<P>
<PRE>
  14.
<P>
  16.9.92          IBCLR (I, POS)
<P>
</PRE>
1 Description. I with bit POS replaced by zero.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I                shall be of type integer.
<P>
  POS              shall be of type integer. It shall be nonnegative and less than BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The result has the value of the sequence of bits of I, except that bit POS is zero. The model for
<P>
<PRE>
  the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Examples. IBCLR (14, 1) has the value 12. If V has the value [1, 2, 3, 4], the value of IBCLR (POS = V, I = 31)
<P>
<PRE>
  is [29, 27, 23, 15].
<P>
  16.9.93          IBITS (I, POS, LEN)
<P>
</PRE>
1 Description. Specified sequence of bits.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I                shall be of type integer.
<P>
  POS              shall be of type integer. It shall be nonnegative and POS + LEN shall be less than or equal to
<P>
                   BIT_SIZE (I).
<P>
  LEN              shall be of type integer and nonnegative.
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The result has the value of the sequence of LEN bits in I beginning at bit POS, right-adjusted
<P>
<PRE>
  and with all other bits zero. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
  388                                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Example. IBITS (14, 1, 3) has the value 7.
<P>
<PRE>
  16.9.94         IBSET (I, POS)
<P>
</PRE>
1 Description. I with bit POS replaced by one.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I               shall be of type integer.
<P>
  POS             shall be of type integer. It shall be nonnegative and less than BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The result has the value of the sequence of bits of I, except that bit POS is one. The model for
<P>
<PRE>
  the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Examples. IBSET (12, 1) has the value 14. If V has the value [1, 2, 3, 4], the value of IBSET (POS = V, I = 0)
<P>
<PRE>
  is [2, 4, 8, 16].
<P>
  16.9.95         ICHAR (C [, KIND])
<P>
</PRE>
1 Description. Code value for character.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  C               shall be of type character and of length one. Its value shall be that of a character capable of
<P>
                  representation in the processor.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result is the position of C in the processor collating sequence associated with the kind type
<P>
<PRE>
  parameter of C; it is nonnegative and less than n, where n is the number of characters in the collating sequence.
<P>
  The kind type parameter of the result shall specify an integer kind that is capable of representing n. For any char-
<P>
  acters C and D capable of representation in the processor, C &lt;= D is true if and only if ICHAR (C) &lt;= ICHAR (D)
<P>
  is true and C == D is true if and only if ICHAR (C) == ICHAR (D) is true.
<P>
</PRE>
6 Example. ICHAR (’X’) has the value 88 on a processor using the ASCII collating sequence for default characters.
<P>
<PRE>
  16.9.96         IEOR (I, J)
<P>
</PRE>
1 Description. Bitwise exclusive OR.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I               shall be of type integer or a boz-literal-constant.
<P>
  J               shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
<P>
                  the same kind type parameter. I and J shall not both be boz-literal-constants.
<P>
</PRE>
4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
<P>
5 Result Value. If either I or J is a boz-literal-constant, it is first converted as if by the intrinsic function INT to
<P>
<PRE>
  type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               389
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  bit-by-bit according to the following table:
<P>
                                                  I   J    IEOR (I, J)
<P>
                                                  1   1         0
<P>
                                                  1   0         1
<P>
                                                  0   1         1
<P>
                                                  0   0         0
<P>
</PRE>
6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
7 Example. IEOR (1, 3) has the value 2.
<P>
<PRE>
  16.9.97       IMAGE_INDEX (COARRAY, SUB) or (COARRAY, SUB, TEAM) or
<P>
                (COARRAY, SUB, TEAM_NUMBER)
<P>
</PRE>
1 Description. Image index from cosubscripts.
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  COARRAY shall be a coarray of any type. If its designator has more than one part-ref , the rightmost part-ref
<P>
                shall have nonzero corank. If TEAM_NUMBER appears and the current team is not the initial
<P>
                team, it shall be established in an ancestor of the current team. Otherwise, if TEAM appears, it
<P>
                shall be established in that team. Otherwise, it shall be established in the current team.
<P>
  SUB           shall be a rank-one integer array of size equal to the corank of COARRAY.
<P>
  TEAM          shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, with a
<P>
                value that identifies the current or an ancestor team.
<P>
  TEAM_NUMBER shall be an integer scalar. It shall identify the initial team or a team whose parent is the
<P>
                same as that of the current team.
<P>
</PRE>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. If the value of SUB is a valid sequence of cosubscripts for COARRAY in the team specified by
<P>
<PRE>
  TEAM or TEAM_NUMBER, or the current team if neither TEAM nor TEAM_NUMBER appears, the result
<P>
  is the index of the corresponding image in that team. Otherwise, the result is zero.
<P>
</PRE>
6 Examples. If A and B are declared as A [0:*] and B (10, 20) [10, 0:9, 0:*] respectively, IMAGE_INDEX (A, [0])
<P>
<PRE>
  has the value 1 and IMAGE_INDEX (B, [3, 1, 2]) has the value 213 (on any image).
<P>
  16.9.98       IMAGE_STATUS (IMAGE [, TEAM])
<P>
</PRE>
1 Description. Image execution state.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  IMAGE         shall be of type integer. Its value shall be positive and less than or equal to the number of images
<P>
                in the specified team.
<P>
  TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV. Its
<P>
                value shall represent the current or an ancestor team. If TEAM is absent, the team specified is the
<P>
                current team.
<P>
</PRE>
4 Result Characteristics. Default integer.
<P>
<PRE>
  390                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value. The result value is STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV
<P>
<PRE>
  if the specified image has failed, STAT_STOPPED_IMAGE from the intrinsic module ISO_FORTRAN_ENV
<P>
  if that image has initiated normal termination, and zero otherwise.
<P>
</PRE>
6 Example. If image 3 of the current team has failed, IMAGE_STATUS (3) has the value STAT_FAILED_-
<P>
<PRE>
  IMAGE.
<P>
  16.9.99        INDEX (STRING, SUBSTRING [, BACK, KIND])
<P>
</PRE>
1 Description. Character string search.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  STRING         shall be of type character.
<P>
  SUBSTRING shall be of type character with the same kind type parameter as STRING.
<P>
  BACK (optional) shall be of type logical.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):      If STRING % LEN &lt; SUBSTRING % LEN, the result has the value zero.
<P>
  Case (ii):     Otherwise, if there is an integer I in the range 1 ≤ I ≤ STRING % LEN − SUBSTRING % LEN
<P>
                 + 1, such that STRING(I : I + SUBSTRING % LEN − 1) is equal to SUBSTRING, the result has
<P>
                 the value of the smallest such I if BACK is absent or present with the value false, and the greatest
<P>
                 such I if BACK is present with the value true.
<P>
  Case (iii):    Otherwise, the result has the value zero.
<P>
</PRE>
6 Examples. INDEX (’FORTRAN’, ’R’) has the value 3.
<P>
<PRE>
  INDEX (’FORTRAN’, ’R’, BACK = .TRUE.) has the value 5.
<P>
  16.9.100 INT (A [, KIND])
<P>
</PRE>
1 Description. Conversion to integer type.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be of type integer, real, or complex, or a boz-literal-constant.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):      If A is of type integer, INT (A) = A.
<P>
  Case (ii):     If A is of type real, there are two cases: if |A| &lt; 1, INT (A) has the value 0; if |A| ≥ 1, INT (A)
<P>
                 is the integer whose magnitude is the largest integer that does not exceed the magnitude of A and
<P>
                 whose sign is the same as the sign of A.
<P>
  Case (iii):    If A is of type complex, INT (A) = INT (REAL (A, KIND (A))).
<P>
  Case (iv):     If A is a boz-literal-constant, the value of the result is the value whose bit sequence according to the
<P>
                 model in 16.3 is the same as that of A as modified by padding or truncation according to 16.3.3.
<P>
                 The interpretation of a bit sequence whose most significant bit is 1 is processor dependent.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             391
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Example. INT (−3.7) has the value −3.
<P>
<PRE>
  16.9.101 IOR (I, J)
<P>
</PRE>
1 Description. Bitwise inclusive OR.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I                   shall be of type integer or a boz-literal-constant.
<P>
  J                   shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
<P>
                      the same kind type parameter. I and J shall not both be boz-literal-constants.
<P>
</PRE>
4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
<P>
5 Result Value. If either I or J is a boz-literal-constant, it is first converted as if by the intrinsic function INT to
<P>
<PRE>
  type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
<P>
  bit-by-bit according to the following table:
<P>
                                                                I    J   IOR (I, J)
<P>
                                                                1    1        1
<P>
                                                                1    0        1
<P>
                                                                0    1        1
<P>
                                                                0    0        0
<P>
</PRE>
6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
7 Example. IOR (5, 3) has the value 7.
<P>
<PRE>
  16.9.102 IPARITY (ARRAY, DIM [, MASK]) or IPARITY (ARRAY [, MASK])
<P>
</PRE>
1 Description. Array reduced by IEOR function.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY               shall be of type integer. It shall be an array.
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
<P>
<PRE>
  DIM does not appear; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where
<P>
  [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):           The result of IPARITY (ARRAY) has a value equal to the bitwise exclusive OR of all the elements
<P>
                      of ARRAY. If ARRAY has size zero the result has the value zero.
<P>
  Case (ii):          The result of IPARITY (ARRAY, MASK=MASK) has a value equal to that of IPARITY (PACK
<P>
                      (ARRAY, MASK)).
<P>
  Case (iii):         The result of IPARITY (ARRAY, DIM=DIM [, MASK=MASK]) has a value equal to that of
<P>
                      IPARITY (ARRAY [, MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element
<P>
                      (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to IPARITY (ARRAY (s1 , s2 , . . . ,
<P>
                      sDIM−1 , :, sDIM+1 , . . . , sn ) [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )]).
<P>
  392                                                                              ⃝
<P>
                                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Examples. IPARITY ([14, 13, 8]) has the value 11. IPARITY ([14, 13, 8], MASK=[.true., .false., .true]) has the
<P>
<PRE>
  value 6.
<P>
  16.9.103 ISHFT (I, SHIFT)
<P>
</PRE>
1 Description. Logical shift.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I              shall be of type integer.
<P>
  SHIFT          shall be of type integer. The absolute value of SHIFT shall be less than or equal to BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The result has the value obtained by shifting the bits of I by SHIFT positions. If SHIFT is
<P>
<PRE>
  positive, the shift is to the left; if SHIFT is negative, the shift is to the right; if SHIFT is zero, no shift is
<P>
  performed. Bits shifted out from the left or from the right, as appropriate, are lost. Zeros are shifted in from the
<P>
  opposite end. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Example. ISHFT (3, 1) has the value 6.
<P>
<PRE>
  16.9.104 ISHFTC (I, SHIFT [, SIZE])
<P>
</PRE>
1 Description. Circular shift of the rightmost bits.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I              shall be of type integer.
<P>
  SHIFT          shall be of type integer. The absolute value of SHIFT shall be less than or equal to SIZE.
<P>
  SIZE (optional) shall be of type integer. The value of SIZE shall be positive and shall not exceed BIT_SIZE (I).
<P>
                 If SIZE is absent, it is as if it were present with the value of BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The result has the value obtained by shifting the SIZE rightmost bits of I circularly by SHIFT
<P>
<PRE>
  positions. If SHIFT is positive, the shift is to the left; if SHIFT is negative, the shift is to the right; and if SHIFT
<P>
  is zero, no shift is performed. No bits are lost. The unshifted bits are unaltered. The model for the interpretation
<P>
  of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Example. ISHFTC (3, 2, 3) has the value 5.
<P>
<PRE>
  16.9.105 IS_CONTIGUOUS (ARRAY)
<P>
</PRE>
1 Description. Array contiguity test (8.5.7).
<P>
2 Class. Inquiry function.
<P>
3 Argument. ARRAY may be of any type. It shall be assumed-rank or an array. If it is a pointer it shall be
<P>
<PRE>
  associated.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
<P>
5 Result Value. The result has the value true if ARRAY has rank zero or is contiguous, and false otherwise.
<P>
6 Example. After the pointer assignment AP =&gt; TARGET (1:10:2), IS_CONTIGUOUS (AP) has the value
<P>
<PRE>
  false.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                393
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.106 IS_IOSTAT_END (I)
<P>
</PRE>
1 Description. IOSTAT value test for end of file.
<P>
2 Class. Elemental function.
<P>
3 Argument. I shall be of type integer.
<P>
4 Result Characteristics. Default logical.
<P>
5 Result Value. The result has the value true if and only if I is a value for the stat-variable in an IOSTAT=
<P>
<PRE>
  specifier (12.11.5) that would indicate an end-of-file condition.
<P>
  16.9.107 IS_IOSTAT_EOR (I)
<P>
</PRE>
1 Description. IOSTAT value test for end of record.
<P>
2 Class. Elemental function.
<P>
3 Argument. I shall be of type integer.
<P>
4 Result Characteristics. Default logical.
<P>
5 Result Value. The result has the value true if and only if I is a value for the stat-variable in an IOSTAT=
<P>
<PRE>
  specifier (12.11.5) that would indicate an end-of-record condition.
<P>
  16.9.108 KIND (X)
<P>
</PRE>
1 Description. Value of the kind type parameter of X.
<P>
2 Class. Inquiry function.
<P>
3 Argument. X may be of any intrinsic type. It may be a scalar or an array.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The result has a value equal to the kind type parameter value of X.
<P>
6 Example. KIND (0.0) has the kind type parameter value of default real.
<P>
<PRE>
  16.9.109 LBOUND (ARRAY [, DIM, KIND])
<P>
</PRE>
1 Description. Lower <B>bound</B>(s).
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY          shall be assumed-rank or an array. It shall not be an unallocated allocatable variable or a pointer
<P>
                 that is not associated.
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
                 The corresponding actual argument shall not be an optional dummy argument, a disassociated
<P>
                 pointer, or an unallocated allocatable.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is present;
<P>
  otherwise, the result is an array of rank one and size n, where n is the rank of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  394                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
  Case (i):     If DIM is present, ARRAY is a whole array, and either ARRAY is an assumed-size array of rank
<P>
                DIM or dimension DIM of ARRAY has nonzero extent, the result has a value equal to the lower
<P>
                bound for subscript DIM of ARRAY. Otherwise, if DIM is present, the result value is 1.
<P>
  Case (ii):    LBOUND (ARRAY) has a value whose ith element is equal to LBOUND (ARRAY, i), for i = 1, 2,
<P>
                . . . , n, where n is the rank of ARRAY. LBOUND (ARRAY, KIND=KIND) has a value whose ith
<P>
                element is equal to LBOUND (ARRAY, i, KIND), for i = 1, 2, . . . , n, where n is the rank of
<P>
                ARRAY.
<P>
       NOTE 16.19
<P>
       If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it cannot satisfy the requirement
<P>
       1 ≤ DIM ≤ 0.
<P>
</PRE>
6 Examples. If A is declared by the statement
<TABLE width=100% cellpadding=3><!-- tsb: 6 Examples. If A is declared by the statement
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7</B> </TD><TD valign=bottom>
REAL A (2:3, 7:10)
</TD></TR>
<TR><TD colspan=2>
8 then LBOUND (A) is [2, 7] and LBOUND (A, DIM=2) is 7.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.110 LCOBOUND (COARRAY [, DIM, KIND])
<P>
</PRE>
1 Description. Lower <B>cobound</B>(s) of a coarray.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  COARRAY shall be a coarray and may be of any type. It may be a scalar or an array. If it is allocatable it
<P>
                shall be allocated. If its designator has more than one part-ref , the rightmost part-ref shall have
<P>
                nonzero corank.
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the corank
<P>
                of COARRAY. The corresponding actual argument shall not be an optional dummy argument, a
<P>
                disassociated pointer, or an unallocated allocatable.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type. The result is scalar if DIM is present;
<P>
  otherwise, the result is an array of rank one and size n, where n is the corank of COARRAY.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     If DIM is present, the result has a value equal to the lower cobound for codimension DIM of
<P>
                COARRAY.
<P>
  Case (ii):    If DIM is absent, the result has a value whose ith element is equal to the lower cobound for codi-
<P>
                mension i of COARRAY, for i = 1, 2,. . . , n, where n is the corank of COARRAY.
<P>
</PRE>
6 Examples. If A is allocated by the statement ALLOCATE (A [2:3, 7:*]) then LCOBOUND (A) is [2, 7] and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  LCOBOUND (A, DIM=2) is 7.
<P>
  16.9.111 LEADZ (I)
<P>
</PRE>
1 Description. Number of leading zero bits.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. I shall be of type integer.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default integer.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         395
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value. If all of the bits of I are zero, the result has the value BIT_SIZE (I). Otherwise, the result has
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value BIT_SIZE (I) − 1 − k, where k is the position of the leftmost 1 bit in I. The model for the interpretation
<P>
  of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Examples. LEADZ (1) has the value 31 if BIT_SIZE (1) has the value 32.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.112 LEN (STRING [, KIND])
<P>
</PRE>
1 Description. Length of a character entity.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  STRING        shall be of type character. If it is an unallocated allocatable variable or a pointer that is not
<P>
                associated, its length type parameter shall not be deferred.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer scalar. If KIND is present, the kind type parameter is that specified by the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value of KIND; otherwise the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result has a value equal to the number of characters in STRING if it is scalar or in an
</TD></TR>
<TR><TD colspan=2>
<PRE>
  element of STRING if it is an array.
<P>
</PRE>
6 Example. If C is declared by the statement
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>7</B> </TD><TD valign=bottom>
CHARACTER (11) C (100)
</TD></TR>
<TR><TD colspan=2>
8 LEN (C) has the value 11.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.113 LEN_TRIM (STRING [, KIND])
<P>
</PRE>
1 Description. Length without trailing blanks.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  STRING        shall be of type character.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result has a value equal to the number of characters remaining after any trailing blanks in
</TD></TR>
<TR><TD colspan=2>
<PRE>
  STRING are removed. If the argument contains no nonblank characters, the result is zero.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>6 Examples. LEN_TRIM (’ A B ’) has the value 4 and LEN_TRIM (’</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
’) has the value 0.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.114 LGE (STRING_A, STRING_B)
<P>
</PRE>
1 Description. ASCII greater than or equal.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  STRING_A shall be default character or ASCII character.
<P>
  STRING_B shall be of type character with the same kind type parameter as STRING_A.
<P>
</PRE>
4 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  396                                                                ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
</TD></TR>
<TR><TD colspan=2>
<PRE>
  on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
<P>
  character set, the result is processor dependent. The result is true if the strings are equal or if STRING_A follows
<P>
  STRING_B in the ASCII collating sequence; otherwise, the result is false.
<P>
       NOTE 16.20
<P>
       The result is true if both STRING_A and STRING_B are of zero length.
<P>
</PRE>
6 Example. LGE (’ONE’, ’TWO’) has the value false.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.115 LGT (STRING_A, STRING_B)
<P>
</PRE>
1 Description. ASCII greater than.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  STRING_A shall be default character or ASCII character.
<P>
  STRING_B shall be of type character with the same kind type parameter as STRING_A.
<P>
</PRE>
4 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
</TD></TR>
<TR><TD colspan=2>
<PRE>
  on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
<P>
  character set, the result is processor dependent. The result is true if STRING_A follows STRING_B in the
<P>
  ASCII collating sequence; otherwise, the result is false.
<P>
       NOTE 16.21
<P>
       The result is false if both STRING_A and STRING_B are of zero length.
<P>
</PRE>
6 Example. LGT (’ONE’, ’TWO’) has the value false.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.116 LLE (STRING_A, STRING_B)
<P>
</PRE>
1 Description. ASCII less than or equal.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  STRING_A shall be default character or ASCII character.
<P>
  STRING_B shall be of type character with the same kind type parameter as STRING_A.
<P>
</PRE>
4 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
</TD></TR>
<TR><TD colspan=2>
<PRE>
  on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
<P>
  character set, the result is processor dependent. The result is true if the strings are equal or if STRING_A
<P>
  precedes STRING_B in the ASCII collating sequence; otherwise, the result is false.
<P>
       NOTE 16.22
<P>
       The result is true if both STRING_A and STRING_B are of zero length.
<P>
</PRE>
6 Example. LLE (’ONE’, ’TWO’) has the value true.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           397
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.117 LLT (STRING_A, STRING_B)
<P>
</PRE>
1 Description. ASCII less than.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  STRING_A shall be default character or ASCII character.
<P>
  STRING_B shall be of type character with the same kind type parameter as STRING_A.
<P>
</PRE>
4 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
</TD></TR>
<TR><TD colspan=2>
<PRE>
  on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
<P>
  character set, the result is processor dependent. The result is true if STRING_A precedes STRING_B in the
<P>
  ASCII collating sequence; otherwise, the result is false.
<P>
        NOTE 16.23
<P>
        The result is false if both STRING_A and STRING_B are of zero length.
<P>
</PRE>
6 Example. LLT (’ONE’, ’TWO’) has the value true.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.118 LOG (X)
<P>
</PRE>
1 Description. Natural logarithm.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real or complex. If X is real, its value shall be greater than zero. If X is complex,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  its value shall not be zero.
<P>
</PRE>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to loge X. A result of type
</TD></TR>
<TR><TD colspan=2>
<PRE>
  complex is the principal value with imaginary part ω in the range −π ≤ ω ≤ π. If the real part of X is less
<P>
  than zero and the imaginary part of X is zero, then the imaginary part of the result is approximately π if the
<P>
  imaginary part of X is positive real zero or the processor does not distinguish between positive and negative real
<P>
  zero, and approximately −π if the imaginary part of X is negative real zero.
<P>
</PRE>
6 Example. LOG (10.0) has the value 2.3025851 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.119 LOG_GAMMA (X)
<P>
</PRE>
1 Description. Logarithm of the absolute value of the gamma function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. Its value shall not be a negative integer or zero.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to the natural logarithm
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of the absolute value of the gamma function of X.
<P>
</PRE>
6 Example. LOG_GAMMA (3.0) has the value 0.693 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  398                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.120 LOG10 (X)
<P>
</PRE>
1 Description. Common logarithm.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. The value of X shall be greater than zero.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has a value equal to a processor-dependent approximation to log10 X.
</TD></TR>
<TR><TD colspan=2>
6 Example. LOG10 (10.0) has the value 1.0 (approximately).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.121 LOGICAL (L [, KIND])
<P>
</PRE>
1 Description. Conversion between kinds of logical.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  L             shall be of type logical.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Logical. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise, the kind type parameter is that of default logical.
<P>
</PRE>
5 Result Value. The value is that of L.
</TD></TR>
<TR><TD colspan=2>
6 Example. LOGICAL (L .OR. .NOT. L) has the value true and is default logical, regardless of the kind type
</TD></TR>
<TR><TD colspan=2>
<PRE>
  parameter of the logical variable L.
<P>
  16.9.122 MASKL (I [, KIND])
<P>
</PRE>
1 Description. Left justified mask.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  I             shall be of type integer. It shall be nonnegative and less than or equal to the number of bits z of
<P>
                the model integer defined for bit manipulation contexts in 16.3 for the kind of the result.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result value has its leftmost I bits set to 1 and the remaining bits set to 0. The model for
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Example. MASKL (3) has the value SHIFTL (7, BIT_SIZE (0) − 3).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.123 MASKR (I [, KIND])
<P>
</PRE>
1 Description. Right justified mask.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                       399
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  I              shall be of type integer. It shall be nonnegative and less than or equal to the number of bits z of
<P>
                 the model integer defined for bit manipulation contexts in 16.3 for the kind of the result.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result value has its rightmost I bits set to 1 and the remaining bits set to 0. The model for
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Example. MASKR (3) has the value 7.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.124 MATMUL (MATRIX_A, MATRIX_B)
<P>
</PRE>
1 Description. Matrix multiplication.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  MATRIX_A shall be a rank-one or rank-two array of numeric type or logical type.
<P>
  MATRIX_B shall be of numeric type if MATRIX_A is of numeric type and of logical type if MATRIX_A is of
<P>
                 logical type. It shall be an array of rank one or two. MATRIX_A and MATRIX_B shall not both
<P>
                 have rank one. The size of the first (or only) dimension of MATRIX_B shall equal the size of the
<P>
                 last (or only) dimension of MATRIX_A.
<P>
</PRE>
4 Result Characteristics. If the arguments are of numeric type, the type and kind type parameter of the result
</TD></TR>
<TR><TD colspan=2>
<PRE>
  are determined by the types of the arguments as specified in 10.1.9.3 for the * operator. If the arguments are of
<P>
  type logical, the result is of type logical with the kind type parameter of the arguments as specified in 10.1.9.3
<P>
  for the .AND. operator. The shape of the result depends on the shapes of the arguments as follows:
<P>
  Case (i):      If MATRIX_A has shape [n, m] and MATRIX_B has shape [m, k], the result has shape [n, k].
<P>
  Case (ii):     If MATRIX_A has shape [m] and MATRIX_B has shape [m, k], the result has shape [k].
<P>
  Case (iii):    If MATRIX_A has shape [n, m] and MATRIX_B has shape [m], the result has shape [n].
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):      Element (i, j) of the result has the value SUM (MATRIX_A (i, :) * MATRIX_B (:, j)) if the
<P>
                 arguments are of numeric type and has the value ANY (MATRIX_A (i, :) .AND. MATRIX_B (:,
<P>
                 j)) if the arguments are of logical type.
<P>
  Case (ii):     Element (j) of the result has the value SUM (MATRIX_A (:) * MATRIX_B (:, j)) if the arguments
<P>
                 are of numeric type and has the value ANY (MATRIX_A (:) .AND. MATRIX_B (:, j)) if the
<P>
                 arguments are of logical type.
<P>
  Case (iii): Element (i) of the result has the value SUM (MATRIX_A (i, :) * MATRIX_B (:)) if the arguments
<P>
                 are of numeric type and has the value ANY (MATRIX_A (i, :) .AND. MATRIX_B (:)) if the
<P>
                 arguments are of logical type.
<P>
                                                                          
<P>
                                                                    1 2
<P>
                                                    1 2 3
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>6 Examples. Let A and B be the matrices</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
and  2 3 ; let X and Y be the vectors [1, 2] and
<P>
2 3 4
<TABLE width=100% cellpadding=3><!-- tsb: 2 3 4
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 4
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
[1, 2, 3].
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                                                            
<P>
                                                                                                     14 20
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Case (i):</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The result of MATMUL (A, B) is the matrix-matrix product AB with the value                   .
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                                                     20 29
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Case (ii):</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The result of MATMUL (X, A) is the vector-matrix product XA with the value [5, 8, 11].
</TD></TR>
<TR><TD colspan=2>
Case (iii): The result of MATMUL (A, Y) is the matrix-vector product AY with the value [14, 20].
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>400</B> <!-- .PP -->
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
16.9.125 MAX (A1, A2 [, A3, &#46;&#46;&#46;])
</TD></TR>
<TR><TD colspan=2>
1 Description. Maximum value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments. The arguments shall all have the same type which shall be integer, real, or character and they shall
</TD></TR>
<TR><TD colspan=2>
<PRE>
  all have the same kind type parameter.
<P>
</PRE>
4 Result Characteristics. The type and kind type parameter of the result are the same as those of the arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  For arguments of character type, the length of the result is the length of the longest argument.
<P>
</PRE>
5 Result Value. The value of the result is that of the largest argument. For arguments of character type, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  result is the value that would be selected by application of intrinsic relational operators; that is, the collating
<P>
  sequence for characters with the kind type parameter of the arguments is applied. If the selected argument is
<P>
  shorter than the longest argument, the result is extended with blanks on the right to the length of the longest
<P>
  argument.
<P>
</PRE>
6 Examples. MAX (−9.0, 7.0, 2.0) has the value 7.0, MAX (’Z’, ’BB’) has the value ’Z ’, and MAX ([’A’, ’Z’],
</TD></TR>
<TR><TD colspan=2>
<PRE>
  [’BB’, ’Y ’]) has the value [’BB’, ’Z ’].
<P>
  16.9.126 MAXEXPONENT (X)
<P>
</PRE>
1 Description. Maximum exponent of a real model.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default integer scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has the value emax , as defined in 16.4 for the model representing numbers of the same
</TD></TR>
<TR><TD colspan=2>
<PRE>
  type and kind type parameter as X.
<P>
</PRE>
6 Example. MAXEXPONENT (X) has the value 127 for real X whose model is as in NOTE 16.4.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.127 MAXLOC (ARRAY, DIM [, MASK, KIND, BACK]) or
<P>
                      MAXLOC (ARRAY [, MASK, KIND, BACK])
<P>
</PRE>
1 Description. <B>Location</B>(s) of maximum value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ARRAY               shall be an array of type integer, real, or character.
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
  BACK (optional) shall be a logical scalar.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
<P>
  an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank n − 1 and shape
<P>
  [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ], where [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):           If DIM does not appear and MASK is absent, the result is a rank-one array whose element values
<P>
                      are the values of the subscripts of an element of ARRAY whose value equals the maximum value of
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                 401
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                      all of the elements of ARRAY. The ith subscript returned lies in the range 1 to ei , where ei is the
<P>
                      extent of the ith dimension of ARRAY. If ARRAY has size zero, all elements of the result are zero.
<P>
  Case (ii):          If DIM does not appear and MASK is present, the result is a rank-one array whose element values
<P>
                      are the values of the subscripts of an element of ARRAY, corresponding to a true element of MASK,
<P>
                      whose value equals the maximum value of all such elements of ARRAY. The ith subscript returned
<P>
                      lies in the range 1 to ei , where ei is the extent of the ith dimension of ARRAY. If ARRAY has size
<P>
                      zero or every element of MASK has the value false, all elements of the result are zero.
<P>
  Case (iii): If ARRAY has rank one and DIM is specified, the result has a value equal to that of the first element
<P>
                      of MAXLOC (ARRAY [, MASK = MASK, KIND = KIND, BACK = BACK]). Otherwise, if DIM
<P>
                      is specified, the value of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to
<P>
                              MAXLOC (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ),
<P>
                                          DIM = 1
<P>
                                          [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ),
<P>
                                           KIND = KIND,
<P>
                                           BACK = BACK] ).
<P>
</PRE>
6 If only one element has the maximum value, that element’s subscripts are returned. Otherwise, if more than
</TD></TR>
<TR><TD colspan=2>
<PRE>
  one element has the maximum value and BACK is absent or present with the value false, the element whose
<P>
  subscripts are returned is the first such element, taken in array element order. If BACK is present with the value
<P>
  true, the element whose subscripts are returned is the last such element, taken in array element order.
<P>
</PRE>
7 If ARRAY has type character, the result is the value that would be selected by application of intrinsic relational
</TD></TR>
<TR><TD colspan=2>
<PRE>
  operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<P>
</PRE>
8 Examples.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):           The value of MAXLOC ([2, 6, 4, 6]) is [2] and the value of MAXLOC ([2, 6, 4, 6], BACK=.TRUE.)
<P>
                      is [4].
<P>
                                                                
<P>
                                             0 −5 8 −3
<P>
  Case (ii):          If A has the value  3 4 −1 2 , MAXLOC (A, MASK = A &lt; 6) has the value [3, 2]. This
<P>
                                             1 5       6 −4
<P>
                      is independent of the declared lower bounds for A.
<P>
                                                                                                                     
<P>
                                                                                                           1 3 −9
<P>
  Case (iii):         The value of MAXLOC ([5, −9, 3], DIM = 1) is 1. If B has the value                                , MAXLOC
<P>
                                                                                                           2 2 6
<P>
                      (B, DIM = 1) is [2, 1, 2] and MAXLOC (B, DIM = 2) is [2, 3]. This is independent of the declared
<P>
                      lower bounds for B.
<P>
  16.9.128 MAXVAL (ARRAY, DIM [, MASK]) or MAXVAL (ARRAY [, MASK])
<P>
</PRE>
1 Description. Maximum <B>value</B>(s) of array.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ARRAY               shall be an array of type integer, real, or character.
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and type parameters as ARRAY. It is scalar if DIM
</TD></TR>
<TR><TD colspan=2>
<PRE>
  does not appear; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where
<P>
  [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):           The result of MAXVAL (ARRAY) has a value equal to the maximum value of all the elements of
<P>
                      ARRAY if the size of ARRAY is not zero. If ARRAY has size zero and type integer or real, the
<P>
                      result has the value of the negative number of the largest magnitude supported by the processor
<P>
                      for numbers of the type and kind type parameter of ARRAY. If ARRAY has size zero and type
<P>
  402                                                                          ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
                character, the result has the value of a string of characters of length LEN (ARRAY), with each
<P>
                character equal to CHAR (0, KIND (ARRAY)).
<P>
  Case (ii):    The result of MAXVAL (ARRAY, MASK = MASK) has a value equal to that of MAXVAL (PACK
<P>
                (ARRAY, MASK)).
<P>
  Case (iii):   The result of MAXVAL (ARRAY, DIM = DIM [,MASK = MASK]) has a value equal to that of
<P>
                MAXVAL (ARRAY [,MASK = MASK]) if ARRAY has rank one. Otherwise, the value of element
<P>
                (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to
<P>
                         MAXVAL (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )
<P>
                         [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ) ] ).
<P>
</PRE>
6 If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
</TD></TR>
<TR><TD colspan=2>
<PRE>
  operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<P>
</PRE>
7 Examples.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     The value of MAXVAL ([1, 2, 3]) is 3.
<P>
  Case (ii):    MAXVAL (C, MASK = C &lt; 0.0) is the maximum of the negative elements of C.
<P>
                                                   
<P>
                                          1 3 5
<P>
  Case (iii):   If B is the array                     , MAXVAL (B, DIM = 1) is [2, 7, 6] and MAXVAL (B, DIM = 2) is
<P>
                                          2 7 6
<P>
                [5, 7].
<P>
  16.9.129 MERGE (TSOURCE, FSOURCE, MASK)
<P>
</PRE>
1 Description. Expression value selection.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  TSOURCE       may be of any type.
<P>
  FSOURCE       shall be of the same type and type parameters as TSOURCE.
<P>
  MASK          shall be of type logical.
<P>
</PRE>
4 Result Characteristics. Same type and type parameters as TSOURCE. Because TSOURCE and FSOURCE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  are required to have the same type and type parameters (for both the declared and dynamic types), the result is
<P>
  polymorphic if and only if both TSOURCE and FSOURCE are polymorphic.
<P>
</PRE>
5 Result Value. The result is TSOURCE if MASK is true and FSOURCE otherwise.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                                                     
<P>
                                                      1     6   5                                 0 3 2
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>6 Examples. If TSOURCE is the array</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
, FSOURCE is the array               and MASK is the
<TABLE width=100% cellpadding=3><!-- tsb: , FSOURCE is the array               and MASK is the
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>2</B> </TD><TD valign=bottom>
4   6                                 7 4 8
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
           T . T
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>array</B> </TD><TD valign=bottom>
, where “T” represents true and “.” represents false, then MERGE (TSOURCE, FSOURCE,
</TD></TR>
<TR><TD colspan=2>
<PRE>
            . . T
<P>
                            
<P>
                1 3 5
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MASK) is</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<BR>.The value of MERGE (1.0, 0.0, K &gt; 0) is 1.0 for K = 5 and 0.0 for K = −2.
<P>
7 4 6
</TD></TR>
<TR></TR></TABLE>16.9.130 MERGE_BITS (I, J, MASK)
</TD></TR>
<TR><TD colspan=2>
1 Description. Merge of bits under mask.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  I             shall be of type integer or a boz-literal-constant.
<P>
  J             shall be of type integer or a boz-literal-constant. If both I and J are of type integer they shall have
<P>
                the same kind type parameter. I and J shall not both be boz-literal-constants.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                              403
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  MASK           shall be of type integer or a boz-literal-constant. If MASK is of type integer, it shall have the same
<P>
                 kind type parameter as each other argument of type integer.
<P>
</PRE>
4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. If any argument is a boz-literal-constant, it is first converted as if by the intrinsic function
</TD></TR>
<TR><TD colspan=2>
<PRE>
  INT to the type and kind type parameter of the result. The result has the value of IOR (IAND (I, MASK),
<P>
  IAND (J, NOT (MASK))).
<P>
</PRE>
6 Example. MERGE_BITS (13, 18, 22) has the value 4.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.131 MIN (A1, A2 [, A3, &#46;&#46;&#46;])
<P>
</PRE>
1 Description. Minimum value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments. The arguments shall all be of the same type which shall be integer, real, or character and they
</TD></TR>
<TR><TD colspan=2>
<PRE>
  shall all have the same kind type parameter.
<P>
</PRE>
4 Result Characteristics. The type and kind type parameter of the result are the same as those of the arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  For arguments of character type, the length of the result is the length of the longest argument.
<P>
</PRE>
5 Result Value. The value of the result is that of the smallest argument. For arguments of character type, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  result is the value that would be selected by application of intrinsic relational operators; that is, the collating
<P>
  sequence for characters with the kind type parameter of the arguments is applied. If the selected argument is
<P>
  shorter than the longest argument, the result is extended with blanks on the right to the length of the longest
<P>
  argument.
<P>
</PRE>
6 Examples. MIN (−9.0, 7.0, 2.0) has the value −9.0, MIN (’A’, ’YY’) has the value ’A ’, and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  MIN ([’Z’, ’A’], [’YY’, ’B ’]) has the value [’YY’, ’A ’].
<P>
  16.9.132 MINEXPONENT (X)
<P>
</PRE>
1 Description. Minimum exponent of a real model.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default integer scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has the value emin , as defined in 16.4 for the model representing numbers of the same
</TD></TR>
<TR><TD colspan=2>
<PRE>
  type and kind type parameter as X.
<P>
</PRE>
6 Example. MINEXPONENT (X) has the value −126 for real X whose model is as in NOTE 16.4.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.133 MINLOC (ARRAY, DIM [, MASK, KIND, BACK]) or
<P>
                MINLOC (ARRAY [, MASK, KIND, BACK])
<P>
</PRE>
1 Description. <B>Location</B>(s) of minimum value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ARRAY          shall be an array of type integer, real, or character.
<P>
  DIM            shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
  404                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
  BACK (optional) shall be a logical scalar.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
<P>
  an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank n − 1 and shape
<P>
  [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ], where [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):           If DIM does not appear and MASK is absent the result is a rank-one array whose element values
<P>
                      are the values of the subscripts of an element of ARRAY whose value equals the minimum value
<P>
                      of all the elements of ARRAY. The ith subscript returned lies in the range 1 to ei , where ei is the
<P>
                      extent of the ith dimension of ARRAY. If ARRAY has size zero, all elements of the result are zero.
<P>
  Case (ii):          If DIM does not appear and MASK is present, the result is a rank-one array whose element values
<P>
                      are the values of the subscripts of an element of ARRAY, corresponding to a true element of MASK,
<P>
                      whose value equals the minimum value of all such elements of ARRAY. The ith subscript returned
<P>
                      lies in the range 1 to ei , where ei is the extent of the ith dimension of ARRAY. If ARRAY has size
<P>
                      zero or every element of MASK has the value false, all elements of the result are zero.
<P>
  Case (iii): If ARRAY has rank one and DIM is specified, the result has a value equal to that of the first element
<P>
                      of MINLOC (ARRAY [, MASK = MASK, KIND = KIND, BACK = BACK]). Otherwise, if DIM
<P>
                      is specified, the value of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to
<P>
                              MINLOC (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ),
<P>
                                         DIM = 1
<P>
                                         [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ),
<P>
                                          KIND = KIND,
<P>
                                          BACK = BACK] ).
<P>
</PRE>
6 If only one element has the minimum value, that element’s subscripts are returned. Otherwise, if more than one
</TD></TR>
<TR><TD colspan=2>
<PRE>
  element has the minimum value and BACK is absent or present with the value false, the element whose subscripts
<P>
  are returned is the first such element, taken in array element order. If BACK is present with the value true, the
<P>
  element whose subscripts are returned is the last such element, taken in array element order.
<P>
</PRE>
7 If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
</TD></TR>
<TR><TD colspan=2>
<PRE>
  operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<P>
</PRE>
8 Examples.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):           The value of MINLOC ([4, 3, 6, 3]) is [2] and the value of MINLOC ([4, 3, 6, 3], BACK = .TRUE.)
<P>
                      is [4].
<P>
                                                                      
<P>
                                                0 −5 8 −3
<P>
  Case (ii):          If A has the value  3 4 −1 2 , MINLOC (A, MASK = A &gt; −4) has the value [1, 4].
<P>
                                                1 5        6 −4
<P>
                      This is independent of the declared lower bounds for A.
<P>
                                                                                                                           
<P>
                                                                                                                1 3 −9
<P>
  Case (iii):         The value of MINLOC ([5, −9, 3], DIM = 1) is 2. If B has the value                                     , MIN-
<P>
                                                                                                                2 2 6
<P>
                      LOC (B, DIM = 1) is [1, 2, 1] and MINLOC (B, DIM = 2) is [3, 1]. This is independent of
<P>
                      the declared lower bounds for B.
<P>
  16.9.134 MINVAL (ARRAY, DIM [, MASK]) or MINVAL (ARRAY [, MASK])
<P>
</PRE>
1 Description. Minimum <B>value</B>(s) of array.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ARRAY               shall be an array of type integer, real, or character.
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                        405
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. The result is of the same type and type parameters as ARRAY. It is scalar if DIM
</TD></TR>
<TR><TD colspan=2>
<PRE>
  does not appear; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where
<P>
  [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):           The result of MINVAL (ARRAY) has a value equal to the minimum value of all the elements of
<P>
                      ARRAY if the size of ARRAY is not zero. If ARRAY has size zero and type integer or real, the
<P>
                      result has the value of the positive number of the largest magnitude supported by the processor
<P>
                      for numbers of the type and kind type parameter of ARRAY. If ARRAY has size zero and type
<P>
                      character, the result has the value of a string of characters of length LEN (ARRAY), with each
<P>
                      character equal to CHAR (n − 1, KIND (ARRAY)), where n is the number of characters in the
<P>
                      collating sequence for characters with the kind type parameter of ARRAY.
<P>
  Case (ii):          The result of MINVAL (ARRAY, MASK = MASK) has a value equal to that of MINVAL (PACK
<P>
                      (ARRAY, MASK)).
<P>
  Case (iii):         The result of MINVAL (ARRAY, DIM = DIM [, MASK = MASK]) has a value equal to that of
<P>
                      MINVAL (ARRAY [, MASK = MASK]) if ARRAY has rank one. Otherwise, the value of element
<P>
                      (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of the result is equal to
<P>
                              MINVAL (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )
<P>
                              [, MASK= MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ) ] ).
<P>
</PRE>
6 If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
</TD></TR>
<TR><TD colspan=2>
<PRE>
  operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<P>
</PRE>
7 Examples.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):           The value of MINVAL ([1, 2, 3]) is 1.
<P>
  Case (ii):          MINVAL (C, MASK = C &gt; 0.0) is the minimum of the positive elements of C.
<P>
                                                         
<P>
                                                1 3 5
<P>
  Case (iii):         If B is the array                     , MINVAL (B, DIM = 1) is [1, 3, 5] and MINVAL (B, DIM = 2) is
<P>
                                                2 4 6
<P>
                      [1, 2].
<P>
  16.9.135 MOD (A, P)
<P>
</PRE>
1 Description. Remainder function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A                   shall be of type integer or real.
<P>
  P                   shall be of the same type and kind type parameter as A. P shall not be zero.
<P>
</PRE>
4 Result Characteristics. Same as A.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The value of the result is A − INT (A/P) * P.
</TD></TR>
<TR><TD colspan=2>
6 Examples. MOD (3.0, 2.0) has the value 1.0 (approximately). MOD (8, 5) has the value 3. MOD (−8, 5) has
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value −3. MOD (8, −5) has the value 3. MOD (−8, −5) has the value −3.
<P>
  16.9.136 MODULO (A, P)
<P>
</PRE>
1 Description. Modulo function.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A                   shall be of type integer or real.
<P>
  P                   shall be of the same type and kind type parameter as A. P shall not be zero.
<P>
  406                                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Same as A.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     A is of type integer. MODULO (A, P) has the value R such that A = Q × P + R, where Q is an
<P>
                integer, the inequalities 0 ≤ R &lt; P hold if P &gt; 0, and P &lt; R ≤ 0 hold if P &lt; 0.
<P>
  Case (ii):    A is of type real. The value of the result is A − FLOOR (A / P) * P.
<P>
</PRE>
6 Examples. MODULO (8, 5) has the value 3. MODULO (−8, 5) has the value 2. MODULO (8, −5) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value −2. MODULO (−8, −5) has the value −3.
<P>
  16.9.137 MOVE_ALLOC (FROM, TO [, STAT, ERRMSG])
<P>
</PRE>
1 Description. Move an allocation.
</TD></TR>
<TR><TD colspan=2>
2 Class. Subroutine, pure if and only if FROM is not a coarray.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  FROM          may be of any type, rank, and corank. It shall be allocatable and shall not be a coindexed object.
<P>
                It is an INTENT (INOUT) argument.
<P>
  TO            shall be type compatible (7.3.2.3) with FROM and have the same rank and corank. It shall be
<P>
                allocatable and shall not be a coindexed object. It shall be polymorphic if FROM is polymorphic.
<P>
                It is an INTENT (OUT) argument. Each nondeferred parameter of the declared type of TO shall
<P>
                have the same value as the corresponding parameter of the declared type of FROM.
<P>
  STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
<P>
                INTENT (OUT) argument.
<P>
  ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
<P>
</PRE>
4 If execution of MOVE_ALLOC is successful, or if STAT_FAILED_IMAGE is assigned to STAT,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • On invocation of MOVE_ALLOC, if the allocation status of TO is allocated, it is deallocated. Then,
<P>
        if FROM has an allocation status of allocated on entry to MOVE_ALLOC, TO becomes allocated with
<P>
        dynamic type, type parameters, bounds, cobounds, and value identical to those that FROM had on entry
<P>
        to MOVE_ALLOC. Note that if FROM and TO are the same variable, it shall be unallocated when
<P>
        MOVE_ALLOC is invoked.
<P>
      • If TO has the TARGET attribute, any pointer associated with FROM on entry to MOVE_ALLOC becomes
<P>
        correspondingly associated with TO. If TO does not have the TARGET attribute, the pointer association
<P>
        status of any pointer associated with FROM on entry becomes undefined.
<P>
      • The allocation status of FROM becomes unallocated.
<P>
</PRE>
5 When a reference to MOVE_ALLOC is executed for which the FROM argument is a coarray, there is an implicit
</TD></TR>
<TR><TD colspan=2>
<PRE>
  synchronization of all active images of the current team. On those images, execution of the segment (11.6.2)
<P>
  following the CALL statement is delayed until all other active images of the current team have executed the same
<P>
  statement the same number of times. When such a reference is executed, if any image of the current team has
<P>
  stopped or failed, an error condition occurs.
<P>
</PRE>
6 If STAT is present and execution is successful, it is assigned the value zero.
</TD></TR>
<TR><TD colspan=2>
7 If an error condition occurs,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      • if STAT is absent, error termination is initiated;
<P>
      • otherwise, if FROM is a coarray and the current team contains a stopped image, STAT is assigned the value
<P>
        STAT_STOPPED_IMAGE from the intrinsic module ISO_FORTRAN_ENV;
<P>
      • otherwise, if FROM is a coarray and the current team contains a failed image, and no other error condition
<P>
        occurs, STAT is assigned the value STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_-
<P>
        ENV;
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
407
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
      • otherwise, STAT is assigned a processor-dependent positive value that differs from that of STAT_STOP-
<P>
        PED_IMAGE or STAT_FAILED_IMAGE.
<P>
</PRE>
8 If the ERRMSG argument is present and an error condition occurs, it is assigned an explanatory message. If no
<P>
<PRE>
  error condition occurs, the definition status and value of ERRMSG are unchanged.
<P>
</PRE>
9 Example. The example below demonstrates reallocation of GRID to twice its previous size, with its previous
<P>
<PRE>
  contents evenly distributed over the new elements so that intermediate points can be inserted.
<P>
           REAL,ALLOCATABLE :: GRID(:),TEMPGRID(:)
<P>
           &#46;&#46;&#46;
<P>
           ALLOCATE(GRID(-N:N))              ! initial allocation of GRID
<P>
           &#46;&#46;&#46;
<P>
           ALLOCATE(TEMPGRID(-2*N:2*N)) ! allocate bigger grid
<P>
           TEMPGRID(::2)=GRID ! distribute values to new locations
<P>
           CALL MOVE_ALLOC(TO=GRID,FROM=TEMPGRID)
<P>
  The old grid is deallocated because TO is INTENT (OUT), and GRID then takes over the new grid allocation.
<P>
        NOTE 16.24
<P>
       It is expected that the implementation of allocatable objects will typically involve descriptors to locate the
<P>
       allocated storage; MOVE_ALLOC could then be implemented by transferring the contents of the descriptor
<P>
       for FROM to the descriptor for TO and clearing the descriptor for FROM.
<P>
  16.9.138 MVBITS (FROM, FROMPOS, LEN, TO, TOPOS)
<P>
</PRE>
1 Description. Copy a sequence of bits.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental subroutine.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 Arguments.
<P>
<PRE>
  FROM          shall be of type integer. It is an INTENT (IN) argument.
<P>
  FROMPOS shall be of type integer and nonnegative. It is an INTENT (IN) argument. FROMPOS + LEN
<P>
                shall be less than or equal to BIT_SIZE (FROM). The model for the interpretation of an integer
<P>
                value as a sequence of bits is in 16.3.
<P>
  LEN           shall be of type integer and nonnegative. It is an INTENT (IN) argument.
<P>
  TO            shall be a variable of the same type and kind type parameter value as FROM and may be associated
<P>
                with FROM (15.8.3). It is an INTENT (INOUT) argument. TO is defined by copying the sequence
<P>
                of bits of length LEN, starting at position FROMPOS of FROM to position TOPOS of TO. No
<P>
                other bits of TO are altered. On return, the LEN bits of TO starting at TOPOS are equal to
<P>
                the value that the LEN bits of FROM starting at FROMPOS had on entry. The model for the
<P>
                interpretation of an integer value as a sequence of bits is in 16.3.
<P>
  TOPOS         shall be of type integer and nonnegative. It is an INTENT (IN) argument. TOPOS + LEN shall
<P>
                be less than or equal to BIT_SIZE (TO).
<P>
</PRE>
4 Example. If TO has the initial value 6, its value after the statement CALL MVBITS (7, 2, 2, TO, 0) is 5.
<P>
<PRE>
  16.9.139 NEAREST (X, S)
<P>
</PRE>
1 Description. Adjacent machine number.
<P>
2 Class. Elemental function.
<P>
<PRE>
  408                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  X              shall be of type real.
<P>
  S              shall be of type real and not equal to zero.
<P>
</PRE>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to the machine-representable number distinct from X and nearest
<P>
<PRE>
  to it in the direction of the ∞ with the same sign as S.
<P>
</PRE>
6 Example. NEAREST (3.0, 2.0) has the value 3 + 2−22 on a machine whose representation is that of the model
<P>
<PRE>
  in NOTE 16.4.
<P>
        NOTE 16.25
<P>
        Unlike other floating-point manipulation functions, NEAREST operates on machine-representable numbers
<P>
        rather than model numbers. On many systems there are machine-representable numbers that lie between
<P>
        adjacent model numbers.
<P>
  16.9.140 NEW_LINE (A)
<P>
</PRE>
1 Description. Newline character.
<P>
2 Class. Inquiry function.
<P>
3 Argument. A shall be of type character. It may be a scalar or an array.
<P>
4 Result Characteristics. Character scalar of length one with the same kind type parameter as A.
<P>
5 Result Value.
<P>
<PRE>
  Case (i):      If A is default character and the character in position 10 of the ASCII collating sequence is repres-
<P>
                 entable in the default character set, then the result is ACHAR (10).
<P>
  Case (ii):     If A is ASCII character or ISO 10646 character, then the result is CHAR (10, KIND (A)).
<P>
  Case (iii):    Otherwise, the result is a processor-dependent character that represents a newline in output to files
<P>
                 connected for formatted stream output if there is such a character.
<P>
  Case (iv):     Otherwise, the result is the blank character.
<P>
</PRE>
6 Example. If there is a suitable newline character, and unit 10 is connected for formatted stream output, the
<P>
<PRE>
  statement
<P>
            WRITE (10, ’(A)’) ’New’//NEW_LINE(’a’)//’Line’
<P>
  will write a record containing “New” and then a record containing “Line”.
<P>
  16.9.141 NINT (A [, KIND])
<P>
</PRE>
1 Description. Nearest integer.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be of type real.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value. The result is the integer nearest A, or if there are two integers equally near A, the result is
<P>
<PRE>
  whichever such integer has the greater magnitude.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          409
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Example. NINT (2.783) has the value 3.
<P>
<PRE>
  16.9.142 NORM2 (X) or NORM2 (X, DIM)
<P>
</PRE>
1 Description. L2 norm of an array.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  X              shall be a real array.
<P>
  DIM            shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of X.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and type parameters as X. It is scalar if DIM does not
<P>
<PRE>
  appear; otherwise the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ], where n is the rank
<P>
  of X and [d1 , d2 , . . . , dn ] is the shape of X.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):      The result of NORM2 (X) has a value equal to a processor-dependent approximation to the gener-
<P>
                 alized L2 norm of X, which is the square root of the sum of the squares of the elements of X. If X
<P>
                 has size zero, the result has the value zero.
<P>
  Case (ii):     The result of NORM2 (X, DIM=DIM) has a value equal to that of NORM2 (X) if X has rank
<P>
                 one. Otherwise, the value of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . sn ) of the result is equal to
<P>
                 NORM2 (X(s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . sn )).
<P>
</PRE>
6 It is recommended that the processor compute the result without undue overflow or underflow.
<P>
<PRE>
                                                                                                                   
<P>
                                                                                                          1.0 2.0
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>7 Example. The value of NORM2 ([3.0, 4.0]) is 5.0 (approximately). If X has the value</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
then the
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                                                          3.0 4.0
<P>
</PRE>
value of NORM2 (X, DIM=1) is [3.162, 4.472] (approximately) and the value of NORM2 (X, DIM=2) is [2.236,
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
5.0] (approximately).
<P>
16.9.143 NOT (I)
</TD></TR>
<TR></TR></TABLE>1 Description. Bitwise complement.
<P>
2 Class. Elemental function.
<P>
3 Argument. I shall be of type integer.
<P>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The result has the value obtained by complementing I bit-by-bit according to the following table:
<P>
<PRE>
                                                         I   NOT (I)
<P>
                                                         1        0
<P>
                                                         0        1
<P>
</PRE>
6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
7 Example. If I is represented by the string of bits 01010101, NOT (I) has the binary value 10101010.
<P>
<PRE>
  16.9.144 NULL ([MOLD])
<P>
</PRE>
1 Description. Disassociated pointer or unallocated allocatable entity.
<P>
2 Class. Transformational function.
<P>
<PRE>
  410                                                                      ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Argument. MOLD shall be a pointer or allocatable. It may be of any type or may be a procedure pointer.
<P>
<PRE>
  If MOLD is a pointer its pointer association status may be undefined, disassociated, or associated. If MOLD is
<P>
  allocatable its allocation status may be allocated or unallocated. It need not be defined with a value.
<P>
</PRE>
4 Result Characteristics. If MOLD is present, the characteristics are the same as MOLD. If MOLD has deferred
<P>
<PRE>
  type parameters, those type parameters of the result are deferred.
<P>
</PRE>
5 If MOLD is absent, the characteristics of the result are determined by the entity with which the reference is
<P>
<PRE>
  associated. See Table 16.5. MOLD shall not be absent in any other context. If any type parameters of the
<P>
  contextual entity are deferred, those type parameters of the result are deferred. If any type parameters of the
<P>
  contextual entity are assumed, MOLD shall be present.
<P>
</PRE>
6 If the context of the reference to NULL is an actual argument in a generic procedure reference, MOLD shall be
<P>
<PRE>
  present if the type, type parameters, or rank are required to resolve the generic reference.
<P>
                               Table 16.5: Characteristics of the result of NULL ( )
<P>
             Appearance of NULL ( )                        Type, type parameters, and rank of result:
<P>
             right side of a pointer assignment            pointer on the left side
<P>
             initialization for an object in a declaration the object
<P>
             default initialization for a component        the component
<P>
             in a structure constructor                    the corresponding component
<P>
             as an actual argument                         the corresponding dummy argument
<P>
             in a DATA statement                           the corresponding pointer object
<P>
</PRE>
7 Result. The result is a disassociated pointer or an unallocated allocatable entity.
<P>
8 Examples.
<P>
<PRE>
  Case (i):      REAL, POINTER, DIMENSION (:) :: VEC =&gt; NULL ( ) defines the initial association status of
<P>
                 VEC to be disassociated.
<P>
  Case (ii):     The MOLD argument is required in the following:
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE GEN</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE S1 (J, PI)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER J</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER, POINTER :: PI
</BLOCKQUOTE>
<P>
END SUBROUTINE S1
<BLOCKQUOTE>
<P>
SUBROUTINE S2 (K, PR)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER K</H4>
</A>
<BLOCKQUOTE>
<P>
REAL, POINTER :: PR
</BLOCKQUOTE>
<P>
END SUBROUTINE S2
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
REAL, POINTER :: REAL_PTR
<TABLE cellpadding=3><!-- tsb: REAL, POINTER :: REAL_PTR
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>CALL GEN (7, NULL (REAL_PTR) )</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Invokes S2
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
16.9.145 NUM_IMAGES ( ) or NUM_IMAGES (TEAM) or
<P>
<PRE>
                NUM_IMAGES (TEAM_NUMBER)
<P>
</PRE>
1 Description. Number of images.
<BLOCKQUOTE>
<P>
2 Class. Transformational function.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                     411
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  TEAM          shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, with a
<P>
                value that identifies the current or an ancestor team.
<P>
  TEAM_NUMBER shall be an integer scalar. It shall identify the initial team or a team whose parent is the
<P>
                same as that of the current team.
<P>
</PRE>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The number of images in the specified team, or in the current team if no team is specified.
<P>
6 Example. The following code uses image 1 to read data and broadcast it to other images.
<P>
<PRE>
           REAL :: P[*]
<P>
           IF (THIS_IMAGE()==1) THEN
<P>
              READ (6,*) P
<P>
              DO I = 2, NUM_IMAGES()
<P>
                   P[I] = P
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
16.9.146 OUT_OF_RANGE (X, MOLD [, ROUND])
</BLOCKQUOTE>
<P>
1 Description. Whether a value cannot be converted safely.
<BLOCKQUOTE>
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be of type integer or real.
<P>
  MOLD          shall be an integer or real scalar. If it is a variable, it need not be defined.
<P>
  ROUND (optional) shall be a logical scalar. ROUND shall be present only if X is of type real and MOLD is of
<P>
                type integer.
<P>
</PRE>
4 Result Characteristics. Default logical.
<P>
5 Result Value.
<P>
<PRE>
  Case (i):     If MOLD is of type integer, and ROUND is absent or present with the value false, the result is true
<P>
                if and only if the value of X is an IEEE infinity or NaN, or if the integer with largest magnitude
<P>
                that lies between zero and X inclusive is not representable by objects with the type and kind of
<P>
                MOLD.
<P>
  Case (ii):    If MOLD is of type integer, and ROUND is present with the value true, the result is true if and only
<P>
                if the value of X is an IEEE infinity or NaN, or if the integer nearest X, or the integer of greater
<P>
                magnitude if two integers are equally near to X, is not representable by objects with the type and
<P>
                kind of MOLD.
<P>
  Case (iii):   Otherwise, the result is true if and only if the value of X is an IEEE infinity or NaN that is not
<P>
                supported by objects of the type and kind of MOLD, or if X is a finite number and the result of
<P>
                rounding the value of X (according to the IEEE rounding mode if appropriate) to the extended
<P>
                model for the kind of MOLD has magnitude larger than that of the largest finite number with the
<P>
                same sign as X that is representable by objects with the type and kind of MOLD.
<P>
</PRE>
6 Examples. If INT8 is the kind value for an 8-bit binary integer type, OUT_OF_RANGE (−128.5, 0_INT8)
<P>
<PRE>
  will have the value false and OUT_OF_RANGE (−128.5, 0_INT8, .TRUE.) will have the value true.
<P>
  412                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 16.26
<P>
       MOLD is required to be a scalar because the only information taken from it is its type and kind. Allowing
<P>
       an array MOLD would require that it be conformable with X. ROUND is scalar because allowing an array
<P>
       rounding mode would have severe performance difficulties on many processors.
<P>
  16.9.147 PACK (ARRAY, MASK [, VECTOR])
<P>
</PRE>
1 Description. Array packed into a vector.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY           shall be an array of any type.
<P>
  MASK            shall be of type logical and shall be conformable with ARRAY.
<P>
  VECTOR (optional) shall be of the same type and type parameters as ARRAY and shall have rank one. VEC-
<P>
                  TOR shall have at least as many elements as there are true elements in MASK. If MASK is scalar
<P>
                  with the value true, VECTOR shall have at least as many elements as there are in ARRAY.
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>4 Result Characteristics.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The result is an array of rank one with the same type and type parameters as
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ARRAY. If VECTOR is present, the result size is that of VECTOR; otherwise, the result size is the number t
<P>
  of true elements in MASK unless MASK is scalar with the value true, in which case the result size is the size of
<P>
  ARRAY.
<P>
</PRE>
5 Result Value. Element i of the result is the element of ARRAY that corresponds to the ith true element of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  MASK, taking elements in array element order, for i = 1, 2, . . . , t. If VECTOR is present and has size n &gt; t,
<P>
  element i of the result has the value VECTOR (i), for i = t + 1, . . . , n.
<P>
                                                                                         
<P>
                                                                                 0 0 0
<P>
</PRE>
6 Examples. The nonzero elements of an array M with the value  9 0 0  can be “gathered” by the func-
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
0 0 7
</TD></TR>
<TR><TD colspan=2>
tion PACK. The result of PACK (M, MASK = M /= 0) is [9, 7] and the result of PACK (M, M /= 0, VEC-
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
TOR = [2, 4, 6, 8, 10, 12]) is [9, 7, 6, 8, 10, 12].
<P>
16.9.148 PARITY (MASK) or PARITY (MASK, DIM)
</TD></TR>
<TR></TR></TABLE>1 Description. Array reduced by .NEQV. operation.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  MASK            shall be a logical array.
<P>
  DIM             shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
<P>
</PRE>
4 Result Characteristics. The result is of type logical with the same kind type parameter as MASK. It is scalar
<P>
<PRE>
  if DIM does not appear; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ]
<P>
  where [d1 , d2 , . . . , dn ] is the shape of MASK.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):       The result of PARITY (MASK) has the value true if an odd number of the elements of MASK are
<P>
                  true, and false otherwise.
<P>
  Case (ii):      If MASK has rank one, PARITY (MASK, DIM) is equal to PARITY (MASK). Otherwise, the
<P>
                  value of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of PARITY (MASK, DIM) is equal to
<P>
                  PARITY (MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn )).
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                             413
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):      The value of PARITY ([T, T, T, F]) is true if T has the value true and F has the value false.
<P>
                                                
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; T T F</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Case (ii):</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
If B is the array                 , where T has the value true and F has the value false, then
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; T T T</H4>
</A>
<BLOCKQUOTE>
<P>
PARITY (B, DIM=1) has the value [F, F, T] and PARITY (B, DIM=2) has the value [F, T].
</BLOCKQUOTE>
<P>
16.9.149 POPCNT (I)
<BLOCKQUOTE>
<P>
1 Description. Number of one bits.
<P>
2 Class. Elemental function.
<P>
3 Argument. I shall be of type integer.
<P>
4 Result Characteristics. Default integer.
<P>
5 Result Value. The result value is equal to the number of one bits in the sequence of bits of I. The model for
<P>
<PRE>
  the interpretation of an integer value as a sequence of bits is in 16.3.
<P>
</PRE>
6 Examples. POPCNT ([1, 2, 3, 4, 5, 6]) has the value [1, 1, 2, 1, 2, 2].
<P>
<PRE>
  16.9.150 POPPAR (I)
<P>
</PRE>
1 Description. Parity expressed as 0 or 1.
<P>
2 Class. Elemental function.
<P>
3 Argument. I shall be of type integer.
<P>
4 Result Characteristics. Default integer.
<P>
5 Result Value. POPPAR (I) has the value 1 if POPCNT (I) is odd, and 0 if POPCNT (I) is even.
<P>
6 Examples. POPPAR ([1, 2, 3, 4, 5, 6]) has the value [1, 1, 0, 1, 0, 0].
<P>
<PRE>
  16.9.151 PRECISION (X)
<P>
</PRE>
1 Description. Decimal precision of a real model.
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be of type real or complex. It may be a scalar or an array.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The result has the value INT ((p − 1) * LOG10 (b)) + k, where b and p are as defined in 16.4
<P>
<PRE>
  for the model representing real numbers with the same value for the kind type parameter as X, and where k is 1
<P>
  if b is an integral power of 10 and 0 otherwise.
<P>
</PRE>
6 Example. PRECISION (X) has the value INT (23 * LOG10 (2.)) = INT (6.92. . . ) = 6 for real X whose model
<P>
<PRE>
  is as in NOTE 16.4.
<P>
  16.9.152 PRESENT (A)
<P>
</PRE>
1 Description. Presence of optional argument.
<P>
2 Class. Inquiry function.
<P>
3 Argument. A shall be the name of an optional dummy argument that is accessible in the subprogram in which
<P>
<PRE>
  the PRESENT function reference appears. There are no other requirements on A.
<P>
  414                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
<P>
5 Result Value. The result has the value true if A is present (15.5.2.12) and otherwise has the value false.
<P>
<PRE>
  16.9.153 PRODUCT (ARRAY, DIM [, MASK]) or
<P>
                      PRODUCT (ARRAY [, MASK])
<P>
</PRE>
1 Description. Array reduced by multiplication.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY               shall be an array of numeric type.
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
<P>
<PRE>
  DIM does not appear; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where
<P>
  [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):           The result of PRODUCT (ARRAY) has a value equal to a processor-dependent approximation to
<P>
                      the product of all the elements of ARRAY or has the value one if ARRAY has size zero.
<P>
  Case (ii):          The result of PRODUCT (ARRAY, MASK = MASK) has a value equal to a processor-dependent
<P>
                      approximation to the product of the elements of ARRAY corresponding to the true elements of
<P>
                      MASK or has the value one if there are no true elements.
<P>
  Case (iii):         If ARRAY has rank one, PRODUCT (ARRAY, DIM = DIM [, MASK = MASK]) has a value equal
<P>
                      to that of PRODUCT (ARRAY [, MASK = MASK ]). Otherwise, the value of element (s1 , s2 , . . . ,
<P>
                      sDIM−1 , sDIM+1 , . . . , sn ) of PRODUCT (ARRAY, DIM = DIM [, MASK = MASK]) is equal to
<P>
                              PRODUCT (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ) [, MASK = MASK (s1 , s2 , . . . ,
<P>
                              sDIM−1 , :, sDIM+1 , . . . , sn ) ] ).
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):           The value of PRODUCT ([1, 2, 3]) is 6.
<P>
  Case (ii):          PRODUCT (C, MASK = C &gt; 0.0) forms the product of the positive elements of C.
<P>
                                                      
<P>
                                           1 3 5
<P>
  Case (iii):         If B is the array                   , PRODUCT (B, DIM = 1) is [2, 12, 30] and PRODUCT (B, DIM = 2)
<P>
                                           2 4 6
<P>
                      is [15, 48].
<P>
  16.9.154 RADIX (X)
<P>
</PRE>
1 Description. Base of a numeric model.
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be of type integer or real. It may be a scalar or an array.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The result has the value r if X is of type integer and the value b if X is of type real, where r and
<P>
<PRE>
  b are as defined in 16.4 for the model representing numbers of the same type and kind type parameter as X.
<P>
</PRE>
6 Example. RADIX (X) has the value 2 for real X whose model is as in NOTE 16.4.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                    415
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.155 RANDOM_INIT (REPEATABLE, IMAGE_DISTINCT)
<P>
</PRE>
1 Description. Initialize the pseudorandom number generator.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  REPEATABLE shall be a logical scalar. It is an INTENT (IN) argument. If it has the value true, the seed
<P>
                accessed by the pseudorandom number generator is set to a processor-dependent value that is the
<P>
                same each time RANDOM_INIT is called from the same image. If it has the value false, the seed
<P>
                is set to a processor-dependent, unpredictably different value on each call.
<P>
  IMAGE_DISTINCT shall be a logical scalar. It is an INTENT (IN) argument. If it has the value true, the
<P>
                seed accessed by the pseudorandom number generator is set to a processor-dependent value that
<P>
                is distinct from the value that would be set by a call to RANDOM_INIT by another image. If
<P>
                it has the value false, the value to which the seed is set does not depend on which image calls
<P>
                RANDOM_INIT.
<P>
</PRE>
4 Example. The following statement initializes the pseudorandom number generator so that the seed is different
<P>
<PRE>
  on each call and that the sequence generated will differ from that of another image:
<P>
     CALL RANDOM_INIT (REPEATABLE=.FALSE., IMAGE_DISTINCT=.TRUE.)
<P>
  16.9.156 RANDOM_NUMBER (HARVEST)
<P>
</PRE>
1 Description. Generate pseudorandom <B>number</B>(s).
<P>
2 Class. Subroutine.
<P>
3 Argument. HARVEST shall be of type real. It is an INTENT (OUT) argument. It may be a scalar or an array.
<P>
<PRE>
  It is assigned pseudorandom numbers from the uniform distribution in the interval 0 ≤ x &lt; 1. If images use a
<P>
  common generator, the interleaving of values assigned in unordered segments is processor dependent.
<P>
</PRE>
4 Example.
<P>
<PRE>
  REAL X, Y (10, 10)
<P>
  ! Initialize X with a pseudorandom number
<P>
  CALL RANDOM_NUMBER (HARVEST = X)
<P>
  CALL RANDOM_NUMBER (Y)
<P>
  ! X and Y contain uniformly distributed random numbers
<P>
  16.9.157 RANDOM_SEED ([SIZE, PUT, GET])
<P>
</PRE>
1 Description. Restart or query the pseudorandom number generator.
<P>
2 Class. Subroutine.
<P>
3 Arguments. There shall either be exactly one or no arguments present.
<P>
<PRE>
  SIZE (optional) shall be a default integer scalar. It is an INTENT (OUT) argument. It is assigned the number
<P>
                N of integers that the processor uses to hold the value of the seed.
<P>
  PUT (optional) shall be a default integer array of rank one and size ≥ N . It is an INTENT (IN) argument. It
<P>
                is used in a processor-dependent manner to compute the seed value accessed by the pseudorandom
<P>
                number generator.
<P>
  GET (optional) shall be a default integer array of rank one and size ≥ N . It is an INTENT (OUT) argument.
<P>
                It is assigned the value of the seed.
<P>
  416                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 If no argument is present, the processor assigns a processor-dependent value to the seed.
<P>
5 The pseudorandom number generator used by RANDOM_NUMBER maintains a seed that is updated during the
<P>
<PRE>
  execution of RANDOM_NUMBER and that can be retrieved or changed by RANDOM_SEED. Computation
<P>
  of the seed from the argument PUT is performed in a processor-dependent manner. The value assigned to GET
<P>
  need not be the same as the value of PUT in an immediately preceding reference to RANDOM_SEED. For
<P>
  example, following execution of the statements
<P>
      CALL RANDOM_SEED (PUT=SEED1)
<P>
      CALL RANDOM_SEED (GET=SEED2)
<P>
  SEED2 need not equal SEED1. When the values differ, the use of either value as the PUT argument in a
<P>
  subsequent call to RANDOM_SEED shall result in the same sequence of pseudorandom numbers being generated.
<P>
  For example, after execution of the statements
<P>
      CALL   RANDOM_SEED (PUT=SEED1)
<P>
      CALL   RANDOM_SEED (GET=SEED2)
<P>
      CALL   RANDOM_NUMBER (X1)
<P>
      CALL   RANDOM_SEED (PUT=SEED2)
<P>
      CALL   RANDOM_NUMBER (X2)
<P>
  X2 equals X1.
<P>
</PRE>
6 Examples.
<P>
<PRE>
  CALL  RANDOM_SEED                                  ! Processor initialization
<P>
  CALL  RANDOM_SEED (SIZE = K)                       ! Puts size of seed in K
<P>
  CALL  RANDOM_SEED (PUT = SEED (1 : K))             ! Define seed
<P>
  CALL  RANDOM_SEED (GET = OLD (1 : K))              ! Read current seed
<P>
  16.9.158 RANGE (X)
<P>
</PRE>
1 Description. Decimal exponent range of a numeric model (16.4).
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be of type integer, real, or complex. It may be a scalar or an array.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value.
<P>
<PRE>
  Case (i):     If X is of type integer, the result has the value INT (LOG10 (HUGE (X))).
<P>
  Case (ii):    If X is of type real, the result has the value INT (MIN (LOG10 (HUGE (X)), −LOG10 (TINY (X)))).
<P>
  Case (iii):   If X is of type complex, the result has the value RANGE (REAL (X)).
<P>
</PRE>
6 Examples. RANGE (X) has the value 38 for real X whose model is as in NOTE 16.4, because in this case
<P>
<PRE>
  HUGE (X) = (1 − 2−24 ) × 2127 and TINY (X) = 2−127 .
<P>
  16.9.159 RANK (A)
<P>
</PRE>
1 Description. Rank of a data object.
<P>
2 Class. Inquiry function.
<P>
3 Argument. A shall be a data object of any type.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                   417
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The value of the result is the rank of A.
<P>
6 Example. If X is an assumed-rank dummy argument and its associated effective argument is an array of rank
<P>
<PRE>
  3, RANK(X) has the value 3.
<P>
  16.9.160 REAL (A [, KIND])
<P>
</PRE>
1 Description. Conversion to real type.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A             shall be of type integer, real, or complex, or a boz-literal-constant.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Real.
<P>
<PRE>
  Case (i):     If A is of type integer or real and KIND is present, the kind type parameter is that specified by the
<P>
                value of KIND. If A is of type integer or real and KIND is not present, the kind type parameter is
<P>
                that of default real kind.
<P>
  Case (ii):    If A is of type complex and KIND is present, the kind type parameter is that specified by the value
<P>
                of KIND. If A is of type complex and KIND is not present, the kind type parameter is the kind
<P>
                type parameter of A.
<P>
  Case (iii):   If A is a boz-literal-constant and KIND is present, the kind type parameter is that specified by the
<P>
                value of KIND. If A is a boz-literal-constant and KIND is not present, the kind type parameter is
<P>
                that of default real kind.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     If A is of type integer or real, the result is equal to a processor-dependent approximation to A.
<P>
  Case (ii):    If A is of type complex, the result is equal to a processor-dependent approximation to the real part
<P>
                of A.
<P>
  Case (iii):   If A is a boz-literal-constant, the value of the result is the value whose internal representation as a
<P>
                bit sequence is the same as that of A as modified by padding or truncation according to 16.3.3. The
<P>
                interpretation of the bit sequence is processor dependent.
<P>
</PRE>
6 Examples. REAL (−3) has the value −3.0. REAL (Z) has the same kind type parameter and the same value
<P>
<PRE>
  as the real part of the complex variable Z.
<P>
  16.9.161 REDUCE (ARRAY, OPERATION [, MASK, IDENTITY, ORDERED])
<P>
                or REDUCE (ARRAY, OPERATION, DIM [, MASK, IDENTITY,
<P>
                ORDERED])
<P>
</PRE>
1 Description. General reduction of array.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY         shall be an array of any type.
<P>
  OPERATION shall be a pure function with exactly two arguments; each argument shall be a scalar, nonal-
<P>
                locatable, nonpointer, nonpolymorphic, nonoptional dummy data object with the same type and
<P>
                type parameters as ARRAY. If one argument has the ASYNCHRONOUS, TARGET, or VALUE
<P>
                attribute, the other shall have that attribute. Its result shall be a nonpolymorphic scalar and have
<P>
                the same type and type parameters as ARRAY. OPERATION should implement a mathematically
<P>
                associative operation. It need not be commutative.
<P>
  418                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
  IDENTITY (optional) shall be scalar with the same type and type parameters as ARRAY.
<P>
  ORDERED (optional) shall be a logical scalar.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and type parameters as ARRAY. It is scalar if DIM
<P>
<PRE>
  does not appear; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where
<P>
  [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):           The result of REDUCE (ARRAY, OPERATION [, IDENTITY = IDENTITY, ORDERED =
<P>
                      ORDERED]) over the sequence of values in ARRAY is the result of an iterative process. The
<P>
                      initial order of the sequence is array element order. While the sequence has more than one element,
<P>
                      each iteration involves the execution of r = OPERATION(x, y) for adjacent x and y in the sequence,
<P>
                      with x immediately preceding y, and the subsequent replacement of x and y with r; if ORDERED
<P>
                      is present with the value true, x and y shall be the first two elements of the sequence. The process
<P>
                      continues until the sequence has only one element which is the value of the reduction. If the initial
<P>
                      sequence is empty, the result has the value IDENTITY if IDENTITY is present, and otherwise,
<P>
                      error termination is initiated.
<P>
  Case (ii):          The result of REDUCE (ARRAY, OPERATION, MASK = MASK [, IDENTITY = IDENTITY,
<P>
                      ORDERED = ORDERED]) is as for Case (i) except that the initial sequence is only those elements
<P>
                      of ARRAY for which the corresponding elements of MASK are true.
<P>
  Case (iii):         If ARRAY has rank one, REDUCE (ARRAY, OPERATION, DIM = DIM [, MASK = MASK,
<P>
                      IDENTITY = IDENTITY, ORDERED = ORDERED]) has a value equal to that of REDUCE (AR-
<P>
                      RAY, OPERATION [, MASK = MASK, IDENTITY = IDENTITY, ORDERED = ORDERED]).
<P>
                      Otherwise, the value of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 , . . . , sn ) of REDUCE (ARRAY,
<P>
                      DIM = DIM [, MASK = MASK, IDENTITY = IDENTITY]) is equal to
<P>
                              REDUCE (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ),
<P>
                                          OPERATION = OPERATION,
<P>
                                          DIM=1
<P>
                                          [, MASK = MASK (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ),
<P>
                                           IDENTITY = IDENTITY,
<P>
                                           ORDERED = ORDERED] ).
<P>
</PRE>
6 Examples. The following examples all use the function MY_MULT, which returns the product of its two integer
<P>
<PRE>
  arguments.
<P>
  Case (i):           The value of REDUCE ([1, 2, 3], MY_MULT) is 6.
<P>
  Case (ii):          REDUCE (C, MY_MULT, MASK= C &gt; 0, IDENTITY=1) forms the product of the positive
<P>
                      elements of C.              
<P>
                                            1 3 5
<P>
  Case (iii):         If B is the array              , REDUCE (B, MY_MULT, DIM = 1) is [2, 12, 30] and REDUCE (B,
<P>
                                            2 4 6
<P>
                      MY_MULT, DIM = 2) is [15, 48].
<P>
         NOTE 16.27
<P>
         If OPERATION is not computationally associative, REDUCE without ORDERED=.TRUE. with the same
<P>
         argument values might not always produce the same result, as the processor can apply the associative law
<P>
         to the evaluation.
<P>
  16.9.162 REPEAT (STRING, NCOPIES)
<P>
</PRE>
1 Description. Repetitive string concatenation.
<P>
2 Class. Transformational function.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               419
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  STRING         shall be a character scalar.
<P>
  NCOPIES        shall be an integer scalar. Its value shall not be negative.
<P>
</PRE>
4 Result Characteristics. Character scalar of length NCOPIES times that of STRING, with the same kind type
<P>
<PRE>
  parameter as STRING.
<P>
</PRE>
5 Result Value. The value of the result is the concatenation of NCOPIES copies of STRING.
<P>
6 Examples. REPEAT (’H’, 2) has the value HH. REPEAT (’XYZ’, 0) has the value of a zero-length string.
<P>
<PRE>
  16.9.163 RESHAPE (SOURCE, SHAPE [, PAD, ORDER])
<P>
</PRE>
1 Description. Arbitrary shape array construction.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  SOURCE         shall be an array of any type. If PAD is absent or of size zero, the size of SOURCE shall be greater
<P>
                 than or equal to PRODUCT (SHAPE). The size of the result is the product of the values of the
<P>
                 elements of SHAPE.
<P>
  SHAPE          shall be a rank-one integer array. SIZE (x), where x is the actual argument corresponding to
<P>
                 SHAPE, shall be a constant expression whose value is positive and less than 16. It shall not have
<P>
                 an element whose value is negative.
<P>
  PAD (optional) shall be an array of the same type and type parameters as SOURCE.
<P>
  ORDER (optional) shall be of type integer, shall have the same shape as SHAPE, and its value shall be a
<P>
                 permutation of (1, 2, . . . , n), where n is the size of SHAPE. If absent, it is as if it were present with
<P>
                 value (1, 2, . . . , n).
<P>
</PRE>
4 Result Characteristics. The result is an array of shape SHAPE (that is, SHAPE (RESHAPE (SOURCE,
<P>
<PRE>
  SHAPE, PAD, ORDER)) is equal to SHAPE) with the same type and type parameters as SOURCE.
<P>
</PRE>
5 Result Value. The elements of the result, taken in permuted subscript order ORDER (1), . . . , ORDER (n), are
<P>
<PRE>
  those of SOURCE in normal array element order followed if necessary by those of PAD in array element order,
<P>
  followed if necessary by additional copies of PAD in array element order.
<P>
                                                                                 
<P>
                                                                          1 3 5
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>6 Examples. RESHAPE ([1, 2, 3, 4, 5, 6], [2, 3]) has the value</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                         2 4 6       
<P>
                                                                          1 2 3 4
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>RESHAPE ([1, 2, 3, 4, 5, 6], [2, 4], [0, 0], [2, 1]) has the value</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
5 6 0 0
</TD></TR>
<TR></TR></TABLE>16.9.164 RRSPACING (X)
</TD></TR>
<TR></TR></TABLE>1 Description. Reciprocal of relative spacing of model numbers.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has the value |Y × b−e | × bp = ABS (FRACTION (Y)) * RADIX (X) / EPSILON (X),
<P>
<PRE>
  where b, e, and p are as defined in 16.4 for Y, the value nearest to X in the model for real values whose kind type
<P>
  parameter is that of X; if there are two such values, the value of greater absolute value is taken. If X is an IEEE
<P>
  infinity, the result is an IEEE NaN. If X is an IEEE NaN, the result is that NaN.
<P>
</PRE>
6 Example. RRSPACING (−3.0) has the value 0.75 × 224 for reals whose model is as in NOTE 16.4.
<P>
<PRE>
  420                                                                     ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.165 SAME_TYPE_AS (A, B)
<P>
</PRE>
1 Description. Dynamic type equality test.
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  A             shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
<P>
                pointer, it shall not have an undefined association status.
<P>
  B             shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
<P>
                pointer, it shall not have an undefined association status.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
<P>
5 Result Value. If the dynamic type of A or B is extensible, the result is true if and only if the dynamic type of
<P>
<PRE>
  A is the same as the dynamic type of B. If neither A nor B has extensible dynamic type, the result is processor
<P>
  dependent.
<P>
       NOTE 16.28
<P>
       The dynamic type of a disassociated pointer or unallocated allocatable variable is its declared type. An
<P>
       unlimited polymorphic entity has no declared type.
<P>
       NOTE 16.29
<P>
       The test performed by SAME_TYPE_AS is not the same as the test performed by the type guard TYPE
<P>
       IS. The test performed by SAME_TYPE_AS does not consider kind type parameters.
<P>
</PRE>
6 Example. Given the declarations and assignments
<P>
<PRE>
           TYPE T1
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; REAL C</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE, <B>EXTENDS</B>(T1) :: T2
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>CLASS</B>(T1), POINTER :: P, Q, R
<P>
<B>ALLOCATE</B>(P, Q)
<P>
<B>ALLOCATE</B>(T2 :: R)
</BLOCKQUOTE>
<P>
the value of SAME_TYPE_AS (P, Q) will be true, and the value of SAME_TYPE_AS (P, R) will be false.
<BLOCKQUOTE>
<P>
16.9.166 SCALE (X, I)
</BLOCKQUOTE>
<P>
1 Description. Real number scaled by radix power.
<BLOCKQUOTE>
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be of type real.
<P>
  I             shall be of type integer.
<P>
</PRE>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has the value X × bI , where b is defined in 16.4 for model numbers representing values
<P>
<PRE>
  of X, provided this result is representable; if not, the result is processor dependent.
<P>
</PRE>
6 Example. SCALE (3.0, 2) has the value 12.0 for reals whose model is as in NOTE 16.4.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                      421
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.167 SCAN (STRING, SET [, BACK, KIND])
<P>
</PRE>
1 Description. Character set membership search.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  STRING        shall be of type character.
<P>
  SET           shall be of type character with the same kind type parameter as STRING.
<P>
  BACK (optional) shall be of type logical.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     If BACK is absent or is present with the value false and if STRING contains at least one character
<P>
                that is in SET, the value of the result is the position of the leftmost character of STRING that is
<P>
                in SET.
<P>
  Case (ii):    If BACK is present with the value true and if STRING contains at least one character that is in
<P>
                SET, the value of the result is the position of the rightmost character of STRING that is in SET.
<P>
  Case (iii):   The value of the result is zero if no character of STRING is in SET or if the length of STRING or
<P>
                SET is zero.
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):     SCAN (’FORTRAN’, ’TR’) has the value 3.
<P>
  Case (ii):    SCAN (’FORTRAN’, ’TR’, BACK = .TRUE.) has the value 5.
<P>
  Case (iii):   SCAN (’FORTRAN’, ’BCD’) has the value 0.
<P>
  16.9.168 SELECTED_CHAR_KIND (NAME)
<P>
</PRE>
1 Description. Character kind selection.
<P>
2 Class. Transformational function.
<P>
3 Argument. NAME shall be default character scalar.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. If NAME has the value DEFAULT, then the result has a value equal to that of the kind type
<P>
<PRE>
  parameter of default character. If NAME has the value ASCII, then the result has a value equal to that of the
<P>
  kind type parameter of ASCII character if the processor supports such a kind; otherwise the result has the value
<P>
  −1. If NAME has the value ISO_10646, then the result has a value equal to that of the kind type parameter of
<P>
  the ISO 10646 character kind (corresponding to UCS-4 as specified in ISO/IEC 10646) if the processor supports
<P>
  such a kind; otherwise the result has the value −1. If NAME is a processor-defined name of some other character
<P>
  kind supported by the processor, then the result has a value equal to that kind type parameter value. If NAME is
<P>
  not the name of a supported character type, then the result has the value −1. The NAME is interpreted without
<P>
  respect to case or trailing blanks.
<P>
</PRE>
6 Examples. SELECTED_CHAR_KIND (’ASCII’) has the value 1 on a processor that uses 1 as the kind type
<P>
<PRE>
  parameter for the ASCII character set. The following subroutine produces a Japanese date stamp.
<P>
              SUBROUTINE create_date_string(string)
<P>
                INTRINSIC date_and_time,selected_char_kind
<P>
                INTEGER,PARAMETER :: ucs4 = selected_char_kind("ISO_10646")
<P>
  422                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
                CHARACTER(1,UCS4),PARAMETER :: nen=CHAR(INT(Z’5e74’),UCS4), & !year
<P>
                   gatsu=CHAR(INT(Z’6708’),UCS4), & !month
<P>
                   nichi=CHAR(INT(Z’65e5’),UCS4) !day
<P>
                CHARACTER(len= *, kind= ucs4) string
<P>
                INTEGER values(8)
<P>
                CALL date_and_time(values=values)
<P>
                WRITE(string,1) values(1),nen,values(2),gatsu,values(3),nichi
<P>
              1 FORMAT(I0,A,I0,A,I0,A)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
16.9.169 SELECTED_INT_KIND (R)
</BLOCKQUOTE>
<P>
1 Description. Integer kind selection.
<BLOCKQUOTE>
<P>
2 Class. Transformational function.
<P>
3 Argument. R shall be an integer scalar.
<P>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The result has a value equal to the value of the kind type parameter of an integer type that
<P>
<PRE>
  represents all values n in the range −10R &lt; n &lt; 10R , or if no such kind type parameter is available on the
<P>
  processor, the result is −1. If more than one kind type parameter meets the criterion, the value returned is the
<P>
  one with the smallest decimal exponent range, unless there are several such values, in which case the smallest of
<P>
  these kind values is returned.
<P>
</PRE>
6 Example. Assume a processor supports two integer kinds, 32 with representation method r = 2 and q = 31,
<P>
<PRE>
  and 64 with representation method r = 2 and q = 63. On this processor SELECTED_INT_KIND (9) has the
<P>
  value 32 and SELECTED_INT_KIND (10) has the value 64.
<P>
  16.9.170 SELECTED_REAL_KIND ([P, R, RADIX])
<P>
</PRE>
1 Description. Real kind selection.
<P>
2 Class. Transformational function.
<P>
3 Arguments. At least one argument shall be present.
<P>
<PRE>
  P (optional) shall be an integer scalar.
<P>
  R (optional) shall be an integer scalar.
<P>
  RADIX (optional) shall be an integer scalar.
<P>
</PRE>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. If P or R is absent, the result value is the same as if it were present with the value zero. If
<P>
<PRE>
  RADIX is absent, there is no requirement on the radix of the selected kind.
<P>
</PRE>
6 The result has a value equal to a value of the kind type parameter of a real type with decimal precision, as
<P>
<PRE>
  returned by the function PRECISION, of at least P digits, a decimal exponent range, as returned by the function
<P>
  RANGE, of at least R, and a radix, as returned by the function RADIX, of RADIX, if such a kind type parameter
<P>
  is available on the processor.
<P>
</PRE>
7 Otherwise, the result is −1 if the processor supports a real type with radix RADIX and exponent range of at least
<P>
<PRE>
  R but not with precision of at least P, −2 if the processor supports a real type with radix RADIX and precision of
<P>
  at least P but not with exponent range of at least R, −3 if the processor supports a real type with radix RADIX
<P>
  but with neither precision of at least P nor exponent range of at least R, −4 if the processor supports a real type
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          423
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  with radix RADIX and either precision of at least P or exponent range of at least R but not both together, and
<P>
  −5 if the processor supports no real type with radix RADIX.
<P>
</PRE>
8 If more than one kind type parameter value meets the criteria, the value returned is the one with the smallest
<P>
<PRE>
  decimal precision, unless there are several such values, in which case the smallest of these kind values is returned.
<P>
</PRE>
9 Example. SELECTED_REAL_KIND (6, 70) has the value KIND (0.0) on a machine that supports a default
<P>
<PRE>
  real approximation method with b = 16, p = 6, emin = −64, and emax = 63 and does not have a less precise
<P>
  approximation method.
<P>
  16.9.171 SET_EXPONENT (X, I)
<P>
</PRE>
1 Description. Real value with specified exponent.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be of type real.
<P>
  I             shall be of type integer.
<P>
</PRE>
4 Result Characteristics. Same as X.
<P>
5 Result Value. If X has the value zero, the result has the same value as X. If X is an IEEE infinity, the result is
<P>
<PRE>
  an IEEE NaN. If X is an IEEE NaN, the result is the same NaN. Otherwise, the result has the value X × bI−e ,
<P>
  where b and e are as defined in 16.4 for the representation for the value of X in the extended real model for the
<P>
  kind of X.
<P>
</PRE>
6 Example. SET_EXPONENT (3.0, 1) has the value 1.5 for reals whose model is as in NOTE 16.4.
<P>
<PRE>
  16.9.172 SHAPE (SOURCE [, KIND])
<P>
</PRE>
1 Description. Shape of an array or a scalar.
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  SOURCE        shall be a scalar or array of any type. It shall not be an unallocated allocatable variable or a pointer
<P>
                that is not associated. It shall not be an assumed-size array.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value
<P>
<PRE>
  of KIND; otherwise the kind type parameter is that of default integer type. The result is an array of rank one
<P>
  whose size is equal to the rank of SOURCE.
<P>
</PRE>
5 Result Value. The result has a value whose ith element is equal to the extent of dimension i of SOURCE,
<P>
<PRE>
  except that if SOURCE is assumed-rank, and associated with an assumed-size array, the last element is equal to
<P>
  −1.
<P>
</PRE>
6 Examples. The value of SHAPE (A (2:5, −1:1) ) is [4, 3]. The value of SHAPE (3) is the rank-one array of size
<P>
<PRE>
  zero.
<P>
  16.9.173 SHIFTA (I, SHIFT)
<P>
</PRE>
1 Description. Right shift with fill.
<P>
2 Class. Elemental function.
<P>
<PRE>
  424                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer.
<P>
  SHIFT         shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The result has the value obtained by shifting the bits of I to the right SHIFT bits and replicating
<P>
<PRE>
  the leftmost bit of I in the left SHIFT bits.
<P>
</PRE>
6 If SHIFT is zero the result is I. Bits shifted out from the right are lost. The model for the interpretation of an
<P>
<PRE>
  integer value as a sequence of bits is in 16.3.
<P>
</PRE>
7 Example. SHIFTA (IBSET (0, BIT_SIZE (0) − 1), 2) is equal to SHIFTL (7, BIT_SIZE (0) − 3).
<P>
<PRE>
  16.9.174 SHIFTL (I, SHIFT)
<P>
</PRE>
1 Description. Left shift.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer.
<P>
  SHIFT         shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The value of the result is ISHFT (I, SHIFT).
<P>
6 Examples. SHIFTL (3, 1) has the value 6.
<P>
<PRE>
  16.9.175 SHIFTR (I, SHIFT)
<P>
</PRE>
1 Description. Right shift.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  I             shall be of type integer.
<P>
  SHIFT         shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
<P>
</PRE>
4 Result Characteristics. Same as I.
<P>
5 Result Value. The value of the result is ISHFT (I, −SHIFT).
<P>
6 Examples. SHIFTR (3, 1) has the value 1.
<P>
<PRE>
  16.9.176 SIGN (A, B)
<P>
</PRE>
1 Description. Magnitude of A with the sign of B.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A             shall be of type integer or real.
<P>
  B             shall be of the same type as A.
<P>
</PRE>
4 Result Characteristics. Same as A.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        425
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case   (i):     If B &gt; 0, the value of the result is |A|.
<P>
  Case   (ii):    If B &lt; 0, the value of the result is -|A|.
<P>
  Case   (iii):   If B is of type integer and B=0, the value of the result is |A|.
<P>
  Case   (iv):    If B is of type real and is zero, then:
<P>
                     • if the processor does not distinguish between positive and negative real zero, or if B is positive
<P>
                        real zero, the value of the result is |A|;
<P>
                     • if the processor distinguishes between positive and negative real zero, and B is negative real
<P>
                        zero, the value of the result is -|A|.
<P>
</PRE>
6 Example. SIGN (−3.0, 2.0) has the value 3.0.
<P>
<PRE>
  16.9.177 SIN (X)
<P>
</PRE>
1 Description. Sine function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>sin</B>(X). If X is of type
<P>
<PRE>
  real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
<P>
</PRE>
6 Example. SIN (1.0) has the value 0.84147098 (approximately).
<P>
<PRE>
  16.9.178 SINH (X)
<P>
</PRE>
1 Description. Hyperbolic sine function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>sinh</B>(X). If X is of type
<P>
<PRE>
  complex its imaginary part is regarded as a value in radians.
<P>
</PRE>
6 Example. SINH (1.0) has the value 1.1752012 (approximately).
<P>
<PRE>
  16.9.179 SIZE (ARRAY [, DIM, KIND])
<P>
</PRE>
1 Description. Size of an array or one extent.
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY           shall be assumed-rank or an array. It shall not be an unallocated allocatable variable or a pointer
<P>
                  that is not associated. If ARRAY is an assumed-size array, DIM shall be present with a value less
<P>
                  than the rank of ARRAY.
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer scalar. If KIND is present, the kind type parameter is that specified by the
<P>
<PRE>
  value of KIND; otherwise the kind type parameter is that of default integer type.
<P>
  426                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value. If DIM is present, the result has a value equal to the extent of dimension DIM of ARRAY, except
<P>
<PRE>
  that if ARRAY is assumed-rank and associated with an assumed-size array and DIM is present with a value equal
<P>
  to the rank of ARRAY, the value is −1.
<P>
</PRE>
6 If DIM is absent and ARRAY is assumed-rank, the result has a value equal to <B>PRODUCT</B>(<B>SHAPE</B>(ARRAY,
<P>
<PRE>
  KIND)). Otherwise, the result has a value equal to the total number of elements of ARRAY.
<P>
</PRE>
7 Examples. The value of SIZE (A (2:5, −1:1), DIM=2) is 3. The value of SIZE (A (2:5, −1:1)) is 12.
<P>
<PRE>
        NOTE 16.30
<P>
        If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it cannot satisfy the requirement
<P>
        1 ≤ DIM ≤ 0.
<P>
</PRE>
16.9.180 SPACING (X)
<P>
1 Description. Spacing of model numbers.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. If X does not have the value zero and is not an IEEE infinity or NaN, the result has the value
<P>
<PRE>
  be−p , where b, e, and p are as defined in 16.4 for the value nearest to X in the model for real values whose kind
<P>
  type parameter is that of X, provided this result is representable; otherwise, the result is the same as that of
<P>
  TINY (X). If there are two extended model values equally near to X, the value of greater absolute value is taken.
<P>
  If X has the value zero, the result is the same as that of TINY (X). If X is an IEEE infinity, the result is an IEEE
<P>
  NaN. If X is an IEEE NaN, the result is that NaN.
<P>
</PRE>
6 Example. SPACING (3.0) has the value 2−22 for reals whose model is as in NOTE 16.4.
<P>
<PRE>
  16.9.181 SPREAD (SOURCE, DIM, NCOPIES)
<P>
</PRE>
1 Description. Value replicated in a new dimension.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  SOURCE        shall be a scalar or array of any type. The rank of SOURCE shall be less than 15.
<P>
  DIM           shall be an integer scalar with value in the range 1 ≤ DIM ≤ n + 1, where n is the rank of SOURCE.
<P>
  NCOPIES       shall be an integer scalar.
<P>
</PRE>
4 Result Characteristics. The result is an array of the same type and type parameters as SOURCE and of rank
<P>
<PRE>
  n + 1, where n is the rank of SOURCE.
<P>
  Case (i):     If SOURCE is scalar, the shape of the result is (MAX (NCOPIES, 0)).
<P>
  Case (ii):    If SOURCE is an array with shape [d1 , d2 , . . . , dn ], the shape of the result is [d1 , d2 , . . . , dDIM−1 ,
<P>
                MAX (NCOPIES, 0), dDIM , . . . , dn ].
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     If SOURCE is scalar, each element of the result has a value equal to SOURCE.
<P>
  Case (ii):    If SOURCE is an array, the element of the result with subscripts (r1 , r2 , . . . , rn+1 ) has the value
<P>
                SOURCE (r1 , r2 , . . . , rDIM−1 , rDIM+1 , . . . , rn+1 ).
<P>
                                                                                                                       
<P>
                                                                                                          2 3 4
<P>
</PRE>
6 Examples. If A is the array [2, 3, 4], SPREAD (A, DIM=1, NCOPIES=NC) is the array  2 3 4  if NC
<BLOCKQUOTE>
<P>
2 3 4
</BLOCKQUOTE>
<P>
has the value 3 and is a zero-sized array if NC has the value 0.
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: has the value 3 and is a zero-sized array if NC has the value 0.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
427
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
16.9.182 SQRT (X)
</BLOCKQUOTE>
<P>
1 Description. Square root.
<BLOCKQUOTE>
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex. If X is real, its value shall be greater than or equal to zero.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to the square root of X. A
<P>
<PRE>
  result of type complex is the principal value with the real part greater than or equal to zero. When the real part
<P>
  of the result is zero, the imaginary part has the same sign as the imaginary part of X.
<P>
</PRE>
6 Example. SQRT (4.0) has the value 2.0 (approximately).
<P>
<PRE>
  16.9.183 STOPPED_IMAGES ([TEAM, KIND])
<P>
</PRE>
1 Description. Indices of stopped images.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
<P>
                 whose value identifies the current or an ancestor team. If TEAM is absent the team specified is the
<P>
                 current team.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value
<P>
<PRE>
  of KIND; otherwise, the kind type parameter is that of default integer type. The result is an array of rank one
<P>
  whose size is equal to the number of images in the specified team that have initiated normal termination.
<P>
</PRE>
5 Result Value. The elements of the result are the values of the indices of the images that are known to have
<P>
<PRE>
  initiated normal termination in the specified team, in numerically increasing order. If the executing image has
<P>
  previously executed an image control statement whose STAT= specifier assigned the value STAT_STOPPED_-
<P>
  IMAGE from the intrinsic module ISO_FORTRAN_ENV or invoked a collective subroutine whose STAT argu-
<P>
  ment was assigned STAT_STOPPED_IMAGE, at least one of the images participating in that image control
<P>
  statement or collective invocation shall be known to have initiated normal termination.
<P>
</PRE>
6 Examples. If image 3 is the only image in the current team that is known to have initiated normal termination,
<P>
<PRE>
  STOPPED_IMAGES() will have the value [3]. If there are no images in the current team that have initiated
<P>
  normal termination, the value of STOPPED_IMAGES() will be a zero-sized array.
<P>
  16.9.184 STORAGE_SIZE (A [, KIND])
<P>
</PRE>
1 Description. Storage size in bits.
<P>
2 Class. Inquiry function.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be a data object of any type. If it is polymorphic it shall not be an undefined pointer. If
<P>
                 it is unlimited polymorphic or has any deferred type parameters, it shall not be an unallocated
<P>
                 allocatable variable or a disassociated or undefined pointer.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer scalar. If KIND is present, the kind type parameter is that specified by the
<P>
<PRE>
  value of KIND; otherwise, the kind type parameter is that of default integer type.
<P>
  428                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value. The result value is the size expressed in bits for an element of an array that has the dynamic
<P>
<PRE>
  type and type parameters of A. If the type and type parameters are such that storage association (19.5.3) applies,
<P>
  the result is consistent with the named constants defined in the intrinsic module ISO_FORTRAN_ENV.
<P>
         NOTE 16.31
<P>
         An array element might take more bits to store than an isolated scalar, since any hardware-imposed align-
<P>
         ment requirements for array elements might not apply to a simple scalar variable.
<P>
         NOTE 16.32
<P>
         This is intended to be the size in memory that an object takes when it is stored; this might differ from the
<P>
         size it takes during expression handling (which might be the native register size) or when stored in a file.
<P>
         If an object is never stored in memory but only in a register, this function nonetheless returns the size it
<P>
         would take if it were stored in memory.
<P>
</PRE>
6 Example. STORAGE_SIZE (1.0) has the same value as the named constant NUMERIC_STORAGE_SIZE in
<P>
<PRE>
  the intrinsic module ISO_FORTRAN_ENV.
<P>
  16.9.185 SUM (ARRAY, DIM [, MASK]) or SUM (ARRAY [, MASK])
<P>
</PRE>
1 Description. Array reduced by addition.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  ARRAY               shall be an array of numeric type.
<P>
  DIM                 shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
  MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
<P>
<PRE>
  DIM does not appear; otherwise, the result has rank n − 1 and shape [d1 , d2 , . . . , dDIM−1 , dDIM+1 , . . . , dn ] where
<P>
  [d1 , d2 , . . . , dn ] is the shape of ARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):           The result of SUM (ARRAY) has a value equal to a processor-dependent approximation to the sum
<P>
                      of all the elements of ARRAY or has the value zero if ARRAY has size zero.
<P>
  Case (ii):          The result of SUM (ARRAY, MASK = MASK) has a value equal to a processor-dependent approx-
<P>
                      imation to the sum of the elements of ARRAY corresponding to the true elements of MASK or has
<P>
                      the value zero if there are no true elements.
<P>
  Case (iii):         If ARRAY has rank one, SUM (ARRAY, DIM = DIM [, MASK = MASK]) has a value equal to that
<P>
                      of SUM (ARRAY [,MASK = MASK ]). Otherwise, the value of element (s1 , s2 , . . . , sDIM−1 , sDIM+1 ,
<P>
                      . . . , sn ) of SUM (ARRAY, DIM = DIM [ , MASK = MASK]) is equal to
<P>
                                SUM (ARRAY (s1 , s2 , . . . , sDIM−1 , :, sDIM+1 , . . . , sn ) [, MASK= MASK (s1 , s2 , . . . , sDIM−1 ,
<P>
                                :, sDIM+1 , . . . , sn ) ] ).
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):           The value of SUM ([1, 2, 3]) is 6.
<P>
  Case (ii):          SUM (C, MASK= C &gt; 0.0) forms the sum of the positive elements of C.
<P>
                                                             
<P>
                                                 1 3 5
<P>
  Case (iii):         If B is the array                        , SUM (B, DIM = 1) is [3, 7, 11] and SUM (B, DIM = 2) is [9, 12].
<P>
                                                 2 4 6
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                             429
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.186 SYSTEM_CLOCK ([COUNT, COUNT_RATE, COUNT_MAX])
<P>
</PRE>
1 Description. Query system clock.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  COUNT (optional) shall be an integer scalar. It is an INTENT (OUT) argument. It is assigned a processor-
<P>
                  dependent value based on the value of a processor clock, or −HUGE (COUNT) if there is no clock
<P>
                  for the invoking image. The processor-dependent value is incremented by one for each clock count
<P>
                  until the value COUNT_MAX is reached and is reset to zero at the next count. It lies in the range
<P>
                  0 to COUNT_MAX if there is a clock.
<P>
  COUNT_RATE (optional) shall be an integer or real scalar. It is an INTENT (OUT) argument. It is assigned
<P>
                  a processor-dependent approximation to the number of processor clock counts per second, or zero
<P>
                  if there is no clock for the invoking image.
<P>
  COUNT_MAX (optional) shall be an integer scalar. It is an INTENT (OUT) argument. It is assigned the
<P>
                  maximum value that COUNT can have, or zero if there is no clock for the invoking image.
<P>
</PRE>
4 Whether an image has no clock, has a single clock of its own, or shares a clock with another image, is processor
<P>
<PRE>
  dependent.
<P>
</PRE>
5 Example. If the processor clock is a 24-hour clock that registers time at approximately 18.20648193 ticks per
<P>
<PRE>
  second, at 11:30 A.M. the reference
<P>
       CALL SYSTEM_CLOCK (COUNT = C, COUNT_RATE = R, COUNT_MAX = M)
<P>
  defines C = (11×3600+30×60)×18.20648193 = 753748, R = 18.20648193, and M = 24×3600×18.20648193−1 =
<P>
  1573039.
<P>
  16.9.187 TAN (X)
<P>
</PRE>
1 Description. Tangent function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>tan</B>(X). If X is of type
<P>
<PRE>
  real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
<P>
</PRE>
6 Example. TAN (1.0) has the value 1.5574077 (approximately).
<P>
<PRE>
  16.9.188 TANH (X)
<P>
</PRE>
1 Description. Hyperbolic tangent function.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real or complex.
<P>
4 Result Characteristics. Same as X.
<P>
5 Result Value. The result has a value equal to a processor-dependent approximation to <B>tanh</B>(X). If X is of type
<P>
<PRE>
  complex its imaginary part is regarded as a value in radians.
<P>
</PRE>
6 Example. TANH (1.0) has the value 0.76159416 (approximately).
<P>
<PRE>
  430                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.9.189 TEAM_NUMBER ([TEAM])
<P>
</PRE>
1 Description. Team number.
<P>
2 Class. Transformational function.
<P>
3 Argument. TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FOR-
<P>
<PRE>
  TRAN_ENV, whose value identifies the current or an ancestor team. If TEAM is absent, the team specified is
<P>
  the current team.
<P>
</PRE>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. The result has the value −1 if the specified team is the initial team; otherwise, the result value
<P>
<PRE>
  is equal to the positive integer that identifies the specified team within its parent team.
<P>
</PRE>
6 Example. The team number can be used to control which statements get executed, for example:
<P>
<PRE>
           TYPE(TEAM_TYPE) :: ODD_EVEN
<P>
           &#46;&#46;&#46;
<P>
           FORM TEAM (2-MOD(ME,2), ODD_EVEN)
<P>
           &#46;&#46;&#46;
<P>
           CHANGE TEAM (ODD_EVEN)
<P>
              SELECT CASE (TEAM_NUMBER())
<P>
              CASE (1)
<P>
                ! Case for images with odd image indices in the parent team.
<P>
              CASE (2)
<P>
                ! Case for images with even image indices in the parent team.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TEAM</H4>
</A>
<BLOCKQUOTE>
<P>
16.9.190 THIS_IMAGE ([TEAM]) or THIS_IMAGE (COARRAY [, TEAM]) or
<P>
<PRE>
                THIS_IMAGE (COARRAY, DIM [, TEAM])
<P>
</PRE>
1 Description. <B>Cosubscript</B>(s) for this image.
</BLOCKQUOTE>
<P>
2 Class. Transformational function.
<BLOCKQUOTE>
<P>
3 Arguments.
<P>
<PRE>
  COARRAY shall be a coarray of any type. If it is allocatable it shall be allocated. If its designator has more
<P>
                than one part-ref , the rightmost part-ref shall have nonzero corank. If it is of type TEAM_TYPE
<P>
                from the intrinsic module ISO_FORTRAN_ENV, the TEAM argument shall appear.
<P>
  DIM           shall be an integer scalar. Its value shall be in the range 1 ≤ DIM ≤ n, where n is the corank of
<P>
                COARRAY.
<P>
  TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
<P>
                whose value identifies the current or an ancestor team. If COARRAY appears, it shall be established
<P>
                in that team.
<P>
</PRE>
4 Result Characteristics. Default integer. It is scalar if COARRAY does not appear or DIM appears; otherwise,
<P>
<PRE>
  the result has rank one and its size is equal to the corank of COARRAY.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):     The result of THIS_IMAGE ([TEAM]) is a scalar with a value equal to the index of the invoking
<P>
                image in the team specified by TEAM, if present, or in the current team if absent.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        431
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  Case (ii):    The result of THIS_IMAGE (COARRAY [, TEAM = TEAM]) is the sequence of cosubscript values
<P>
                for COARRAY that would specify the invoking image in the team specified by TEAM, if present,
<P>
                or in the current team if absent.
<P>
  Case (iii):   The result of THIS_IMAGE (COARRAY, DIM [, TEAM = TEAM]) is the value of cosubscript
<P>
                DIM in the sequence of cosubscript values for COARRAY that would specify the invoking image in
<P>
                the team specified by TEAM, if present, or in the current team if absent.
<P>
</PRE>
6 Examples. If A is declared by the statement
<P>
<PRE>
       REAL A (10, 20) [10, 0:9, 0:*]
<P>
</PRE>
then on image 5, THIS_IMAGE ( ) has the value 5 and THIS_IMAGE (A) has the value [5, 0, 0]. For the same
<BLOCKQUOTE>
<P>
coarray on image 213, THIS_IMAGE (A) has the value [3, 1, 2].
</BLOCKQUOTE>
<P>
7 The following code uses image 1 to read data. The other images then copy the data.
<P>
<PRE>
      IF (THIS_IMAGE()==1) READ (*,*) P
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC ALL</H4>
</A>
<BLOCKQUOTE>
<P>
P = P[1]
</BLOCKQUOTE>
<P>
16.9.191 TINY (X)
<BLOCKQUOTE>
<P>
1 Description. Smallest positive model number.
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be a real scalar or array.
<P>
4 Result Characteristics. Scalar with the same type and kind type parameter as X.
<P>
5 Result Value. The result has the value bemin −1 where b and emin are as defined in 16.4 for the model representing
<P>
<PRE>
  numbers of the same type and kind type parameter as X.
<P>
</PRE>
6 Example. TINY (X) has the value 2−127 for real X whose model is as in NOTE 16.4.
<P>
<PRE>
  16.9.192 TRAILZ (I)
<P>
</PRE>
1 Description. Number of trailing zero bits.
<P>
2 Class. Elemental function.
<P>
3 Argument. I shall be of type integer.
<P>
4 Result Characteristics. Default integer.
<P>
5 Result Value. If all of the bits of I are zero, the result value is BIT_SIZE (I). Otherwise, the result value is the
<P>
<PRE>
  position of the rightmost 1 bit in I. The model for the interpretation of an integer value as a sequence of bits is
<P>
  in 16.3.
<P>
</PRE>
6 Examples. TRAILZ (8) has the value 3.
<P>
<PRE>
  16.9.193 TRANSFER (SOURCE, MOLD [, SIZE])
<P>
</PRE>
1 Description. Transfer physical representation.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  SOURCE        shall be a scalar or array of any type.
<P>
  432                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
  MOLD           shall be a scalar or array of any type. If it is a variable, it need not be defined. If the storage size of
<P>
                 SOURCE is greater than zero and MOLD is an array, a scalar with the type and type parameters
<P>
                 of MOLD shall not have a storage size equal to zero.
<P>
  SIZE (optional) shall be an integer scalar. The corresponding actual argument shall not be an optional dummy
<P>
                 argument.
<P>
</PRE>
4 Result Characteristics. The result is of the same type and type parameters as MOLD.
<P>
<PRE>
  Case (i):      If MOLD is a scalar and SIZE is absent, the result is a scalar.
<P>
  Case (ii):     If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small
<P>
                 as possible such that its physical representation is not shorter than that of SOURCE.
<P>
  Case (iii):    If SIZE is present, the result is an array of rank one and size SIZE.
<P>
</PRE>
5 Result Value. If the physical representation of the result has the same length as that of SOURCE, the physical
<P>
<PRE>
  representation of the result is that of SOURCE. If the physical representation of the result is longer than that
<P>
  of SOURCE, the physical representation of the leading part is that of SOURCE and the remainder is processor
<P>
  dependent. If the physical representation of the result is shorter than that of SOURCE, the physical representation
<P>
  of the result is the leading part of SOURCE. If D and E are scalar variables such that the physical representation
<P>
  of D is as long as or longer than that of E, the value of TRANSFER (TRANSFER (E, D), E) shall be the value
<P>
  of E. IF D is an array and E is an array of rank one, the value of TRANSFER (TRANSFER (E, D), E, SIZE (E))
<P>
  shall be the value of E.
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):      TRANSFER (1082130432, 0.0) has the value 4.0 on a processor that represents the values 4.0 and
<P>
                 1082130432 as the string of binary digits 0100 0000 1000 0000 0000 0000 0000 0000.
<P>
  Case (ii):     TRANSFER ([1.1, 2.2, 3.3], [(0.0, 0.0)])) is a complex rank-one array of length two whose first
<P>
                 element has the value (1.1, 2.2) and whose second element has a real part with the value 3.3. The
<P>
                 imaginary part of the second element is processor dependent.
<P>
  Case (iii):    TRANSFER ([1.1, 2.2, 3.3], [(0.0, 0.0)], 1) is a complex rank-one array of length one whose only
<P>
                 element has the value (1.1, 2.2).
<P>
  16.9.194 TRANSPOSE (MATRIX)
<P>
</PRE>
1 Description. Transpose of an array of rank two.
<P>
2 Class. Transformational function.
<P>
3 Argument. MATRIX shall be a rank-two array of any type.
<P>
4 Result Characteristics. The result is an array of the same type and type parameters as MATRIX and with
<P>
<PRE>
  rank two and shape [n, m] where [m, n] is the shape of MATRIX.
<P>
</PRE>
5 Result Value. Element (i, j) of the result has the value MATRIX (j + LBOUND (MATRIX, 1) − 1, i +
<P>
<PRE>
  LBOUND (MATRIX, 2) − 1).
<P>
                                                                                                     
<P>
                                    1   2  3                                                  1   4  7
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>6 Example. If A is the array  4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
5  6 , then TRANSPOSE (A) has the value  2              5  8 .
<TABLE width=100% cellpadding=3><!-- tsb: 5  6 , then TRANSPOSE (A) has the value  2              5  8 .
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>7</B> </TD><TD valign=bottom>
8  9                                                  3   6  9
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
16.9.195 TRIM (STRING)
</TD></TR>
<TR><TD colspan=2>
1 Description. String without trailing blanks.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. STRING shall be a character scalar.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                433
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Character with the same kind type parameter value as STRING and with a length
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that is the length of STRING less the number of trailing blanks in STRING. If STRING contains no nonblank
<P>
  characters, the result has zero length.
<P>
</PRE>
5 Result Value. The value of the result is the same as STRING except any trailing blanks are removed.
</TD></TR>
<TR><TD colspan=2>
6 Example. TRIM (’ A B ’) has the value ’ A B’.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  16.9.196 UBOUND (ARRAY [, DIM, KIND])
<P>
</PRE>
1 Description. Upper <B>bound</B>(s).
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ARRAY         shall be assumed-rank or an array. It shall not be an unallocated allocatable array or a pointer that
<P>
                is not associated. If ARRAY is an assumed-size array, DIM shall be present with a value less than
<P>
                the rank of ARRAY.
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
<P>
                The corresponding actual argument shall not be an optional dummy argument, a disassociated
<P>
                pointer, or an unallocated allocatable.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is present;
<P>
  otherwise, the result is an array of rank one and size n, where n is the rank of ARRAY.
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     If DIM is present, ARRAY is a whole array, and dimension DIM of ARRAY has nonzero extent,
<P>
                the result has a value equal to the upper bound for subscript DIM of ARRAY. Otherwise, if DIM
<P>
                is present and ARRAY is assumed-rank, the value of the result is as if ARRAY were a whole array,
<P>
                with the extent of the final dimension of ARRAY when ARRAY is associated with an assumed-size
<P>
                array being considered to be −1. Otherwise, if DIM is present, the result has a value equal to the
<P>
                number of elements in dimension DIM of ARRAY.
<P>
  Case (ii):    If ARRAY has rank zero, UBOUND (ARRAY) has a value that is a zero-sized array. Otherwise,
<P>
                UBOUND (ARRAY) has a value whose ith element is equal to UBOUND (ARRAY, i), for i = 1, 2,
<P>
                . . . , n, where n is the rank of ARRAY. UBOUND (ARRAY, KIND=KIND) has a value whose ith
<P>
                element is equal to UBOUND (ARRAY, i, KIND=KIND), for i = 1, 2, . . . , n, where n is the
<P>
                rank of ARRAY.
<P>
</PRE>
6 Examples. If A is declared by the statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
      REAL A (2:3, 7:10)
<P>
</PRE>
then UBOUND (A) is [3, 10] and UBOUND (A, DIM = 2) is 10.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 16.33
<P>
       If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it cannot satisfy the requirement
<P>
       1 ≤ DIM ≤ 0.
<P>
</PRE>
16.9.197 UCOBOUND (COARRAY [, DIM, KIND])
</TD></TR>
<TR><TD colspan=2>
1 Description. Upper <B>cobound</B>(s) of a coarray.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  434                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  COARRAY shall be a coarray of any type. It may be a scalar or an array. If it is allocatable it shall be allocated.
<P>
                If its designator has more than one part-ref , the rightmost part-ref shall have nonzero corank.
<P>
  DIM (optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the corank
<P>
                of COARRAY. The corresponding actual argument shall not be an optional dummy argument, a
<P>
                disassociated pointer, or an unallocated allocatable.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer type. The result is scalar if DIM is present;
<P>
  otherwise, the result is an array of rank one and size n, where n is the corank of COARRAY.
<P>
</PRE>
5 Result Value. The final upper cobound is the final cosubscript in the cosubscript list for the coarray that selects
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the image whose index is equal to the number of images in the team current when COARRAY was established.
<P>
  Case (i):     If DIM is present, the result has a value equal to the upper cobound for codimension DIM of
<P>
                COARRAY.
<P>
  Case (ii):    If DIM is absent, the result has a value whose ith element is equal to the upper cobound for
<P>
                codimension i of COARRAY, for i = 1, 2,. . . , n, where n is the corank of COARRAY.
<P>
</PRE>
6 Examples. If <B>NUM_IMAGES</B>( ) has the value 30 and A is allocated by the statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
      ALLOCATE (A [2:3, 0:7, *])
<P>
</PRE>
then UCOBOUND (A) is [3, 7, 2] and UCOBOUND (A, DIM=2) is 7. Note that the cosubscripts [3, 7, 2] do
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
not correspond to an actual image.
<P>
16.9.198 UNPACK (VECTOR, MASK, FIELD)
</TD></TR>
<TR><TD colspan=2>
1 Description. Vector unpacked into an array.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  VECTOR        shall be a rank-one array of any type. Its size shall be at least t where t is the number of true
<P>
                elements in MASK.
<P>
  MASK          shall be a logical array.
<P>
  FIELD         shall be of the same type and type parameters as VECTOR and shall be conformable with MASK.
<P>
</PRE>
4 Result Characteristics. The result is an array of the same type and type parameters as VECTOR and the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  same shape as MASK.
<P>
</PRE>
5 Result Value. The element of the result that corresponds to the ith true element of MASK, in array element
</TD></TR>
<TR><TD colspan=2>
<PRE>
  order, has the value VECTOR (i) for i = 1, 2, . . . , t, where t is the number of true values in MASK. Each other
<P>
  element has a value equal to FIELD if FIELD is scalar or to the corresponding element of FIELD if it is an array.
<P>
</PRE>
6 Examples.
</TD></TR>
<TR><TD colspan=2>
<PRE>
              Particular
<P>
                          values can be “scattered” to particular positionsin an array by
<P>
                                                                                           using UNPACK. If M is the
<P>
           1  0    0                                                            . T     .
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>array  0</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
1    0 , V is the array [1, 2, 3], and Q is the logical mask  T .       . , where “T” represents true
<TABLE width=100% cellpadding=3><!-- tsb: 1    0 , V is the array [1, 2, 3], and Q is the logical mask  T .       . , where “T” represents true
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>0</B> </TD><TD valign=bottom>
0    1                                                            . .    T
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                                                                                    
<P>
                                                                                                           1 2    0
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>and “.” represents false, then the result of UNPACK (V, MASK = Q, FIELD = M) has the value  1 1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
0 
<TABLE width=100% cellpadding=3><!-- tsb: 0 
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>0 0</B> </TD><TD valign=bottom>
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<P>
0 2 0
</TD></TR>
<TR><TD colspan=2>
and the result of UNPACK (V, MASK = Q, FIELD = 0) has the value  1 0 0 .
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
0 0 3
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
435
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
16.9.199 VERIFY (STRING, SET [, BACK, KIND])
</BLOCKQUOTE>
<P>
1 Description. Character set non-membership search.
<BLOCKQUOTE>
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  STRING         shall be of type character.
<P>
  SET            shall be of type character with the same kind type parameter as STRING.
<P>
  BACK (optional) shall be of type logical.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise the kind type parameter is that of default integer type.
<P>
</PRE>
5 Result Value.
<P>
<PRE>
  Case (i):      If BACK is absent or has the value false and if STRING contains at least one character that is not
<P>
                 in SET, the value of the result is the position of the leftmost character of STRING that is not in
<P>
                 SET.
<P>
  Case (ii):     If BACK is present with the value true and if STRING contains at least one character that is not
<P>
                 in SET, the value of the result is the position of the rightmost character of STRING that is not in
<P>
                 SET.
<P>
  Case (iii):    The value of the result is zero if each character in STRING is in SET or if STRING has zero length.
<P>
</PRE>
6 Examples.
<P>
<PRE>
  Case (i):      VERIFY (’ABBA’, ’A’) has the value 2.
<P>
  Case (ii):     VERIFY (’ABBA’, ’A’, BACK = .TRUE.) has the value 3.
<P>
  Case (iii):    VERIFY (’ABBA’, ’AB’) has the value 0.
<P>
  16.10        Standard intrinsic modules
<P>
  16.10.1      General
<P>
</PRE>
1 This document defines five standard intrinsic modules: a Fortran environment module, a set of three modules
<P>
<PRE>
  to support floating-point exceptions and IEEE arithmetic, and a module to support interoperability with the C
<P>
  programming language.
<P>
</PRE>
2 The intrinsic modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES are described in
<P>
<PRE>
  Clause 17. The intrinsic module ISO_C_BINDING is described in Clause 18. The module procedures described
<P>
  in 16.10.2 are pure.
<P>
       NOTE 16.34
<P>
       The types and procedures defined in standard intrinsic modules are not themselves intrinsic.
<P>
</PRE>
3 A processor may extend the standard intrinsic modules to provide public entities in them in addition to those
<P>
<PRE>
  specified in this document.
<P>
  16.10.2      The ISO_FORTRAN_ENV intrinsic module
<P>
  16.10.2.1    General
<P>
</PRE>
1 The intrinsic module ISO_FORTRAN_ENV provides public entities relating to the Fortran environment.
<P>
<PRE>
  436                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The processor shall provide the named constants, derived types, and procedures described in subclause 16.10.2.
<P>
<PRE>
  In the detailed descriptions below, procedure names are generic and not specific.
<P>
  16.10.2.2    ATOMIC_INT_KIND
<P>
</PRE>
1 The value of the default integer scalar constant ATOMIC_INT_KIND is the kind type parameter value of type
<P>
<PRE>
  integer variables for which the processor supports atomic operations specified by atomic subroutines.
<P>
  16.10.2.3    ATOMIC_LOGICAL_KIND
<P>
</PRE>
1 The value of the default integer scalar constant ATOMIC_LOGICAL_KIND is the kind type parameter value
<P>
<PRE>
  of type logical variables for which the processor supports atomic operations specified by atomic subroutines.
<P>
  16.10.2.4    CHARACTER_KINDS
<P>
</PRE>
1 The values of the elements of the default integer array constant CHARACTER_KINDS are the kind values
<P>
<PRE>
  supported by the processor for variables of type character. The order of the values is processor dependent. The
<P>
  rank of the array is one, its lower bound is one, and its size is the number of character kinds supported.
<P>
  16.10.2.5    CHARACTER_STORAGE_SIZE
<P>
</PRE>
1 The value of the default integer scalar constant CHARACTER_STORAGE_SIZE is the size expressed in bits
<P>
<PRE>
  of the character storage unit (19.5.3.2).
<P>
  16.10.2.6    COMPILER_OPTIONS ( )
<P>
</PRE>
1 Description. Processor-dependent string describing the options that controlled the program translation phase.
<P>
2 Class. Transformational function.
<P>
3 Argument. None.
<P>
4 Result Characteristics. Default character scalar with processor-dependent length.
<P>
5 Result Value. A processor-dependent value which describes the options that controlled the translation phase of
<P>
<PRE>
  program execution. This value should include relevant information that could be useful for diagnosing problems
<P>
  at a later date.
<P>
</PRE>
6 Example. COMPILER_OPTIONS ( ) might have the value ’/OPTIMIZE /FLOAT=IEEE’.
<P>
<PRE>
  16.10.2.7    COMPILER_VERSION ( )
<P>
</PRE>
1 Description. Processor-dependent string identifying the program translation phase.
<P>
2 Class. Transformational function.
<P>
3 Argument. None.
<P>
4 Result Characteristics. Default character scalar with processor-dependent length.
<P>
5 Result Value. A processor-dependent value that identifies the name and version of the program translation
<P>
<PRE>
  phase of the processor. This value should include relevant information that could be useful for diagnosing problems
<P>
  at a later date.
<P>
</PRE>
6 Example. COMPILER_VERSION ( ) might have the value ’Fast KL-10 Compiler Version 7’.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          437
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 16.35
<P>
       Relevant information that could be useful for diagnosing problems at a later date might include compiler
<P>
       release and patch level, default compiler arguments, environment variable values, and run time library
<P>
       requirements. A processor might include this information in an object file automatically, without the user
<P>
       needing to save the result of this function in a variable.
<P>
  16.10.2.8    CURRENT_TEAM
<P>
</PRE>
1 The value of the default integer scalar constant CURRENT_TEAM identifies the current team when it is used
<P>
<PRE>
  as the LEVEL argument to GET_TEAM.
<P>
  16.10.2.9    ERROR_UNIT
<P>
</PRE>
1 The value of the default integer scalar constant ERROR_UNIT identifies the processor-dependent preconnected
<P>
<PRE>
  external unit used for the purpose of error reporting (12.5). This unit may be the same as OUTPUT_UNIT.
<P>
  The value shall not be −1.
<P>
  16.10.2.10     EVENT_TYPE
<P>
</PRE>
1 EVENT_TYPE is a derived type with private components. It is an extensible type with no type parameters.
<P>
<PRE>
  Each nonallocatable component is fully default-initialized.
<P>
</PRE>
2 A scalar variable of type EVENT_TYPE is an event variable. The value of an event variable includes its event
<P>
<PRE>
  count, which is updated by execution of a sequence of EVENT POST or EVENT WAIT statements. The effect
<P>
  of each change is as if the intrinsic subroutine ATOMIC_ADD were executed with a variable that stores the
<P>
  event count as its ATOM argument. A coarray that is of type EVENT_TYPE may be referenced or defined
<P>
  during execution of a segment that is unordered relative to the execution of another segment in which that
<P>
  coarray is defined. The event count is of type integer with kind ATOMIC_INT_KIND from the intrinsic module
<P>
  ISO_FORTRAN_ENV. The initial value of the event count of an event variable is zero.
<P>
  C1603 A named entity with declared type EVENT_TYPE, or which has a noncoarray potential subobject
<P>
           component with declared type EVENT_TYPE, shall be a variable. A component that is of such a type
<P>
           shall be a data component.
<P>
  C1604 A named variable with declared type EVENT_TYPE shall be a coarray. A named variable with a
<P>
           noncoarray potential subobject component of type EVENT_TYPE shall be a coarray.
<P>
  C1605 An event variable shall not appear in a variable definition context except as the event-variable in an
<P>
           EVENT POST or EVENT WAIT statement, as an allocate-object, or as an actual argument in a reference
<P>
           to a procedure with an explicit interface if the corresponding dummy argument has INTENT (INOUT).
<P>
  C1606 A variable with a nonpointer subobject of type EVENT_TYPE shall not appear in a variable definition
<P>
           context except as an allocate-object in an ALLOCATE statement without a SOURCE= specifier, as an
<P>
           allocate-object in a DEALLOCATE statement, or as an actual argument in a reference to a procedure
<P>
           with an explicit interface if the corresponding dummy argument has INTENT (INOUT).
<P>
       NOTE 16.36
<P>
       The restrictions against changing an event variable except via EVENT POST and EVENT WAIT state-
<P>
       ments ensure the integrity of its value and facilitate efficient implementation, particularly when special
<P>
       synchronization is needed for correct event handling.
<P>
       NOTE 16.37
<P>
       Updates to variables via atomic subroutines are coherent but not necessarily consistent, so a processor
<P>
       might have to use extra synchronization to obtain the consistency required for the segments ordered by
<P>
       EVENT POST and EVENT WAIT statements.
<P>
  438                                                                ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.10.2.11     FILE_STORAGE_SIZE
<P>
</PRE>
1 The value of the default integer scalar constant FILE_STORAGE_SIZE is the size expressed in bits of the file
<P>
<PRE>
  storage unit (12.3.5).
<P>
  16.10.2.12     INITIAL_TEAM
<P>
</PRE>
1 The value of the default integer scalar constant INITIAL_TEAM identifies the initial team when it is used as
<P>
<PRE>
  the LEVEL argument to GET_TEAM.
<P>
  16.10.2.13     INPUT_UNIT
<P>
</PRE>
1 The value of the default integer scalar constant INPUT_UNIT identifies the same processor-dependent external
<P>
<PRE>
  unit preconnected for sequential formatted input as the one identified by an asterisk in a READ statement; this
<P>
  unit is the one used for a READ statement that does not contain an input/output control list (12.6.4.3). The
<P>
  value shall not be −1.
<P>
  16.10.2.14     INT8, INT16, INT32, and INT64
<P>
</PRE>
1 The values of these default integer scalar constants shall be those of the kind type parameters that specify an
<P>
<PRE>
  INTEGER type whose storage size expressed in bits is 8, 16, 32, and 64 respectively. If, for any of these constants,
<P>
  the processor supports more than one kind of that size, it is processor dependent which kind value is provided. If
<P>
  the processor supports no kind of a particular size, that constant shall be equal to −2 if the processor supports
<P>
  a kind with larger size and −1 otherwise.
<P>
  16.10.2.15     INTEGER_KINDS
<P>
</PRE>
1 The values of the elements of the default integer array constant INTEGER_KINDS are the kind values supported
<P>
<PRE>
  by the processor for variables of type integer. The order of the values is processor dependent. The rank of the
<P>
  array is one, its lower bound is one, and its size is the number of integer kinds supported.
<P>
  16.10.2.16     IOSTAT_END
<P>
</PRE>
1 The value of the default integer scalar constant IOSTAT_END is assigned to the variable specified in an IOSTAT=
<P>
<PRE>
  specifier (12.11.5) if an end-of-file condition occurs during execution of an input statement and no error condition
<P>
  occurs. This value shall be negative.
<P>
  16.10.2.17     IOSTAT_EOR
<P>
</PRE>
1 The value of the default integer scalar constant IOSTAT_EOR is assigned to the variable specified in an IOSTAT=
<P>
<PRE>
  specifier (12.11.5) if an end-of-record condition occurs during execution of an input statement and no end-of-file
<P>
  or error condition occurs. This value shall be negative and different from the value of IOSTAT_END.
<P>
  16.10.2.18     IOSTAT_INQUIRE_INTERNAL_UNIT
<P>
</PRE>
1 The value of the default integer scalar constant IOSTAT_INQUIRE_INTERNAL_UNIT is assigned to the
<P>
<PRE>
  variable specified in an IOSTAT= specifier in an INQUIRE statement (12.10) if a file-unit-number identifies an
<P>
  internal unit in that statement.
<P>
       NOTE 16.38
<P>
       This can only occur when a defined input/output procedure is called by the processor as the result of
<P>
       executing a parent data transfer statement (12.6.4.8.3) for an internal unit.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          439
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.10.2.19     LOCK_TYPE
<P>
</PRE>
1 LOCK_TYPE is a derived type with private components; no component is allocatable or a pointer. It is an
<P>
<PRE>
  extensible type with no type parameters. All components have default initialization.
<P>
</PRE>
2 A scalar variable of type LOCK_TYPE is a lock variable. A lock variable can have one of two states: locked and
<P>
<PRE>
  unlocked. The unlocked state is represented by the one value that is the default value of a LOCK_TYPE variable;
<P>
  this is the value specified by the structure constructor LOCK_TYPE ( ). The locked state is represented by all
<P>
  other values. The value of a lock variable can be changed with the LOCK and UNLOCK statements (11.6.10).
<P>
  C1607 A named entity with declared type LOCK_TYPE, or which has a noncoarray potential subobject com-
<P>
            ponent with declared type LOCK_TYPE, shall be a variable. A component that is of such a type shall
<P>
            be a data component.
<P>
  C1608 A named variable with declared type LOCK_TYPE shall be a coarray. A named variable with a
<P>
            noncoarray potential subobject component of type LOCK_TYPE shall be a coarray.
<P>
  C1609 A lock variable shall not appear in a variable definition context except as the lock-variable in a LOCK or
<P>
            UNLOCK statement, as an allocate-object, or as an actual argument in a reference to a procedure with
<P>
            an explicit interface where the corresponding dummy argument has INTENT (INOUT).
<P>
  C1610 A variable with a subobject of type LOCK_TYPE shall not appear in a variable definition context except
<P>
            as an allocate-object or as an actual argument in a reference to a procedure with an explicit interface
<P>
            where the corresponding dummy argument has INTENT (INOUT).
<P>
        NOTE 16.39
<P>
        The restrictions against changing a lock variable except via the LOCK and UNLOCK statements ensure
<P>
        the integrity of its value and facilitate efficient implementation, particularly when special synchronization
<P>
        is needed for correct lock operation.
<P>
  16.10.2.20     LOGICAL_KINDS
<P>
</PRE>
1 The values of the elements of the default integer array constant LOGICAL_KINDS are the kind values supported
<P>
<PRE>
  by the processor for variables of type logical. The order of the values is processor dependent. The rank of the
<P>
  array is one, its lower bound is one, and its size is the number of logical kinds supported.
<P>
  16.10.2.21     NUMERIC_STORAGE_SIZE
<P>
</PRE>
1 The value of the default integer scalar constant NUMERIC_STORAGE_SIZE is the size expressed in bits of the
<P>
<PRE>
  numeric storage unit (19.5.3.2).
<P>
  16.10.2.22     OUTPUT_UNIT
<P>
</PRE>
1 The value of the default integer scalar constant OUTPUT_UNIT identifies the same processor-dependent external
<P>
<PRE>
  unit preconnected for sequential formatted output as the one identified by an asterisk in a WRITE statement
<P>
  (12.6.4.3). The value shall not be −1.
<P>
  16.10.2.23     PARENT_TEAM
<P>
</PRE>
1 The value of the default integer scalar constant PARENT_TEAM identifies the parent team when it is used as
<P>
<PRE>
  the LEVEL argument to GET_TEAM.
<P>
  16.10.2.24     REAL_KINDS
<P>
</PRE>
1 The values of the elements of the default integer array constant REAL_KINDS are the kind values supported by
<P>
<PRE>
  the processor for variables of type real. The order of the values is processor dependent. The rank of the array is
<P>
  one, its lower bound is one, and its size is the number of real kinds supported.
<P>
  440                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.10.2.25     REAL32, REAL64, and REAL128
<P>
</PRE>
1 The values of these default integer scalar named constants shall be those of the kind type parameters that specify
<P>
<PRE>
  a REAL type whose storage size expressed in bits is 32, 64, and 128 respectively. If, for any of these constants,
<P>
  the processor supports more than one kind of that size, it is processor dependent which kind value is provided. If
<P>
  the processor supports no kind of a particular size, that constant shall be equal to −2 if the processor supports
<P>
  kinds of a larger size and −1 otherwise.
<P>
  16.10.2.26     STAT_FAILED_IMAGE
<P>
</PRE>
1 If the processor has the ability to detect that an image has failed, the value of the default integer scalar constant
<P>
<PRE>
  STAT_FAILED_IMAGE is positive; otherwise, the value of STAT_FAILED_IMAGE is negative. If an image
<P>
  involved in execution of an image control statement, a reference to a coindexed object, or execution of a collective
<P>
  or atomic subroutine has failed, and no other error condition occurs, the value of STAT_FAILED_IMAGE is
<P>
  assigned to the variable specified in a STAT= specifier in the execution of an image control statement or reference
<P>
  to a coindexed object, or to the STAT argument in an invocation of a collective or atomic subroutine.
<P>
  16.10.2.27     STAT_LOCKED
<P>
</PRE>
1 The value of the default integer scalar constant STAT_LOCKED is assigned to the variable specified in a STAT=
<P>
<PRE>
  specifier (11.6.11) of a LOCK statement if the lock variable is locked by the executing image.
<P>
  16.10.2.28     STAT_LOCKED_OTHER_IMAGE
<P>
</PRE>
1 The value of the default integer scalar constant STAT_LOCKED_OTHER_IMAGE is assigned to the variable
<P>
<PRE>
  specified in a STAT= specifier (11.6.11) of an UNLOCK statement if the lock variable is locked by another image.
<P>
  16.10.2.29     STAT_STOPPED_IMAGE
<P>
</PRE>
1 The value of the default integer scalar constant STAT_STOPPED_IMAGE is assigned to the variable specified
<P>
<PRE>
  in a STAT= specifier (9.7.4, 11.6.11), if execution of the statement with that specifier requires synchronization
<P>
  with an image that has initiated normal termination. It is assigned to a STAT argument in a reference to a
<P>
  collective subroutine if any image of the current team has initiated normal termination. This value shall be
<P>
  positive.
<P>
  16.10.2.30     STAT_UNLOCKED
<P>
</PRE>
1 The value of the default integer scalar constant STAT_UNLOCKED is assigned to the variable specified in a
<P>
<PRE>
  STAT= specifier (11.6.11) of an UNLOCK statement if the lock variable is unlocked.
<P>
  16.10.2.31     STAT_UNLOCKED_FAILED_IMAGE
<P>
</PRE>
1 The value of the default integer scalar constant STAT_UNLOCKED_FAILED_IMAGE is assigned to the vari-
<P>
<PRE>
  able specified in a STAT= specifier (11.6.11) of a LOCK statement if the lock variable is unlocked because of the
<P>
  failure of the image that locked it.
<P>
  16.10.2.32     TEAM_TYPE
<P>
</PRE>
1 TEAM_TYPE is a derived type with private components. It is an extensible type with no type parameters.
<P>
<PRE>
  Each nonallocatable component is fully default-initialized.
<P>
</PRE>
2 A scalar variable of type TEAM_TYPE is a team variable, and can identify a team. The default initial value of
<P>
<PRE>
  a team variable does not identify any team.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            441
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  16.10.2.33   Uniqueness of named constant values
<P>
</PRE>
1 The values of these named constants shall be distinct:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; IOSTAT_INQUIRE_INTERNAL_UNIT STAT_STOPPED_IMAGE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; STAT_FAILED_IMAGE STAT_UNLOCKED</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; STAT_LOCKED STAT_UNLOCKED_FAILED_IMAGE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; STAT_LOCKED_OTHER_IMAGE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>442</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
17 Exceptions and IEEE arithmetic
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: 17 Exceptions and IEEE arithmetic
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>17.1</B> </TD><TD valign=bottom>
Overview of IEEE arithmetic support
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The intrinsic modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES provide support
<P>
<PRE>
  for the facilities defined by ISO/IEC/IEEE 60559:2011∗ . Whether the modules are provided is processor depend-
<P>
  ent. If the module IEEE_FEATURES is provided, which of the named constants defined in this document are
<P>
  included is processor dependent. The module IEEE_ARITHMETIC behaves as if it contained a USE statement
<P>
  for IEEE_EXCEPTIONS; everything that is public in IEEE_EXCEPTIONS is public in IEEE_ARITHMETIC.
<P>
        NOTE 17.1
<P>
        The types and procedures defined in these modules are not themselves intrinsic.
<P>
</PRE>
2 If IEEE_EXCEPTIONS or IEEE_ARITHMETIC is accessible in a scoping unit, the exceptions IEEE_OVER-
<P>
<PRE>
  FLOW and IEEE_DIVIDE_BY_ZERO are supported in the scoping unit for all kinds of real and complex
<P>
  IEEE floating-point data. Which other exceptions are supported can be determined by the inquiry function
<P>
  IEEE_SUPPORT_FLAG (17.11.51); whether control of halting is supported can be determined by the inquiry
<P>
  function IEEE_SUPPORT_HALTING. The extent of support of the other exceptions may be influenced by
<P>
  the accessibility of the named constants IEEE_INEXACT_FLAG, IEEE_INVALID_FLAG, and IEEE_UN-
<P>
  DERFLOW_FLAG of the module IEEE_FEATURES. If a scoping unit has access to IEEE_UNDERFLOW_-
<P>
  FLAG of IEEE_FEATURES, within the scoping unit the processor shall support underflow and return true from
<P>
  IEEE_SUPPORT_FLAG (IEEE_UNDERFLOW, X) for at least one kind of real. Similarly, if IEEE_INEX-
<P>
  ACT_FLAG or IEEE_INVALID_FLAG is accessible, within the scoping unit the processor shall support the
<P>
  exception and return true from the corresponding inquiry function for at least one kind of real. If IEEE_HALT-
<P>
  ING is accessible, within the scoping unit the processor shall support control of halting and return true from
<P>
  IEEE_SUPPORT_HALTING (FLAG) for the flag.
<P>
        NOTE 17.2
<P>
        IEEE_INVALID is not required to be supported whenever IEEE_EXCEPTIONS is accessed. This is to
<P>
        allow a processor whose arithmetic does not conform to ISO/IEC/IEEE 60559:2011 to provide support for
<P>
        overflow and divide_by_zero. On a processor which does support ISO/IEC/IEEE 60559:2011, invalid is
<P>
        an equally serious condition.
<P>
</PRE>
3 If a scoping unit does not access IEEE_FEATURES, IEEE_EXCEPTIONS, or IEEE_ARITHMETIC, the level
<P>
<PRE>
  of support is processor dependent, and need not include support for any exceptions. If a flag is signaling on entry
<P>
  to such a scoping unit, the processor ensures that it is signaling on exit. If a flag is quiet on entry to such a
<P>
  scoping unit, whether it is signaling on exit is processor dependent.
<P>
</PRE>
4 Additional ISO/IEC/IEEE 60559:2011 facilities are available from the module IEEE_ARITHMETIC. The extent
<P>
<PRE>
  of support may be influenced by the accessibility of the named constants of the module IEEE_FEATURES. If a
<P>
  scoping unit has access to IEEE_DATATYPE of IEEE_FEATURES, within the scoping unit the processor shall
<P>
  support IEEE arithmetic and return true from IEEE_SUPPORT_DATATYPE (X) (17.11.48) for at least one
<P>
  kind of real. Similarly, if IEEE_DENORMAL, IEEE_DIVIDE, IEEE_INF, IEEE_NAN, IEEE_ROUNDING,
<P>
  IEEE_SQRT, or IEEE_SUBNORMAL is accessible, within the scoping unit the processor shall support the
<P>
  feature and return true from the corresponding inquiry function for at least one kind of real. In the case of
<P>
  IEEE_ROUNDING, it shall return true for the rounding modes IEEE_NEAREST, IEEE_TO_ZERO, IEEE_-
<P>
  UP, and IEEE_DOWN; support for IEEE_AWAY is also required if there is at least one kind of real X for
<P>
      ∗ Because ISO/IEC/IEEE 60559:2011 was originally an IEEE standard, its facilities are widely known as “IEEE arithmetic”,
<P>
  and this terminology is used by this document.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                 443
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  which IEEE_SUPPORT_DATATYPE (X) is true and RADIX (X) is equal to ten. Note that the effect of
<P>
  IEEE_DENORMAL is the same as that of IEEE_SUBNORMAL.
<P>
</PRE>
5 Execution might be slowed on some processors by the support of some features. If IEEE_EXCEPTIONS or
<P>
<PRE>
  IEEE_ARITHMETIC is accessed but IEEE_FEATURES is not accessed, the supported subset of features is
<P>
  processor dependent. The processor’s fullest support is provided when all of IEEE_FEATURES is accessed as in
<P>
           USE, INTRINSIC :: IEEE_ARITHMETIC; USE, INTRINSIC :: IEEE_FEATURES
<P>
  but execution might then be slowed by the presence of a feature that is not needed. In all cases, the extent of
<P>
  support can be determined by the inquiry functions.
<P>
  17.2       Derived types, constants, and operators defined in the modules
<P>
</PRE>
1 The modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES define five derived types,
<P>
<PRE>
  whose components are all private. No direct component of any of these types is allocatable or a pointer.
<P>
</PRE>
2 The module IEEE_EXCEPTIONS defines the following types.
<P>
<PRE>
      • IEEE_FLAG_TYPE is for identifying a particular exception flag. Its only possible values are those of
<P>
        named constants defined in the module: IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_-
<P>
        ZERO, IEEE_UNDERFLOW, and IEEE_INEXACT. The module also defines the array named constants
<P>
        IEEE_USUAL = [ IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_INVALID ] and IEEE_-
<P>
        ALL = [ IEEE_USUAL, IEEE_UNDERFLOW, IEEE_INEXACT ].
<P>
      • IEEE_MODES_TYPE is for representing the floating-point modes.
<P>
      • IEEE_STATUS_TYPE is for representing the floating-point status.
<P>
</PRE>
3 The module IEEE_ARITHMETIC defines the following types, constants, and operators.
<P>
<PRE>
      • The type IEEE_CLASS_TYPE, for identifying a class of floating-point values. Its only possible
<P>
        values are those of named constants defined in the module: IEEE_SIGNALING_NAN, IEEE_QUI-
<P>
        ET_NAN, IEEE_NEGATIVE_INF, IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_DENORMAL,
<P>
        IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, IEEE_POSITIVE_SUBNORMAL, IEEE_POS-
<P>
        ITIVE_NORMAL, IEEE_POSITIVE_INF, and IEEE_OTHER_VALUE. The named constants IEEE_-
<P>
        NEGATIVE_DENORMAL and IEEE_POSITIVE_DENORMAL are defined with the same value as
<P>
        IEEE_NEGATIVE_SUBNORMAL and IEEE_POSITIVE_SUBNORMAL respectively.
<P>
      • The type IEEE_ROUND_TYPE, for identifying a particular rounding mode. Its only possible values
<P>
        are those of named constants defined in the module: IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP,
<P>
        IEEE_DOWN, IEEE_AWAY and IEEE_OTHER for the rounding modes specified in this document.
<P>
      • The pure elemental operator == for two values of one of these types to return true if the values are the
<P>
        same and false otherwise.
<P>
      • The pure elemental operator /= for two values of one of these types to return true if the values differ and
<P>
        false otherwise.
<P>
</PRE>
4 The module IEEE_FEATURES defines the type IEEE_FEATURES_TYPE, for expressing the need for particu-
<P>
<PRE>
  lar ISO/IEC/IEEE 60559:2011 features. Its only possible values are those of named constants defined in the mod-
<P>
  ule: IEEE_DATATYPE, IEEE_DENORMAL, IEEE_DIVIDE, IEEE_HALTING, IEEE_INEXACT_FLAG,
<P>
  IEEE_INF, IEEE_INVALID_FLAG, IEEE_NAN, IEEE_ROUNDING, IEEE_SQRT, IEEE_SUBNORMAL,
<P>
  and IEEE_UNDERFLOW_FLAG.
<P>
  17.3       The exceptions
<P>
</PRE>
1 The exceptions are the following.
<P>
<PRE>
  444                                                              ⃝
<P>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
      • IEEE_OVERFLOW occurs in an intrinsic real addition, subtraction, multiplication, division, or conversion
<P>
        by the intrinsic function REAL, as specified by ISO/IEC/IEEE 60559:2011 if IEEE_SUPPORT_DATA-
<P>
        TYPE is true for the operands of the operation or conversion, and as determined by the processor otherwise.
<P>
        It occurs in an intrinsic real exponentiation as determined by the processor. It occurs in a complex op-
<P>
        eration, or conversion by the intrinsic function CMPLX, if it is caused by the calculation of the real or
<P>
        imaginary part of the result.
<P>
      • IEEE_DIVIDE_BY_ZERO occurs in a real division as specified by ISO/IEC/IEEE 60559:2011 if IEEE_-
<P>
        SUPPORT_DATATYPE is true for the operands of the division, and as determined by the processor
<P>
        otherwise. It is processor-dependent whether it occurs in a real exponentiation with a negative exponent.
<P>
        It occurs in a complex division if it is caused by the calculation of the real or imaginary part of the result.
<P>
      • IEEE_INVALID occurs when a real or complex operation or assignment is invalid; possible examples are
<P>
        SQRT (X) when X is real and has a nonzero negative value, and conversion to an integer (by assignment,
<P>
        an intrinsic procedure, or a procedure defined in an intrinsic module) when the result is too large to be
<P>
        representable. IEEE_INVALID occurs for numeric relational intrinsic operations as specified below.
<P>
      • IEEE_UNDERFLOW occurs when the result for an intrinsic real operation or assignment has an absolute
<P>
        value less than a processor-dependent limit, or the real or imaginary part of the result for an intrinsic
<P>
        complex operation or assignment has an absolute value less than a processor-dependent limit.
<P>
      • IEEE_INEXACT occurs when the result of a real or complex operation or assignment is not exact.
<P>
</PRE>
2 Each exception has a flag whose value is either quiet or signaling. The value can be determined by the subroutine
<P>
<PRE>
  IEEE_GET_FLAG. Its initial value is quiet. It is set to signaling when the associated exception occurs, except
<P>
  that the flag for IEEE_UNDERFLOW is not set if the result of the operation that caused the exception was exact
<P>
  and default ISO/IEC/IEEE 60559:2011 exception handling is in effect for IEEE_UNDERFLOW. Its status can
<P>
  also be changed by the subroutine IEEE_SET_FLAG or the subroutine IEEE_SET_STATUS. Once signaling
<P>
  within a procedure, it remains signaling unless set quiet by an invocation of the subroutine IEEE_SET_FLAG
<P>
  or the subroutine IEEE_SET_STATUS.
<P>
</PRE>
3 If a flag is signaling on entry to a procedure other than IEEE_GET_FLAG or IEEE_GET_STATUS, the
<P>
<PRE>
  processor will set it to quiet on entry and restore it to signaling on return. If a flag signals during execution of a
<P>
  procedure, the processor shall not set it to quiet on return.
<P>
</PRE>
4 Evaluation of a specification expression might cause an exception to signal.
<BLOCKQUOTE>
<P>
5 In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if an intrinsic procedure
<P>
<PRE>
  or a procedure defined in an intrinsic module executes normally, the values of the flags IEEE_OVERFLOW,
<P>
  IEEE_DIVIDE_BY_ZERO, and IEEE_INVALID shall be as on entry to the procedure, even if one or more of
<P>
  them signals during the calculation. If a real or complex result is too large for the procedure to handle, IEEE_-
<P>
  OVERFLOW may signal. If a real or complex result is a NaN because of an invalid operation (for example,
<P>
  LOG (−1.0)), IEEE_INVALID may signal. Similar rules apply to format processing and to intrinsic operations:
<P>
  no signaling flag shall be set quiet and no quiet flag shall be set signaling because of an intermediate calculation
<P>
  that does not affect the result.
<P>
</PRE>
6 In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if x1 and x2 are numeric
<P>
<PRE>
  entities, the type of x1 + x2 is real, and IEEE_SUPPORT_NAN (x1 + x2 ) is true, the relational intrinsic
<P>
  operation x1 rel-op x2 shall signal IEEE_INVALID as specified for the conditional predicate of ISO/IEC/IEEE
<P>
  60559:2011 corresponding to rel-op indicated by Table 17.1. If the types or kind type parameters of x1 or x2 differ,
<P>
  the conversions (10.1.5.5.1) might signal exceptions instead of or in addition to an IEEE_INVALID exception
<P>
  signaled by the comparison.
<P>
        NOTE 17.3
<P>
       Each comparison predicate defined by ISO/IEC/IEEE 60559:2011 is either unordered signaling or unordered
<P>
       quiet. An unordered signaling predicate signals an invalid operation exception if and only if one of the values
<P>
       being compared is a NaN. An unordered quiet predicate signals an invalid operation exception if and only
<P>
       if one of the values being compared is a signaling NaN. The comparison predicates do not signal any other
<P>
       exceptions.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            445
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
                                 Table 17.1: IEEE relational operator correspondence
<P>
                                Operator     ISO/IEC/IEEE 60559:2011 comparison predicate
<P>
                               .LT. or &lt;                  compareSignalingLess
<P>
                             .LE. or &lt;=                compareSignalingLessEqual
<P>
                               .GT. or &gt;                compareSignalingGreater
<P>
                             .GE. or &gt;=              compareSignalingGreaterEqual
<P>
                             .EQ. or ==                    compareQuietEqual
<P>
                              .NE. or /=                 compareQuietNotEqual
<P>
</PRE>
7 In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if x1 or x2 are numeric
<P>
<PRE>
   entities, the type of x1 + x2 is complex, and IEEE_SUPPORT_NAN (REAL (x1 + x2 )) is true, the intrinsic
<P>
   equality or inequality operation between x1 and x2 may signal IEEE_INVALID if the value of the real or
<P>
   imaginary part of either operand is a signaling NaN. If any conversions are done before the values are compared,
<P>
   those conversions might signal exceptions instead of or in addition to an IEEE_INVALID exception signaled by
<P>
   the comparison.
<P>
</PRE>
8 In a sequence of statements that has no invocations of IEEE_GET_FLAG, IEEE_SET_FLAG, IEEE_GET_-
<P>
<PRE>
   STATUS, IEEE_SET_HALTING_MODE, or IEEE_SET_STATUS, if the execution of an operation would
<P>
   cause an exception to signal but after execution of the sequence no value of a variable depends on the operation,
<P>
   whether the exception is signaling is processor dependent. For example, when Y has the value zero, whether the
<P>
   code
<P>
             X = 1.0/Y
<P>
             X = 3.0
<P>
   signals IEEE_DIVIDE_BY_ZERO is processor dependent. Another example is the following:
<P>
             REAL, PARAMETER :: X=0.0, Y=6.0
<P>
             IF (1.0/X == Y) PRINT *,’Hello world’
<P>
   where the processor is permitted to discard the IF statement because the logical expression can never be true
<P>
   and no value of a variable depends on it.
<P>
</PRE>
9 An exception shall not signal if this could arise only during execution of an operation beyond those required or
<P>
<PRE>
   permitted by the standard. For example, the statement
<P>
             IF (F (X) &gt; 0.0) Y = 1.0/Z
<P>
   shall not signal IEEE_DIVIDE_BY_ZERO when both F (X) and Z are zero and the statement
<P>
             WHERE (A &gt; 0.0) A = 1.0/A
<P>
   shall not signal IEEE_DIVIDE_BY_ZERO. On the other hand, when X has the value 1.0 and Y has the value
<P>
   0.0, the expression
<P>
             X&gt;0.00001 .OR. X/Y&gt;0.00001
<P>
   is permitted to cause the signaling of IEEE_DIVIDE_BY_ZERO.
<P>
</PRE>
10 The processor need not support IEEE_INVALID, IEEE_UNDERFLOW, and IEEE_INEXACT. If an exception
<P>
<PRE>
   is not supported, its flag is always quiet. The inquiry function IEEE_SUPPORT_FLAG can be used to inquire
<P>
   whether a particular flag is supported.
<P>
   446                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>17.4</B> </TD><TD valign=bottom>
The rounding modes
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 This document specifies a binary rounding mode that affects floating-point arithmetic with radix two, and a
<P>
<PRE>
  decimal rounding mode that affects floating-point arithmetic with radix ten. Unqualified references to the round-
<P>
  ing mode with respect to a particular arithmetic operation or operands refers to the mode for the radix of the
<P>
  operation or operands, and other unqualified references to the rounding mode refers to both binary and decimal
<P>
  rounding modes.
<P>
</PRE>
2 ISO/IEC/IEEE 60559:2011 specifies five possible rounding-direction attributes: roundTiesToEven, roundTo-
<P>
<PRE>
  wardZero, roundTowardPositive, roundTowardNegative, and roundTiesToAway. These correspond to the round-
<P>
  ing modes IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP, IEEE_DOWN, and IEEE_AWAY respectively.
<P>
  The rounding mode IEEE_OTHER does not correspond to any ISO/IEC/IEEE 60559:2011 rounding-direction
<P>
  attribute; if supported, the effect of this rounding mode is processor dependent.
<P>
</PRE>
3 The subroutine IEEE_GET_ROUNDING_MODE can be used to get the rounding modes. The initial rounding
<P>
<PRE>
  modes are processor dependent.
<P>
</PRE>
4 If the processor supports the alteration of the rounding modes during execution, the subroutine IEEE_SET_-
<P>
<PRE>
  ROUNDING_MODE can be used to alter them. The inquiry function IEEE_SUPPORT_ROUNDING can be
<P>
  used to inquire whether this facility is available for a particular mode. The inquiry function IEEE_SUPPORT_-
<P>
  IO can be used to inquire whether rounding for base conversion in formatted input/output (12.5.6.16, 12.6.2.13,
<P>
  13.7.2.3.8) is as specified in ISO/IEC/IEEE 60559:2011.
<P>
</PRE>
5 In a procedure other than IEEE_SET_ROUNDING_MODE or IEEE_SET_STATUS, the processor shall not
<P>
<PRE>
  change the rounding modes on entry, and on return shall ensure that the rounding modes are the same as they
<P>
  were on entry.
<P>
        NOTE 17.4
<P>
        ISO/IEC/IEEE 60559:2011 requires support for roundTiesToAway only for decimal floating-point.
<P>
        NOTE 17.5
<P>
        ISO/IEC/IEEE 60559:2011 requires that there is a language-defined means to specify a constant value
<P>
        for the rounding-direction attribute for all standard operations in a block. The means provided by this
<P>
        document are a CALL to IEEE_GET_ROUNDING_MODE at the beginning of the block followed by
<P>
        a CALL to IEEE_SET_ROUNDING_MODE with constant arguments, together with another CALL to
<P>
        IEEE_SET_ROUNDING_MODE at the end of the block to restore the rounding mode.
<P>
        NOTE 17.6
<P>
        Within a program, all literal constants that have the same form have the same value (7.1.4). Therefore, the
<P>
        value of a literal constant is not affected by the rounding modes.
<P>
  17.5       Underflow mode
<P>
</PRE>
1 Some processors allow control during program execution of whether underflow produces a subnormal number in
<P>
<PRE>
  conformance with ISO/IEC/IEEE 60559:2011 (gradual underflow) or produces zero instead (abrupt underflow).
<P>
  On some processors, floating-point performance is typically better in abrupt underflow mode than in gradual
<P>
  underflow mode.
<P>
</PRE>
2 Control over the underflow mode is exercised by invocation of IEEE_SET_UNDERFLOW_MODE. The sub-
<P>
<PRE>
  routine IEEE_GET_UNDERFLOW_MODE can be used to get the underflow mode. The inquiry function
<P>
  IEEE_SUPPORT_UNDERFLOW_CONTROL can be used to inquire whether this facility is available. The
<P>
  initial underflow mode is processor dependent. In a procedure other than IEEE_SET_UNDERFLOW_MODE
<P>
  or IEEE_SET_STATUS, the processor shall not change the underflow mode on entry, and on return shall ensure
<P>
  that the underflow mode is the same as it was on entry.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        447
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 The underflow mode affects only floating-point calculations whose type is that of an X for which IEEE_SUP-
<P>
<PRE>
  PORT_UNDERFLOW_CONTROL returns true.
<P>
  17.6        Halting
<P>
</PRE>
1 Some processors allow control during program execution of whether to abort or continue execution after an
<P>
<PRE>
  exception. Such control is exercised by invocation of the subroutine IEEE_SET_HALTING_MODE. Halting
<P>
  is not precise and may occur any time after the exception has occurred. The inquiry function IEEE_SUP-
<P>
  PORT_HALTING can be used to inquire whether this facility is available. The initial halting mode is processor
<P>
  dependent. In a procedure other than IEEE_SET_HALTING_MODE or IEEE_SET_STATUS, the processor
<P>
  shall not change the halting mode on entry, and on return shall ensure that the halting mode is the same as it
<P>
  was on entry.
<P>
  17.7        The floating-point modes and status
<P>
</PRE>
1 The values of the rounding modes, underflow mode, and halting mode are collectively called the floating-point
<P>
<PRE>
  modes. The values of all the supported flags for exceptions and the floating-point modes are collectively called the
<P>
  floating-point status. The floating-point modes can be stored in a scalar variable of type IEEE_MODES_TYPE
<P>
  with the subroutine IEEE_GET_MODES and restored with the subroutine IEEE_SET_MODES. The floating-
<P>
  point status can be stored in a scalar variable of type IEEE_STATUS_TYPE with the subroutine IEEE_GET_-
<P>
  STATUS and restored with the subroutine IEEE_SET_STATUS. There are no facilities for finding the values of
<P>
  particular flags represented by such a variable.
<P>
        NOTE 17.7
<P>
        Each image has its own floating-point status (5.3.4).
<P>
        NOTE 17.8
<P>
        Some processors hold all these flags and modes in one or two status registers that can be obtained and
<P>
        set as a whole faster than all individual flags and modes can be obtained and set. These procedures are
<P>
        provided to exploit this feature.
<P>
        NOTE 17.9
<P>
        The processor is required to ensure that a call to a Fortran procedure does not change the floating-point
<P>
        status other than by setting exception flags to signaling.
<P>
  17.8        Exceptional values
<P>
</PRE>
1 ISO/IEC/IEEE 60559:2011 specifies the following exceptional floating-point values.
<P>
<PRE>
      • Subnormal values have very small absolute values and reduced precision.
<P>
      • Infinite values (+infinity and −infinity) are created by overflow or division by zero.
<P>
      • Not-a-Number ( NaN) values are undefined values or values created by an invalid operation.
<P>
</PRE>
2 A value that does not fall into the above classes is called a normal number.
<P>
3 The functions IEEE_IS_FINITE, IEEE_IS_NAN, IEEE_IS_NEGATIVE, and IEEE_IS_NORMAL are
<P>
<PRE>
  provided to test whether a value is finite, NaN, negative, or normal. The function IEEE_VALUE is provided to
<P>
  generate an IEEE number of any class, including an infinity or a NaN. The inquiry functions IEEE_SUPPORT_-
<P>
  SUBNORMAL, IEEE_SUPPORT_INF, and IEEE_SUPPORT_NAN are provided to determine whether these
<P>
  facilities are available for a particular kind of real.
<P>
  448                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
  17.9       IEEE arithmetic
<P>
</PRE>
1 The inquiry function IEEE_SUPPORT_DATATYPE can be used to inquire whether IEEE arithmetic is sup-
<P>
<PRE>
  ported for a particular kind of real. Complete conformance with ISO/IEC/IEEE 60559:2011 is not required,
<P>
  but
<P>
      • the normal numbers shall be exactly those of an ISO/IEC/IEEE 60559:2011 floating-point format,
<P>
      • for at least one rounding mode, the intrinsic operations of addition, subtraction and multiplication shall
<P>
        conform whenever the operands and result specified by ISO/IEC/IEEE 60559:2011 are normal numbers,
<P>
      • the IEEE function abs shall be provided by the intrinsic function ABS,
<P>
      • the IEEE operation remainder shall be provided by the function IEEE_REM, and
<P>
      • the IEEE functions copySign, logB, and compareQuietUnordered shall be provided by the functions IEEE_-
<P>
        COPY_SIGN, IEEE_LOGB, and IEEE_UNORDERED, respectively,
<P>
  for that kind of real.
<P>
</PRE>
2 The inquiry function IEEE_SUPPORT_NAN is provided to inquire whether the processor supports IEEE NaNs.
<P>
<PRE>
  Where these are supported, the result of the intrinsic operations +, −, and *, and the functions IEEE_REM
<P>
  and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to ISO/IEC/IEEE 60559:2011
<P>
  when the result is an IEEE NaN.
<P>
</PRE>
3 The inquiry function IEEE_SUPPORT_INF is provided to inquire whether the processor supports IEEE infinit-
<P>
<PRE>
  ies. Where these are supported, the result of the intrinsic operations +, −, and *, and the functions IEEE_REM
<P>
  and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to ISO/IEC/IEEE 60559:2011
<P>
  when exactly one operand or the result specified by ISO/IEC/IEEE 60559:2011 is an IEEE infinity.
<P>
</PRE>
4 The inquiry function IEEE_SUPPORT_SUBNORMAL is provided to inquire whether the processor supports
<P>
<PRE>
  subnormal numbers. Where these are supported, the result of the intrinsic operations +, −, and *, and the
<P>
  functions IEEE_REM and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to
<P>
  ISO/IEC/IEEE 60559:2011 when the result specified by ISO/IEC/IEEE 60559:2011 is subnormal, or any op-
<P>
  erand is subnormal and either the result is not an IEEE infinity or IEEE_SUPPORT_INF is true.
<P>
</PRE>
5 The inquiry function IEEE_SUPPORT_DIVIDE is provided to inquire whether, on kinds of real for which
<P>
<PRE>
  IEEE_SUPPORT_DATATYPE returns true, the intrinsic division operation conforms to ISO/IEC/IEEE
<P>
  60559:2011 when both operands and the result specified by ISO/IEC/IEEE 60559:2011 are normal numbers.
<P>
  If IEEE_SUPPORT_NAN is also true for a particular kind of real, the intrinsic division operation on that kind
<P>
  conforms to ISO/IEC/IEEE 60559:2011 when the result specified by ISO/IEC/IEEE 60559:2011 is a NaN. If
<P>
  IEEE_SUPPORT_INF is also true for a particular kind of real, the intrinsic division operation on that kind
<P>
  conforms to ISO/IEC/IEEE 60559:2011 when one operand or the result specified by ISO/IEC/IEEE 60559:2011 is
<P>
  an IEEE infinity. If IEEE_SUPPORT_SUBNORMAL is also true for a particular kind of real, the intrinsic divi-
<P>
  sion operation on that kind conforms to ISO/IEC/IEEE 60559:2011 when the result specified by ISO/IEC/IEEE
<P>
  60559:2011 is subnormal, or when any operand is subnormal and either the result specified by ISO/IEC/IEEE
<P>
  60559:2011 is not an infinity or IEEE_SUPPORT_INF is true.
<P>
</PRE>
6 ISO/IEC/IEEE 60559:2011 specifies a square root function that returns negative real zero for the square root of
<P>
<PRE>
  negative real zero and has certain accuracy requirements. The inquiry function IEEE_SUPPORT_SQRT can
<P>
  be used to inquire whether the intrinsic function SQRT conforms to ISO/IEC/IEEE 60559:2011 for a particular
<P>
  kind of real. If IEEE_SUPPORT_NAN is also true for a particular kind of real, the intrinsic function SQRT
<P>
  on that kind conforms to ISO/IEC/IEEE 60559:2011 when the result specified by ISO/IEC/IEEE 60559:2011
<P>
  is a NaN. If IEEE_SUPPORT_INF is also true for a particular kind of real, the intrinsic function SQRT on
<P>
  that kind conforms to ISO/IEC/IEEE 60559:2011 when the result specified by ISO/IEC/IEEE 60559:2011 is an
<P>
  IEEE infinity. If IEEE_SUPPORT_SUBNORMAL is also true for a particular kind of real, the intrinsic function
<P>
  SQRT on that kind conforms to ISO/IEC/IEEE 60559:2011 when the argument is subnormal.
<P>
</PRE>
7 The inquiry function IEEE_SUPPORT_STANDARD is provided to inquire whether the processor supports all
<P>
<PRE>
  the ISO/IEC/IEEE 60559:2011 facilities defined in this document for a particular kind of real.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                      449
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  17.10       Summary of the procedures
<P>
</PRE>
1 For all of the procedures defined in the modules, the arguments shown are the names that shall be used for
<P>
<PRE>
  argument keywords if the keyword form is used for the actual arguments.
<P>
</PRE>
2 A procedure classified in 17.10 as an inquiry function depends on the properties of one or more of its arguments
<P>
<PRE>
  instead of their values; in fact, these argument values may be undefined. Unless the description of one of these
<P>
  inquiry functions states otherwise, these arguments are permitted to be unallocated allocatable variables or
<P>
  pointers that are undefined or disassociated. A procedure that is classified as a transformational function is
<P>
  neither an inquiry function nor elemental.
<P>
</PRE>
3 In the Class column of Tables 17.2 and 17.3,
<P>
<PRE>
     E  indicates that the  procedure  is an elemental function,
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>ES</B> </TD><TD valign=bottom>
indicates that the  procedure  is an elemental subroutine,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      I indicates that the  procedure  is an inquiry function,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PS</B> </TD><TD valign=bottom>
indicates that the  procedure  is a pure subroutine,
</TD></TR>
<TR><TD colspan=2>
<PRE>
      S indicates that the  procedure  is an impure subroutine, and
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>T</B> </TD><TD valign=bottom>
indicates that the  procedure  in a transformational function.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                       Table 17.2: IEEE_ARITHMETIC module procedure summary
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments               Class Description
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_CLASS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Classify number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_COPY_SIGN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                     E  Copy sign.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_FMA</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B, C)                  E  Fused multiply-add operation.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_ROUNDING_MODE (ROUND_VALUE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
S  Get rounding mode.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                            [, RADIX])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_UNDERFLOW_-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(GRADUAL)                  S  Get underflow mode.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>IEEE_INT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, ROUND [, KIND])        E  Conversion to integer type.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_FINITE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Whether a value is finite.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_NAN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Whether a value is an IEEE NaN.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_NEGATIVE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Whether a value is negative.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_NORMAL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Whether a value is a normal number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_LOGB</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Exponent.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_MAX_NUM</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                     E  Maximum numeric value.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_MAX_NUM_MAG</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                     E  Maximum magnitude numeric value.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_MIN_NUM</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                     E  Minimum numeric value.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_MIN_NUM_MAG</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                     E  Minimum magnitude numeric value.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_NEXT_AFTER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                     E  Adjacent machine number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_NEXT_DOWN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Adjacent lower machine number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_NEXT_UP</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Adjacent higher machine number.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_QUIET_EQ</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                     E  Quiet compares equal.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_QUIET_GE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                     E  Quiet compares greater than or equal.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_QUIET_GT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                     E  Quiet compares greater than.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_QUIET_LE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                     E  Quiet compares less than or equal.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_QUIET_LT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                     E  Quiet compares less than.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_QUIET_NE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                     E  Quiet compares not equal.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_REAL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A [, KIND])               E  Conversion to real type.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_REM</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                     E  Exact remainder.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_RINT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                        E  Round to integer.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SCALB</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, I)                     E  X × 2I .
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SELECTED_REAL_KIND ([P, R, RADIX])</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
T  IEEE kind type parameter value.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SET_ROUNDING_MODE (ROUND_VALUE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
S  Set rounding mode.
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                            [, RADIX])
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>450</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Table 17.2: IEEE_ARITHMETIC module procedure summary</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(cont.)
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments               Class Description
<TABLE width=100% cellpadding=3><!-- tsb: Arguments               Class Description
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SET_UNDERFLOW_-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(GRADUAL)                 S    Set underflow mode.
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; MODE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_EQ</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                    E    Signaling compares equal.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_GE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                    E    Signaling compares greater than or
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                          equal.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_GT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                    E    Signaling compares greater than.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_LE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                    E    Signaling compares less than or equal.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_LT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                    E    Signaling compares less than.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_NE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(A, B)                    E    Signaling compares not equal.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNBIT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X)                       E    Test sign bit.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_DATATYPE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query IEEE arithmetic support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_DENORMAL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query subnormal number support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_DIVIDE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query IEEE division support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_INF</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query IEEE infinity support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_IO</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query IEEE formatting support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_NAN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query IEEE NaN support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_ROUNDING</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(ROUND_VALUE              T    Query IEEE rounding support.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                           [, X])
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_SQRT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query IEEE square root support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_SUBNORMAL ([X])</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
I   Query subnormal number support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_STANDARD</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query IEEE standard support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_UNDER-</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
([X])                      I   Query underflow control support.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; FLOW_CONTROL</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>IEEE_UNORDERED</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, Y)                    E    Whether two values are unordered.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_VALUE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(X, CLASS)                E    Return number in a class.
</TD></TR>
<TR><TD colspan=2>
<PRE>
                        Table 17.3: IEEE_EXCEPTIONS module procedure summary
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Procedure</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments                  Class Description
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_FLAG</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(FLAG, FLAG_VALUE)          ES Get an exception flag.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_HALTING_MODE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(FLAG, HALTING)             ES Get a halting mode.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_MODES</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(MODES)                      S    Get floating-point modes.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_STATUS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(STATUS_VALUE)               S    Get floating-point status.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SET_FLAG</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(FLAG, FLAG_VALUE)          PS Set an exception flag.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SET_HALTING_MODE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(FLAG, HALTING)             PS Set a halting mode.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SET_MODES</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(MODES)                      S    Set floating-point modes.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SET_STATUS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(STATUS_VALUE)               S    Restore floating-point status.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_FLAG</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(FLAG [, X])                 T    Query exception support.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_HALTING</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
(FLAG)                       T    Query halting mode support.
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
4 In the intrinsic module IEEE_ARITHMETIC, the elemental functions listed are provided for all reals X and Y.
<P>
<PRE>
  17.11        Specifications of the procedures
<P>
  17.11.1       General
<P>
</PRE>
1 In the detailed descriptions in 17.11, procedure names are generic and are not specific. All the functions are pure
<P>
<PRE>
  and all the subroutines are impure unless otherwise stated. All dummy arguments have INTENT (IN) if the
<P>
  intent is not stated explicitly. In the examples, it is assumed that the processor supports IEEE arithmetic for
<P>
  default real.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          451
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 For the elemental functions of IEEE_ARITHMETIC that return a floating-point result, if X or Y has a value
<P>
<PRE>
  that is an infinity or a NaN, the result shall be consistent with the general rules in 6.1 and 6.2 of ISO/IEC/IEEE
<P>
  60559:2011. For example, the result for an infinity shall be constructed as the limiting case of the result with a
<P>
  value of arbitrarily large magnitude, if such a limit exists.
<P>
</PRE>
3 A program may contain statements that, if executed, would violate the requirements listed in a Restriction
<P>
<PRE>
  paragraph.
<P>
       NOTE 17.10
<P>
       A program can avoid violating those requirements by using IF constructs to check whether particular
<P>
       features are supported. For example,
<P>
                 IF (IEEE_SUPPORT_DATATYPE (X)) THEN
<P>
                   C = IEEE_CLASS (X)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
avoids invoking IEEE_CLASS except on a processor which supports that facility.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: avoids invoking IEEE_CLASS except on a processor which supports that facility.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>17.11.2</B> </TD><TD valign=bottom>
IEEE_CLASS (X)
<P>
1 Description. Classify number.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Restriction. IEEE_CLASS (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<P>
5 Result Characteristics. IEEE_CLASS_TYPE.
<P>
6 Result Value. The result value shall be IEEE_SIGNALING_NAN or IEEE_QUIET_NAN if IEEE_SUP-
<P>
<PRE>
  PORT_NAN (X) has the value true and the value of X is a signaling or quiet NaN, respectively. The result
<P>
  value shall be IEEE_NEGATIVE_INF or IEEE_POSITIVE_INF if IEEE_SUPPORT_INF (X) has the value
<P>
  true and the value of X is negative or positive infinity, respectively. The result value shall be IEEE_NEG-
<P>
  ATIVE_SUBNORMAL or IEEE_POSITIVE_SUBNORMAL if IEEE_SUPPORT_SUBNORMAL (X) has the
<P>
  value true and the value of X is a negative or positive subnormal value, respectively. The result value shall
<P>
  be IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, or IEEE_POSIT-
<P>
  IVE_NORMAL if the value of X is negative normal, negative zero, positive zero, or positive normal, respectively.
<P>
  Otherwise, the result value shall be IEEE_OTHER_VALUE.
<P>
</PRE>
7 Example. IEEE_CLASS (−1.0) has the value IEEE_NEGATIVE_NORMAL.
<P>
<PRE>
       NOTE 17.11
<P>
       The result value IEEE_OTHER_VALUE is useful on systems that are almost IEEE-compatible, but do
<P>
       not implement all of it. For example, if a subnormal value is encountered on a system that does not support
<P>
       them.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>17.11.3</B> </TD><TD valign=bottom>
IEEE_COPY_SIGN (X, Y)
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 Description. Copy sign.
<P>
2 Class. Elemental function.
<P>
3 Arguments. The arguments shall be of type real.
<P>
<PRE>
  452                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>4 Restriction.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_COPY_SIGN (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_SUPPORT_DATATYPE (Y) has the value false.
<P>
</PRE>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the absolute value of X with the sign of Y. This is true even for IEEE special
</TD></TR>
<TR><TD colspan=2>
<PRE>
  values, such as a NaN or an infinity (on processors supporting such values).
<P>
</PRE>
7 Example. The value of IEEE_COPY_SIGN (X, 1.0) is ABS (X) even when X is a NaN.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.4       IEEE_FMA (A, B, C)
<P>
</PRE>
1 Description. Fused multiply-add operation.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A             shall be of type real.
<P>
  B             shall be of the same type and kind type parameter as A.
<P>
  C             shall be of the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_FMA (A, B, C) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the value
</TD></TR>
<TR><TD colspan=2>
<PRE>
  false.
<P>
</PRE>
5 Result Characteristics. Same as A.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified by ISO/IEC/IEEE 60559:2011 for the fusedMultiplyAdd
</TD></TR>
<TR><TD colspan=2>
<PRE>
  operation; that is, when the result is in range, its value is equal to the mathematical value of (A × B) + C rounded
<P>
  to the representation method of A according to the rounding mode. IEEE_OVERFLOW, IEEE_UNDERFLOW,
<P>
  and IEEE_INEXACT shall be signaled according to the final step in the calculation and not by any intermediate
<P>
  calculation.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>7 Example.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The value of IEEE_FMA (TINY (0.0), TINY (0.0), 1.0), when the rounding mode is IEEE_-
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
  NEAREST, is equal to 1.0; only the IEEE_INEXACT exception is signaled.
<P>
  17.11.5       IEEE_GET_FLAG (FLAG, FLAG_VALUE)
<P>
</PRE>
1 Description. Get an exception flag.
<P>
2 Class. Elemental subroutine.
<P>
3 Arguments.
<P>
<PRE>
  FLAG          shall be of type IEEE_FLAG_TYPE. It specifies the exception flag to be obtained.
<P>
  FLAG_VALUE shall be of type logical. It is an INTENT (OUT) argument. If the value of FLAG is IEEE_-
<P>
                INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_-
<P>
                INEXACT, FLAG_VALUE is assigned the value true if the corresponding exception flag is signaling
<P>
                and is assigned the value false otherwise.
<P>
</PRE>
4 Example. Following CALL IEEE_GET_FLAG (IEEE_OVERFLOW, FLAG_VALUE), FLAG_VALUE is
<P>
<PRE>
  true if the IEEE_OVERFLOW flag is signaling and is false if it is quiet.
<P>
  17.11.6       IEEE_GET_HALTING_MODE (FLAG, HALTING)
<P>
</PRE>
1 Description. Get a halting mode.
<P>
2 Class. Elemental subroutine.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           453
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
<P>
<PRE>
  FLAG          shall be of type IEEE_FLAG_TYPE. It specifies the exception flag. It shall have one of the val-
<P>
                ues IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW,
<P>
                or IEEE_INEXACT.
<P>
  HALTING       shall be of type logical. It is an INTENT (OUT) argument. It is assigned the value true if the
<P>
                exception specified by FLAG will cause halting. Otherwise, it is assigned the value false.
<P>
</PRE>
4 Example. To store the halting mode for IEEE_OVERFLOW, do a calculation without halting, and restore the
<P>
<PRE>
  halting mode later:
<P>
           USE, INTRINSIC :: IEEE_ARITHMETIC
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; LOGICAL HALTING</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
CALL IEEE_GET_HALTING_MODE (IEEE_OVERFLOW, HALTING) ! Store halting mode
<P>
CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, .FALSE.) ! No halting
<P>
&#46;&#46;&#46; ! calculation without halting
<P>
CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, HALTING) ! Restore halting mode
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, HALTING) ! Restore halting mode
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>17.11.7</B> </TD><TD valign=bottom>
IEEE_GET_MODES (MODES)
<P>
1 Description. Get floating-point modes.
<P>
2 Class. Subroutine.
<P>
3 Argument. MODES shall be a scalar of type IEEE_MODES_TYPE. It is an INTENT (OUT) argument that
<P>
<PRE>
  is assigned the value of the floating-point modes.
<P>
</PRE>
4 Example. To save the floating-point modes, do a calculation with specific rounding and underflow modes, and
<P>
<PRE>
  restore them later:
<P>
           USE, INTRINSIC :: IEEE_ARITHMETIC
<P>
           TYPE (IEEE_MODES_TYPE) SAVE_MODES
<P>
           &#46;&#46;&#46;
<P>
           CALL IEEE_GET_MODES (SAVE_MODES) ! Save all modes.
<P>
           CALL IEEE_SET_ROUNDING_MODE (IEEE_TO_ZERO))
<P>
           CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
<P>
           &#46;&#46;&#46; ! calculation with abrupt round-to-zero.
<P>
           CALL IEEE_SET_MODES (SAVE_MODES) ! Restore all modes.
<P>
  17.11.8       IEEE_GET_ROUNDING_MODE (ROUND_VALUE [, RADIX])
<P>
</PRE>
1 Description. Get rounding mode.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ROUND_VALUE shall be a scalar of type IEEE_ROUND_TYPE. It is an INTENT (OUT) argument. It is
<P>
                assigned the value IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP, IEEE_DOWN, or IEEE_-
<P>
                AWAY if the corresponding rounding mode is in operation and IEEE_OTHER otherwise.
<P>
  RADIX (optional) shall be an integer scalar with the value two or ten. If RADIX is present with the value ten,
<P>
                the rounding mode queried is the decimal rounding mode, otherwise it is the binary rounding mode.
<P>
</PRE>
4 Example. To save the binary rounding mode, do a calculation with round to nearest, and restore the rounding
<P>
<PRE>
  mode later:
<P>
  454                                                            ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
           USE, INTRINSIC :: IEEE_ARITHMETIC
<P>
           TYPE (IEEE_ROUND_TYPE) ROUND_VALUE
<P>
           &#46;&#46;&#46;
<P>
           CALL IEEE_GET_ROUNDING_MODE (ROUND_VALUE) ! Store the rounding mode
<P>
           CALL IEEE_SET_ROUNDING_MODE (IEEE_NEAREST)
<P>
           &#46;&#46;&#46; ! calculation with round to nearest
<P>
           CALL IEEE_SET_ROUNDING_MODE (ROUND_VALUE) ! Restore the rounding mode
<P>
  17.11.9       IEEE_GET_STATUS (STATUS_VALUE)
<P>
</PRE>
1 Description. Get floating-point status.
<P>
2 Class. Subroutine.
<P>
3 Argument. STATUS_VALUE shall be a scalar of type IEEE_STATUS_TYPE. It is an INTENT (OUT)
<P>
<PRE>
  argument. It is assigned the value of the floating-point status.
<P>
</PRE>
4 Example. To store all the exception flags, do a calculation involving exception handling, and restore them later:
<P>
<PRE>
           USE, INTRINSIC :: IEEE_ARITHMETIC
<P>
           TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
<P>
           &#46;&#46;&#46;
<P>
           CALL IEEE_GET_STATUS (STATUS_VALUE) ! Get the flags
<P>
           CALL IEEE_SET_FLAG (IEEE_ALL, .FALSE.) ! Set the flags quiet.
<P>
           &#46;&#46;&#46; ! calculation involving exception handling
<P>
           CALL IEEE_SET_STATUS (STATUS_VALUE) ! Restore the flags
<P>
</PRE>
17.11.10 IEEE_GET_UNDERFLOW_MODE (GRADUAL)
<P>
1 Description. Get underflow mode.
<P>
2 Class. Subroutine.
<P>
3 Argument. GRADUAL shall be a logical scalar. It is an INTENT (OUT) argument. It is assigned the value
<P>
<PRE>
  true if the underflow mode is gradual underflow, and false if the underflow mode is abrupt underflow.
<P>
</PRE>
4 Restriction. IEEE_GET_UNDERFLOW_MODE shall not be invoked unless IEEE_SUPPORT_UNDER-
<P>
<PRE>
  FLOW_CONTROL (X) is true for some X.
<P>
</PRE>
5 Example. After CALL IEEE_SET_UNDERFLOW_MODE (.FALSE.), a subsequent CALL IEEE_GET_-
<P>
<PRE>
  UNDERFLOW_MODE (GRADUAL) will set GRADUAL to false.
<P>
  17.11.11 IEEE_INT (A, ROUND [, KIND])
<P>
</PRE>
1 Description. Conversion to integer type.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A             shall be of type real.
<P>
  ROUND         shall be of type IEEE_ROUND_TYPE.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Restriction. IEEE_INT (A, ROUND, KIND) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
<P>
<PRE>
  the value false.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                       455
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise, the kind type parameter is that of default integer.
<P>
</PRE>
6 Result Value. The result has the value specified by ISO/IEC/IEEE 60559:2011 for the convertToInteger{round}
<P>
<PRE>
  or the convertToIntegerExact{round} operation; the processor shall consistently choose which operation it
<P>
  provides. That is, the value of A is converted to an integer according to the rounding mode specified by ROUND;
<P>
  if this value is representable in the representation method of the result, the result has this value, otherwise IEEE_-
<P>
  INVALID is signaled and the result is processor dependent. If the processor provides the convertToIntegerExact
<P>
  operation, IEEE_INVALID did not signal, and the value of the result differs from that of A, IEEE_INEXACT
<P>
  will be signaled.
<P>
</PRE>
7 Example. The value of IEEE_INT (12.5, IEEE_UP) is 13; IEEE_INEXACT will be signaled if the processor
<P>
<PRE>
  provides the convertToIntegerExact operation.
<P>
  17.11.12 IEEE_IS_FINITE (X)
<P>
</PRE>
1 Description. Whether a value is finite.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Restriction. IEEE_IS_FINITE (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
<P>
<PRE>
  false.
<P>
</PRE>
5 Result Characteristics. Default logical.
<P>
6 Result Value. The result has the value true if the value of X is finite, that is, IEEE_CLASS (X) has one
<P>
<PRE>
  of the values IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_SUBNORMAL, IEEE_NEGATIVE_ZERO,
<P>
  IEEE_POSITIVE_ZERO, IEEE_POSITIVE_SUBNORMAL, or IEEE_POSITIVE_NORMAL; otherwise, the
<P>
  result has the value false.
<P>
</PRE>
7 Example. IEEE_IS_FINITE (1.0) has the value true.
<P>
<PRE>
  17.11.13 IEEE_IS_NAN (X)
<P>
</PRE>
1 Description. Whether a value is an IEEE NaN.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Restriction. IEEE_IS_NAN (X) shall not be invoked if IEEE_SUPPORT_NAN (X) has the value false.
<P>
5 Result Characteristics. Default logical.
<P>
6 Result Value. The result has the value true if the value of X is an IEEE NaN; otherwise, it has the value false.
<P>
7 Example. IEEE_IS_NAN (SQRT (−1.0)) has the value true if IEEE_SUPPORT_SQRT (1.0) has the value
<P>
<PRE>
  true.
<P>
  17.11.14 IEEE_IS_NEGATIVE (X)
<P>
</PRE>
1 Description. Whether a value is negative.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Restriction. IEEE_IS_NEGATIVE (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
<P>
<PRE>
  value false.
<P>
  456                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Characteristics. Default logical.
<P>
6 Result Value. The result has the value true if IEEE_CLASS (X) has one of the values IEEE_NEGATIVE_-
<P>
<PRE>
  NORMAL, IEEE_NEGATIVE_SUBNORMAL, IEEE_NEGATIVE_ZERO or IEEE_NEGATIVE_INF; oth-
<P>
  erwise, the result has the value false.
<P>
</PRE>
7 Example. IEEE_IS_NEGATIVE (0.0) has the value false.
<P>
<PRE>
  17.11.15 IEEE_IS_NORMAL (X)
<P>
</PRE>
1 Description. Whether a value is a normal number.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Restriction. IEEE_IS_NORMAL (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
<P>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
<P>
6 Result Value. The result has the value true if IEEE_CLASS (X) has one of the values IEEE_NEGATIVE_-
<P>
<PRE>
  NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO or IEEE_POSITIVE_NORMAL; otherwise,
<P>
  the result has the value false.
<P>
</PRE>
7 Example. IEEE_IS_NORMAL (SQRT (−1.0) has the value false if IEEE_SUPPORT_SQRT (1.0) has the
<P>
<PRE>
  value true.
<P>
  17.11.16 IEEE_LOGB (X)
<P>
</PRE>
1 Description. Exponent.
<P>
2 Class. Elemental function.
<P>
3 Argument. X shall be of type real.
<P>
4 Restriction. IEEE_LOGB (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<P>
5 Result Characteristics. Same as X.
<P>
6 Result Value.
<P>
<PRE>
  Case (i):     If the value of X is neither zero, infinity, nor NaN, the result has the value of the unbiased exponent
<P>
                of X. Note: this value is equal to EXPONENT (X)− 1.
<P>
  Case (ii):    If X==0, the result is −infinity if IEEE_SUPPORT_INF (X) is true and −HUGE (X) otherwise;
<P>
                IEEE_DIVIDE_BY_ZERO signals.
<P>
  Case (iii):   If IEEE_SUPPORT_INF (X) is true and X is infinite, the result is +infinity.
<P>
  Case (iv):    If IEEE_SUPPORT_NAN (X) is true and X is a NaN, the result is a NaN.
<P>
</PRE>
7 Example. IEEE_LOGB (−1.1) has the value 0.0.
<P>
<PRE>
  17.11.17 IEEE_MAX_NUM (X, Y)
<P>
</PRE>
1 Description. Maximum numeric value.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be of type real.
<P>
  Y             shall be of the same type and kind type parameter as X.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            457
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Restriction. IEEE_MAX_NUM shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
<P>
<PRE>
  false.
<P>
</PRE>
5 Result Characteristics. Same as X.
<TABLE width=100% cellpadding=3><!-- tsb: 5 Result Characteristics. Same as X.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>6 Result Value.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The result has the value specified for the maxNum operation in ISO/IEC/IEEE 60559:2011;
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that is,
<P>
      • if X &lt; Y the result has the value of Y;
<P>
      • if Y &lt; X the result has the value of X;
<P>
      • if exactly one of X and Y is a quiet NaN the result has the value of the other argument;
<P>
      • if one or both of X and Y are signaling NaNs, IEEE_INVALID signals and the result is a NaN;
<P>
      • otherwise, the result is either X or Y (processor dependent).
<P>
</PRE>
7 Except when X or Y is a signaling NaN, no exception is signaled.
</TD></TR>
<TR><TD colspan=2>
8 Example. The value of IEEE_MAX_NUM (1.5, IEEE_VALUE (IEEE_QUIET_NAN)) is 1.5.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.18 IEEE_MAX_NUM_MAG (X, Y)
<P>
</PRE>
1 Description. Maximum magnitude numeric value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  X              shall be of type real.
<P>
  Y              shall be of the same type and kind type parameter as X.
<P>
</PRE>
4 Restriction. IEEE_MAX_NUM_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the maxNumMag operation in ISO/IEC/IEEE 60559:2011;
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that is,
<P>
      • if ABS (X) &lt; ABS (Y) the result has the value of Y;
<P>
      • if ABS (Y) &lt; ABS (X) the result has the value of X;
<P>
      • otherwise, the result has the value of IEEE_MAX_NUM (X, Y).
<P>
</PRE>
7 Except when X or Y is a signaling NaN, no exception is signaled.
</TD></TR>
<TR><TD colspan=2>
8 Example. The value of IEEE_MAX_NUM_MAG (1.5, −2.5) is −2.5.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.19 IEEE_MIN_NUM (X, Y)
<P>
</PRE>
1 Description. Minimum numeric value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  X              shall be of type real.
<P>
  Y              shall be of the same type and kind type parameter as X.
<P>
</PRE>
4 Restriction. IEEE_MIN_NUM shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
</TD></TR>
<TR><TD colspan=2>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  458                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>6 Result Value.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The result has the value specified for the minNum operation in ISO/IEC/IEEE 60559:2011;
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that is,
<P>
     • if X &lt; Y the result has the value of X;
<P>
     • if Y &lt; X the result has the value of Y;
<P>
     • if exactly one of X and Y is a quiet NaN the result has the value of the other argument;
<P>
     • if one or both of X and Y are signaling NaNs, IEEE_INVALID signals and the result is a NaN;
<P>
     • otherwise, the result is either X or Y (processor dependent).
<P>
</PRE>
7 Except when X or Y is a signaling NaN, no exception is signaled.
</TD></TR>
<TR><TD colspan=2>
8 Example. The value of IEEE_MIN_NUM (1.5, IEEE_VALUE (IEEE_QUIET_NAN)) is 1.5.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.20 IEEE_MIN_NUM_MAG (X, Y)
<P>
</PRE>
1 Description. Minimum magnitude numeric value.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  X             shall be of type real.
<P>
  Y             shall be of the same type and kind type parameter as X.
<P>
</PRE>
4 Restriction. IEEE_MIN_NUM_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the minNumMag operation in ISO/IEC/IEEE 60559:2011;
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that is,
<P>
     • if ABS (X) &lt; ABS (Y) the result has the value of X;
<P>
     • if ABS (Y) &lt; ABS (X) the result has the value of Y;
<P>
     • otherwise, the result has the value of IEEE_MIN_NUM (X, Y).
<P>
</PRE>
7 Except when X or Y is a signaling NaN, no exception is signaled.
</TD></TR>
<TR><TD colspan=2>
8 Example. The value of IEEE_MIN_NUM_MAG (1.5, −2.5) is 1.5.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.21 IEEE_NEXT_AFTER (X, Y)
<P>
</PRE>
1 Description. Adjacent machine number.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments. The arguments shall be of type real.
</TD></TR>
<TR><TD colspan=2>
4 Restriction. IEEE_NEXT_AFTER (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_SUPPORT_DATATYPE (Y) has the value false.
<P>
</PRE>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
6 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     If X == Y, the result is X and no exception is signaled.
<P>
  Case (ii):    If X ̸= Y, the result has the value of the next representable neighbor of X in the direction of Y.
<P>
                The neighbors of zero (of either sign) are both nonzero. IEEE_OVERFLOW is signaled when
<P>
                X is finite but IEEE_NEXT_AFTER (X, Y) is infinite; IEEE_UNDERFLOW is signaled when
<P>
                IEEE_NEXT_AFTER (X, Y) is subnormal; in both cases, IEEE_INEXACT signals.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                      459
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
7 Example. The value of IEEE_NEXT_AFTER (1.0, 2.0) is 1.0 + EPSILON (X).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.22 IEEE_NEXT_DOWN (X)
<P>
</PRE>
1 Description. Adjacent lower machine number.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real.
</TD></TR>
<TR><TD colspan=2>
4 Restriction. IEEE_NEXT_DOWN (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false. IEEE_NEXT_DOWN (−HUGE (X)) shall not be invoked if IEEE_SUPPORT_INF (X) has the
<P>
  value false.
<P>
</PRE>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the nextDown operation in ISO/IEC/IEEE 60559:2011;
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that is, it is the greatest value in the representation method of X that compares less than X, except when X is
<P>
  equal to −∞ the result has the value −∞, and when X is a NaN the result is a NaN. If X is a signaling NaN,
<P>
  IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. If IEEE_SUPPORT_SUBNORMAL (0.0) is true, the value of IEEE_NEXT_DOWN (+0.0) is the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  negative subnormal number with least magnitude.
<P>
  17.11.23 IEEE_NEXT_UP (X)
<P>
</PRE>
1 Description. Adjacent higher machine number.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real.
</TD></TR>
<TR><TD colspan=2>
4 Restriction. IEEE_NEXT_UP (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
</TD></TR>
<TR><TD colspan=2>
<PRE>
  false. IEEE_NEXT_UP (HUGE (X)) shall not be invoked if IEEE_SUPPORT_INF (X) has the value false.
<P>
</PRE>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the nextUp operation in ISO/IEC/IEEE 60559:2011; that
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is, it is the least value in the representation method of X that compares greater than X, except when X is
<P>
  equal to +∞ the result has the value +∞, and when X is a NaN the result is a NaN. If X is a signaling NaN,
<P>
  IEEE_INVALID_signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. If IEEE_SUPPORT_INF (X) is true, the value of IEEE_NEXT_UP (HUGE (X)) is +∞.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.24 IEEE_QUIET_EQ (A, B)
<P>
</PRE>
1 Description. Quiet compares equal.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A               shall be of type real.
<P>
  B               shall have the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_QUIET_EQ (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  460                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Result Value. The result has the value specified for the compareQuietEqual operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares equal to B. If A or B is a NaN, the result will be false. If
<P>
  A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_QUIET_EQ (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and no exception
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is signaled.
<P>
  17.11.25 IEEE_QUIET_GE (A, B)
<P>
</PRE>
1 Description. Quiet compares greater than or equal.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A              shall be of type real.
<P>
  B              shall have the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_QUIET_GE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the compareQuietGreaterEqual operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares greater than or equal to B. If A or B is a NaN, the result
<P>
  will be false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_QUIET_GE (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and no exception
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is signaled.
<P>
  17.11.26 IEEE_QUIET_GT (A, B)
<P>
</PRE>
1 Description. Quiet compares greater than.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A              shall be of type real.
<P>
  B              shall have the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_QUIET_GT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the compareQuietGreater operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares greater than B. If A or B is a NaN, the result will be
<P>
  false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_QUIET_GT (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and no exception
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is signaled.
<P>
  17.11.27 IEEE_QUIET_LE (A, B)
<P>
</PRE>
1 Description. Quiet compares less than or equal.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            461
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A              shall be of type real.
<P>
  B              shall have the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_QUIET_LE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the compareQuietLessEqual operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares less than or equal to B. If A or B is a NaN, the result will
<P>
  be false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_QUIET_LE (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and no exception
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is signaled.
<P>
  17.11.28 IEEE_QUIET_LT (A, B)
<P>
</PRE>
1 Description. Quiet compares less than.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A              shall be of type real.
<P>
  B              shall have the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_QUIET_LT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>6 Result Value.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The result has the value specified for the compareQuietLess operation in ISO/IEC/IEEE
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
  60559:2011; that is, it is true if and only if A compares less than B. If A or B is a NaN, the result will be
<P>
  false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_QUIET_LT (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and no exception
<P>
<PRE>
  is signaled.
<P>
  17.11.29 IEEE_QUIET_NE (A, B)
<P>
</PRE>
1 Description. Quiet compares not equal.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be of type real.
<P>
  B              shall have the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_QUIET_NE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
<P>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
<P>
6 Result Value. The result has the value specified for the compareQuietNotEqual operation in ISO/IEC/IEEE
<P>
<PRE>
  60559:2011; that is, it is true if and only if A compares not equal to B. If A or B is a NaN, the result will be true.
<P>
  If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_QUIET_NE (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value true and no exception
<P>
<PRE>
  is signaled.
<P>
  462                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
  17.11.30 IEEE_REAL (A [, KIND])
<P>
</PRE>
1 Description. Conversion to real type.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A              shall be of type integer or real.
<P>
  KIND (optional) shall be a scalar integer constant expression.
<P>
</PRE>
4 Restriction. IEEE_REAL shall not be invoked if A is of type real and IEEE_SUPPORT_DATATYPE (A)
<P>
<PRE>
  has the value false, or if IEEE_SUPPORT_DATATYPE (IEEE_REAL (A, KIND)) has the value false.
<P>
</PRE>
5 Result Characteristics. Real. If KIND is present, the kind type parameter is that specified by the value of
<P>
<PRE>
  KIND; otherwise, the kind type parameter is that of default real.
<P>
</PRE>
6 Result Value. The result has the same value as A if that value is representable in the representation method
<P>
<PRE>
  of the result, and is rounded according to the rounding mode otherwise. This shall be consistent with the
<P>
  specification of ISO/IEC/IEEE 60559:2011 for the convertFromInt operation when A is of type integer, and with
<P>
  the convertFormat operation otherwise.
<P>
</PRE>
7 Example. The value of IEEE_REAL (123) is 123.0.
<P>
<PRE>
  17.11.31 IEEE_REM (X, Y)
<P>
</PRE>
1 Description. Exact remainder.
<P>
2 Class. Elemental function.
<P>
3 Arguments. The arguments shall be of type real and have the same radix.
<P>
4 Restriction. IEEE_REM (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or IEEE_SUP-
<P>
<PRE>
  PORT_DATATYPE (Y) has the value false.
<P>
</PRE>
5 Result Characteristics. Real with the kind type parameter of whichever argument has the greater precision.
<P>
6 Result Value. This function computes the remainder operation specified in ISO/IEC/IEEE 60559:2011.
<P>
7 The result value when X and Y are finite, and Y is nonzero, regardless of the rounding mode, shall be exactly X
<P>
<PRE>
  − Y*N, where N is the integer nearest to the exact value X/Y; whenever |N − X/Y| = 12 , N shall be even. If the
<P>
  result value is zero, the sign shall be that of X.
<P>
</PRE>
8 When X is finite and Y is infinite, the result value is X. If Y is zero or X is infinite, and neither is a NaN, the
<P>
<PRE>
  IEEE_INVALID exception shall occur; if IEEE_SUPPORT_NAN(X+Y) is true, the result is a NaN. If X is
<P>
  subnormal and Y is infinite, the IEEE_UNDERFLOW exception shall occur. No exception shall signal if X is
<P>
  finite and normal, and Y is infinite.
<P>
</PRE>
9 Examples. The value of IEEE_REM (4.0, 3.0) is 1.0, the value of IEEE_REM (3.0, 2.0) is −1.0, and the value
<P>
<PRE>
  of IEEE_REM (5.0, 2.0) is 1.0.
<P>
  17.11.32 IEEE_RINT (X [, ROUND])
<P>
</PRE>
1 Description. Round to integer.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X              shall be of type real.
<P>
  ROUND (optional) shall be of type IEEE_ROUND_TYPE.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         463
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Restriction. IEEE_RINT (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<P>
5 Result Characteristics. Same as X.
<P>
6 Result Value. If ROUND is present, the value of the result is the value of X rounded to an integer according
<P>
<PRE>
  to the mode specified by ROUND; this is the ISO/IEC/IEEE 60559:2011 operation roundToInteger{rounding}.
<P>
  Otherwise, the value of the result is that specified for the operation roundIntegralToExact in ISO/IEC/IEEE
<P>
  60559:2011; this is the value of X rounded to an integer according to the rounding mode. If the result has the
<P>
  value zero, the sign is that of X.
<P>
</PRE>
7 Examples. If the rounding mode is round to nearest, the value of IEEE_RINT (1.1) is 1.0. The value of
<P>
<PRE>
  IEEE_RINT (1.1, IEEE_UP) is 2.0.
<P>
  17.11.33 IEEE_SCALB (X, I)
<P>
</PRE>
1 Description. X × 2I .
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  X             shall be of type real.
<P>
  I             shall be of type integer.
<P>
</PRE>
4 Restriction. IEEE_SCALB (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<P>
5 Result Characteristics. Same as X.
<P>
6 Result Value.
<P>
<PRE>
  Case (i):     If X × 2I is representable as a normal number, the result has this value.
<P>
  Case (ii):    If X is finite and X × 2I is too large, the IEEE_OVERFLOW exception shall occur. If IEEE_-
<P>
                SUPPORT_INF (X) is true, the result value is infinity with the sign of X; otherwise, the result
<P>
                value is SIGN (HUGE (X), X).
<P>
  Case (iii):   If X × 2I is too small and there is loss of accuracy, the IEEE_UNDERFLOW exception shall occur.
<P>
                The result is the representable number having a magnitude nearest to |2I | and the same sign as X.
<P>
  Case (iv):    If X is infinite, the result is the same as X; no exception signals.
<P>
</PRE>
7 Example. The value of IEEE_SCALB (1.0, 2) is 4.0.
<P>
<PRE>
  17.11.34 IEEE_SELECTED_REAL_KIND ([P, R, RADIX])
<P>
</PRE>
1 Description. IEEE kind type parameter value.
<P>
2 Class. Transformational function.
<P>
3 Arguments. At least one argument shall be present.
<P>
<PRE>
  P (optional) shall be an integer scalar.
<P>
  R (optional) shall be an integer scalar.
<P>
  RADIX (optional) shall be an integer scalar.
<P>
</PRE>
4 Result Characteristics. Default integer scalar.
<P>
5 Result Value. If P or R is absent, the result value is the same as if it were present with the value zero. If
<P>
<PRE>
  RADIX is absent, there is no requirement on the radix of the selected kind. The result has a value equal to a
<P>
  value of the kind type parameter of an ISO/IEC/IEEE 60559:2011 floating-point format with decimal precision,
<P>
  as returned by the intrinsic function PRECISION, of at least P digits, a decimal exponent range, as returned
<P>
  by the intrinsic function RANGE, of at least R, and a radix, as returned by the intrinsic function RADIX, of
<P>
  RADIX, if such a kind type parameter is available on the processor.
<P>
  464                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Otherwise, the result is −1 if the processor supports an IEEE real type with radix RADIX and exponent range
<P>
<PRE>
  of at least R but not with precision of at least P, −2 if the processor supports an IEEE real type with radix
<P>
  RADIX and precision of at least P but not with exponent range of at least R, −3 if the processor supports an
<P>
  IEEE real type with radix RADIX but with neither precision of at least P nor exponent range of at least R, −4 if
<P>
  the processor supports an IEEE real type with radix RADIX and either precision of at least P or exponent range
<P>
  of at least R but not both together, and −5 if the processor supports no IEEE real type with radix RADIX.
<P>
</PRE>
7 If more than one kind type parameter value meets the criteria, the value returned is the one with the smallest
<P>
<PRE>
  decimal precision, unless there are several such values, in which case the smallest of these kind values is returned.
<P>
</PRE>
8 Example. IEEE_SELECTED_REAL_KIND (6, 30) has the value KIND (0.0) on a machine that supports
<P>
<PRE>
  ISO/IEC/IEEE 60559:2011 single precision arithmetic for its default real approximation method.
<P>
  17.11.35 IEEE_SET_FLAG (FLAG, FLAG_VALUE)
<P>
</PRE>
1 Description. Set an exception flag.
<P>
2 Class. Pure subroutine.
<P>
3 Arguments.
<P>
<PRE>
  FLAG          shall be a scalar or array of type IEEE_FLAG_TYPE. If a value of FLAG is IEEE_INVALID,
<P>
                IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT,
<P>
                the corresponding exception flag is assigned a value. No two elements of FLAG shall have the same
<P>
                value.
<P>
  FLAG_VALUE shall be a logical scalar or array. It shall be conformable with FLAG. If an element has the value
<P>
                true, the corresponding flag is set to be signaling; otherwise, the flag is set to be quiet.
<P>
</PRE>
4 Example. CALL IEEE_SET_FLAG (IEEE_OVERFLOW, .TRUE.) sets the IEEE_OVERFLOW flag to be
<P>
<PRE>
  signaling.
<P>
  17.11.36 IEEE_SET_HALTING_MODE (FLAG, HALTING)
<P>
</PRE>
1 Description. Set a halting mode.
<P>
2 Class. Pure subroutine.
<P>
3 Arguments.
<P>
<PRE>
  FLAG          shall be a scalar or array of type IEEE_FLAG_TYPE. It shall have only the values IEEE_-
<P>
                INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_-
<P>
                INEXACT. No two elements of FLAG shall have the same value.
<P>
  HALTING       shall be a logical scalar or array. It shall be conformable with FLAG. If an element has the value
<P>
                true, the corresponding exception specified by FLAG will cause halting. Otherwise, execution will
<P>
                continue after this exception.
<P>
</PRE>
4 Restriction. IEEE_SET_HALTING_MODE (FLAG, HALTING) shall not be invoked if IEEE_SUPPORT_-
<P>
<PRE>
  HALTING (FLAG) has the value false.
<P>
</PRE>
5 Example. CALL IEEE_SET_HALTING_MODE (IEEE_DIVIDE_BY_ZERO, .TRUE.) causes halting after
<P>
<PRE>
  a divide_by_zero exception.
<P>
  17.11.37 IEEE_SET_MODES (MODES)
<P>
</PRE>
1 Description. Set floating-point modes.
<P>
2 Class. Subroutine.
<P>
3 Argument. MODES shall be a scalar of type IEEE_MODES_TYPE. Its value shall be one that was assigned
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            465
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  by a previous invocation of IEEE_GET_MODES to its MODES argument. The floating-point modes (17.7) are
<P>
  restored to the state at that invocation.
<P>
</PRE>
4 Example.
<P>
<PRE>
  To save the floating-point modes, do a calculation with specific rounding and underflow modes, and restore them
<P>
  later:
<P>
           USE, INTRINSIC :: IEEE_ARITHMETIC
<P>
           TYPE (IEEE_MODES_TYPE) SAVE_MODES
<P>
           &#46;&#46;&#46;
<P>
           CALL IEEE_GET_MODES (SAVE_MODES) ! Save all modes.
<P>
           CALL IEEE_SET_ROUNDING_MODE (IEEE_TO_ZERO))
<P>
           CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
<P>
           &#46;&#46;&#46; ! calculation with abrupt round-to-zero.
<P>
           CALL IEEE_SET_MODES (SAVE_MODES) ! Restore all modes.
<P>
  17.11.38 IEEE_SET_ROUNDING_MODE (ROUND_VALUE [, RADIX])
<P>
</PRE>
1 Description. Set rounding mode.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  ROUND_VALUE shall be a scalar of type IEEE_ROUND_TYPE. It specifies the rounding mode to be set.
<P>
  RADIX (optional) shall be an integer scalar with the value two or ten. If RADIX is present with the value ten,
<P>
                the rounding mode set is the decimal rounding mode; otherwise it is the binary rounding mode.
<P>
</PRE>
4 Restriction. IEEE_SET_ROUNDING_MODE (ROUND_VALUE) shall not be invoked unless IEEE_SUP-
<P>
<PRE>
  PORT_ROUNDING (ROUND_VALUE, X) is true for some X such that IEEE_SUPPORT_DATATYPE (X)
<P>
  is true. IEEE_SET_ROUNDING_MODE (ROUND_VALUE, RADIX) shall not be invoked unless IEEE_-
<P>
  SUPPORT_ROUNDING (ROUND_VALUE, X) is true for some X with radix RADIX such that IEEE_SUP-
<P>
  PORT_DATATYPE (X) is true.
<P>
</PRE>
5 Example. To save the binary rounding mode, do a calculation with round to nearest, and restore the rounding
<P>
<PRE>
  mode later:
<P>
           USE, INTRINSIC :: IEEE_ARITHMETIC
<P>
           TYPE (IEEE_ROUND_TYPE) ROUND_VALUE
<P>
           &#46;&#46;&#46;
<P>
           CALL IEEE_GET_ROUNDING_MODE (ROUND_VALUE) ! Store the rounding mode
<P>
           CALL IEEE_SET_ROUNDING_MODE (IEEE_NEAREST)
<P>
           &#46;&#46;&#46; ! calculation with round to nearest
<P>
           CALL IEEE_SET_ROUNDING_MODE (ROUND_VALUE) ! Restore the rounding mode
<P>
  17.11.39 IEEE_SET_STATUS (STATUS_VALUE)
<P>
</PRE>
1 Description. Restore floating-point status.
<P>
2 Class. Subroutine.
<P>
3 Argument. STATUS_VALUE shall be a scalar of type IEEE_STATUS_TYPE. Its value shall be one that was
<P>
<PRE>
  assigned by a previous invocation of IEEE_GET_STATUS to its STATUS_VALUE argument. The floating-
<P>
  point status (17.7 is restored to the state at that invocation).
<P>
  466                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Example. To store all the exceptions flags, do a calculation involving exception handling, and restore them
<P>
<PRE>
  later:
<P>
             USE, INTRINSIC :: IEEE_EXCEPTIONS
<P>
             TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
<P>
             &#46;&#46;&#46;
<P>
             CALL IEEE_GET_STATUS (STATUS_VALUE) ! Store the flags
<P>
             CALL IEEE_SET_FLAG (IEEE_ALL, .FALSE.) ! Set them quiet
<P>
             &#46;&#46;&#46; ! calculation involving exception handling
<P>
             CALL IEEE_SET_STATUS (STATUS_VALUE) ! Restore the flags
<P>
  17.11.40 IEEE_SET_UNDERFLOW_MODE (GRADUAL)
<P>
</PRE>
1 Description. Set underflow mode.
<P>
2 Class. Subroutine.
<P>
3 Argument. GRADUAL shall be a logical scalar. If it is true, the underflow mode is set to gradual underflow.
<P>
<PRE>
  If it is false, the underflow mode is set to abrupt underflow.
<P>
</PRE>
4 Restriction. IEEE_SET_UNDERFLOW_MODE shall not be invoked unless IEEE_SUPPORT_UNDER-
<P>
<PRE>
  FLOW_CONTROL (X) is true for some X.
<P>
</PRE>
5 Example. To perform some calculations with abrupt underflow and then restore the previous mode:
<P>
<PRE>
             USE, INTRINSIC :: IEEE_ARITHMETIC
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; LOGICAL SAVE_UNDERFLOW_MODE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
CALL IEEE_GET_UNDERFLOW_MODE (SAVE_UNDERFLOW_MODE)
<P>
CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
<P>
&#46;&#46;&#46; ! Perform some calculations with abrupt underflow
<P>
CALL IEEE_SET_UNDERFLOW_MODE (SAVE_UNDERFLOW_MODE)
</BLOCKQUOTE>
<P>
17.11.41 IEEE_SIGNALING_EQ (A, B)
<BLOCKQUOTE>
<P>
1 Description. Signaling compares equal.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A                shall be of type real.
<P>
  B                shall be of the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_SIGNALING_EQ (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
<P>
<PRE>
  the value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
<P>
6 Result Value. The result has the value specified for the compareSignalingEqual operation in ISO/IEC/IEEE
<P>
<PRE>
  60559:2011; that is, it is true if and only if A compares equal to B. If A or B is a NaN, the result will be false
<P>
  and IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_SIGNALING_EQ (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and signals
<P>
<PRE>
  IEEE_INVALID.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        467
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  17.11.42 IEEE_SIGNALING_GE (A, B)
<P>
</PRE>
1 Description. Signaling compares greater than or equal.
<P>
2 Class. Elemental function.
<P>
3 Arguments.
<P>
<PRE>
  A             shall be of type real.
<P>
  B             shall be of the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_SIGNALING_GE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
<P>
<PRE>
  the value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
<TABLE cellpadding=3><!-- tsb: 5 Result Characteristics. Default logical.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>6 Result Value.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The result has the value specified for the compareSignalingGreaterEqual operation in
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ISO/IEC/IEEE 60559:2011; that is, it is true if and only if A compares greater than or equal to B. If A or
<P>
  B is a NaN, the result will be false and IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_SIGNALING_GE (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and signals
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_INVALID.
<P>
  17.11.43 IEEE_SIGNALING_GT (A, B)
<P>
</PRE>
1 Description. Signaling compares greater than.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A             shall be of type real.
<P>
  B             shall be of the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_SIGNALING_GT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the compareSignalingGreater operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares greater than B. If A or B is a NaN, the result will be false
<P>
  and IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_SIGNALING_GT (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and signals
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_INVALID.
<P>
  17.11.44 IEEE_SIGNALING_LE (A, B)
<P>
</PRE>
1 Description. Signaling compares less than or equal.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A             shall be of type real.
<P>
  B             shall be of the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_SIGNALING_LE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  468                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Result Value. The result has the value specified for the compareSignalingLessEqual operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares less than or equal to B. If A or B is a NaN, the result will
<P>
  be false and IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_SIGNALING_LE (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and signals
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_INVALID.
<P>
  17.11.45 IEEE_SIGNALING_LT (A, B)
<P>
</PRE>
1 Description. Signaling compares less than.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A             shall be of type real.
<P>
  B             shall be of the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_SIGNALING_LT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the compareSignalingLess operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares less than B. If A or B is a NaN, the result will be false
<P>
  and IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_SIGNALING_LT (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value false and signals
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_INVALID.
<P>
  17.11.46 IEEE_SIGNALING_NE (A, B)
<P>
</PRE>
1 Description. Signaling compares not equal.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  A             shall be of type real.
<P>
  B             shall be of the same type and kind type parameter as A.
<P>
</PRE>
4 Restriction. IEEE_SIGNALING_NE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the compareSignalingNotEqual operation in ISO/IEC/IEEE
</TD></TR>
<TR><TD colspan=2>
<PRE>
  60559:2011; that is, it is true if and only if A compares not equal to B. If A or B is a NaN, the result will be true
<P>
  and IEEE_INVALID signals; otherwise, no exception is signaled.
<P>
</PRE>
7 Example. IEEE_SIGNALING_NE (1.0, IEEE_VALUE (IEEE_QUIET_NAN)) has the value true and signals
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_INVALID.
<P>
  17.11.47 IEEE_SIGNBIT (X)
<P>
</PRE>
1 Description. Test sign bit.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            469
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Restriction. IEEE_SIGNBIT (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
</TD></TR>
<TR><TD colspan=2>
<PRE>
  false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value specified for the isSignMinus operation in ISO/IEC/IEEE 60559:2011;
</TD></TR>
<TR><TD colspan=2>
<PRE>
  that is, it is true if and only if the sign bit of X is nonzero. No exception is signaled even if X is a signaling NaN.
<P>
</PRE>
7 Example. IEEE_SIGNBIT (−1.0) has the value true.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.48 IEEE_SUPPORT_DATATYPE () or
<P>
                  IEEE_SUPPORT_DATATYPE (X)
<P>
</PRE>
1 Description. Query IEEE arithmetic support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has the value true if the processor supports IEEE arithmetic for all reals (X does
</TD></TR>
<TR><TD colspan=2>
<PRE>
  not appear) or for real variables of the same kind type parameter as X; otherwise, it has the value false. Here,
<P>
  support is as defined in the first paragraph of 17.9.
<P>
</PRE>
6 Example. If default real kind conforms to ISO/IEC/IEEE 60559:2011 except that underflow values flush to zero
</TD></TR>
<TR><TD colspan=2>
<PRE>
  instead of being subnormal, IEEE_SUPPORT_DATATYPE (1.0) has the value true.
<P>
  17.11.49 IEEE_SUPPORT_DENORMAL () or
<P>
                  IEEE_SUPPORT_DENORMAL (X)
<P>
</PRE>
1 Description. Query subnormal number support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):       IEEE_SUPPORT_DENORMAL (X) has the value true if IEEE_SUPPORT_DATATYPE (X) has
<P>
                  the value true and the processor supports arithmetic operations and assignments with subnormal
<P>
                  numbers (biased exponent e = 0 and fraction f ̸= 0, see subclause 3.2 of ISO/IEC/IEEE 60559:2011)
<P>
                  for real variables of the same kind type parameter as X; otherwise, it has the value false.
<P>
  Case (ii):      IEEE_SUPPORT_DENORMAL () has the value true if IEEE_SUPPORT_DENORMAL (X) has
<P>
                  the value true for all real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_DENORMAL (X) has the value true if the processor supports subnormal values
</TD></TR>
<TR><TD colspan=2>
<PRE>
  for X.
<P>
        NOTE 17.12
<P>
        A reference to IEEE_SUPPORT_DENORMAL will have the same result value as a reference to IEEE_-
<P>
        SUPPORT_SUBNORMAL with the same argument list.
<P>
  470                                                                   ⃝
<P>
                                                                        c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  17.11.50 IEEE_SUPPORT_DIVIDE () or IEEE_SUPPORT_DIVIDE (X)
<P>
</PRE>
1 Description. Query IEEE division support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     IEEE_SUPPORT_DIVIDE (X) has the value true if the processor supports division with the
<P>
                accuracy specified by ISO/IEC/IEEE 60559:2011 for real variables of the same kind type parameter
<P>
                as X; otherwise, it has the value false.
<P>
  Case (ii):    IEEE_SUPPORT_DIVIDE () has the value true if IEEE_SUPPORT_DIVIDE (X) has the value
<P>
                true for all real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_DIVIDE (X) has the value true if division of operands with the same kind as X
</TD></TR>
<TR><TD colspan=2>
<PRE>
  conforms to ISO/IEC/IEEE 60559:2011.
<P>
  17.11.51 IEEE_SUPPORT_FLAG (FLAG) or IEEE_SUPPORT_FLAG (FLAG,
<P>
                X)
<P>
</PRE>
1 Description. Query exception support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  FLAG          shall be a scalar of type IEEE_FLAG_TYPE. Its value shall be one of IEEE_INVALID, IEEE_-
<P>
                OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT.
<P>
  X             shall be of type real. It may be a scalar or an array.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     IEEE_SUPPORT_FLAG (FLAG, X) has the value true if the processor supports detection of the
<P>
                specified exception for real variables of the same kind type parameter as X; otherwise, it has the
<P>
                value false.
<P>
  Case (ii):    IEEE_SUPPORT_FLAG (FLAG) has the value true if IEEE_SUPPORT_FLAG (FLAG, X) has
<P>
                the value true for all real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_FLAG (IEEE_INEXACT) has the value true if the processor supports the inexact
</TD></TR>
<TR><TD colspan=2>
<PRE>
  exception.
<P>
  17.11.52 IEEE_SUPPORT_HALTING (FLAG)
<P>
</PRE>
1 Description. Query halting mode support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. FLAG shall be a scalar of type IEEE_FLAG_TYPE. Its value shall be one of IEEE_INVALID,
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value. The result has the value true if the processor supports the ability to control during program
</TD></TR>
<TR><TD colspan=2>
<PRE>
  execution whether to abort or continue execution after the exception specified by FLAG; otherwise, it has the
<P>
  value false. Support includes the ability to change the mode by CALL IEEE_SET_HALTING_MODE (FLAG).
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                      471
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Example. IEEE_SUPPORT_HALTING (IEEE_OVERFLOW) has the value true if the processor supports
</TD></TR>
<TR><TD colspan=2>
<PRE>
  control of halting after an overflow.
<P>
  17.11.53 IEEE_SUPPORT_INF () or IEEE_SUPPORT_INF (X)
<P>
</PRE>
1 Description. Query IEEE infinity support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     IEEE_SUPPORT_INF (X) has the value true if the processor supports IEEE infinities (positive
<P>
                and negative) for real variables of the same kind type parameter as X; otherwise, it has the value
<P>
                false.
<P>
  Case (ii):    IEEE_SUPPORT_INF () has the value true if IEEE_SUPPORT_INF (X) has the value true for
<P>
                all real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_INF (X) has the value true if the processor supports IEEE infinities for X.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.54 IEEE_SUPPORT_IO () or IEEE_SUPPORT_IO (X)
<P>
</PRE>
1 Description. Query IEEE formatting support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     IEEE_SUPPORT_IO (X) has the value true if base conversion during formatted input/output
<P>
                (12.5.6.16, 12.6.2.13, 13.7.2.3.8) conforms to ISO/IEC/IEEE 60559:2011 for the modes UP, DOWN,
<P>
                ZERO, and NEAREST for real variables of the same kind type parameter as X; otherwise, it has
<P>
                the value false.
<P>
  Case (ii):    IEEE_SUPPORT_IO () has the value true if IEEE_SUPPORT_IO (X) has the value true for all
<P>
                real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_IO (X) has the value true if formatted input/output base conversions conform to
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ISO/IEC/IEEE 60559:2011.
<P>
  17.11.55 IEEE_SUPPORT_NAN () or IEEE_SUPPORT_NAN (X)
<P>
</PRE>
1 Description. Query IEEE NaN support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):     IEEE_SUPPORT_NAN (X) has the value true if the processor supports IEEE NaNs for real
<P>
                variables of the same kind type parameter as X; otherwise, it has the value false.
<P>
  Case (ii):    IEEE_SUPPORT_NAN () has the value true if IEEE_SUPPORT_NAN (X) has the value true
<P>
                for all real X; otherwise, it has the value false.
<P>
  472                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Example. IEEE_SUPPORT_NAN (X) has the value true if the processor supports IEEE NaNs for X.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.56 IEEE_SUPPORT_ROUNDING (ROUND_VALUE) or
<P>
               IEEE_SUPPORT_ROUNDING (ROUND_VALUE, X)
<P>
</PRE>
1 Description. Query IEEE rounding support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Transformational function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ROUND_VALUE shall be of type IEEE_ROUND_TYPE.
<P>
  X            shall be of type real. It may be a scalar or an array.
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):    IEEE_SUPPORT_ROUNDING (ROUND_VALUE, X) has the value true if the processor supports
<P>
               the rounding mode defined by ROUND_VALUE for real variables of the same kind type parameter
<P>
               as X; otherwise, it has the value false. Support includes the ability to change the mode by CALL
<P>
               IEEE_SET_ROUNDING_MODE (ROUND_VALUE).
<P>
  Case (ii):   IEEE_SUPPORT_ROUNDING (ROUND_VALUE) has the value true if IEEE_SUPPORT_-
<P>
               ROUNDING (ROUND_VALUE, X) has the value true for all real X; otherwise, it has the value
<P>
               false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_ROUNDING (IEEE_TO_ZERO) has the value true if the processor supports
</TD></TR>
<TR><TD colspan=2>
<PRE>
  rounding to zero for all reals.
<P>
  17.11.57 IEEE_SUPPORT_SQRT () or IEEE_SUPPORT_SQRT (X)
<P>
</PRE>
1 Description. Query IEEE square root support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):    IEEE_SUPPORT_SQRT (X) has the value true if the intrinsic function SQRT conforms to
<P>
               ISO/IEC/IEEE 60559:2011 for real variables of the same kind type parameter as X; otherwise,
<P>
               it has the value false.
<P>
  Case (ii):   IEEE_SUPPORT_SQRT () has the value true if IEEE_SUPPORT_SQRT (X) has the value true
<P>
               for all real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. If IEEE_SUPPORT_SQRT (1.0) has the value true, SQRT (−0.0) will have the value −0.0.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  17.11.58 IEEE_SUPPORT_STANDARD () or
<P>
               IEEE_SUPPORT_STANDARD (X)
<P>
</PRE>
1 Description. Query IEEE standard support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                     473
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):      IEEE_SUPPORT_STANDARD (X) has the value true if the results of all the func-
<P>
                 tions IEEE_SUPPORT_DATATYPE (X), IEEE_SUPPORT_DIVIDE (X), IEEE_SUPPORT_-
<P>
                 FLAG (FLAG, X) for valid FLAG, IEEE_SUPPORT_HALTING (FLAG) for valid FLAG, IEEE_-
<P>
                 SUPPORT_INF (X), IEEE_SUPPORT_NAN (X), IEEE_SUPPORT_ROUNDING (ROUND_-
<P>
                 VALUE, X) for valid ROUND_VALUE, IEEE_SUPPORT_SQRT (X), and IEEE_SUPPORT_-
<P>
                 SUBNORMAL (X) are all true; otherwise, it has the value false.
<P>
  Case (ii):     IEEE_SUPPORT_STANDARD () has the value true if IEEE_SUPPORT_STANDARD (X) has
<P>
                 the value true for all real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_STANDARD () has the value false if some but not all kinds of reals conform to
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ISO/IEC/IEEE 60559:2011.
<P>
  17.11.59 IEEE_SUPPORT_SUBNORMAL () or
<P>
                IEEE_SUPPORT_SUBNORMAL (X)
<P>
</PRE>
1 Description. Query subnormal number support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):      IEEE_SUPPORT_SUBNORMAL (X) has the value true if IEEE_SUPPORT_DATATYPE (X)
<P>
                 has the value true and the processor supports arithmetic operations and assignments with subnormal
<P>
                 numbers (biased exponent e = 0 and fraction f ̸= 0, see subclause 3.2 of ISO/IEC/IEEE 60559:2011)
<P>
                 for real variables of the same kind type parameter as X; otherwise, it has the value false.
<P>
  Case (ii):     IEEE_SUPPORT_SUBNORMAL () has the value true if IEEE_SUPPORT_SUBNORMAL (X)
<P>
                 has the value true for all real X; otherwise, it has the value false.
<P>
</PRE>
6 Example. IEEE_SUPPORT_SUBNORMAL (X) has the value true if the processor supports subnormal values
</TD></TR>
<TR><TD colspan=2>
<PRE>
  for X.
<P>
       NOTE 17.13
<P>
       The subnormal numbers are not included in the 16.4 model for real numbers; they satisfy the inequality
<P>
       ABS (X) &lt; TINY (X). They usually occur as a result of an arithmetic operation whose exact result is
<P>
       less than TINY (X). Such an operation causes IEEE_UNDERFLOW to signal unless the result is exact.
<P>
       IEEE_SUPPORT_SUBNORMAL (X) is false if the processor never returns a subnormal number as the
<P>
       result of an arithmetic operation.
<P>
  17.11.60 IEEE_SUPPORT_UNDERFLOW_CONTROL () or
<P>
                IEEE_SUPPORT_UNDERFLOW_CONTROL (X)
<P>
</PRE>
1 Description. Query underflow control support.
</TD></TR>
<TR><TD colspan=2>
2 Class. Inquiry function.
</TD></TR>
<TR><TD colspan=2>
3 Argument. X shall be of type real. It may be a scalar or an array.
</TD></TR>
<TR><TD colspan=2>
4 Result Characteristics. Default logical scalar.
</TD></TR>
<TR><TD colspan=2>
5 Result Value.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  Case (i):      IEEE_SUPPORT_UNDERFLOW_CONTROL (X) has the value true if the processor supports
<P>
                 control of the underflow mode for floating-point calculations with the same type as X, and false
<P>
                 otherwise.
<P>
  474                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  Case (ii):     IEEE_SUPPORT_UNDERFLOW_CONTROL () has the value true if the processor supports
<P>
                 control of the underflow mode for all floating-point calculations, and false otherwise.
<P>
</PRE>
6 Example. IEEE_SUPPORT_UNDERFLOW_CONTROL (2.5) has the value true if the processor supports
</TD></TR>
<TR><TD colspan=2>
<PRE>
  underflow mode control for default real calculations.
<P>
  17.11.61 IEEE_UNORDERED (X, Y)
<P>
</PRE>
1 Description. Whether two values are unordered.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments. The arguments shall be of type real.
</TD></TR>
<TR><TD colspan=2>
4 Restriction. IEEE_UNORDERED (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
</TD></TR>
<TR><TD colspan=2>
<PRE>
  IEEE_SUPPORT_DATATYPE (Y) has the value false.
<P>
</PRE>
5 Result Characteristics. Default logical.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result has the value true if X or Y is a NaN or both are NaNs; otherwise, it has the value
</TD></TR>
<TR><TD colspan=2>
<PRE>
  false. If X or Y is a signaling NaN, IEEE_INVALID may signal.
<P>
</PRE>
7 Example. IEEE_UNORDERED (0.0, SQRT (−1.0)) has the value true if IEEE_SUPPORT_SQRT (1.0) has
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the value true.
<P>
  17.11.62 IEEE_VALUE (X, CLASS)
<P>
</PRE>
1 Description. Return number in a class.
</TD></TR>
<TR><TD colspan=2>
2 Class. Elemental function.
</TD></TR>
<TR><TD colspan=2>
3 Arguments.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  X              shall be of type real.
<P>
  CLASS          shall be of type IEEE_CLASS_TYPE. The value is permitted to be: IEEE_SIGNALING_NAN or
<P>
                 IEEE_QUIET_NAN if IEEE_SUPPORT_NAN (X) has the value true, IEEE_NEGATIVE_INF
<P>
                 or IEEE_POSITIVE_INF if IEEE_SUPPORT_INF (X) has the value true, IEEE_NEGATIVE_-
<P>
                 SUBNORMAL or IEEE_POSITIVE_SUBNORMAL if IEEE_SUPPORT_SUBNORMAL (X) has
<P>
                 the value true, IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_-
<P>
                 ZERO or IEEE_POSITIVE_NORMAL.
<P>
</PRE>
4 Restriction. IEEE_VALUE (X, CLASS) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  value false.
<P>
</PRE>
5 Result Characteristics. Same as X.
</TD></TR>
<TR><TD colspan=2>
6 Result Value. The result value is an IEEE value as specified by CLASS. Although in most cases the value is
</TD></TR>
<TR><TD colspan=2>
<PRE>
  processor dependent, the value shall not vary between invocations for any particular X kind type parameter and
<P>
  CLASS value.
<P>
</PRE>
7 Example. IEEE_VALUE (1.0, IEEE_NEGATIVE_INF) has the value −infinity.
</TD></TR>
<TR><TD colspan=2>
8 Whenever IEEE_VALUE returns a signaling NaN, it is processor dependent whether or not invalid is raised and
</TD></TR>
<TR><TD colspan=2>
<PRE>
  processor dependent whether or not the signaling NaN is converted into a quiet NaN.
<P>
        NOTE 17.14
<P>
        If the expr in an assignment statement is a reference to the IEEE_VALUE function that returns a signaling
<P>
        NaN and the variable is of the same type and kind as the function result, it is recommended that the
<P>
        signaling NaN be preserved.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                      475
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>17.12</B> </TD><TD valign=bottom>
Examples
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
    NOTE 17.15
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE DOT</H4>
</A>
<BLOCKQUOTE>
<P>
! Module for dot product of two real arrays of rank 1.
<P>
! The caller needs to ensure that exceptions do not cause halting.
<P>
USE, INTRINSIC :: IEEE_EXCEPTIONS
<P>
LOGICAL :: MATRIX_ERROR = .FALSE.
<P>
INTERFACE <B>OPERATOR</B>(.dot.)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE PROCEDURE MULT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
REAL FUNCTION MULT (A, B)
<P>
<PRE>
                    REAL, INTENT (IN) :: A(:), B(:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER I</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; LOGICAL OVERFLOW</H4>
</A>
<BLOCKQUOTE>
<P>
IF (<B>SIZE</B>(A) /= <B>SIZE</B>(B)) THEN
<P>
<PRE>
                       MATRIX_ERROR = .TRUE.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; RETURN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
! The processor ensures that IEEE_OVERFLOW is quiet.
<P>
MULT = 0.0
<P>
DO I = 1, SIZE (A)
<P>
<PRE>
                       MULT = MULT + A(I)*B(I)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
CALL IEEE_GET_FLAG (IEEE_OVERFLOW, OVERFLOW)
<P>
IF (OVERFLOW) MATRIX_ERROR = .TRUE.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION MULT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE DOT</H4>
</A>
<BLOCKQUOTE>
<P>
This module provides a function that computes the dot product of two real arrays of rank 1. If the sizes
<P>
of the arrays are different, an immediate return occurs with MATRIX_ERROR true. If overflow occurs
<P>
during the actual calculation, the IEEE_OVERFLOW flag will signal and MATRIX_ERROR will be true.
<P>
NOTE 17.16
<P>
<PRE>
            USE, INTRINSIC :: IEEE_EXCEPTIONS
<P>
            USE, INTRINSIC :: IEEE_FEATURES, ONLY: IEEE_INVALID_FLAG
<P>
            ! The other exceptions of IEEE_USUAL (IEEE_OVERFLOW and
<P>
            ! IEEE_DIVIDE_BY_ZERO) are always available with IEEE_EXCEPTIONS
<P>
            TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
<P>
            LOGICAL, DIMENSION(3) :: FLAG_VALUE
<P>
            &#46;&#46;&#46;
<P>
            CALL IEEE_GET_STATUS (STATUS_VALUE)
<P>
            CALL IEEE_SET_HALTING_MODE (IEEE_USUAL, .FALSE.) ! Needed in case the
<P>
            !                      default on the processor is to halt on exceptions
<P>
            CALL IEEE_SET_FLAG (IEEE_USUAL, .FALSE.)
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>476</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><P>
<PRE>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 17.16 (cont.)
<P>
<PRE>
             ! First try the "fast" algorithm for inverting a matrix:
<P>
             MATRIX1 = FAST_INV (MATRIX) ! This shall not alter MATRIX.
<P>
             CALL IEEE_GET_FLAG (IEEE_USUAL, FLAG_VALUE)
<P>
             IF (ANY(FLAG_VALUE)) THEN
<P>
                ! "Fast" algorithm failed; try "slow" one:
<P>
                CALL IEEE_SET_FLAG (IEEE_USUAL, .FALSE.)
<P>
                MATRIX1 = SLOW_INV (MATRIX)
<P>
                CALL IEEE_GET_FLAG (IEEE_USUAL, FLAG_VALUE)
<P>
                IF (ANY (FLAG_VALUE)) THEN
<P>
                   WRITE (*, *) ’Cannot invert matrix’
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; STOP</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
CALL IEEE_SET_STATUS (STATUS_VALUE)
</BLOCKQUOTE>
<P>
In this example, the function FAST_INV might cause a condition to signal. If it does, another try is made
<BLOCKQUOTE>
<P>
with SLOW_INV. If this still fails, a message is printed and the program stops. Note, also, that it is
<P>
important to set the flags quiet before the second try. The state of all the flags is stored and restored.
<P>
NOTE 17.17
<P>
<PRE>
             USE, INTRINSIC :: IEEE_EXCEPTIONS
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; LOGICAL FLAG_VALUE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, .FALSE.)
<P>
! First try a fast algorithm for inverting a matrix.
<P>
CALL IEEE_SET_FLAG (IEEE_OVERFLOW, .FALSE.)
<P>
DO K = 1, N
<P>
<PRE>
                &#46;&#46;&#46;
<P>
                CALL IEEE_GET_FLAG (IEEE_OVERFLOW, FLAG_VALUE)
<P>
                IF (FLAG_VALUE) EXIT
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
IF (FLAG_VALUE) THEN
<P>
! Alternative code which knows that K-1 steps have executed normally.
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
Here the code for matrix inversion is in line and the transfer is made more precise by adding extra tests of
<P>
the flag.
</BLOCKQUOTE>
<P>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
477
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>478</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
18 Interoperability with C
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>18.1</B> </TD><TD valign=bottom>
General
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 Fortran provides a means of referencing procedures that are defined by means of the C programming language
<P>
<PRE>
  or procedures that can be described by C prototypes as defined in 6.7.6.3 of ISO/IEC 9899:2011, even if they
<P>
  are not actually defined by means of C. Conversely, there is a means of specifying that a procedure defined by a
<P>
  Fortran subprogram can be referenced from a function defined by means of C. In addition, there is a means of
<P>
  declaring global variables that are associated with C variables whose names have external linkage as defined in
<P>
  6.2.2 of ISO/IEC 9899:2011.
<P>
</PRE>
2 The ISO_C_BINDING module provides access to named constants that represent kind type parameters of data
<P>
<PRE>
  representations compatible with C types. Fortran also provides facilities for defining derived types (7.5) and
<P>
  enumerations (7.6) that correspond to C types.
<P>
</PRE>
3 The source file ISO_Fortran_binding.h provides definitions and prototypes to enable a C function to interoperate
<P>
<PRE>
  with a Fortran procedure that has a dummy data object that is allocatable, assumed-shape, assumed-rank, pointer,
<P>
  or is of type character with an assumed length.
<P>
  18.2        The ISO_C_BINDING intrinsic module
<P>
  18.2.1      Summary of contents
<P>
</PRE>
1 The processor shall provide the intrinsic module ISO_C_BINDING. This module shall make accessible the
<P>
<PRE>
  following entities: the named constants C_NULL_PTR, C_NULL_FUNPTR, and those with names listed in
<P>
  the first column of Table 18.1 and the second column of Table 18.2, the types C_PTR and C_FUNPTR, and the
<P>
  procedures in 18.2.3. A processor may provide other public entities in the ISO_C_BINDING intrinsic module
<P>
  in addition to those listed here.
<P>
  18.2.2      Named constants and derived types in the module
<P>
</PRE>
1 The entities listed in the second column of Table 18.2 shall be default integer named constants.
<P>
2 A Fortran intrinsic type whose kind type parameter is one of the values in the module shall have the same
<P>
<PRE>
  representation as the C type with which it interoperates, for each value that a variable of that type can have.
<P>
  For C_BOOL, the internal representation of .TRUE._C_BOOL and .FALSE._C_BOOL shall be the same as those of
<P>
  the C values (_Bool)1 and (_Bool)0 respectively.
<P>
</PRE>
3 The value of C_INT shall be a valid value for an integer kind parameter on the processor. The values of
<P>
<PRE>
  C_SHORT, C_LONG, C_LONG_LONG, C_SIGNED_CHAR, C_SIZE_T, C_INT8_T, C_INT16_T, C_-
<P>
  INT32_T, C_INT64_T, C_INT_LEAST8_T, C_INT_LEAST16_T, C_INT_LEAST32_T, C_INT_LEAST-
<P>
  64_T, C_INT_FAST8_T, C_INT_FAST16_T, C_INT_FAST32_T, C_INT_FAST64_T, C_INTMAX_T,
<P>
  and C_INTPTR_T shall each be a valid value for an integer kind type parameter on the processor or shall be
<P>
  −1 if the companion processor (5.5.7) defines the corresponding C type and there is no interoperating Fortran
<P>
  processor kind, or −2 if the companion processor does not define the corresponding C type.
<P>
</PRE>
4 The values of C_FLOAT, C_DOUBLE, and C_LONG_DOUBLE shall each be a valid value for a real kind
<P>
<PRE>
  type parameter on the processor or shall be −1 if the companion processor’s type does not have a precision equal
<P>
  to the precision of any of the Fortran processor’s real kinds, −2 if the companion processor’s type does not have
<P>
  a range equal to the range of any of the Fortran processor’s real kinds, −3 if the companion processor’s type
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        479
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  has neither the precision nor range of any of the Fortran processor’s real kinds, and equal to −4 if there is no
<P>
  interoperating Fortran processor kind for other reasons. The values of C_FLOAT_COMPLEX, C_DOUBLE_-
<P>
  COMPLEX, and C_LONG_DOUBLE_COMPLEX shall be the same as those of C_FLOAT, C_DOUBLE, and
<P>
  C_LONG_DOUBLE, respectively.
<P>
</PRE>
5 The value of C_BOOL shall be a valid value for a logical kind parameter on the processor or shall be −1.
<P>
6 The value of C_CHAR shall be a valid value for a character kind type parameter on the processor or shall be −1.
<P>
<PRE>
  If the value of C_CHAR is nonnegative, the character kind specified is the C character kind; otherwise, there is
<P>
  no C character kind.
<P>
</PRE>
7 The following entities shall be named constants of type character with a length parameter of one. The kind
<P>
<PRE>
  parameter value shall be equal to the value of C_CHAR unless C_CHAR = −1, in which case the kind parameter
<P>
  value shall be the same as for default kind. The values of these constants are specified in Table 18.1. In the case
<P>
  that C_CHAR ̸= −1 the value is specified using C syntax. The semantics of these values are explained in 5.2.1
<P>
  and 5.2.2 of ISO/IEC 9899:2011.
<P>
                            Table 18.1: Names of C characters with special semantics
<P>
                                                                                  Value
<P>
                  Name                           C definition     C_CHAR = −1 C_CHAR ̸= −1
<P>
                  C_NULL_CHAR                    null character   CHAR(0)                   ’\0’
<P>
                  C_ALERT                        alert            ACHAR(7)                  ’\a’
<P>
                  C_BACKSPACE                    backspace        ACHAR(8)                  ’\b’
<P>
                  C_FORM_FEED                    form feed        ACHAR(12)                 ’\f’
<P>
                  C_NEW_LINE                     new line         ACHAR(10)                 ’\n’
<P>
                  C_CARRIAGE_RETURN carriage return ACHAR(13)                               ’\r’
<P>
                  C_HORIZONTAL_TAB               horizontal tab   ACHAR(9)                  ’\t’
<P>
                  C_VERTICAL_TAB                 vertical tab     ACHAR(11)                 ’\v’
<P>
</PRE>
8 The entities C_PTR and C_FUNPTR are described in 18.3.3.
<P>
9 The entity C_NULL_PTR shall be a named constant of type C_PTR. The value of C_NULL_PTR shall be the
<P>
<PRE>
  same as the value NULL in C. The entity C_NULL_FUNPTR shall be a named constant of type C_FUNPTR.
<P>
  The value of C_NULL_FUNPTR shall be that of a null pointer to a function in C.
<P>
        NOTE 18.1
<P>
       The value of NEW_LINE(C_NEW_LINE) is C_NEW_LINE (16.9.140).
<P>
  18.2.3     Procedures in the module
<P>
  18.2.3.1    General
<P>
</PRE>
1 In the detailed descriptions below, procedure names are generic and not specific. The C_F_POINTER subroutine
<P>
<PRE>
  is impure; all other procedures in the module are pure.
<P>
  18.2.3.2      C_ASSOCIATED (C_PTR_1 [, C_PTR_2])
<P>
</PRE>
1 Description. Query C pointer status.
<P>
2 Class. Transformational function.
<P>
3 Arguments.
<P>
<PRE>
  C_PTR_1        shall be a scalar of type C_PTR or C_FUNPTR.
<P>
  C_PTR_2 (optional) shall be a scalar of the same type as C_PTR_1.
<P>
  480                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Result Characteristics. Default logical scalar.
<P>
5 Result Value.
<P>
<PRE>
  Case (i):     If C_PTR_2 is absent, the result is false if C_PTR_1 is a C null pointer and true otherwise.
<P>
  Case (ii):    If C_PTR_2 is present, the result is false if C_PTR_1 is a C null pointer. If C_PTR_1 is not a
<P>
                C null pointer, the result is true if C_PTR_1 compares equal to C_PTR_2 in the sense of 6.3.2.3
<P>
                and 6.5.9 of ISO/IEC 9899:2011, and false otherwise.
<P>
       NOTE 18.2
<P>
       The following example illustrates the use of C_LOC and C_ASSOCIATED.
<P>
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR, C_FLOAT, C_ASSOCIATED, C_LOC
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>FOO</B>(GAMMA) <B>BIND</B>(C)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; IMPORT C_PTR</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(C_PTR), VALUE :: GAMMA
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE FOO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>REAL</B>(C_FLOAT), TARGET, <B>DIMENSION</B>(100) :: ALPHA
<P>
<B>TYPE</B>(C_PTR) :: BETA
<P>
&#46;&#46;&#46;
<P>
IF (.NOT. <B>C_ASSOCIATED</B>(BETA)) THEN
<P>
<PRE>
         BETA = C_LOC(ALPHA)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ENDIF</H4>
</A>
<BLOCKQUOTE>
<P>
CALL <B>FOO</B>(BETA)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: CALL <B>FOO</B>(BETA)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>18.2.3.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_F_POINTER (CPTR, FPTR [, SHAPE])
<P>
1 Description. Associate a data pointer with the target of a C pointer and specify its shape.
<P>
2 Class. Subroutine.
<P>
3 Arguments.
<P>
<PRE>
  CPTR          shall be a scalar of type C_PTR. It is an INTENT (IN) argument. Its value shall be
<P>
                    • the C address of an interoperable data entity,
<P>
                    • the result of a reference to C_LOC with a noninteroperable argument, or
<P>
                    • the C address of a storage sequence that is not in use by any other Fortran entity.
<P>
                The value of CPTR shall not be the C address of a Fortran variable that does not have the TARGET
<P>
                attribute.
<P>
  FPTR          shall be a pointer, shall not have a deferred type parameter, and shall not be a coindexed object.
<P>
                It is an INTENT (OUT) argument. If FPTR is an array, its shape is specified by SHAPE and each
<P>
                lower bound is equal to 1.
<P>
                      Case (i):     If the value of CPTR is the C address of an interoperable data entity, FPTR
<P>
                                    shall be a data pointer with type and type parameter values interoperable with
<P>
                                    the type of the entity. If the target T of CPTR is scalar, FPTR becomes pointer
<P>
                                    associated with T; if FPTR is an array, SHAPE shall specify a size of 1. If T is
<P>
                                    an array, and FPTR is scalar, FPTR becomes associated with the first element of
<P>
                                    T. If both T and FPTR are arrays, SHAPE shall specify a size that is less than or
<P>
                                    equal to the size of T, and FPTR becomes associated with the first PRODUCT
<P>
                                    (SHAPE) elements of T (this could be the entirety of T).
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         481
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                   Case (ii):   If the value of CPTR is the result of a reference to C_LOC with a noninter-
<P>
                                operable effective argument X, FPTR shall be a nonpolymorphic pointer with
<P>
                                the same type and type parameters as X. In this case, X shall not have been
<P>
                                deallocated or have become undefined due to execution of a RETURN or END
<P>
                                statement since the reference. If X is scalar, FPTR becomes pointer associated
<P>
                                with X; if FPTR is an array, SHAPE shall specify a size of 1. If X is an array and
<P>
                                FPTR is scalar, FPTR becomes associated with the first element of X. If both X
<P>
                                and FPTR are arrays, SHAPE shall specify a size that is less than or equal to
<P>
                                the size of X, and FPTR becomes associated with the first PRODUCT (SHAPE)
<P>
                                elements of X (this could be the entirety of X).
<P>
                   Case (iii):  If the value of CPTR is the C address of a storage sequence that is not in use by
<P>
                                any other Fortran entity, FPTR becomes associated with that storage sequence.
<P>
                                If FPTR is an array, its shape is specified by SHAPE and each lower bound
<P>
                                is 1. The storage sequence shall be large enough to contain the target object
<P>
                                described by FPTR and shall satisfy any other processor-dependent requirement
<P>
                                for association.
<P>
  SHAPE (optional) shall be a rank-one integer array. It is an INTENT (IN) argument. SHAPE shall be present
<P>
              if and only if FPTR is an array; its size shall be equal to the rank of FPTR.
<P>
</PRE>
4 Examples.
<P>
<PRE>
  Case (i):   extern double c_x;
<P>
              void *address_of_x (void)
<P>
              {
<P>
                 return &c_x;
<P>
              }
<P>
              ! Assume interface to "address_of_x" is available.
<P>
              Real (C_double), Pointer :: xp
<P>
              Call C_F_Pointer (address_of_x (), xp)
<P>
  Case (ii):  Type t
<P>
                 Real, Allocatable :: v(:,:)
<P>
              End Type
<P>
              Type(t), Target :: x
<P>
              Type(C_ptr) :: xloc
<P>
              xloc = C_Loc (x)
<P>
              &#46;&#46;&#46;
<P>
              Type(t), Pointer :: y
<P>
              Call C_F_Pointer (xloc, y)
<P>
  Case (iii): void *getmem (int nbits)
<P>
              {
<P>
                  return malloc ((nbits+CHAR_BIT-1)/CHAR_BIT);
<P>
              }
<P>
              ! Assume interface to "getmem" is available,
<P>
              ! and there is a derived type "mytype" accessible.
<P>
              Type(mytype), Pointer :: x
<P>
              Call C_F_Pointer (getmem (Storage_Size (x)), x)
<P>
  482                                                              ⃝
<P>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  The following statements illustrate the use of C_F_POINTER when the pointer to be set has a deferred type
<P>
  parameter:
<P>
                 Character(42), Pointer :: C1
<P>
                 Character(:), Pointer :: C2
<P>
                 Call C_F_Pointer (CPTR, C1)
<P>
                 C2 =&gt; C1
<P>
  This will associate C2 with the entity at the C address specified by CPTR, and specify its length to be the same
<P>
  as that of C1.
<P>
       NOTE 18.3
<P>
       In the case of associating FPTR with a storage sequence, there might be processor-dependent requirements
<P>
       such as alignment of the memory address or placement in memory.
<P>
  18.2.3.4      C_F_PROCPOINTER (CPTR, FPTR)
<P>
</PRE>
1 Description. Associate a procedure pointer with the target of a C function pointer.
<P>
2 Class. Pure subroutine.
<P>
3 Arguments.
<P>
<PRE>
  CPTR          shall be a scalar of type C_FUNPTR. It is an INTENT (IN) argument. Its value shall be the C
<P>
                address of a procedure that is interoperable, or the result of a reference to the function C_FUNLOC
<P>
                from the intrinsic module ISO_C_BINDING.
<P>
  FPTR          shall be a procedure pointer, and shall not be a component of a coindexed object. It is an INTENT
<P>
                (OUT) argument. If the target of CPTR is interoperable, the interface for FPTR shall be interoper-
<P>
                able with the prototype that describes the target of CPTR; otherwise, the interface for FPTR shall
<P>
                have the same characteristics as that target. FPTR becomes pointer associated with the target of
<P>
                CPTR.
<P>
       NOTE 18.4
<P>
       The term “target” in the descriptions of C_F_POINTER and C_F_PROCPOINTER denotes the entity
<P>
       referenced by a C pointer, as described in 6.2.5 of ISO/IEC 9899:2011.
<P>
  18.2.3.5      C_FUNLOC (X)
<P>
</PRE>
1 Description. C address of the argument.
<P>
2 Class. Transformational function.
<P>
3 Argument. X shall be a procedure; if it is a procedure pointer it shall be associated. It shall not be a coindexed
<P>
<PRE>
  object.
<P>
</PRE>
4 Result Characteristics. Scalar of type C_FUNPTR.
<P>
5 Result Value. The result value is described using the result name FUNPTR. The result is determined as if
<P>
<PRE>
  C_FUNPTR were a derived type containing a procedure pointer component PX with an implicit interface and
<P>
  the pointer assignment FUNPTR%PX =&gt; X were executed.
<P>
</PRE>
6 The result is a value that can be used as an actual CPTR argument in a call to C_F_PROCPOINTER where
<P>
<PRE>
  the FPTR argument has attributes that would allow the pointer assignment FPTR =&gt; X. Such a call to C_F_-
<P>
  PROCPOINTER shall have the effect of the pointer assignment FPTR =&gt; X.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         483
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  18.2.3.6       C_LOC (X)
<P>
</PRE>
1 Description. C address of the argument.
<P>
2 Class. Transformational function.
<P>
3 Argument. X shall have either the POINTER or TARGET attribute. It shall not be a coindexed object. It
<P>
<PRE>
  shall either be a variable with interoperable type and kind type parameters, or be a nonpolymorphic variable
<P>
  with no length type parameters. If it is allocatable, it shall be allocated. If it is a pointer, it shall be associated.
<P>
  If it is an array, it shall be contiguous and have nonzero size. It shall not be a zero-length string.
<P>
</PRE>
4 Result Characteristics. Scalar of type C_PTR.
<P>
5 Result Value. The result value is described using the result name CPTR.
<P>
6 If X is a scalar data entity, the result is determined as if C_PTR were a derived type containing a scalar pointer
<P>
<PRE>
  component PX of the type and type parameters of X and the pointer assignment CPTR%PX =&gt; X were executed.
<P>
</PRE>
7 If X is an array data entity, the result is determined as if C_PTR were a derived type containing a scalar pointer
<P>
<PRE>
  component PX of the type and type parameters of X and the pointer assignment of CPTR%PX to the first
<P>
  element of X were executed.
<P>
</PRE>
8 If X is a data entity that is interoperable or has interoperable type and type parameters, the result is the value
<P>
<PRE>
  that the C processor returns as the result of applying the unary “&” operator (as defined in ISO/IEC 9899:2011,
<P>
  6.5.3.2) to the target of CPTR%PX.
<P>
</PRE>
9 The result is a value that can be used as an actual CPTR argument in a call to C_F_POINTER where FPTR
<P>
<PRE>
  has attributes that would allow the pointer assignment FPTR =&gt; X. Such a call to C_F_POINTER shall have
<P>
  the effect of the pointer assignment FPTR =&gt; X.
<P>
         NOTE 18.5
<P>
         Where the actual argument is of noninteroperable type or type parameters, the result of C_LOC provides
<P>
         an opaque “handle” for it. In an actual implementation, this handle might be the C address of the argument;
<P>
         however, only a C function that treats it as a void (generic) C pointer that cannot be dereferenced (6.5.3.2
<P>
         in ISO/IEC 9899:2011) is likely to be portable.
<P>
  18.2.3.7       C_SIZEOF (X)
<P>
</PRE>
1 Description. Size of X in bytes.
<P>
2 Class. Inquiry function.
<P>
3 Argument. X shall be an interoperable data entity that is not an assumed-size array or an assumed-rank array
<P>
<PRE>
  that is associated with an assumed-size array.
<P>
</PRE>
4 Result Characteristics. Scalar integer of kind C_SIZE_T (18.3.2).
<P>
5 Result Value. If X is scalar, the result value is the value that the companion processor returns as the result
<P>
<PRE>
  of applying the sizeof operator (ISO/IEC 9899:2011, subclause 6.5.3.4) to an object of a type that interoperates
<P>
  with the type and type parameters of X.
<P>
</PRE>
6 If X is an array, the result value is the value that the companion processor returns as the result of applying the
<P>
<PRE>
  sizeof operator to an object of a type that interoperates with the type and type parameters of X, multiplied by
<P>
  the number of elements in X.
<P>
  484                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  18.3      Interoperability between Fortran and C entities
<P>
  18.3.1     General
<P>
</PRE>
1 Subclause 18.3 defines the conditions under which a Fortran entity is interoperable. If a Fortran entity is inter-
<P>
<PRE>
  operable, an equivalent entity could be defined by means of C and the Fortran entity would interoperate with the
<P>
  C entity. There does not have to be such an interoperating C entity.
<P>
       NOTE 18.6
<P>
       A Fortran entity can be interoperable with more than one C entity.
<P>
  18.3.2     Interoperability of intrinsic types
<P>
</PRE>
1 Table 18.2 shows the interoperability between Fortran intrinsic types and C types. A Fortran intrinsic type with
<P>
<PRE>
  particular type parameter values is interoperable with a C type if the type and kind type parameter value are listed
<P>
  in the table on the same row as that C type. If the type is character, the length type parameter is interoperable
<P>
  if and only if its value is one. A combination of Fortran type and type parameters that is interoperable with a
<P>
  C type listed in the table is also interoperable with any unqualified C type that is compatible with the listed C
<P>
  type.
<P>
</PRE>
2 The second column of the table refers to the named constants made accessible by the ISO_C_BINDING intrinsic
<P>
<PRE>
  module. If the value of any of these named constants is negative, there is no combination of Fortran type and
<P>
  type parameters interoperable with the C type shown in that row.
<P>
</PRE>
3 A combination of intrinsic type and type parameters is interoperable if it is interoperable with a C type. The C
<P>
<PRE>
  types mentioned in table 18.2 are defined in subclauses 6.2.5, 7.19, and 7.20.1 of ISO/IEC 9899:2011.
<P>
                            Table 18.2: Interoperability between Fortran and C types
<P>
                             Named constant from the ISO_C_BINDING module
<P>
        Fortran type                                                                    C type
<P>
                             (kind type parameter if value is positive)
<P>
                             C_INT                                                      int
<P>
                             C_SHORT                                                    short int
<P>
                             C_LONG                                                     long int
<P>
                             C_LONG_LONG                                                long long int
<P>
                                                                                        signed char
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; C_SIGNED_CHAR</H4>
</A>
<BLOCKQUOTE>
<P>
unsigned char
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: unsigned char
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>C_SIZE_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
size_t
<TABLE width=100% cellpadding=3><!-- tsb: size_t
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>C_INT8_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
int8_t
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_INT16_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
int16_t
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_INT32_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
int32_t
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_INT64_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
int64_t
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_INT_LEAST8_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
int_least8_t
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_INT_LEAST16_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
int_least16_t
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_INT_LEAST32_T</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
int_least32_t
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INTEGER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_LEAST64_T                                            int_least64_t
</TD></TR>
<TR><TD colspan=2>
<PRE>
                             C_INT_FAST8_T                                              int_fast8_t
<P>
                             C_INT_FAST16_T                                             int_fast16_t
<P>
                             C_INT_FAST32_T                                             int_fast32_t
<P>
                             C_INT_FAST64_T                                             int_fast64_t
<P>
                             C_INTMAX_T                                                 intmax_t
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
485
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                              Interoperability between Fortran and C types                               (cont.)
<P>
</PRE>
Named constant from the ISO_C_BINDING module
<TABLE width=100% cellpadding=3><!-- tsb: Named constant from the ISO_C_BINDING module
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Fortran type</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C type
</TD></TR>
<TR><TD colspan=2>
<PRE>
                             (kind type parameter if value is positive)
<P>
                             C_INTPTR_T                                               intptr_t
<P>
                             C_PTRDIFF_T                                              ptrdiff_t
<P>
                             C_FLOAT                                                  float
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>REAL</B> </TD><TD valign=bottom>
C_DOUBLE                                                 double
</TD></TR>
<TR><TD colspan=2>
<PRE>
                             C_LONG_DOUBLE                                            long double
<P>
                             C_FLOAT_COMPLEX                                          float _Complex
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>COMPLEX</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_DOUBLE_COMPLEX                                         double _Complex
</TD></TR>
<TR><TD colspan=2>
<PRE>
                             C_LONG_DOUBLE_COMPLEX                                    long double _Complex
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LOGICAL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_BOOL                                                   _Bool
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CHARACTER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_CHAR                                                   char
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
NOTE 18.7
<TABLE width=100% cellpadding=3><!-- tsb: NOTE 18.7
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
ISO/IEC 9899:2011 specifies that the representations for nonnegative signed integers are the same as the
<P>
corresponding values of unsigned integers. Because Fortran does not provide direct support for unsigned
<P>
kinds of integers, the ISO_C_BINDING module does not make accessible named constants for their kind
<P>
type parameter values. A user can use the signed kinds of integers to interoperate with the unsigned types
<P>
and all their qualified versions as well. This has the potentially surprising side effect that the C type
<P>
unsigned char is interoperable with the type integer with a kind type parameter of C_SIGNED_CHAR.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>18.3.3</B> </TD><TD valign=bottom>
Interoperability with C pointer types
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 C_PTR and C_FUNPTR shall be derived types with only private components. No direct component of either
<P>
<PRE>
  of these types is allocatable or a pointer. C_PTR is interoperable with any C object pointer type. C_FUNPTR
<P>
  is interoperable with any C function pointer type.
<P>
        NOTE 18.8
<P>
        This means that only a C processor with the same representation method for all C object pointer types,
<P>
        and the same representation method for all C function pointer types, can be the target of interoperability
<P>
        of a Fortran processor. ISO/IEC 9899:2011 does not require this to be the case.
<P>
        NOTE 18.9
<P>
        The function C_LOC can be used to return a value of type C_PTR that is the C address of an allocated
<P>
        allocatable variable. The function C_FUNLOC can be used to return a value of type C_FUNPTR that is
<P>
        the C address of a procedure. For C_LOC and C_FUNLOC the returned value is of an interoperable type
<P>
        and thus can be used in contexts where the procedure or allocatable variable is not directly allowed. For
<P>
        example, it could be passed as an actual argument to a C function.
<P>
        Similarly, type C_FUNPTR or C_PTR can be used in a dummy argument or structure component and
<P>
        can have a value that is the C address of a procedure or allocatable variable, even in contexts where a
<P>
        procedure or allocatable variable is not directly allowed.
<P>
  18.3.4      Interoperability of derived types and C struct types
<P>
</PRE>
1 Interoperability between a derived type in Fortran and a struct type in C is provided by the BIND attribute on
<P>
<PRE>
  the Fortran type.
<P>
  C1801 (R726) A derived type with the BIND attribute shall not have the SEQUENCE attribute.
<P>
  486                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
  C1802 (R726) A derived type with the BIND attribute shall not have type parameters.
<P>
  C1803 (R726) A derived type with the BIND attribute shall not have the EXTENDS attribute.
<P>
  C1804 (R726) A derived-type-def that defines a derived type with the BIND attribute shall not have a type-
<P>
            bound-procedure-part.
<P>
  C1805 (R726) A derived type with the BIND attribute shall have at least one component.
<P>
  C1806 (R726) Each component of a derived type with the BIND attribute shall be a nonpointer, nonallocatable
<P>
            data component with interoperable type and type parameters.
<P>
        NOTE 18.10
<P>
        The syntax rules and their constraints require that a derived type that is interoperable with a C struct
<P>
        type have components that are all data entities that are interoperable. No component is permitted to be
<P>
        allocatable or a pointer, but the value of a component of type C_FUNPTR or C_PTR can be the C address
<P>
        of such an entity.
<P>
</PRE>
2 A derived type is interoperable with a C struct type if and only if the derived type has the BIND attribute (7.5.2),
<P>
<PRE>
  the derived type and the C struct type have the same number of components, and the components of the derived
<P>
  type would interoperate with corresponding components of the C struct type as described in 18.3.5 and 18.3.6 if
<P>
  the components were variables. A component of a derived type and a component of a C struct type correspond
<P>
  if they are declared in the same relative position in their respective type definitions.
<P>
        NOTE 18.11
<P>
        The names of the corresponding components of the derived type and the C struct type need not be the
<P>
        same.
<P>
</PRE>
3 There is no Fortran type that is interoperable with a C struct type that contains a bit field or that contains a
<P>
<PRE>
  flexible array member. There is no Fortran type that is interoperable with a C union type.
<P>
        NOTE 18.12
<P>
        For example, the C type myctype, declared below, is interoperable with the Fortran type myftype, declared
<P>
        below.
<P>
        typedef struct {
<P>
           int m, n;
<P>
           float r;
<P>
        } myctype;
<P>
        USE, INTRINSIC :: ISO_C_BINDING
<P>
        TYPE, BIND(C) :: MYFTYPE
<P>
           INTEGER(C_INT) :: I, J
<P>
           REAL(C_FLOAT) :: S
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE MYFTYPE</H4>
</A>
<BLOCKQUOTE>
<P>
The names of the types and the names of the components are not significant for the purposes of determining
<P>
whether a Fortran derived type is interoperable with a C struct type.
<P>
NOTE 18.13
<P>
ISO/IEC 9899:2011 requires the names and component names to be the same in order for the types to be
<P>
compatible (ISO/IEC 9899:2011, subclause 6.2.7). This is similar to Fortran’s rule describing when different
<P>
derived type definitions describe the same sequence type. This rule was not extended to determine whether
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: derived type definitions describe the same sequence type. This rule was not extended to determine whether
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
487
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
         NOTE 18.13 (cont.)
<P>
         a Fortran derived type is interoperable with a C struct type because the case of identifiers is significant in
<P>
         C but not in Fortran.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>18.3.5</B> </TD><TD valign=bottom>
Interoperability of scalar variables
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 A named scalar Fortran variable is interoperable if and only if its type and type parameters are interoperable, it
</TD></TR>
<TR><TD colspan=2>
<PRE>
  is not a coarray, it has neither the ALLOCATABLE nor the POINTER attribute, and if it is of type character
<P>
  its length is not assumed or declared by an expression that is not a constant expression.
<P>
</PRE>
2 An interoperable scalar Fortran variable is interoperable with a scalar C entity if their types and type parameters
</TD></TR>
<TR><TD colspan=2>
<PRE>
  are interoperable.
<P>
  18.3.6        Interoperability of array variables
<P>
</PRE>
1 A Fortran variable that is a named array is interoperable if and only if its type and type parameters are interop-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  erable, it is not a coarray, it is of explicit shape or assumed size, and if it is of type character its length is not
<P>
  assumed or declared by an expression that is not a constant expression.
<P>
                                                                                      
<P>
</PRE>
2 An explicit-shape or assumed-size array of rank r, with a shape of e1 . . . er is interoperable with a C array
</TD></TR>
<TR><TD colspan=2>
<PRE>
  if its size is nonzero and
<P>
           (1)   either
<P>
                 (a)    the array is assumed-size, and the C array does not specify a size, or
<P>
                 (b)    the array is an explicit-shape array, and the extent of the last dimension (er ) is the same as
<P>
                        the size of the C array, and
<P>
           (2)   either
<P>
                 (a)    r is equal to one, and an element of the array is interoperable with an element of the C array,
<P>
                        or
<P>
                                                                                                            
<P>
                 (b)    r is greater than one, and an explicit-shape array with shape of e1 . . . er−1 , with the
<P>
                        same type and type parameters as the original array, is interoperable with a C array of a type
<P>
                        equal to the element type of the original C array.
<P>
         NOTE 18.14
<P>
         An element of a multi-dimensional C array is an array type, so a Fortran array of rank one is not interop-
<P>
         erable with a multidimensional C array.
<P>
         NOTE 18.15
<P>
         An allocatable array or array pointer is never interoperable. Such an array does not meet the requirement
<P>
         of being an explicit-shape or assumed-size array.
<P>
         NOTE 18.16
<P>
         For example, a Fortran array declared as
<P>
         INTEGER(C_INT) :: A(18, 3:7, *)
<P>
         is interoperable with a C array declared as
<P>
         int b[][5][18];
<P>
  488                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
       NOTE 18.17
<P>
       The C programming language defines null-terminated strings, which are actually arrays of the C type char
<P>
       that have a C null character in them to indicate the last valid element. A Fortran array of type character
<P>
       with a kind type parameter equal to C_CHAR is interoperable with a C string.
<P>
       Fortran’s rules of sequence association (15.5.2.11) permit a character scalar actual argument to correspond
<P>
       to a dummy argument array. This makes it possible to argument associate a Fortran character string with
<P>
       a C string.
<P>
       NOTE 18.21 has an example of interoperation between Fortran and C strings.
<P>
  18.3.7     Interoperability of procedures and procedure interfaces
<P>
</PRE>
1 A Fortran procedure is interoperable if and only if it has the BIND attribute, that is, if its interface is specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  with a proc-language-binding-spec.
<P>
</PRE>
2 A Fortran procedure interface is interoperable with a C function prototype if
</TD></TR>
<TR><TD colspan=2>
<PRE>
         (1)   the interface has the BIND attribute,
<P>
         (2)   either
<P>
               (a)    the interface describes a function whose result is a scalar variable that is interoperable with
<P>
                      the result of the prototype or
<P>
               (b)    the interface describes a subroutine and the prototype has a result type of void,
<P>
         (3)   the number of dummy arguments of the interface is equal to the number of formal parameters of the
<P>
               prototype,
<P>
         (4)   any scalar dummy argument with the VALUE attribute is interoperable with the corresponding
<P>
               formal parameter of the prototype,
<P>
         (5)   any dummy argument without the VALUE attribute corresponds to a formal parameter of the pro-
<P>
               totype that is of a pointer type, and either
<P>
                   • the dummy argument is interoperable with an entity of the referenced type (ISO/IEC 9899:2011,
<P>
                      6.2.5, 7.19, and 7.20.1) of the formal parameter,
<P>
                   • the dummy argument is a nonallocatable nonpointer variable of type CHARACTER with
<P>
                      assumed character length and the formal parameter is a pointer to CFI_cdesc_t,
<P>
                   • the dummy argument is allocatable, assumed-shape, assumed-rank, or a pointer without the
<P>
                      CONTIGUOUS attribute, and the formal parameter is a pointer to CFI_cdesc_t, or
<P>
                   • the dummy argument is assumed-type and not allocatable, assumed-shape, assumed-rank, or
<P>
                      a pointer, and the formal parameter is a pointer to void,
<P>
         (6)   each allocatable or pointer dummy argument of type CHARACTER has deferred character length,
<P>
               and
<P>
         (7)   the prototype does not have variable arguments as denoted by the ellipsis (&#46;&#46;&#46;).
<P>
</PRE>
NOTE 18.18
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
The referenced type of a C pointer type is the C type of the object that the C pointer type points to.
<P>
For example, the referenced type of the pointer type int * is int.
<P>
NOTE 18.19
<P>
The C language allows specification of a C function that can take a variable number of arguments (ISO/IEC
<P>
9899:2011, 7.16). This document does not provide a mechanism for Fortran procedures to interoperate with
<P>
such C functions.
</TD></TR>
<TR></TR></TABLE>3 A formal parameter of a C function prototype corresponds to a dummy argument of a Fortran interface if they
<P>
<PRE>
  are in the same relative positions in the C parameter list and the dummy argument list, respectively.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           489
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 In a reference from C to a Fortran procedure with an interoperable interface, a C actual argument shall be the
<P>
<PRE>
  address of a C descriptor for the intended effective argument if the corresponding dummy argument interoperates
<P>
  with a C formal parameter that is a pointer to CFI_cdesc_t. In this C descriptor, the members other than
<P>
  attribute and type shall describe an object with the same characteristics as the intended effective argument.
<P>
  The value of the attribute member of the C descriptor shall be compatible with the characteristics of the dummy
<P>
  argument. The type member shall have a value that depends on the intended effective argument as follows:
<P>
      • if the dynamic type of the intended effective argument is an interoperable type listed in Table 18.4, the
<P>
        corresponding value for that type;
<P>
      • if the dynamic type of the intended effective argument is an intrinsic type for which the processor defines
<P>
        a nonnegative type specifier value not listed in Table 18.4, that type specifier value;
<P>
      • otherwise, CFI_type_other.
<P>
</PRE>
5 When an interoperable Fortran procedure with a simply contiguous dummy argument is invoked from C and the
<P>
<PRE>
  actual argument is the address of a C descriptor for a discontiguous object, the Fortran processor shall handle
<P>
  the difference in contiguity.
<P>
</PRE>
6 When an interoperable C procedure whose Fortran interface has a simply contiguous dummy argument is invoked
<P>
<PRE>
  from Fortran and the effective argument is discontiguous, the Fortran processor shall ensure that the C procedure
<P>
  receives a descriptor for a contiguous object.
<P>
</PRE>
7 When an interoperable C procedure whose Fortran interface has a simply contiguous dummy argument is invoked
<P>
<PRE>
  from C, and the actual argument is the address of a C descriptor for a discontiguous object, the C code within
<P>
  the procedure shall be prepared to handle the discontiguous argument.
<P>
</PRE>
8 If an interoperable procedure defined by means other than Fortran has an optional dummy argument, and the
<P>
<PRE>
  corresponding actual argument in a reference from Fortran is absent, the procedure is invoked with a null pointer
<P>
  for that argument. If an interoperable procedure defined by means of Fortran is invoked by a C function, an
<P>
  optional dummy argument is absent if and only if the corresponding argument in the invocation is a null pointer.
<P>
       NOTE 18.20
<P>
       For example, a Fortran procedure interface described by
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION <B>FUNC</B>(I, J, K, L, M) <B>BIND</B>(C)
<P>
<PRE>
             USE, INTRINSIC :: ISO_C_BINDING
<P>
             INTEGER(C_SHORT) :: FUNC
<P>
             INTEGER(C_INT), VALUE :: I
<P>
             REAL(C_DOUBLE) :: J
<P>
             INTEGER(C_INT) :: K, L(10)
<P>
             TYPE(C_PTR), VALUE :: M
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION FUNC</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
is interoperable with the C function prototype
<P>
short <B>func</B>(int i, double *j, int *k, int l[10], void *m);
<P>
A C pointer can correspond to a Fortran dummy argument of type C_PTR with the VALUE attribute or
<P>
to a Fortran scalar that does not have the VALUE attribute. In the above example, the C pointers j and
<P>
k correspond to the Fortran scalars J and K, respectively, and the C pointer m corresponds to the Fortran
<P>
dummy argument M of type C_PTR.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: dummy argument M of type C_PTR.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>490</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 18.21
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
The interoperability of Fortran procedure interfaces with C function prototypes is only one part of invocation
<P>
of a C function from Fortran. There are four pieces to consider in such an invocation: the procedure
<P>
reference, the Fortran procedure interface, the C function prototype, and the C function. Conversely,
<P>
the invocation of a Fortran procedure from C involves the function reference, the C function prototype,
<P>
the Fortran procedure interface, and the Fortran procedure. In order to determine whether a reference is
<P>
allowed, it is necessary to consider all four pieces.
<P>
For example, consider a C function that can be described by the C function prototype
<P>
void <B>copy</B>(char in[], char out[]);
<P>
Such a function can be invoked from Fortran as follows:
<P>
<PRE>
          USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR, C_NULL_CHAR
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>COPY</B>(IN, OUT) <B>BIND</B>(C)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; IMPORT C_CHAR</H4>
</A>
<BLOCKQUOTE>
<P>
<B>CHARACTER</B>(KIND=C_CHAR), <B>DIMENSION</B>(*) :: IN, OUT
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE COPY</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>CHARACTER</B>(LEN=10, KIND=C_CHAR) :: &
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <B>CHARACTER</B>(LEN=10, KIND=C_CHAR) :: &
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>&</B> </TD><TD valign=bottom>
DIGIT_STRING = C_CHAR_’123456789’ // C_NULL_CHAR
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
          CHARACTER(KIND=C_CHAR) :: DIGIT_ARR(10)
<P>
          CALL COPY(DIGIT_STRING, DIGIT_ARR)
<P>
          PRINT ’(1X, A1)’, DIGIT_ARR(1:9)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
The procedure reference has character string actual arguments. These correspond to character array dummy
<P>
arguments in the procedure interface body as allowed by Fortran’s rules of sequence association (15.5.2.11).
<P>
Those array dummy arguments in the procedure interface are interoperable with the formal parameters of
<P>
the C function prototype. The C function is not shown here, but is assumed to be compatible with the C
<P>
function prototype.
<P>
NOTE 18.22
<P>
The requirements on the Fortran processor when a discontiguous actual argument is being passed to a
<P>
simply contiguous dummy argument are such that the C programmer has the same functionality (and
<P>
safety) as the Fortran programmer, when either the calling or called procedure are Fortran procedures. The
<P>
requirements on the C procedure, in the case when both the called and calling procedure are C procedures,
<P>
effectively require that the C procedure not access memory through the descriptor that is not described by
<P>
the descriptor; otherwise the program will not conform to this document. A dummy argument is simply
<P>
contiguous if it has the CONTIGUOUS attribute or is an array that is not assumed-shape, assumed-rank,
<P>
or a pointer.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: or a pointer.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>18.4</B> </TD><TD valign=bottom>
C descriptors
<P>
1 A C descriptor is a C structure of type CFI_cdesc_t. Together with library functions that have standard
<P>
<PRE>
  prototypes, it provides a means for describing and manipulating Fortran data objects from within a C function.
<P>
  This C structure is defined in the source file ISO_Fortran_binding.h.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          491
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  18.5       The source file ISO_Fortran_binding.h
<P>
  18.5.1      Summary of contents
<P>
</PRE>
1 The source file ISO_Fortran_binding.h shall contain the C structure definitions, typedef declarations, macro
<P>
<PRE>
  definitions, and function prototypes specified in subclauses 18.5.2 to 18.5.5. The definitions and declarations in
<P>
  ISO_Fortran_binding.h can be used by a C function to interpret and manipulate a C descriptor. These provide
<P>
  a means to specify a C prototype that interoperates with a Fortran interface that has a non-interoperable dummy
<P>
  variable (18.3.7).
<P>
</PRE>
2 The source file ISO_Fortran_binding.h may be included in any order relative to the standard C headers, and
<P>
<PRE>
  may be included more than once in a given scope, with no effect different from being included only once, other
<P>
  than the effect on line numbers.
<P>
</PRE>
3 A C source file that includes the ISO_Fortran_binding.h header file shall not use any names starting with
<P>
<PRE>
  CFI_ that are not defined in the header, and shall not define any of the structure names defined in the header
<P>
  as macro names. All names other than structure member names defined in the header begin with CFI_ or an
<P>
  underscore character, or are defined by a standard C header that it includes.
<P>
  18.5.2      The CFI_dim_t structure type
<P>
</PRE>
1 CFI_dim_t is a typedef name for a C structure. It is used to represent lower bound, extent, and memory stride
<P>
<PRE>
  information for one dimension of an array. The type CFI_index_t is described in 18.5.4. CFI_dim_t contains
<P>
  at least the following members in any order.
<P>
  CFI_index_t lower_bound; The value is equal to the value of the lower bound for the dimension being
<P>
        described.
<P>
  CFI_index_t extent; The value is equal to the number of elements in the dimension being described, or −1
<P>
        for the final dimension of an assumed-size array.
<P>
  CFI_index_t sm; The value is equal to the memory stride for a dimension; this is the difference in bytes
<P>
        between the addresses of successive elements in the dimension being described.
<P>
  18.5.3      The CFI_cdesc_t structure type
<P>
</PRE>
1 CFI_cdesc_t is a typedef name for a C structure, which contains a flexible array member. It shall contain at least
<P>
<PRE>
  the members described in this subclause. The values of these members of a structure of type CFI_cdesc_t that
<P>
  is produced by the functions and macros specified in this document, or received by a C function when invoked
<P>
  by a Fortran procedure, shall have the properties described in this subclause.
<P>
</PRE>
2 The first three members of the structure shall be base_addr, elem_len, and version in that order. The final
<P>
<PRE>
  member shall be dim. All other members shall be between version and dim, in any order. The types CFI_-
<P>
  attribute_t, CFI_rank_t, and CFI_type_t are described in 18.5.4. The type CFI_dim_t is described in 18.5.2.
<P>
  void * base_addr; If the object is an unallocated allocatable variable or a pointer that is disassociated, the
<P>
        value is a null pointer. If the object has zero size, the value is not a null pointer but is otherwise processor-
<P>
        dependent. Otherwise, the value is the base address of the object being described. The base address of a
<P>
        scalar is its C address. The base address of an array is the C address of the first element in Fortran array
<P>
        element order.
<P>
  size_t elem_len; If the object is scalar, the value is the storage size in bytes of the object; otherwise, the value
<P>
        is the storage size in bytes of an element of the object.
<P>
  int version; The value is equal to the value of CFI_VERSION in the source file ISO_Fortran_binding.h that
<P>
        defined the format and meaning of this C descriptor when the descriptor was established.
<P>
  492                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
  CFI_rank_t rank; The value is equal to the number of dimensions of the Fortran object being described; if
<P>
        the object is scalar, the value is zero.
<P>
  CFI_type_t type; The value is equal to the specifier for the type of the object. Each interoperable intrinsic C
<P>
        type has a specifier. Specifiers are also provided to indicate that the type of the object is an interoperable
<P>
        structure, or is unknown. The macros listed in Table 18.4 provide values that correspond to each specifier.
<P>
  CFI_attribute_t attribute; The value is equal to the value of an attribute code that indicates whether the
<P>
        object described is allocatable, a data pointer, or a nonallocatable nonpointer data object. The macros
<P>
        listed in Table 18.3 provide values that correspond to each code.
<P>
  CFI_dim_t dim; The number of elements in the dim array is equal to the rank of the object. Each element of
<P>
        the array contains the lower bound, extent, and memory stride information for the corresponding dimension
<P>
        of the Fortran object.
<P>
</PRE>
3 For a C descriptor of an array pointer or allocatable array, the value of the lower_bound member of each element
<P>
<PRE>
  of the dim member of the descriptor is determined by argument association, allocation, or pointer association.
<P>
  For a C descriptor of a nonallocatable nonpointer object, the value of the lower_bound member of each element
<P>
  of the dim member of the descriptor is zero.
<P>
</PRE>
4 There shall be an ordering of the dimensions such that the absolute value of the sm member of the first dimension
<P>
<PRE>
  is not less than the elem_len member of the C descriptor and the absolute value of the sm member of each
<P>
  subsequent dimension is not less than the absolute value of the sm member of the previous dimension multiplied
<P>
  by the extent of the previous dimension.
<P>
</PRE>
5 In a C descriptor of an assumed-size array, the extent member of the last element of the dim member has the
<P>
<PRE>
  value −1.
<P>
       NOTE 18.23
<P>
       The reason for the restriction on the absolute values of the sm members is to ensure that there is no overlap
<P>
       between the elements of the array that is being described, while allowing for the reordering of subscripts.
<P>
       Within Fortran, such a reordering can be achieved with the intrinsic function TRANSPOSE or the intrinsic
<P>
       function RESHAPE with the optional argument ORDER, and an optimizing compiler can accommodate it
<P>
       without making a copy by constructing the appropriate descriptor whenever it can determine that a copy
<P>
       is not needed.
<P>
       NOTE 18.24
<P>
       The value of elem_len for a Fortran CHARACTER object is equal to the character length times the number
<P>
       of bytes of a single character of that kind. If the kind is C_CHAR, this value will be equal to the character
<P>
       length.
<P>
  18.5.4      Macros and typedefs in ISO_Fortran_binding.h
<P>
</PRE>
1 Except for CFI_CDESC_T, each macro defined in ISO_Fortran_binding.h expands to an integer constant
<P>
<PRE>
  expression that is either a single token or a parenthesized expression that is suitable for use in #if preprocessing
<P>
  directives.
<P>
</PRE>
2 CFI_CDESC_T is a function-like macro that takes one argument, which is the rank of the C descriptor to create,
<P>
<PRE>
  and evaluates to an unqualified type of suitable size and alignment for defining a variable to use as a C descriptor
<P>
  of that rank. The argument shall be an integer constant expression with a value that is greater than or equal to
<P>
  zero and less than or equal to CFI_MAX_RANK. A pointer to a variable declared using CFI_CDESC_T can
<P>
  be cast to CFI_cdesc_t *. A variable declared using CFI_CDESC_T shall not have an initializer.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          493
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 18.25
<P>
        The CFI_CDESC_T macro provides the memory for a C descriptor. The address of an entity declared
<P>
        using the macro is not usable as an actual argument corresponding to a formal parameter of type CFI_-
<P>
        cdesc_t * without an explicit cast. For example, the following code uses CFI_CDESC_T to declare a C
<P>
        descriptor of rank 5 and pass it to CFI_deallocate (18.5.5.4).
<P>
               CFI_CDESC_T(5) object;
<P>
               int ind;
<P>
               &#46;&#46;&#46; code to define and use C descriptor ...
<P>
               ind = CFI_deallocate((CFI_cdesc_t *)&object);
<P>
</PRE>
3 CFI_index_t is a typedef name for a standard signed integer type capable of representing the result of subtracting
<P>
<PRE>
   two pointers.
<P>
</PRE>
4 The CFI_MAX_RANK macro has a processor-dependent value equal to the largest rank supported. The value
<P>
<PRE>
   shall be greater than or equal to 15. CFI_rank_t is a typedef name for a standard integer type capable of
<P>
   representing the largest supported rank.
<P>
</PRE>
5 The CFI_VERSION macro has a processor-dependent value that encodes the version of the ISO_Fortran_-
<P>
<PRE>
   binding.h source file containing this macro. This value should be increased if a new version of the source file is
<P>
   incompatible with the previous version.
<P>
</PRE>
6 The macros in Table 18.3 are for use as attribute codes. The values shall be nonnegative and distinct. CFI_-
<P>
<PRE>
   attribute_t is a typedef name for a standard integer type capable of representing the values of the attribute
<P>
   codes.
<P>
                        Table 18.3: ISO_Fortran_binding.h macros for attribute codes
<P>
                                        Macro name                      Attribute
<P>
                                CFI_attribute_pointer          data pointer
<P>
                                CFI_attribute_allocatable      allocatable
<P>
                                CFI_attribute_other            nonallocatable nonpointer
<P>
</PRE>
7 CFI_attribute_pointer specifies a data object with the Fortran POINTER attribute. CFI_attribute_allocatable
<P>
<PRE>
   specifies an object with the Fortran ALLOCATABLE attribute. CFI_attribute_other specifies a nonallocatable
<P>
   nonpointer object.
<P>
</PRE>
8 The macros in Table 18.4 are for use as type specifiers. The value for CFI_type_other shall be negative and
<P>
<PRE>
   distinct from all other type specifiers. CFI_type_struct specifies a C structure that is interoperable with a
<P>
   Fortran derived type; its value shall be positive and distinct from all other type specifiers. If a C type is not
<P>
   interoperable with a Fortran type and kind supported by the Fortran processor, its macro shall evaluate to a
<P>
   negative value. Otherwise, the value for an intrinsic type shall be positive.
<P>
</PRE>
9 If the processor supports interoperability of a Fortran intrinsic type with a C type not listed in Table 18.4,
<P>
<PRE>
   the processor shall define a type specifier value for that type which is positive and distinct from all other type
<P>
   specifiers.
<P>
</PRE>
10 CFI_type_t is a typedef name for a standard integer type capable of representing the values for the supported
<P>
<PRE>
   type specifiers.
<P>
                           Table 18.4: ISO_Fortran_binding.h macros for type codes
<P>
                                        Macro name                            C Type
<P>
                             CFI_type_signed_char                   signed char
<P>
                             CFI_type_short                         short int
<P>
   494                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
                             ISO_Fortran_binding.h macros for type codes              (cont.)
<P>
                                        Macro name                         C Type
<P>
                             CFI_type_int                         int
<P>
                             CFI_type_long                        long int
<P>
                             CFI_type_long_long                   long long int
<P>
                             CFI_type_size_t                      size_t
<P>
                             CFI_type_int8_t                      int8_t
<P>
                             CFI_type_int16_t                     int16_t
<P>
                             CFI_type_int32_t                     int32_t
<P>
                             CFI_type_int64_t                     int64_t
<P>
                             CFI_type_int_least8_t                int_least8_t
<P>
                             CFI_type_int_least16_t               int_least16_t
<P>
                             CFI_type_int_least32_t               int_least32_t
<P>
                             CFI_type_int_least64_t               int_least64_t
<P>
                             CFI_type_int_fast8_t                 int_fast8_t
<P>
                             CFI_type_int_fast16_t                int_fast16_t
<P>
                             CFI_type_int_fast32_t                int_fast32_t
<P>
                             CFI_type_int_fast64_t                int_fast64_t
<P>
                             CFI_type_intmax_t                    intmax_t
<P>
                             CFI_type_intptr_t                    intptr_t
<P>
                             CFI_type_ptrdiff_t                   ptrdiff_t
<P>
                             CFI_type_float                       float
<P>
                             CFI_type_double                      double
<P>
                             CFI_type_long_double                 long double
<P>
                             CFI_type_float_Complex               float _Complex
<P>
                             CFI_type_double_Complex              double _Complex
<P>
                             CFI_type_long_double_Complex         long double _Complex
<P>
                             CFI_type_Bool                        _Bool
<P>
                             CFI_type_char                        char
<P>
                             CFI_type_cptr                        void *
<P>
                             CFI_type_struct                      interoperable C structure
<P>
                             CFI_type_other                       Not otherwise specified
<P>
        NOTE 18.26
<P>
        The values for different C types can be the same; for example, CFI_type_int and CFI_type_int32_t might
<P>
        have the same value.
<P>
</PRE>
11 The macros in Table 18.5 are for use as error codes. The macro CFI_SUCCESS shall be defined to be the integer
<P>
<PRE>
   constant 0. The value of each macro other than CFI_SUCCESS shall be nonzero and shall be different from the
<P>
   values of the other macros specified in this subclause. Error conditions other than those listed in this subclause
<P>
   should be indicated by error codes different from the values of the macros named in this subclause.
<P>
</PRE>
12 The values of the macros in Table 18.5 indicate the error condition described.
<P>
<PRE>
                           Table 18.5: ISO_Fortran_binding.h macros for error codes
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Macro name</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Error condition
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_SUCCESS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
No error detected.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_ERROR_BASE_ADDR_NULL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The base address member of a C descriptor is a null pointer
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                      in a context that requires a non-null pointer value.
<P>
</PRE>
CFI_ERROR_BASE_ADDR_NOT_NULL In a context that requires a null pointer value, the base
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                      address member of a C descriptor is not a null pointer.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_INVALID_ELEM_LEN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The value supplied for the element length member of a
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                      C descriptor is not valid.
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
495
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            ISO_Fortran_binding.h macros for error codes                                         (cont.)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Macro name</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Error condition
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_INVALID_RANK</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The value supplied for the rank member of a C descriptor is
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                       not valid.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_INVALID_TYPE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The value supplied for the type member of a C descriptor is
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                       not valid.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_INVALID_ATTRIBUTE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The value supplied for the attribute member of a
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                       C descriptor is not valid.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_INVALID_EXTENT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The value supplied for the extent member of a CFI_dim_t
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                       structure is not valid.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_INVALID_DESCRIPTOR</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
A C descriptor is invalid in some way.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_ERROR_MEM_ALLOCATION</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Memory allocation failed.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_ERROR_OUT_OF_BOUNDS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
A reference is out of bounds.
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>18.5.5</B> </TD><TD valign=bottom>
Functions declared in ISO_Fortran_binding.h
</TD></TR>
<TR valign=top><TD colspan=2>
<B>18.5.5.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Arguments and results of the functions
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Some of the functions described in 18.5.5 return an error indicator; this is an integer value that indicates whether
</TD></TR>
<TR><TD colspan=2>
<PRE>
  an error condition was detected. The value zero indicates that no error condition was detected, and a nonzero
<P>
  value indicates which error condition was detected. Table 18.5 lists standard error conditions and macro names
<P>
  for their corresponding error codes. A processor is permitted to detect other error conditions. If an invocation of
<P>
  a function defined in 18.5.5 could detect more than one error condition and an error condition is detected, which
<P>
  error condition is detected is processor dependent.
<P>
</PRE>
2 In function arguments representing subscripts, bounds, extents, or strides, the ordering of the elements is the
</TD></TR>
<TR><TD colspan=2>
<PRE>
  same as the ordering of the elements of the dim member of a C descriptor.
<P>
</PRE>
3 Prototypes for these functions, or equivalent macros, are provided in the ISO_Fortran_binding.h file as described
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in 18.5.5. It is unspecified whether the functions defined by this header are macros or identifiers declared with
<P>
  external linkage. If a macro definition is suppressed in order to access an actual function, the behavior is undefined.
<P>
       NOTE 18.27
<P>
       These functions are allowed to be macros to provide extra implementation flexibility. For example, CFI_-
<P>
       establish could include the value of CFI_VERSION in the header used to compile the call to CFI_establish
<P>
       as an extra argument of the actual function used to establish the C descriptor.
<P>
  18.5.5.2      The CFI_address function
<P>
</PRE>
1 Synopsis. C address of an object described by a C descriptor.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  void *CFI_address(const CFI_cdesc_t *dv, const CFI_index_t subscripts[]);
<P>
</PRE>
2 Formal Parameters.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  dv             shall be the address of a C descriptor describing the object. The object shall not be an unallocated
<P>
                 allocatable variable or a pointer that is not associated.
<P>
  subscripts shall be a null pointer or the address of an array of type CFI_index_t. If the object is an array,
<P>
                 subscripts shall be the address of an array of CFI_index_t with at least n elements, where n
<P>
                 is the rank of the object. The value of subscripts[i] shall be within the bounds of dimension i
<P>
                 specified by the dim member of the C descriptor except for the last dimension of a C descriptor for
<P>
                 an assumed-size array. For the C descriptor of an assumed-size array, the value of the subscript for
<P>
                 the last dimension shall not be less than the lower bound, and the subscript order value specified
<P>
                 by the subscripts shall not exceed the size of the array.
<P>
  496                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 Result Value. If the object is an array of rank n, the result is the C address of the element of the object that
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the first n elements of the subscripts argument would specify if used as subscripts. If the object is scalar, the
<P>
  result is its C address.
<P>
</PRE>
4 Example. If dv is the address of a C descriptor for the Fortran array A declared as
</TD></TR>
<TR><TD colspan=2>
<PRE>
             REAL(C_FLOAT) :: A(100, 100)
<P>
</PRE>
the following code calculates the C address of <B>A</B>(5, 10):
</TD></TR>
<TR><TD colspan=2>
<PRE>
             CFI_index_t subscripts[2];
<P>
             float *address;
<P>
             subscripts[0] = 4;
<P>
             subscripts[1] = 9;
<P>
             address = (float *) CFI_address(dv, subscripts );
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>18.5.5.3</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The CFI_allocate function
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Synopsis. Allocate memory for an object described by a C descriptor.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  int CFI_allocate(CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],
<P>
                        const CFI_index_t upper_bounds[], size_t elem_len);
<P>
</PRE>
2 Formal Parameters.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  dv             shall be the address of a C descriptor specifying the rank and type of the object. The base_-
<P>
                 addr member of the C descriptor shall be a null pointer. If the type is not a character type, the
<P>
                 elem_len member shall specify the element length. The attribute member shall have a value of
<P>
                 CFI_attribute_allocatable or CFI_attribute_pointer.
<P>
  lower_bounds shall be the address of an array with at least dv-&gt;rank elements, if dv-&gt;rank&gt;0.
<P>
  upper_bounds shall be the address of an array with at least dv-&gt;rank elements, if dv-&gt;rank&gt;0.
<P>
  elem_len       If the type specified in the C descriptor type is a Fortran character type, the value of elem_len
<P>
                 shall be the storage size in bytes of an element of the object; otherwise, elem_len is ignored.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>3 Description.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Successful execution of CFI_allocate allocates memory for the object described by the C
</TD></TR>
<TR><TD colspan=2>
<PRE>
  descriptor with the address dv using the same mechanism as the Fortran ALLOCATE statement, and assigns the
<P>
  address of that memory to dv-&gt;base_addr. The first dv-&gt;rank elements of the lower_bounds and upper_bounds
<P>
  arguments provide the lower and upper Fortran bounds, respectively, for each corresponding dimension of the
<P>
  object. The supplied lower and upper bounds override any current dimension information in the C descriptor.
<P>
  If the rank is zero, the lower_bounds and upper_bounds arguments are ignored. If the type specified in the C
<P>
  descriptor is a character type, the supplied element length overrides the current element-length information in
<P>
  the descriptor.
<P>
  If an error is detected, the C descriptor is not modified.
<P>
</PRE>
4 Result Value. The result is an error indicator.
</TD></TR>
<TR><TD colspan=2>
5 Example. If dv is the address of a C descriptor for the Fortran array A declared as
</TD></TR>
<TR><TD colspan=2>
<PRE>
             REAL, ALLOCATABLE :: A(:, :)
<P>
</PRE>
and the array is not allocated, the following code allocates it to be of shape [100, 500]:
</TD></TR>
<TR><TD colspan=2>
<PRE>
             CFI_index_t lower[2], upper[2];
<P>
             int ind;
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
497
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
            lower[0] = 1; lower[1] = 1;
<P>
            upper[0] = 100; upper[1] = 500;
<P>
            ind = CFI_allocate(dv, lower, upper, 0);
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>18.5.5.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The CFI_deallocate function
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Synopsis. Deallocate memory for an object described by a C descriptor.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  int CFI_deallocate(CFI_cdesc_t *dv);
<P>
</PRE>
2 Formal Parameter. dv shall be the address of a C descriptor describing the object. It shall have been allocated
</TD></TR>
<TR><TD colspan=2>
<PRE>
  using the same mechanism as the Fortran ALLOCATE statement. If the object is a pointer, it shall be associated
<P>
  with a target satisfying the conditions for successful deallocation by the Fortran DEALLOCATE statement
<P>
  (9.7.3).
<P>
</PRE>
3 Description. Successful execution of CFI_deallocate deallocates memory for the object using the same mech-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  anism as the Fortran DEALLOCATE statement, and the base_addr member of the C descriptor becomes a null
<P>
  pointer.
<P>
  If an error is detected, the C descriptor is not modified.
<P>
</PRE>
4 Result Value. The result is an error indicator.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
5 Example. If dv is the address of a C descriptor for the Fortran array A declared as
<P>
<PRE>
            REAL, ALLOCATABLE :: A(:, :)
<P>
</PRE>
and the array is allocated, the following code deallocates it:
<P>
<PRE>
            int ind;
<P>
            ind = CFI_deallocate(dv);
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>18.5.5.5</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The CFI_establish function
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 Synopsis. Establish a C descriptor.
<P>
<PRE>
  int CFI_establish(CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,
<P>
                          CFI_type_t type, size_t elem_len, CFI_rank_t rank,
<P>
                          const CFI_index_t extents[]);
<P>
</PRE>
2 Formal Parameters.
<P>
<PRE>
  dv             shall be the address of a data object large enough to hold a C descriptor of the rank specified by
<P>
                 rank. It shall not have the same value as either a C formal parameter that corresponds to a Fortran
<P>
                 actual argument or a C actual argument that corresponds to a Fortran dummy argument. It shall
<P>
                 not be the address of a C descriptor that describes an allocated allocatable object.
<P>
  base_addr      shall be a null pointer or the base address of the object to be described. If it is not a null pointer,
<P>
                 it shall be the address of a contiguous storage sequence that is appropriately aligned (ISO/IEC
<P>
                 9899:2011 3.2) for an object of the type specified by type.
<P>
  attribute      shall be one of the attribute codes in Table 18.3. If it is CFI_attribute_allocatable, base_addr
<P>
                 shall be a null pointer.
<P>
  type           shall be one of the type codes in Table 18.4.
<P>
  498                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
  elem_len       If the type is equal to CFI_type_struct, CFI_type_other, or a Fortran character type code, elem_-
<P>
                 len shall be greater than zero and equal to the storage size in bytes of an element of the object.
<P>
                 Otherwise, elem_len will be ignored.
<P>
  rank           shall have a value in the range 0 ≤ rank ≤ CFI_MAX_RANK. It specifies the rank of the object.
<P>
  extents        is ignored if rank is equal to zero or if base_addr is a null pointer. Otherwise, it shall be the address
<P>
                 of an array with rank elements; the value of each element shall be nonnegative, and extents[i]
<P>
                 specifies the extent of dimension i of the object.
<P>
</PRE>
3 Description. Successful execution of CFI_establish updates the object with the address dv to be an established
<P>
<PRE>
  C descriptor for a nonallocatable nonpointer data object of known shape, an unallocated allocatable object, or a
<P>
  data pointer. If base_addr is not a null pointer, it is for a nonallocatable entity that is a scalar or a contiguous
<P>
  array; if the attribute argument has the value CFI_attribute_pointer, the lower bounds of the object described
<P>
  by dv are set to zero. If base_addr is a null pointer, the established C descriptor is for an unallocated allocatable,
<P>
  a disassociated pointer, or is a C descriptor that has the attribute CFI_attribute_other but does not describe
<P>
  a data object. If base_addr is the C address of a Fortran data object, the type and elem_len arguments shall be
<P>
  consistent with the type and type parameters of the Fortran data object. The remaining properties of the object
<P>
  are given by the other arguments.
<P>
  If an error is detected, the object with the address dv is not modified.
<P>
</PRE>
4 Result Value. The result is an error indicator.
<P>
<PRE>
       NOTE 18.28
<P>
       CFI_establish is used to initialize a C descriptor declared in C with CFI_CDESC_T before passing it to
<P>
       any other functions as an actual argument, in order to set the rank, attribute, type and element length.
<P>
       NOTE 18.29
<P>
       A C descriptor with attribute CFI_attribute_other and base_addr a null pointer can be used as the
<P>
       argument result in calls to CFI_section or CFI_select_part, which will produce a C descriptor for a
<P>
       nonallocatable nonpointer data object.
<P>
</PRE>
5 Examples.
<P>
<PRE>
  Case (i):      The following code fragment establishes a C descriptor for an unallocated rank-one allocatable array
<P>
                 that can be passed to Fortran for allocation there.
<P>
                      CFI_rank_t rank;
<P>
                      CFI_CDESC_T(1) field;
<P>
                      int ind;
<P>
                      rank = 1;
<P>
                      ind = CFI_establish((CFI_cdesc_t *)&field, NULL, CFI_attribute_allocatable,
<P>
                                               CFI_type_double, 0, rank, NULL);
<P>
  Case (ii):     Given the Fortran type definition
<P>
                      TYPE, BIND(C) :: T
<P>
                        REAL(C_DOUBLE) :: X
<P>
                        COMPLEX(C_DOUBLE_COMPLEX) :: Y
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
and a Fortran subprogram that has an assumed-shape dummy argument of type T, the following
<P>
code fragment creates a descriptor a_fortran for an array of size 100 that can be used as the actual
<P>
argument in an invocation of the subprogram from C:
<P>
<PRE>
                      typedef struct {double x; double _Complex y;} t;
<P>
                      t a_c[100];
<P>
                      CFI_CDESC_T(1) a_fortran;
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
499
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                   int ind;
<P>
                   CFI_index_t extent[1];
<P>
                   extent[0] = 100;
<P>
                   ind = CFI_establish((CFI_cdesc_t *)&a_fortran, a_c, CFI_attribute_other,
<P>
                                            CFI_type_struct, sizeof(t), 1, extent);
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>18.5.5.6</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The CFI_is_contiguous function
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Synopsis. Test contiguity of an array.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  int CFI_is_contiguous(const CFI_cdesc_t * dv);
<P>
</PRE>
2 Formal Parameter. dv shall be the address of a C descriptor describing an array. The base_addr member of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the C descriptor shall not be a null pointer.
<P>
</PRE>
3 Result Value. The value of the result is 1 if the array described by dv is contiguous, and 0 otherwise.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       NOTE 18.30
<P>
       Assumed-size and allocatable arrays are always contiguous, and therefore the result of CFI_is_contiguous
<P>
       on a C descriptor for such an array will be equal to 1.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>18.5.5.7</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The CFI_section function
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Synopsis. Update a C descriptor for an array section for which each element is an element of a given array.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  int CFI_section(CFI_cdesc_t *result, const CFI_cdesc_t *source,
<P>
                     const CFI_index_t lower_bounds[], const CFI_index_t upper_bounds[],
<P>
                     const CFI_index_t strides[]);
<P>
</PRE>
2 Formal Parameters.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  result       shall be the address of a C descriptor with rank equal to the rank of source minus the number of
<P>
               zero strides. The attribute member shall have the value CFI_attribute_other or CFI_attribute_-
<P>
               pointer. If the value of result is the same as either a C formal parameter that corresponds to a
<P>
               Fortran actual argument or a C actual argument that corresponds to a Fortran dummy argument,
<P>
               the attribute member shall have the value CFI_attribute_pointer.
<P>
  source       shall be the address of a C descriptor that describes a nonallocatable nonpointer array, an allocated
<P>
               allocatable array, or an associated array pointer. The elem_len and type members of source shall
<P>
               have the same values as the corresponding members of result.
<P>
  lower_bounds shall be a null pointer or the address of an array with at least source-&gt;rank elements. If it is not
<P>
               a null pointer, and stridei is zero or (upperi − lower_bounds[i] + stridei )/stridei &gt; 0, the value
<P>
               of lower_bounds[i] shall be within the bounds of dimension i of SOURCE.
<P>
  upper_bounds shall be a null pointer or the address of an array with at least source-&gt;rank elements. If source
<P>
               describes an assumed-size array, upper_bounds shall not be a null pointer. If it is not a null pointer
<P>
               and stridei is zero or (upper_bounds[i] − loweri + stridei )/stridei &gt; 0, the value of upper_-
<P>
               bounds[i] shall be within the bounds of dimension i of SOURCE.
<P>
  strides      shall be a null pointer or the address of an array with at least source-&gt;rank elements.
<P>
</PRE>
3 Description. Successful execution of CFI_section updates the base_addr and dim members of the C descriptor
</TD></TR>
<TR><TD colspan=2>
<PRE>
  with the address result to describe the array section determined by source, lower_bounds, upper_bounds, and
<P>
  strides, as follows.
<P>
  500                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
  The array section is equivalent to the Fortran array section SOURCE(sectsub1 , sectsub2 , &#46;&#46;&#46; sectsubn ), where
<P>
  SOURCE is the array described by source, n is the rank of that array, and sectsubi is the subscript loweri if
<P>
  stridei is zero, and the section subscript loweri : upperi : stridei otherwise. The value of loweri is the lower
<P>
  bound of dimension i of SOURCE if lower_bounds is a null pointer and lower_bounds[i] otherwise. The value
<P>
  of upperi is the upper bound of dimension i of SOURCE if upper_bounds is a null pointer and upper_bounds[i]
<P>
  otherwise. The value of stridei is 1 if strides is a null pointer and strides[i] otherwise. If stridei has the
<P>
  value zero, loweri shall have the same value as upperi .
<P>
  If an error is detected, the C descriptor with the address result is not modified.
<P>
</PRE>
4 Result Value. The result is an error indicator.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
5 Examples.
<P>
<PRE>
  Case (i):      If source is already the address of a C descriptor for the rank-one Fortran array A, the lower
<P>
                 bounds of A are equal to 1, and the lower bounds in the C descriptor are equal to 0, the following
<P>
                 code fragment establishes a new C descriptor section and updates it to describe the array section
<P>
                 A(3::5):
<P>
                     CFI_index_t lower[1], strides[1];
<P>
                     CFI_CDESC_T(1) section;
<P>
                     int ind;
<P>
                     lower[0] = 2;
<P>
                     strides[0] = 5;
<P>
                     ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,
<P>
                                             CFI_type_float, 0, 1, NULL);
<P>
                     ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);
<P>
  Case (ii):     If source is already the address of a C descriptor for a rank-two Fortran assumed-shape array A
<P>
                 with lower bounds equal to 1, the following code fragment establishes a C descriptor and updates
<P>
                 it to describe the rank-one array section A(:, 42).
<P>
                       CFI_index_t lower[2], upper[2], strides[2];
<P>
                       CFI_CDESC_T(1) section;
<P>
                       int ind;
<P>
                       lower[0] = source-&gt;dim[0].lower_bound;
<P>
                       upper[0] = source-&gt;dim[0].lower_bound + source-&gt;dim[0].extent - 1;
<P>
                       strides[0] = 1;
<P>
                       lower[1] = upper[1] = source-&gt;dim[1].lower_bound + 41;
<P>
                       strides[1] = 0;
<P>
                       ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,
<P>
                                              CFI_type_float, 0, 1, NULL);
<P>
                       ind = CFI_section((CFI_cdesc_t *)&section, source, lower, upper, strides);
<P>
  18.5.5.8       The CFI_select_part function
<P>
</PRE>
1 Synopsis. Update a C descriptor for an array section for which each element is a part of the corresponding
<P>
<PRE>
  element of an array.
<P>
  int CFI_select_part(CFI_cdesc_t *result, const CFI_cdesc_t *source, size_t displacement,
<P>
                            size_t elem_len);
<P>
</PRE>
2 Formal Parameters.
<P>
<PRE>
  result         shall be the address of a C descriptor; result-&gt;rank shall have the same value as source-&gt;rank
<P>
                 and result-&gt;attribute shall have the value CFI_attribute_other or CFI_attribute_pointer. If
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        501
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                 the address specified by result is the value of a C formal parameter that corresponds to a For-
<P>
                 tran actual argument or of a C actual argument that corresponds to a Fortran dummy argument,
<P>
                 result-&gt;attribute shall have the value CFI_attribute_pointer. The value of result-&gt;type spe-
<P>
                 cifies the type of the array section.
<P>
  source         shall be the address of a C descriptor for an allocated allocatable array, an associated array pointer,
<P>
                 or a nonallocatable nonpointer array that is not assumed-size.
<P>
  displacement shall have a value 0 ≤ displacement ≤ source-&gt;elem_len −1, and the sum of the displacement
<P>
                 and the size in bytes of an element of the array section shall be less than or equal to source-&gt;elem_-
<P>
                 len. The address displacement bytes greater than the value of source-&gt;base_addr is the base of
<P>
                 the array section and shall be appropriately aligned (ISO/IEC 9899:2011, 3.2) for an object of the
<P>
                 type of the array section.
<P>
  elem_len       shall have a value equal to the storage size in bytes of an element of the array section if result-&gt;type
<P>
                 specifies a Fortran character type; otherwise, elem_len is ignored.
<P>
</PRE>
3 Description. Successful execution of CFI_select_part updates the base_addr, dim, and elem_len members of
<P>
<PRE>
  the C descriptor with the address result for an array section for which each element is a part of the corresponding
<P>
  element of the array described by the C descriptor with the address source. The part shall be a component of a
<P>
  structure, a substring, or the real or imaginary part of a complex value.
<P>
  If an error is detected, the C descriptor with the address result is not modified.
<P>
</PRE>
4 Result Value. The result is an error indicator.
<P>
5 Example. If source is already the address of a C descriptor for the Fortran array A declared with
<P>
<PRE>
     TYPE, BIND(C) :: T
<P>
       REAL(C_DOUBLE) :: X
<P>
       COMPLEX(C_DOUBLE_COMPLEX) :: Y
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(T) <B>A</B>(100)
</BLOCKQUOTE>
<P>
the following code fragment establishes a C descriptor for the array A%Y:
<P>
<PRE>
      typedef struct {
<P>
         double x; double _Complex y;
<P>
      } t;
<P>
      CFI_CDESC_T(1) component;
<P>
      CFI_cdesc_t * comp_cdesc = (CFI_cdesc_t *)&component;
<P>
      CFI_index_t extent[] = { 100 };
<P>
      (void)CFI_establish(comp_cdesc, NULL, CFI_attribute_other, CFI_type_double_Complex,
<P>
                                sizeof(double _Complex), 1, extent);
<P>
      (void)CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>18.5.5.9</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
The CFI_setpointer function
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Synopsis. Update a C descriptor for a Fortran pointer to be associated with the whole of a given object or to
<P>
<PRE>
  be disassociated.
<P>
  int CFI_setpointer(CFI_cdesc_t *result, CFI_cdesc_t *source,
<P>
                            const CFI_index_t lower_bounds[]);
<P>
  502                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 Formal Parameters.
<P>
<PRE>
  result         shall be the address of a C descriptor for a Fortran pointer. It is updated using information from
<P>
                 the source and lower_bounds arguments.
<P>
  source         shall be a null pointer or the address of a C descriptor for an allocated allocatable object, a data
<P>
                 pointer object, or a nonallocatable nonpointer data object that is not an assumed-size array. If
<P>
                 source is not a null pointer, the corresponding values of the elem_len, rank, and type members
<P>
                 shall be the same in the C descriptors with the addresses source and result.
<P>
  lower_bounds If source is not a null pointer and source-&gt;rank is nonzero, lower_bounds shall be a null pointer
<P>
                 or the address of an array with at least source-&gt;rank elements.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>3 Description.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Successful execution of CFI_setpointer updates the base_addr and dim members of the C
</TD></TR>
<TR><TD colspan=2>
<PRE>
  descriptor with the address result as follows:
<P>
      • if source is a null pointer or the address of a C descriptor for a disassociated pointer, the updated C
<P>
        descriptor describes a disassociated pointer;
<P>
      • otherwise, the C descriptor with the address result becomes a C descriptor for the object described by
<P>
        the C descriptor with the address source, except that if source-&gt;rank is nonzero and lower_bounds is
<P>
        not a null pointer, the lower bounds are replaced by the values of the first source-&gt;rank elements of the
<P>
        lower_bounds array.
<P>
  If an error is detected, the C descriptor with the address result is not modified.
<P>
</PRE>
4 Result Value. The result is an error indicator.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>5 Example.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
If ptr is already the address of a C descriptor for an array pointer of rank 1, the following code
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
  updates it to be a C descriptor for a pointer to the same array with lower bound 0.
<P>
       CFI_index_t lower_bounds[1];
<P>
       int ind;
<P>
       lower_bounds[0] = 0;
<P>
       ind = CFI_setpointer(ptr, ptr, lower_bounds);
<P>
  18.6       Restrictions on C descriptors
<P>
</PRE>
1 A C descriptor shall not be initialized, updated, or copied other than by calling the functions specified in 18.5.5.
<P>
2 If the address of a C descriptor is a formal parameter that corresponds to a Fortran actual argument or a C
<P>
<PRE>
  actual argument that corresponds to a Fortran dummy argument,
<P>
      • the C descriptor shall not be modified if either the corresponding dummy argument in the Fortran interface
<P>
        has the INTENT (IN) attribute or the C descriptor is for a nonallocatable nonpointer object, and
<P>
      • the base_addr member of the C descriptor shall not be accessed before it is given a value if the corresponding
<P>
        dummy argument in the Fortran interface has the POINTER and INTENT (OUT) attributes.
<P>
       NOTE 18.31
<P>
       In this context, modification refers to any change to the location or contents of the C descriptor, including
<P>
       establishment and update. The intent of these restrictions is that C descriptors remain intact at all times
<P>
       they are accessible to an active Fortran procedure, so that the Fortran code is not required to copy them.
<P>
</PRE>
3 If the address of a C descriptor is a C actual argument that corresponds to an assumed-shape Fortran dummy
<P>
<PRE>
  argument, that descriptor shall not be for an assumed-size array.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           503
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  18.7        Restrictions on formal parameters
<P>
</PRE>
1 Within a C function, an allocatable object shall be allocated or deallocated only by execution of the CFI_-
<P>
<PRE>
  allocate and CFI_deallocate functions. A Fortran pointer can become associated with a target by execution of
<P>
  the CFI_allocate function.
<P>
</PRE>
2 Calling CFI_allocate or CFI_deallocate for a C descriptor changes the allocation status of the Fortran variable
<P>
<PRE>
  it describes.
<P>
</PRE>
3 If the address of an object is the value of a formal parameter that corresponds to a nonpointer dummy argument
<P>
<PRE>
  in an interface with the BIND attribute, then
<P>
      • if the dummy argument has the INTENT (IN) attribute, the object shall not be defined or become undefined,
<P>
         and
<P>
      • if the dummy argument has the INTENT (OUT) attribute, the object shall not be referenced before it is
<P>
         defined.
<P>
</PRE>
4 If a formal parameter that is a pointer to CFI_cdesc_t corresponds to a dummy argument in an interoperable
<P>
<PRE>
  procedure interface, a pointer based on the base_addr in that C descriptor shall not be used to access memory
<P>
  that is not part of the object described by the C descriptor.
<P>
  18.8        Restrictions on lifetimes
<P>
</PRE>
1 A C descriptor of, or C pointer to, any part of a Fortran object becomes undefined under the same conditions
<P>
<PRE>
  that the association status of a Fortran pointer associated with that object would become undefined, and any
<P>
  further use of it is undefined behavior (ISO/IEC 9899:2011, 3.4.3).
<P>
</PRE>
2 A C descriptor whose address is a formal parameter that corresponds to a Fortran dummy argument becomes
<P>
<PRE>
  undefined on return from a call to the function from Fortran. If the dummy argument does not have either the
<P>
  TARGET or ASYNCHRONOUS attribute, all C pointers to any part of the object described by the C descriptor
<P>
  become undefined on return from the call, and any further use of them is undefined behavior.
<P>
</PRE>
3 If the address of a C descriptor is passed as an actual argument to a Fortran procedure, the lifetime (ISO/IEC
<P>
<PRE>
  9899:2011, 6.2.4) of the C descriptor shall not end before the return from the procedure call. If an object is passed
<P>
  to a Fortran procedure as a nonallocatable, nonpointer dummy argument, its lifetime shall not end before the
<P>
  return from the procedure call.
<P>
</PRE>
4 If the lifetime of a C descriptor for an allocatable object that was established by C ends before the program exits,
<P>
<PRE>
  the object shall be unallocated at that time.
<P>
</PRE>
5 If a Fortran pointer becomes associated with a data object defined by the companion processor, the association
<P>
<PRE>
  status of the Fortran pointer becomes undefined when the lifetime of that data object ends.
<P>
        NOTE 18.32
<P>
        The following example illustrates how a C descriptor becomes undefined upon returning from a call to a C
<P>
        function.
<P>
               REAL, TARGET :: X(1000), B
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
REAL FUNCTION <B>CFUN</B>(ARRAY) <B>BIND</B>(C, NAME="Cfun")
<P>
<PRE>
                       REAL ARRAY(:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
B = <B>CFUN</B>(X)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: B = <B>CFUN</B>(X)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>504</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
NOTE 18.32 (cont.)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
Cfun is a C function. Before or during the invocation of Cfun, the processor will create a C descriptor
<P>
for the array x. On return from Cfun, that C descriptor will become undefined. In addition, because the
<P>
dummy argument ARRAY does not have the TARGET or ASYNCHRONOUS attribute, a C pointer whose
<P>
value was set during execution of Cfun to be the address of any part of X will become undefined.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>18.9</B> </TD><TD valign=bottom>
Interoperation with C global variables
<TABLE width=100% cellpadding=3><!-- tsb: Interoperation with C global variables
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>18.9.1</B> </TD><TD valign=bottom>
General
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 A C variable whose name has external linkage may interoperate with a common block or with a variable declared in
<P>
<PRE>
  the scope of a module. The common block or variable shall be specified to have the BIND attribute.
<P>
</PRE>
2 At most one variable that is associated with a particular C variable whose name has external linkage is permitted
<P>
<PRE>
  to be declared within all the Fortran program units of a program. A variable shall not be initially defined by
<P>
  more than one processor.
<P>
</PRE>
3 If a common block is specified in a BIND statement, it shall be specified in a BIND statement with the same binding label in each
<P>
<PRE>
  scoping unit in which it is declared. A C variable whose name has external linkage interoperates with a common block that has been
<P>
  specified in a BIND statement if
<P>
       • the C variable is of a struct type and the variables that are members of the common block are interoperable with corresponding
<P>
          components of the struct type, or
<P>
       • the common block contains a single variable, and the variable is interoperable with the C variable.
<P>
</PRE>
4 There does not have to be an associated C entity for a Fortran entity with the BIND attribute.
<P>
<PRE>
        NOTE 18.33
<P>
        The following are examples of the usage of the BIND attribute for variables and for a common block. The
<P>
        Fortran variables, C_EXTERN and C2, interoperate with the C variables, c_extern and myVariable,
<P>
        respectively. The Fortran common blocks, COM and SINGLE, interoperate with the C variables, com and single, respectively.
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE LINK_TO_C_VARS</H4>
</A>
<BLOCKQUOTE>
<P>
USE, INTRINSIC :: ISO_C_BINDING
<P>
<B>INTEGER</B>(C_INT), <B>BIND</B>(C) :: C_EXTERN
<P>
<B>INTEGER</B>(C_LONG) :: C2
<P>
<B>BIND</B>(C, NAME=’myVariable’) :: C2
<P>
COMMON /COM/ R, S
<P>
<B>REAL</B>(C_FLOAT) :: R, S, T
<P>
<B>BIND</B>(C) :: /COM/, /SINGLE/
<P>
COMMON /SINGLE/ T
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE LINK_TO_C_VARS</H4>
</A>
<BLOCKQUOTE>
<P>
/* Global variables. */
<P>
int c_extern;
<P>
long myVariable;
<P>
struct { float r, s; } com;
<P>
float single;
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: float single;
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
505
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>18.9.2</B> </TD><TD valign=bottom>
Binding labels for common blocks and variables
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 The binding label of a variable or common block is a default character value that specifies the name by which the
<P>
<PRE>
  variable or common block is known to the companion processor.
<P>
</PRE>
2 If a variable or common block has the BIND attribute with the NAME= specifier and the value of its expression,
<P>
<PRE>
  after discarding leading and trailing blanks, has nonzero length, the variable or common block has this as its binding
<P>
  label. The case of letters in the binding label is significant. If a variable or common block has the BIND attribute
<P>
  specified without a NAME= specifier, the binding label is the same as the name of the entity using lower case
<P>
  letters. Otherwise, the variable or common block has no binding label.
<P>
</PRE>
3 The binding label of a C variable whose name has external linkage is the same as the name of the C variable. A
<P>
<PRE>
  Fortran variable or common block with the BIND attribute that has the same binding label as a C variable whose
<P>
  name has external linkage is linkage associated (19.5.1.5) with that variable.
<P>
  18.10         Interoperation with C functions
<P>
  18.10.1        Definition and reference of interoperable procedures
<P>
</PRE>
1 A procedure that is interoperable may be defined either by means other than Fortran or by means of a Fortran
<P>
<PRE>
  subprogram, but not both. A C function that has an inline definition and no external definition is not considered
<P>
  to be defined in this sense.
<P>
</PRE>
2 If the procedure is defined by means other than Fortran,
<P>
<PRE>
      • it shall be describable by a C prototype that is interoperable with the interface, and
<P>
      • if it is accessed using its binding label, it shall
<P>
            – have a name that has external linkage as defined by 6.2.2 of ISO/IEC 9899:2011, and
<P>
            – have the same binding label as the interface.
<P>
</PRE>
3 A reference to such a procedure causes the function described by the C prototype to be called as specified in
<P>
<PRE>
  ISO/IEC 9899:2011.
<P>
</PRE>
4 A reference in C to a procedure that has the BIND attribute, has the same binding label, and is defined by means
<P>
<PRE>
  of Fortran, causes the Fortran procedure to be invoked. A C function shall not invoke a function pointer whose
<P>
  value is the result of a reference to C_FUNLOC with a noninteroperable argument.
<P>
</PRE>
5 A procedure defined by means of Fortran shall not invoke setjmp or longjmp (ISO/IEC 9899:2011, 7.13). If a
<P>
<PRE>
  procedure defined by means other than Fortran invokes setjmp or longjmp, that procedure shall not cause any
<P>
  procedure defined by means of Fortran to be invoked. A procedure defined by means of Fortran shall not be
<P>
  invoked as a signal handler (ISO/IEC 9899:2011, 7.14.1).
<P>
</PRE>
6 If a procedure defined by means of Fortran and a procedure defined by means other than Fortran perform
<P>
<PRE>
  input/output operations on the same external file, the results are processor dependent (12.5.4).
<P>
</PRE>
7 If the value of a C function pointer will be the result of a reference to C_FUNLOC with a noninteroperable
<P>
<PRE>
  argument, it is recommended that the C function pointer be declared to have the type void (*)().
<P>
  18.10.2        Binding labels for procedures
<P>
</PRE>
1 The binding label of a procedure is a default character value that specifies the name by which a procedure with
<P>
<PRE>
  the BIND attribute is known to the companion processor.
<P>
</PRE>
2 If a procedure has the BIND attribute with the NAME= specifier and the value of its expression, after discarding
<P>
<PRE>
  leading and trailing blanks, has nonzero length, the procedure has this as its binding label. The case of letters
<P>
  in the binding label is significant. If a procedure has the BIND attribute with no NAME= specifier, and the
<P>
  506                                                                  ⃝
<P>
                                                                       c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
  procedure is not a dummy procedure, internal procedure, or procedure pointer, then the binding label of the
<P>
  procedure is the same as the name of the procedure using lower case letters. Otherwise, the procedure has no
<P>
  binding label.
<P>
  C1807 A procedure defined in a submodule shall not have a binding label unless its interface is declared in the
<P>
           ancestor module.
<P>
</PRE>
3 The binding label for a C function whose name has external linkage is the same as the C function name.
<P>
<PRE>
       NOTE 18.34
<P>
       In the following sample, the binding label of C_SUB is "c_sub", and the binding label of C_FUNC is
<P>
       "C_funC".
<P>
       SUBROUTINE C_SUB() BIND(C)
<P>
          &#46;&#46;&#46;
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE C_SUB</H4>
</A>
<BLOCKQUOTE>
<P>
<B>INTEGER</B>(C_INT) FUNCTION <B>C_FUNC</B>() <B>BIND</B>(C, NAME="C_funC")
<P>
<PRE>
          USE, INTRINSIC :: ISO_C_BINDING
<P>
          &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION C_FUNC</H4>
</A>
<BLOCKQUOTE>
<P>
ISO/IEC 9899:2011 permits functions to have names that are not permitted as Fortran names; it also
<P>
distinguishes between names that would be considered as the same name in Fortran. For example, a C
<P>
name can begin with an underscore, and C names that differ in case are distinct names.
<P>
The specification of a binding label allows a program to use a Fortran name to refer to a procedure defined
<P>
by a companion processor.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: by a companion processor.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>18.10.3</B> </TD><TD valign=bottom>
Exceptions and IEEE arithmetic procedures
<P>
1 A procedure defined by means other than Fortran shall not use signal (ISO/IEC 9899:2011, 7.14.1) to change the
<P>
<PRE>
  handling of any exception that is being handled by the Fortran processor.
<P>
</PRE>
2 A procedure defined by means other than Fortran shall not alter the floating-point status (17.7) other than by
<P>
<PRE>
  setting an exception flag to signaling.
<P>
</PRE>
3 The values of the floating-point exception flags on entry to a procedure defined by means other than Fortran are
<P>
<PRE>
  processor dependent.
<P>
  18.10.4      Asynchronous communication
<P>
</PRE>
1 Asynchronous communication for a Fortran variable with the ASYNCHRONOUS attribute occurs through the
<P>
<PRE>
  action of procedures defined by means other than Fortran. It is initiated by execution of an asynchronous
<P>
  communication initiation procedure and completed by execution of an asynchronous communication completion
<P>
  procedure. Between the execution of the initiation and completion procedures, any variable of which any part
<P>
  is associated with any part of the asynchronous communication variable is a pending communication affector.
<P>
  Whether a procedure is an asynchronous communication initiation or completion procedure is processor depend-
<P>
  ent.
<P>
</PRE>
2 Asynchronous communication is either input communication or output communication. For input communication,
<P>
<PRE>
  a pending communication affector shall not be referenced, become defined, become undefined, become associated
<P>
  with a dummy argument that has the VALUE attribute, or have its pointer association status changed. For
<P>
  output communication, a pending communication affector shall not be redefined, become undefined, or have its
<P>
  pointer association status changed. The restrictions for asynchronous input communication are the same as for
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        507
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
asynchronous input data transfer. The restrictions for asynchronous output communication are the same as for
<P>
asynchronous output data transfer.
<P>
<PRE>
    NOTE 18.35
<P>
    Asynchronous communication can be used for nonblocking MPI calls such as MPI_IRECV and MPI_-
<P>
    ISEND. For example,
<P>
         REAL :: BUF(100,100)
<P>
         &#46;&#46;&#46; ! Code that involves BUF
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
ASYNCHRONOUS :: BUF
<P>
CALL <B>MPI_IRECV</B>(BUF,&#46;&#46;&#46;REQ,...)
<P>
<PRE>
               &#46;&#46;&#46; ! Code that does not involve BUF
<P>
</PRE>
CALL <B>MPI_WAIT</B>(REQ,&#46;&#46;&#46;)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END BLOCK</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46; ! Code that involves BUF
</BLOCKQUOTE>
<P>
In this example, there is asynchronous input communication and BUF is a pending communication affector
<BLOCKQUOTE>
<P>
between the two calls. MPI_IRECV can return while the communication (reading values into BUF) is still
<P>
underway. The intent is that the code between MPI_IRECV and MPI_WAIT can execute without waiting
<P>
for this communication to complete.
<P>
Similar code with the call of MPI_IRECV replaced by a call of MPI_ISEND is asynchronous output
<P>
communication.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: communication.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>508</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
19 Scope, association, and definition
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>19.1</B> </TD><TD valign=bottom>
Scopes, identifiers, and entities
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 An entity is identified by an identifier.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 The scope of
<P>
<PRE>
      • a global identifier is a program (5.2.2),
<P>
      • a local identifier is an inclusive scope,
<P>
      • an identifier of a construct entity is that construct (10.2.4, 11.1), and
<P>
      • an identifier of a statement entity is that statement or part of that statement (6.3),
<P>
</PRE>
excluding any nested scope where the identifier is treated as the identifier of a different entity (19.3, 19.4), or
<TABLE width=100% cellpadding=3><!-- tsb: excluding any nested scope where the identifier is treated as the identifier of a different entity (19.3, 19.4), or
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
where an IMPORT statement (8.8) makes the identifier inaccessible.
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
3 An entity may be identified by
<P>
<PRE>
      • an image index (3.85),
<P>
      • a name (3.103),
<P>
      • a statement label (3.135),
<P>
      • an external input/output unit number (12.5),
<P>
      • an identifier of a pending data transfer operation (12.6.2.9, 12.7),
<P>
      • a submodule identifier (14.2.3),
<P>
      • a generic identifier (3.79), or
<P>
      • a binding label (3.15).
<P>
</PRE>
4 By means of association, an entity may be referred to by the same identifier or a different identifier in a different
<P>
<PRE>
  scope, or by a different identifier in the same scope.
<P>
  19.2       Global identifiers
<P>
</PRE>
1 Program units, common blocks, external procedures, entities with binding labels, external input/output units,
<P>
<PRE>
  pending data transfer operations, and images are global entities of a program. The name of a common block with
<P>
  no binding label, external procedure with no binding label, or program unit that is not a submodule is a global
<P>
  identifier. The submodule identifier of a submodule is a global identifier. A binding label of an entity of the
<P>
  program is a global identifier. An entity of the program shall not be identified by more than one binding label.
<P>
</PRE>
2 The global identifier of an entity shall not be the same as the global identifier of any other entity. Furthermore, a
<P>
<PRE>
  binding label shall not be the same as the global identifier of any other global entity, ignoring differences in case.
<P>
  A processor may assign a global identifier to an entity that is not specified by this document to have a global
<P>
  identifier (such as an intrinsic procedure); in such a case, the processor shall ensure that this assigned global
<P>
  identifier differs from all other global identifiers in the program.
<P>
        NOTE 19.1
<P>
        An intrinsic module is not a program unit, so a global identifier can be the same as the name of an intrinsic
<P>
        module.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            509
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 19.2
<P>
        Submodule identifiers are global identifiers, but because they consist of a module name and a descendant
<P>
        submodule name, the name of a submodule can be the same as the name of another submodule so long as
<P>
        they do not have the same ancestor module.
<P>
  19.3         Local identifiers
<P>
  19.3.1        Classes of local identifiers
<P>
</PRE>
1 Identifiers of entities, other than statement or construct entities (19.4), in the classes
<P>
<PRE>
          (1)    named variables, named constants, named procedure pointers, named constructs, statement functions,
<P>
                 internal procedures, module procedures, dummy procedures, intrinsic procedures, external procedures
<P>
                 that have binding labels, intrinsic modules, abstract interfaces, generic interfaces, derived types,
<P>
                 namelist groups, external procedures accessed via USE, and statement labels,
<P>
          (2)    type parameters, components, and type-bound procedure bindings, in a separate class for each type,
<P>
          (3)    argument keywords, in a separate class for each procedure with an explicit interface, and
<P>
          (4)    common blocks that have binding labels
<P>
</PRE>
are local identifiers.
<P>
2 Within its scope, a local identifier of an entity of class (1) or class (4) shall not be the same as a global identifier
<P>
<PRE>
  used in that scope unless the global identifier
<P>
      •  is used only as the use-name of a rename in a USE statement,
<P>
      •  is a common block name (19.3.2),
<P>
      •  is an external procedure name that is also a generic name, or
<P>
      •  is an external function name and the inclusive scope is its defining subprogram (19.3.3).
<P>
</PRE>
3 Within its scope, a local identifier of one class shall not be the same as another local identifier of the same class,
<P>
<PRE>
  except that a generic name may be the same as the name of a procedure as explained in 15.4.3.4 or the same as
<P>
  the name of a derived type (7.5.10). A local identifier of one class may be the same as a local identifier of another
<P>
  class.
<P>
        NOTE 19.3
<P>
        An intrinsic procedure is inaccessible by its own name in a scoping unit that uses the same name as a local
<P>
        identifier of class (1) for a different entity. For example, in the program fragment
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
A = SIN (K)
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION SIN (X)
<P>
<PRE>
                 &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION SIN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
any reference to function SIN in subroutine SUB refers to the internal function SIN, not to the intrinsic
<P>
function of the same name.
</BLOCKQUOTE>
<P>
4 A local identifier identifies an entity in a scope and may be used to identify an entity in another scope except in
<P>
<PRE>
  the following cases.
<P>
  510                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
<P>
      • The name that appears as a subroutine-name in a subroutine-stmt has limited use within the scope estab-
<P>
        lished by the subroutine-stmt. It can be used to identify recursive references of the subroutine or to identify
<P>
        a common block (the latter is possible only for internal and module subroutines).
<P>
      • The name that appears as a function-name in a function-stmt has limited use within the scope established
<P>
        by that function-stmt. It can be used to identify the function result, to identify recursive references of the
<P>
        function, or to identify a common block (the latter is possible only for internal and module functions).
<P>
      • The name that appears as an entry-name in an entry-stmt has limited use within the scope of the subprogram in which
<P>
        the entry-stmt appears. It can be used to identify the function result if the subprogram is a function, to identify recursive
<P>
        references, or to identify a common block (the latter is possible only if the entry-stmt is in a module subprogram).
<P>
  19.3.2       Local identifiers that are the same as common block names
<P>
</PRE>
1 A name that identifies a common block in a scoping unit shall not be used to identify a constant or an intrinsic procedure in that
<P>
<PRE>
  scoping unit. If a local identifier of class (1) is also the name of a common block, the appearance of that name in any context other
<P>
  than as a common block name in a BIND, COMMON, or SAVE statement is an appearance of the local identifier.
<P>
  19.3.3       Function results
<P>
</PRE>
1 For each FUNCTION statement or ENTRY statement in a function subprogram, there is a function result. A function
<P>
<PRE>
  result is either a variable or a procedure pointer, and thus the name of a function result is a local identifier of
<P>
  class (1).
<P>
  19.3.4       Components, type parameters, and bindings
<P>
</PRE>
1 A component name has the scope of its derived-type definition. Outside the type definition, it may also appear
<P>
<PRE>
  within a designator of a component of a structure of that type or as a component keyword in a structure
<P>
  constructor for that type.
<P>
</PRE>
2 A type parameter name has the scope of its derived-type definition. Outside the derived-type definition, it may
<P>
<PRE>
  also appear as a type parameter keyword in a derived-type-spec for the type or as the type-param-name of a
<P>
  type-param-inquiry.
<P>
</PRE>
3 The binding name (7.5.5) of a type-bound procedure has the scope of its derived-type definition. Outside of the
<P>
<PRE>
  derived-type definition, it may also appear as the binding-name in a procedure reference.
<P>
</PRE>
4 A generic binding for which the generic-spec is not a generic-name has a scope that consists of all scoping units
<P>
<PRE>
  in which an entity of the type is accessible.
<P>
</PRE>
5 A component name or binding name may appear only in a scope in which it is accessible.
<BLOCKQUOTE>
<P>
6 The accessibility of components and bindings is specified in 7.5.4.8 and 7.5.5.
<P>
<PRE>
  19.3.5       Argument keywords
<P>
</PRE>
1 As an argument keyword, a dummy argument name in an internal procedure, module procedure, or an interface
<P>
<PRE>
  body has a scope of the scoping unit of the host of the procedure or interface body. As an argument keyword,
<P>
  the name of a dummy argument of a procedure declared by a procedure declaration statement that specifies an
<P>
  explicit interface has a scope of the scoping unit containing the procedure declaration statement. It may appear
<P>
  only in a procedure reference for the procedure of which it is a dummy argument. If the procedure is accessible
<P>
  in another scoping unit by use or host association (19.5.1.3, 19.5.1.4), the argument keyword is accessible for
<P>
  procedure references for that procedure in that scoping unit.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                           511
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 A dummy argument name in an intrinsic procedure has a scope as an argument keyword of the scoping unit
<P>
<PRE>
  in which the reference to the procedure occurs. As an argument keyword, it may appear only in a procedure
<P>
  reference for the procedure of which it is a dummy argument.
<P>
  19.4        Statement and construct entities
<P>
</PRE>
1 A variable that appears as a data-i-do-variable in a DATA statement or an ac-do-variable in an array constructor,
<P>
<PRE>
  as a dummy argument in a statement function statement, or as an index-name in a FORALL statement is a statement entity. A
<P>
  variable that appears as an index-name in a FORALL or DO CONCURRENT, as an associate-name in a SELECT
<P>
  TYPE or ASSOCIATE construct, or as a coarray-name in a codimension-decl in a CHANGE TEAM construct is
<P>
  a construct entity. A variable that has LOCAL or LOCAL_INIT locality in a DO CONCURRENT construct is a
<P>
  construct entity. An entity that is explicitly declared in the specification part of a BLOCK construct, other than
<P>
  only in ASYNCHRONOUS and VOLATILE statements, is a construct entity. A USE statement in a BLOCK
<P>
  construct explicitly declares the entities accessed by use association to be construct entities. Two construct
<P>
  entities of the same construct shall not have the same identifier.
<P>
</PRE>
2 Even if the name of a statement entity is the same as another identifier and the statement is in the scope of that
<P>
<PRE>
  identifier, within the scope of the statement entity the name is interpreted as that of the statement entity.
<P>
</PRE>
3 The name of a statement entity shall not be the same as an accessible global identifier or local identifier of class
<P>
<PRE>
  (1) (19.3.1), except for a common block name or a scalar variable name. Within the scope of a statement entity,
<P>
  another statement entity shall not have the same name.
<P>
</PRE>
4 The name of a data-i-do-variable in a DATA statement or an ac-do-variable in an array constructor has a scope
<P>
<PRE>
  of its data-implied-do or ac-implied-do. It is a scalar variable. If integer-type-spec appears in data-implied-do or
<P>
  ac-implied-do-control it has the specified type and type parameters; otherwise it has the type and type parameters
<P>
  that it would have if it were the name of a variable in the innermost executable construct or scoping unit that
<P>
  includes the DATA statement or array constructor, and this type shall be integer type. It has no other attributes.
<P>
  The appearance of a name as a data-i-do-variable of an implied DO in a DATA statement or an ac-do-variable
<P>
  in an array constructor is not an implicit declaration of a variable whose scope is the scoping unit that contains
<P>
  the statement.
<P>
</PRE>
5 The name of a variable that appears as an index-name in a DO CONCURRENT construct, FORALL statement, or
<P>
<PRE>
  FORALL construct   has a scope of the statement or construct. It is a scalar variable. If integer-type-spec appears in
<P>
  concurrent-header it has the specified type and type parameters; otherwise it has the type and type parameters
<P>
  that it would have if it were the name of a variable in the innermost executable construct or scoping unit that
<P>
  includes the DO CONCURRENT or FORALL, and this type shall be integer type. It has no other attributes.
<P>
  The appearance of a name as an index-name in a DO CONCURRENT construct, FORALL statement, or FORALL
<P>
  construct is not an implicit declaration of a variable whose scope is the scoping unit that contains the statement or
<P>
  construct.
<P>
</PRE>
6 A variable that has LOCAL or LOCAL_INIT locality in a DO CONCURRENT construct has the scope of that
<P>
<PRE>
  construct. Its attributes are specified in 11.1.7.5.
<P>
</PRE>
7 If integer-type-spec does not appear in a concurrent-header, an index-name shall not be the same as an accessible
<P>
<PRE>
  global identifier, local identifier, or identifier of an outer construct entity, except for a common block name or
<P>
  a scalar variable name. An index-name of a contained DO CONCURRENT construct, FORALL statement, or
<P>
  FORALL construct shall not be the same as an index-name of any of its containing DO CONCURRENT or FORALL
<P>
  constructs.
<P>
  512                                                                     ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 The associate name of a SELECT TYPE construct has a separate scope for each block of the construct. Within
<P>
<PRE>
   each block, it has the declared type, dynamic type, type parameters, rank, and bounds specified in 11.1.11.2.
<P>
</PRE>
9 The associate names of an ASSOCIATE construct have the scope of the block. They have the declared type,
<P>
<PRE>
   dynamic type, type parameters, rank, and bounds specified in 11.1.3.2.
<P>
</PRE>
10 The associate names of a CHANGE TEAM construct have the scope of the block. They have the declared type,
<P>
<PRE>
   dynamic type, type parameters, rank, corank, bounds, and cobounds specified in 11.1.5.
<P>
</PRE>
11 The name of a variable that appears as a dummy argument in a statement function statement has a scope of the statement in which
<P>
<PRE>
   it appears. It is a scalar that has the type and type parameters that it would have if it were the name of a variable in the scoping
<P>
   unit that includes the statement function; it has no other attributes.
<P>
   19.5        Association
<P>
   19.5.1       Name association
<P>
   19.5.1.1     Forms of name association
<P>
</PRE>
1 There are five forms of name association: argument association, use association, host association, linkage asso-
<P>
<PRE>
   ciation, and construct association. Argument, use, and host association provide mechanisms by which entities
<P>
   known in one scope may be accessed in another scope.
<P>
   19.5.1.2     Argument association
<P>
</PRE>
1 The rules governing argument association are given in Clause 15. As explained in 15.5, execution of a procedure
<P>
<PRE>
   reference establishes a correspondence between each actual argument and a dummy argument and thus an associ-
<P>
   ation between each present dummy argument and its effective argument. Argument association can be sequence
<P>
   association (15.5.2.11).
<P>
</PRE>
2 The name of the dummy argument may be different from the name, if any, of its effective argument. The dummy
<P>
<PRE>
   argument name is the name by which the effective argument is known, and by which it may be accessed, in the
<P>
   referenced procedure.
<P>
         NOTE 19.4
<P>
         An effective argument can be a nameless data entity, such as the result of evaluating an expression that is
<P>
         not simply a variable or constant.
<P>
</PRE>
3 Upon termination of execution of a procedure reference, all argument associations established by that reference
<P>
<PRE>
   are terminated. A dummy argument of that procedure can be associated with an entirely different effective
<P>
   argument in a subsequent invocation of the procedure.
<P>
   19.5.1.3     Use association
<P>
</PRE>
1 Use association is the association of names in different scopes specified by a USE statement. The rules governing
<P>
<PRE>
   use association are given in 14.2.2. They allow for renaming of entities being accessed. Use association allows
<P>
   access in one scope to entities defined or declared in another scope; it remains in effect throughout the execution
<P>
   of the program.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                                          513
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>19.5.1.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Host association
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 A nested scoping unit has access to named entities from its host as specified in 8.8. A host-associated variable is
<P>
<PRE>
  considered to have been previously declared; any other host-associated entity is considered to have been previously
<P>
  defined. In the case of an internal subprogram, the access is to the entities in its host instance. The accessed
<P>
  entities are identified by the same identifier and have the same attributes as in the host, except that a local entity
<P>
  may have the ASYNCHRONOUS attribute even if the host entity does not, and a noncoarray local entity may
<P>
  have the VOLATILE attribute even if the host entity does not. The accessed entities are named data objects,
<P>
  derived types, abstract interfaces, procedures, generic identifiers, and namelist groups.
<P>
</PRE>
2 If an entity that is accessed by use association has the same nongeneric name as a host entity, the host entity is
<P>
<PRE>
  inaccessible by that name. The name of an external procedure that is given the EXTERNAL attribute (8.5.9)
<P>
  within the scoping unit, or a name that appears within the scoping unit as a module-name in a use-stmt is a
<P>
  global identifier; any entity of the host that has this as its nongeneric name is inaccessible by that name. A name
<P>
  that appears in the scoping unit as
<P>
          (1)    a function-name in a stmt-function-stmt or in an entity-decl in a type-declaration-stmt, unless it is a
<P>
                 global identifier,
<P>
          (2)    an object-name in an entity-decl in a type-declaration-stmt, in a pointer-stmt, in a save-stmt, in an
<P>
                 allocatable-stmt, or in a target-stmt,
<P>
          (3)    a type-param-name in a derived-type-stmt,
<P>
          (4)    a named-constant in a named-constant-def in a parameter-stmt,
<P>
          (5)    a coarray-name in a codimension-stmt,
<P>
          (6)    an array-name in a dimension-stmt,
<P>
          (7)    a variable-name in a common-block-object in a common-stmt,
<P>
          (8)    a procedure pointer given the EXTERNAL attribute in the scoping unit,
<P>
          (9)    the name of a variable that is wholly or partially initialized in a data-stmt,
<P>
          (10) the name of an object that is wholly or partially equivalenced in an equivalence-stmt,
<P>
          (11) a dummy-arg-name in a function-stmt, in a subroutine-stmt, in an entry-stmt, or in a stmt-function-stmt ,
<P>
          (12) a result-name in a function-stmt or in an entry-stmt ,
<P>
          (13) the name of an entity declared by an interface body, unless it is a global identifier,
<P>
          (14) an intrinsic-procedure-name in an intrinsic-stmt,
<P>
          (15) a namelist-group-name in a namelist-stmt,
<P>
          (16) a generic-name in a generic-spec in an interface-stmt, or
<P>
          (17) the name of a named construct
<P>
  is a local identifier in the scoping unit and any entity of the host that has this as its nongeneric name is inaccessible
<P>
  by that name by host association. If a scoping unit is the host of a derived-type definition or a subprogram that
<P>
  does not define a separate module procedure, the name of the derived type or of any procedure defined by the
<P>
  subprogram is a local identifier in the scoping unit; any entity of the host that has this as its nongeneric name is
<P>
  inaccessible by that name. Local identifiers of a subprogram are not accessible to its host.
<P>
        NOTE 19.5
<P>
        A name that appears in an ASYNCHRONOUS or VOLATILE statement is not necessarily the name of a
<P>
        local variable. In an internal or module procedure, if a variable that is accessible via host association is spe-
<P>
        cified in an ASYNCHRONOUS or VOLATILE statement, that host variable is given the ASYNCHRONOUS
<P>
        or VOLATILE attribute in the local scope.
<P>
  514                                                                       ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 If a host entity is inaccessible only because a local variable with the same name is wholly or partially initialized
<P>
<PRE>
  in a DATA statement, the local variable shall not be referenced or defined prior to the DATA statement.
<P>
</PRE>
4 If a derived-type name of a host is inaccessible, data entities of that type or subobjects of such data entities still
<P>
<PRE>
  can be accessible.
<P>
        NOTE 19.6
<P>
        An interface body that is not a module procedure interface body accesses by host association only those
<P>
        entities made accessible by IMPORT statements.
<P>
</PRE>
5 If an external or dummy procedure with an implicit interface is accessed via host association, then it shall have
<P>
<PRE>
  the EXTERNAL attribute in the host scoping unit; if it is invoked as a function in the inner scoping unit, its type
<P>
  and type parameters shall be established in the host scoping unit. The type and type parameters of a function
<P>
  with the EXTERNAL attribute are established in a scoping unit if that scoping unit explicitly declares them,
<P>
  invokes the function, accesses the function from a module, or accesses the function from its host where its type
<P>
  and type parameters are established.
<P>
</PRE>
6 If an intrinsic procedure is accessed via host association, then it shall be established to be intrinsic in the host
<P>
<PRE>
  scoping unit. An intrinsic procedure is established to be intrinsic in a scoping unit if that scoping unit explicitly
<P>
  gives it the INTRINSIC attribute, invokes it as an intrinsic procedure, accesses it from a module, or accesses it
<P>
  from its host where it is established to be intrinsic.
<P>
        NOTE 19.7
<P>
        A host subprogram and an internal subprogram can contain the same and differing use-associated entities,
<P>
        as illustrated in the following example.
<P>
        MODULE B; REAL BX, Q; INTEGER IX, JX; END MODULE B
<P>
        MODULE C; REAL CX; END MODULE C
<P>
        MODULE D; REAL DX, DY, DZ; END MODULE D
<P>
        MODULE E; REAL EX, EY, EZ; END MODULE E
<P>
        MODULE F; REAL FX; END MODULE F
<P>
        MODULE G; USE F; REAL GX; END MODULE G
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM A</H4>
</A>
<BLOCKQUOTE>
<P>
USE B; USE C; USE D
<P>
<PRE>
            &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE INNER_PROC (Q)
<P>
<PRE>
                USE C                 ! Not needed
<P>
                USE B, ONLY: BX ! Entities accessible are BX, IX, and JX
<P>
                                      ! if no other IX or JX
<P>
                                      ! is accessible to INNER_PROC
<P>
                                      ! Q is local to INNER_PROC,
<P>
                                      ! because Q is a dummy argument
<P>
                USE D, X =&gt; DX        ! Entities accessible are DX, DY, and DZ
<P>
                                      ! X is local name for DX in INNER_PROC
<P>
                                      ! X and DX denote same entity if no other
<P>
                                      ! entity DX is local to INNER_PROC
<P>
                USE E, ONLY: EX ! EX is accessible in INNER_PROC, not in program A
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
515
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
        NOTE 19.7 (cont.)
<P>
                                      ! EY and EZ are not accessible in INNER_PROC
<P>
                                      ! or in program A
<P>
                 USE G                ! FX and GX are accessible in INNER_PROC
<P>
                 &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE INNER_PROC</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM A</H4>
</A>
<BLOCKQUOTE>
<P>
Because program A contains the statement
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE B</H4>
</A>
<BLOCKQUOTE>
<P>
all of the entities in module B, except for Q, are accessible in INNER_PROC, even though INNER_PROC
<P>
contains the statement
<P>
USE B, ONLY: BX
<P>
The USE statement with the ONLY option means that this particular statement brings in only the entity
<P>
named, not that this is the only variable from the module accessible in this scoping unit.
<P>
NOTE 19.8
<P>
For more examples of host association, see subclause C.13.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: For more examples of host association, see subclause C.13.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>19.5.1.5</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Linkage association
<P>
1 Linkage association occurs between a module variable that has the BIND attribute and the C variable with which
<P>
<PRE>
  it interoperates, or between a Fortran common block and the C variable with which it interoperates (18.9). Such association
<P>
  remains in effect throughout the execution of the program.
<P>
  19.5.1.6     Construct association
<P>
</PRE>
1 Execution of a SELECT RANK or SELECT TYPE statement establishes an association between the selector and
<P>
<PRE>
  the associate name of the construct. Execution of an ASSOCIATE or CHANGE TEAM statement statement
<P>
  establishes an association between each selector and the corresponding associate name of the construct.
<P>
</PRE>
2 In an ASSOCIATE or SELECT TYPE construct, the following rules apply.
<P>
<PRE>
      • If a selector is allocatable, it shall be allocated; the associate name is associated with the data object and
<P>
         does not have the ALLOCATABLE attribute.
<P>
      • If a selector has the POINTER attribute, it shall be associated; the associate name is associated with the
<P>
         target of the pointer and does not have the POINTER attribute.
<P>
</PRE>
3 If the selector is a variable other than an array section having a vector subscript, the association is with the data
<P>
<PRE>
  object specified by the selector; otherwise, the association is with the value of the selector expression, which is
<P>
  evaluated prior to execution of the block.
<P>
</PRE>
4 Each associate name remains associated with the corresponding selector throughout the execution of the executed
<P>
<PRE>
  block. Within the block, each selector is known by and may be accessed by the corresponding associate name.
<P>
  On completion of execution of the construct, the association is terminated.
<P>
  516                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
<P>
        NOTE 19.9
<P>
        The association between the associate name and a data object is established prior to execution of the block
<P>
        and is not affected by subsequent changes to variables that were used in subscripts or substring ranges in
<P>
        the selector.
<P>
  19.5.2      Pointer association
<P>
  19.5.2.1    General
<P>
</PRE>
1 Pointer association between a pointer and a target allows the target to be referenced by a reference to the pointer.
<P>
<PRE>
  At different times during the execution of a program, a pointer may be undefined, associated with different targets
<P>
  on its own image, or be disassociated. If a pointer is associated with a target, the definition status of the pointer
<P>
  is either defined or undefined, depending on the definition status of the target. If the pointer has deferred type
<P>
  parameters or shape, their values are assumed from the target. If the pointer is polymorphic, its dynamic type
<P>
  is assumed from the dynamic type of the target.
<P>
  19.5.2.2    Pointer association status
<P>
</PRE>
1 A pointer may have a pointer association status of associated, disassociated, or undefined. Its association status
<P>
<PRE>
  may change during execution of a program. Unless a pointer is initialized (explicitly or by default), it has an
<P>
  initial association status of undefined. A pointer may be initialized to have an association status of disassociated
<P>
  or associated.
<P>
        NOTE 19.10
<P>
        A pointer from a module program unit might be accessible in a subprogram via use association. Such
<P>
        pointers have a lifetime that is greater than targets that are declared in the subprogram, unless such targets
<P>
        are saved. Therefore, if such a pointer is associated with a local target, there is the possibility that when
<P>
        a procedure defined by the subprogram completes execution, the target will cease to exist, leaving the
<P>
        pointer “dangling”. This document considers such pointers to have an undefined association status. They
<P>
        are neither associated nor disassociated. They cannot be used again in the program until their status has
<P>
        been reestablished. A processor is not required to detect when a pointer target ceases to exist.
<P>
  19.5.2.3    Events that cause pointers to become associated
<P>
</PRE>
1 A pointer becomes associated when any of the following events occur.
<P>
<PRE>
         (1)    The pointer is allocated (9.7.1) as the result of the successful execution of an ALLOCATE statement
<P>
                referencing the pointer.
<P>
         (2)    The pointer is pointer-assigned to a target (10.2.2) that is associated or is specified with the TARGET
<P>
                attribute and, if allocatable, is allocated.
<P>
         (3)    The pointer is a subobject of an object that is allocated by an ALLOCATE statement in which
<P>
                SOURCE= appears and the corresponding subobject of source-expr is associated.
<P>
         (4)    The pointer is a dummy argument and its corresponding actual argument is not a pointer.
<P>
         (5)    The pointer is a default-initialized subcomponent of an object, the corresponding initializer is not a
<P>
                reference to the intrinsic function NULL, and
<P>
                (a)    a procedure is invoked with this object as an actual argument corresponding to a nonpointer
<P>
                       nonallocatable dummy argument with INTENT (OUT),
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
517
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
              (b)    a procedure with this object as an unsaved nonpointer nonallocatable local variable is invoked,
<P>
              (c)    a BLOCK construct is entered and this object is an unsaved local nonpointer nonallocatable
<P>
                     local variable of the BLOCK construct,
<P>
                     or
<P>
              (d)    this object is allocated other than by an ALLOCATE statement in which SOURCE= appears.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>19.5.2.4</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Events that cause pointers to become disassociated
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 A pointer becomes disassociated when
</TD></TR>
<TR><TD colspan=2>
<PRE>
        (1)   the pointer is nullified (9.7.2),
<P>
        (2)   the pointer is deallocated (9.7.3),
<P>
        (3)   the pointer is pointer-assigned (10.2.2) to a disassociated pointer,
<P>
        (4)   the pointer is a subobject of an object that is allocated by an ALLOCATE statement in which
<P>
              SOURCE= appears and the corresponding subobject of source-expr is disassociated,
<P>
              or
<P>
        (5)   the pointer is a default-initialized subcomponent of an object, the corresponding initializer is a
<P>
              reference to the intrinsic function NULL, and
<P>
              (a)    a procedure is invoked with this object as an actual argument corresponding to a nonpointer
<P>
                     nonallocatable dummy argument with INTENT (OUT),
<P>
              (b)    a procedure with this object as an unsaved nonpointer nonallocatable local variable is invoked,
<P>
              (c)    a BLOCK construct is entered and this object is an unsaved local nonpointer nonallocatable
<P>
                     local variable of the BLOCK construct,
<P>
                     or
<P>
              (d)    this object is allocated other than by an ALLOCATE statement in which SOURCE= appears.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>19.5.2.5</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Events that cause the association status of pointers to become undefined
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 The association status of a pointer becomes undefined when
</TD></TR>
<TR><TD colspan=2>
<PRE>
        (1)   the pointer is pointer-assigned to a target that has an undefined association status,
<P>
        (2)   the pointer is pointer-assigned to a target on a different image,
<P>
        (3)   the target of the pointer is deallocated other than through the pointer,
<P>
        (4)   the target of the pointer is a data object defined by the companion processor and the lifetime of that
<P>
              data object ends,
<P>
        (5)   the allocation transfer procedure (16.9.137) is executed, the pointer is associated with the argument
<P>
              FROM, and the argument TO does not have the TARGET attribute,
<P>
        (6)   completion of execution of an instance of a subprogram causes the pointer’s target to become un-
<P>
              defined (item (3) of 19.6.6),
<P>
        (7)   completion of execution of a BLOCK construct causes the pointer’s target to become undefined (item
<P>
              (23) of 19.6.6),
<P>
        (8)   execution of the host instance of a procedure pointer is completed,
<P>
        (9)   execution of an instance of a subprogram completes and the pointer is declared or accessed in the
<P>
              subprogram that defines the procedure if the pointer
<P>
              (a)    does not have the SAVE attribute,
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>518</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>(b)</B> </TD><TD valign=bottom>
is not in blank common,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>(c)</B> </TD><TD valign=bottom>
is not in a named common block that is declared in any other scoping unit that is in execution,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>(d)</B> </TD><TD valign=bottom>
is not accessed by host association, and
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>(e)</B> </TD><TD valign=bottom>
is not the result of a function declared to have the POINTER attribute,
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
(10) execution of an instance of a subprogram completes, the pointer is associated with a dummy argument
</TD></TR>
<TR><TD colspan=2>
<PRE>
               of the procedure, and
<P>
               (a)    the effective argument does not have the TARGET attribute or is an array section with a
<P>
                      vector subscript, or
<P>
               (b)    the dummy argument has the VALUE attribute,
<P>
</PRE>
(11) a BLOCK construct completes execution and the pointer is an unsaved construct entity of that
</TD></TR>
<TR><TD colspan=2>
<PRE>
               BLOCK construct,
<P>
</PRE>
(12) a DO CONCURRENT construct is terminated and the pointer’s association status was changed in
</TD></TR>
<TR><TD colspan=2>
<PRE>
               more than one iteration of the construct,
<P>
</PRE>
(13) an iteration of a DO CONCURRENT construct completes and the pointer is associated with a
</TD></TR>
<TR><TD colspan=2>
<PRE>
               variable of that construct that has LOCAL or LOCAL_INIT locality,
<P>
</PRE>
(14) the pointer is a subcomponent of an object that is allocated and either
</TD></TR>
<TR><TD colspan=2>
<PRE>
               (a)    the pointer is not default-initialized and SOURCE= does not appear, or
<P>
               (b)    SOURCE= appears and the association status of the corresponding subcomponent of source-
<P>
                      expr is undefined,
<P>
</PRE>
(15) the pointer is a subcomponent of an object, the pointer is not default-initialized, and a procedure is
</TD></TR>
<TR><TD colspan=2>
<PRE>
               invoked with this object as an actual argument corresponding to a dummy argument with INTENT
<P>
               (OUT),
<P>
</PRE>
(16) a procedure is invoked with the pointer as an actual argument corresponding to a pointer dummy
</TD></TR>
<TR><TD colspan=2>
<PRE>
               argument with INTENT (OUT), or
<P>
</PRE>
(17) evaluation of an expression containing a function reference that need not be evaluated completes, if
</TD></TR>
<TR><TD colspan=2>
<PRE>
               execution of that function would change the association status of the pointer.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>19.5.2.6</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Other events that change the association status of pointers
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 When a pointer becomes associated with another pointer by argument association, construct association, or host
</TD></TR>
<TR><TD colspan=2>
<PRE>
  association, the effects on its association status are specified in 19.5.5.
<P>
</PRE>
2 While two pointers are name associated, storage associated, or inheritance associated, if the association status of
</TD></TR>
<TR><TD colspan=2>
<PRE>
  one pointer changes, the association status of the other changes accordingly.
<P>
</PRE>
3 The association status of a pointer object with the VOLATILE attribute might change by means not specified
</TD></TR>
<TR><TD colspan=2>
<PRE>
  by the program.
<P>
  19.5.2.7    Pointer definition status
<P>
</PRE>
1 The definition status of an associated pointer is that of its target. If a pointer is associated with a definable
</TD></TR>
<TR><TD colspan=2>
<PRE>
  target, it may be defined or become undefined according to the rules for a variable (19.6). The definition status
<P>
  of a pointer that is not associated is undefined.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                               519
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  19.5.2.8    Relationship between association status and definition status
<P>
</PRE>
1 If the association status of a pointer is disassociated or undefined, the pointer shall not be referenced or dealloc-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ated. Whatever its association status, a pointer always may be nullified, allocated, or pointer-assigned. A nullified
<P>
  pointer is disassociated. When a pointer is allocated, it becomes associated but undefined. When a pointer is
<P>
  pointer-assigned, its association and definition status become those of the specified data-target or proc-target.
<P>
  19.5.3      Storage association
<P>
  19.5.3.1    General
<P>
</PRE>
1 Storage sequences are used to describe relationships that exist among variables and common blocks. Storage asso-
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ciation is the association of two or more data objects that occurs when two or more storage sequences share or
<P>
  are aligned with one or more storage units.
<P>
  19.5.3.2    Storage sequence
<P>
</PRE>
1 A storage sequence is a sequence of storage units. The size of a storage sequence is the number of storage units
</TD></TR>
<TR><TD colspan=2>
<PRE>
  in the storage sequence. A storage unit is a character storage unit, a numeric storage unit, a file storage unit
<P>
  (12.3.5), or an unspecified storage unit. The sizes of the numeric storage unit, the character storage unit and the
<P>
  file storage unit are the values of constants in the ISO_FORTRAN_ENV intrinsic module (16.10.2).
<P>
</PRE>
2 In a storage association context
</TD></TR>
<TR><TD colspan=2>
<PRE>
          (1)   a nonpointer scalar object that is default integer, default real, or default logical occupies a single
<P>
                numeric storage unit,
<P>
          (2)   a nonpointer scalar object that is double precision real or default complex occupies two contiguous
<P>
                numeric storage units,
<P>
          (3)   a default character nonpointer scalar object of character length len occupies len contiguous character
<P>
                storage units,
<P>
          (4)   if C character kind is not the same as default character kind a nonpointer scalar object of type char-
<P>
                acter with the C character kind (18.2.2) and character length len occupies len contiguous unspecified
<P>
                storage units,
<P>
          (5)   a nonpointer scalar object of sequence type occupies a sequence of storage sequences corresponding
<P>
                to the sequence of its ultimate components,
<P>
          (6)   a nonpointer scalar object of any type not specified in items (1)-(5) occupies a single unspecified
<P>
                storage unit that is different for each case and each set of type parameter values, and that is different
<P>
                from the unspecified storage units of item (4),
<P>
          (7)   a nonpointer array occupies a sequence of contiguous storage sequences, one for each array element,
<P>
                in array element order (9.5.3.2), and
<P>
          (8)   a data pointer occupies a single unspecified storage unit that is different from that of any nonpointer
<P>
                object and is different for each combination of type, type parameters, and rank. A data pointer that
<P>
                has the CONTIGUOUS attribute occupies a storage unit that is different from that of a data pointer
<P>
                that does not have the CONTIGUOUS attribute.
<P>
</PRE>
3 A sequence of storage sequences forms a storage sequence. The order of the storage units in such a composite
</TD></TR>
<TR><TD colspan=2>
<PRE>
  storage sequence is that of the individual storage units in each of the constituent storage sequences taken in
<P>
  succession, ignoring any zero-sized constituent sequences.
<P>
  520                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Each common block has a storage sequence (8.10.2.2).
</TD></TR>
<TR><TD colspan=2>
<PRE>
  19.5.3.3       Association of storage sequences
<P>
</PRE>
1 Two nonzero-sized storage sequences s1 and s2 are storage associated if the ith storage unit of s1 is the same as
</TD></TR>
<TR><TD colspan=2>
<PRE>
  the jth storage unit of s2 . This causes the (i + k)th storage unit of s1 to be the same as the (j + k)th storage
<P>
  unit of s2 , for each integer k such that 1 ≤ i + k ≤ size of s1 and 1 ≤ j + k ≤ size of s2 where size of measures
<P>
  the number of storage units.
<P>
</PRE>
2 Storage association also is defined between two zero-sized storage sequences, and between a zero-sized storage
</TD></TR>
<TR><TD colspan=2>
<PRE>
  sequence and a storage unit. A zero-sized storage sequence in a sequence of storage sequences is storage associated
<P>
  with its successor, if any. If the successor is another zero-sized storage sequence, the two sequences are storage
<P>
  associated. If the successor is a nonzero-sized storage sequence, the zero-sized sequence is storage associated with
<P>
  the first storage unit of the successor. Two storage units that are each storage associated with the same zero-sized
<P>
  storage sequence are the same storage unit.
<P>
  19.5.3.4       Association of scalar data objects
<P>
</PRE>
1 Two scalar data objects are storage associated if their storage sequences are storage associated. Two scalar entities
</TD></TR>
<TR><TD colspan=2>
<PRE>
  are totally associated if they have the same storage sequence. Two scalar entities are partially associated if they
<P>
  are associated without being totally associated.
<P>
</PRE>
2 The definition status and value of a data object affects the definition status and value of any storage associated
</TD></TR>
<TR><TD colspan=2>
<PRE>
  entity. An EQUIVALENCE statement, a COMMON statement, or an ENTRY statement can cause storage association of storage
<P>
  sequences.
<P>
</PRE>
3 An EQUIVALENCE statement causes storage association of data objects only within one scoping unit, unless one of the equivalenced
</TD></TR>
<TR><TD colspan=2>
<PRE>
  entities is also in a common block (8.10.1.2, 8.10.2.2).
<P>
</PRE>
4 COMMON statements cause data objects in one scoping unit to become storage associated with data objects in another scoping unit.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
5 A common block is permitted to contain a sequence of differing storage units. All scoping units that access named common blocks
<P>
<PRE>
  with the same name shall specify an identical sequence of storage units. Blank common blocks may be declared with differing sizes
<P>
  in different scoping units. For any two blank common blocks, the initial sequence of storage units of the longer blank common block
<P>
  shall be identical to the sequence of storage units of the shorter common block. If two blank common blocks are the same length,
<P>
  they shall have the same sequence of storage units.
<P>
</PRE>
6 An ENTRY statement in a function subprogram causes storage association of the function results that are variables.
<P>
7 Partial association shall exist only between
<P>
<PRE>
      • an object that is default character or of character sequence type and an object that is default character or
<P>
          of character sequence type, or
<P>
      • an object that is default complex, double precision real, or of numeric sequence type and an object that is
<P>
          default integer, default real, default logical, double precision real, default complex, or of numeric sequence
<P>
          type.
<P>
</PRE>
8 For noncharacter entities, partial association may occur only through the use of COMMON, EQUIVALENCE, or ENTRY statements.
<P>
<PRE>
  For character entities, partial association may occur only through argument association or the use of COMMON or
<P>
  EQUIVALENCE statements.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                                         521
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
9 Partial association of character entities occurs when some, but not all, of the storage units of the entities are the
<P>
<PRE>
   same.
<P>
</PRE>
10 A storage unit shall not be explicitly initialized more than once in a program. Explicit initialization overrides
<P>
<PRE>
   default initialization, and default initialization for an object of derived type overrides default initialization for
<P>
   a component of the object (7.5.4.6). Default initialization may be specified for a storage unit that is storage
<P>
   associated provided the objects supplying the default initialization are of the same type and type parameters,
<P>
   and supply the same value for the storage unit.
<P>
   19.5.4     Inheritance association
<P>
</PRE>
1 Inheritance association occurs between components of the parent component and components inherited by type
<P>
<PRE>
   extension into an extended type (7.5.7.2). This association is persistent; it is not affected by the accessibility of
<P>
   the inherited components.
<P>
   19.5.5     Establishing associations
<P>
</PRE>
1 When an association is established between two entities by argument association, host association, or construct
<P>
<PRE>
   association, certain properties of the associating entity become those of the pre-existing entity.
<P>
</PRE>
2 For argument association, the pre-existing entity is the effective argument and the associating entity is the dummy
<P>
<PRE>
   argument.
<P>
</PRE>
3 For host association, the associating entity is the entity in the contained scoping unit. When a procedure is
<P>
<PRE>
   invoked, the pre-existing entity that participates in the association is the one from its host instance (15.6.2.4).
<P>
   Otherwise the pre-existing entity that participates in the association is the entity in the host scoping unit.
<P>
</PRE>
4 For construct association, the associating entity is identified by the associate name and the pre-existing entity is
<P>
<PRE>
   the selector.
<P>
</PRE>
5 When an association is established by argument association, host association, or construct association, the fol-
<P>
<PRE>
   lowing applies.
<P>
      • If the entities have the POINTER attribute, the pointer association status of the associating entity becomes
<P>
         the same as that of the pre-existing entity. If the pre-existing entity has a pointer association status of
<P>
         associated, the associating entity becomes pointer associated with the same target and, if they are arrays,
<P>
         the bounds of the associating entity become the same as those of the pre-existing entity.
<P>
      • If the associating entity has the ALLOCATABLE attribute, its allocation status becomes the same as that
<P>
         of the pre-existing entity. If the pre-existing entity is allocated, the bounds (if it is an array), values of
<P>
         deferred type parameters, definition status, and value (if it is defined) become the same as those of the
<P>
         pre-existing entity. If the associating entity is polymorphic and the pre-existing entity is allocated, the
<P>
         dynamic type of the associating entity becomes the same as that of the pre-existing entity.
<P>
      • If the associating entity is neither a pointer nor allocatable, its definition status, value (if it is defined), and
<P>
         dynamic type (if it is polymorphic) become the same as those of the pre-existing entity. If the entities are
<P>
         arrays and the association is not argument association, the bounds of the associating entity become the
<P>
         same as those of the pre-existing entity.
<P>
      • If the associating entity is a pointer dummy argument and the pre-existing entity is a nonpointer actual
<P>
         argument the associating entity becomes pointer associated with the pre-existing entity and, if the entities
<P>
         are arrays, the bounds of the associating entity become the same as those of the pre-existing entity.
<P>
   522                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>19.6</B> </TD><TD valign=bottom>
Definition and undefinition of variables
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>19.6.1</B> </TD><TD valign=bottom>
Definition of objects and subobjects
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
1 A variable may be defined or may be undefined and its definition status may change during execution of a
<P>
<PRE>
  program. An action that causes a variable to become undefined does not imply that the variable was previously
<P>
  defined. An action that causes a variable to become defined does not imply that the variable was previously
<P>
  undefined.
<P>
</PRE>
2 Arrays, including sections, and variables of derived, character, or complex type are objects that consist of zero
<P>
<PRE>
  or more subobjects. Associations may be established between variables and subobjects and between subobjects
<P>
  of different variables. These subobjects may become defined or undefined.
<P>
</PRE>
3 An array is defined if and only if all of its elements are defined.
<P>
4 A derived-type scalar object is defined if and only if all of its nonpointer components are defined.
<P>
5 A complex or character scalar object is defined if and only if all of its subobjects are defined.
<P>
6 If an object is undefined, at least one (but not necessarily all) of its subobjects are undefined.
<P>
<PRE>
  19.6.2      Variables that are always defined
<P>
</PRE>
1 Zero-sized arrays and zero-length strings are always defined.
<P>
<PRE>
  19.6.3      Variables that are initially defined
<P>
</PRE>
1 The following variables are initially defined:
<P>
<PRE>
         (1)    variables specified to have initial values by DATA statements;
<P>
         (2)    variables specified to have initial values by type declaration statements;
<P>
         (3)    nonpointer default-initialized subcomponents of saved variables that do not have the ALLOCAT-
<P>
                ABLE or POINTER attribute;
<P>
         (4)    pointers specified to be initially associated with a variable that is initially defined;
<P>
         (5)    variables that are always defined;
<P>
         (6)    variables with the BIND attribute that are initialized by means other than Fortran.
<P>
</PRE>
NOTE 19.11
<TABLE width=100% cellpadding=3><!-- tsb: NOTE 19.11
 -->
<TR></TR><TR></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
Fortran code:
<P>
module mod
<P>
<PRE>
           integer, bind(c,name="blivet") :: foo
<P>
</PRE>
end module mod
<P>
C code:
<P>
int blivet = 123;
<P>
In the above example, the Fortran variable foo is initially defined to have the value 123 by means other
<P>
than Fortran.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
523
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>19.6.4</B> </TD><TD valign=bottom>
Variables that are initially undefined
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 Variables that are not initially defined are initially undefined.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  19.6.5     Events that cause variables to become defined
<P>
</PRE>
1 Variables become defined by the following events.
</TD></TR>
<TR><TD colspan=2>
<PRE>
        (1)   Execution of an intrinsic assignment statement other than a masked array assignment or FORALL
<P>
              assignment statement causes the variable that precedes the equals to become defined.
<P>
        (2)   Execution of a masked array assignment or FORALL assignment statement might cause some or all of
<P>
              the array elements in the assignment statement to become defined (10.2.3).
<P>
        (3)   As execution of an input statement proceeds, each variable that is assigned a value from the input
<P>
              file becomes defined at the time that data are transferred to it. (See (4) in 19.6.6.) Execution of a
<P>
              WRITE statement whose unit specifier identifies an internal file causes each record that is written
<P>
              to become defined.
<P>
        (4)   Execution of a DO statement causes the DO variable, if any, to become defined.
<P>
        (5)   Beginning of execution of the action specified by an io-implied-do in a synchronous data transfer
<P>
              statement causes the do-variable to become defined.
<P>
        (6)   A reference to a procedure causes an entire dummy data object to become defined if the dummy data
<P>
              object does not have INTENT (OUT) and the entire effective argument is defined.
<P>
              A reference to a procedure causes a subobject of a dummy argument to become defined if the dummy
<P>
              argument does not have INTENT (OUT) and the corresponding subobject of the effective argument
<P>
              is defined.
<P>
        (7)   Execution of an input/output statement containing an IOSTAT= specifier causes the specified integer
<P>
              variable to become defined.
<P>
        (8)   Execution of a synchronous input statement containing a SIZE= specifier causes the specified integer
<P>
              variable to become defined.
<P>
        (9)   Execution of a wait operation (12.7.1) corresponding to an asynchronous input statement containing
<P>
              a SIZE= specifier causes the specified integer variable to become defined.
<P>
        (10) Execution of an INQUIRE statement causes any variable that is assigned a value during the execution
<P>
              of the statement to become defined if no error condition exists.
<P>
        (11) If an error, end-of-file, or end-of-record condition occurs during execution of an input/output state-
<P>
              ment that has an IOMSG= specifier, the iomsg-variable becomes defined.
<P>
        (12) When a character storage unit becomes defined, all associated character storage units become defined.
<P>
              When a numeric storage unit becomes defined, all associated numeric storage units of the same type
<P>
              become defined. When an entity of double precision real type becomes defined, all totally associated
<P>
              entities of double precision real type become defined.
<P>
              When an unspecified storage unit becomes defined, all associated unspecified storage units become
<P>
              defined.
<P>
        (13) When a default complex entity becomes defined, all partially associated default real entities become
<P>
              defined.
<P>
        (14) When both parts of a default complex entity become defined as a result of partially associated default
<P>
              real or default complex entities becoming defined, the default complex entity becomes defined.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>524</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                         ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
(15) When all components of a structure of a numeric sequence type or character sequence type become
</TD></TR>
<TR><TD colspan=2>
<PRE>
         defined as a result of partially associated objects becoming defined, the structure becomes defined.
<P>
</PRE>
(16) Execution of a statement with a STAT= specifier causes the variable specified by the STAT= specifier
</TD></TR>
<TR><TD colspan=2>
<PRE>
         to become defined.
<P>
</PRE>
(17) If an error condition occurs during execution of a statement that has an ERRMSG= specifier, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
         variable specified by the ERRMSG= specifier becomes defined.
<P>
</PRE>
(18) Allocation of a zero-sized array or zero-length character variable causes the array or variable to
</TD></TR>
<TR><TD colspan=2>
<PRE>
         become defined.
<P>
</PRE>
(19) Allocation of an object that has a nonpointer default-initialized subcomponent, except by an AL-
</TD></TR>
<TR><TD colspan=2>
<PRE>
         LOCATE statement with a SOURCE= specifier, causes that subcomponent to become defined.
<P>
</PRE>
(20) Successful execution of an ALLOCATE statement with a SOURCE= specifier causes a subobject of
</TD></TR>
<TR><TD colspan=2>
<PRE>
         the allocated object to become defined if the corresponding subobject of the SOURCE= expression
<P>
         is defined.
<P>
</PRE>
(21) Invocation of a procedure causes any automatic data object of zero size or zero character length in
</TD></TR>
<TR><TD colspan=2>
<PRE>
         that procedure to become defined.
<P>
</PRE>
(22) When a pointer becomes associated with a target that is defined, the pointer becomes defined.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
(23) Invocation of a procedure that contains an unsaved nonpointer nonallocatable local variable causes
<P>
<PRE>
         all nonpointer default-initialized subcomponents of the object to become defined.
<P>
</PRE>
(24) Invocation of a procedure that has a nonpointer nonallocatable INTENT (OUT) dummy argument
<P>
<PRE>
         causes all nonpointer default-initialized subcomponents of the dummy argument to become defined.
<P>
</PRE>
(25) In a DO CONCURRENT or FORALL construct, the index-name becomes defined when the index-
<P>
<PRE>
         name value set is evaluated.
<P>
</PRE>
(26) In a DO CONCURRENT construct, a variable with LOCAL_INIT locality becomes defined at the
<P>
<PRE>
         beginning of each iteration.
<P>
</PRE>
(27) An object with the VOLATILE attribute that is changed by a means not specified by the program
<P>
<PRE>
         might become defined (see 8.5.19).
<P>
</PRE>
(28) Execution of the BLOCK statement of a BLOCK construct that has an unsaved nonpointer non-
<P>
<PRE>
         allocatable local variable causes all nonpointer default-initialized subcomponents of the variable to
<P>
         become defined.
<P>
</PRE>
(29) Execution of an OPEN statement containing a NEWUNIT= specifier causes the specified integer
<P>
<PRE>
         variable to become defined.
<P>
</PRE>
(30) Execution of a LOCK statement containing an ACQUIRED_LOCK= specifier causes the specified
<P>
<PRE>
         logical variable to become defined. If the logical variable becomes defined with the value true, the
<P>
         lock variable in the LOCK statement also becomes defined.
<P>
</PRE>
(31) Successful execution of a LOCK statement that does not contain an ACQUIRED_LOCK= specifier
<P>
<PRE>
         causes the lock variable to become defined.
<P>
</PRE>
(32) Successful execution of an UNLOCK statement causes the lock variable to become defined.
<P>
(33) Failure of an image that locked a lock variable without unlocking it causes the lock variable to become
<P>
<PRE>
         defined.
<P>
</PRE>
(34) Successful execution of an EVENT POST or EVENT WAIT statement causes the event variable to
<P>
<PRE>
         become defined.
<P>
</PRE>
(35) Successful execution of a FORM TEAM statement causes the team variable to become defined.
</TD></TR>
<TR><TD colspan=2>
⃝
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
525
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  19.6.6     Events that cause variables to become undefined
<P>
</PRE>
1 Variables become undefined by the following events.
</TD></TR>
<TR><TD colspan=2>
<PRE>
       (1)  When a scalar variable of intrinsic type becomess defined, all totally associated variables of different type become
<P>
            undefined.    When a double precision scalar variable becomes defined, all partially associated scalar
<P>
            variables become undefined. When a scalar variable becomes undefined, all partially associated double
<P>
            precision scalar variables become undefined.
<P>
       (2)  If the evaluation of a function would cause a variable to become defined and if a reference to the
<P>
            function appears in an expression in which the value of the function is not needed to determine the
<P>
            value of the expression, the variable becomes undefined when the expression is evaluated.
<P>
       (3)  When execution of an instance of a subprogram completes,
<P>
            (a)     its unsaved local variables become undefined,
<P>
            (b)     unsaved variables in a named common block that appears in the subprogram become undefined if they have been
<P>
                    defined or redefined, unless another active scoping unit is referencing the common block, and
<P>
            (c)     a variable of type C_PTR from the intrinsic module ISO_C_BINDING whose value is the C
<P>
                    address of an unsaved local variable of the subprogram becomes undefined.
<P>
       (4)  When an error condition or end-of-file condition occurs during execution of an input statement, all of
<P>
            the variables specified by the input list or namelist group of the statement become undefined.
<P>
       (5)  When an error condition occurs during execution of an output statement in which the unit is an internal
<P>
            file, the internal file becomes undefined.
<P>
       (6)  When an error condition, end-of-file condition, or end-of-record condition occurs during execution of
<P>
            an input/output statement and the statement contains any io-implied-dos, all of the do-variables in
<P>
            the statement become undefined (12.11).
<P>
       (7)  Execution of a direct access input statement that specifies a record that has not been written previously
<P>
            causes all of the variables specified by the input list of the statement to become undefined.
<P>
       (8)  Execution of an INQUIRE statement might cause the NAME=, RECL=, and NEXTREC= variables
<P>
            to become undefined (12.10).
<P>
       (9)  When a character storage unit becomes undefined, all associated character storage units become un-
<P>
            defined.
<P>
            When a numeric storage unit becomes undefined, all associated numeric storage units become undefined
<P>
            unless the undefinition is a result of defining an associated numeric storage unit of different type (see
<P>
            (1) above).
<P>
            When an entity of double precision real type becomes undefined, all totally associated entities of double
<P>
            precision real type become undefined.
<P>
            When an unspecified storage unit becomes undefined, all associated unspecified storage units become
<P>
            undefined.
<P>
       (10) When an allocatable entity is deallocated, it becomes undefined.
<P>
       (11) When the allocation transfer procedure (16.9.137) causes the allocation status of an allocatable entity
<P>
            to become unallocated, the entity becomes undefined.
<P>
       (12) Successful execution of an ALLOCATE statement with no SOURCE= specifier causes a subcomponent
<P>
            of an allocated object to become undefined if default initialization has not been specified for that
<P>
            subcomponent.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>526</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                         ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
(13) Successful execution of an ALLOCATE statement with a SOURCE= specifier causes a subobject of
</TD></TR>
<TR><TD colspan=2>
<PRE>
        the allocated object to become undefined if the corresponding subobject of the SOURCE= expression
<P>
        is undefined.
<P>
</PRE>
(14) Execution of an INQUIRE statement causes all inquiry specifier variables to become undefined if an
</TD></TR>
<TR><TD colspan=2>
<PRE>
        error condition exists, except for any variable in an IOSTAT= or IOMSG= specifier.
<P>
</PRE>
(15) When a procedure is invoked
</TD></TR>
<TR><TD colspan=2>
<PRE>
        (a)    an optional dummy argument that has no corresponding actual argument becomes undefined,
<P>
        (b)    a dummy argument with INTENT (OUT) becomes undefined except for any nonpointer default-
<P>
               initialized subcomponents of the argument,
<P>
        (c)    an actual argument corresponding to a dummy argument with INTENT (OUT) becomes un-
<P>
               defined except for any nonpointer default-initialized subcomponents of the argument,
<P>
        (d)    a subobject of a dummy argument that does not have INTENT (OUT) becomes undefined if the
<P>
               corresponding subobject of the effective argument is undefined, and
<P>
        (e)    a variable that is the function result of that procedure becomes undefined except for any of its
<P>
               nonpointer default-initialized subcomponents.
<P>
</PRE>
(16) When the association status of a pointer becomes undefined or disassociated (19.5.2.4, 19.5.2.5), the
</TD></TR>
<TR><TD colspan=2>
<PRE>
        pointer becomes undefined.
<P>
</PRE>
(17) When a DO CONCURRENT construct terminates, a variable that is defined or becomes undefined
</TD></TR>
<TR><TD colspan=2>
<PRE>
        during more than one iteration of the construct becomes undefined.
<P>
</PRE>
(18) When execution of an iteration of a DO CONCURRENT construct completes, a construct entity of
</TD></TR>
<TR><TD colspan=2>
<PRE>
        that construct which has LOCAL or LOCAL_INIT locality becomes undefined.
<P>
</PRE>
(19) Execution of an asynchronous READ statement causes all of the variables specified by the input list or
</TD></TR>
<TR><TD colspan=2>
<PRE>
        SIZE= specifier to become undefined. Execution of an asynchronous namelist READ statement causes
<P>
        any variable in the namelist group to become undefined if that variable will subsequently be defined
<P>
        during the execution of the READ statement or the corresponding wait operation (12.7.1).
<P>
</PRE>
(20) When a variable with the TARGET attribute is deallocated, a variable of type C_PTR from the
</TD></TR>
<TR><TD colspan=2>
<PRE>
        intrinsic module ISO_C_BINDING becomes undefined if its value is the C address of any part of the
<P>
        variable that is deallocated.
<P>
</PRE>
(21) When a pointer is deallocated, a variable of type C_PTR from the intrinsic module ISO_C_BINDING
</TD></TR>
<TR><TD colspan=2>
<PRE>
        becomes undefined if its value is the C address of any part of the target that is deallocated.
<P>
</PRE>
(22) Execution of the allocation transfer procedure (16.9.137) where the argument TO does not have the
</TD></TR>
<TR><TD colspan=2>
<PRE>
        TARGET attribute causes a variable of type C_PTR from the intrinsic module ISO_C_BINDING to
<P>
        become undefined if its value is the C address of any part of the argument FROM.
<P>
</PRE>
(23) When a BLOCK construct completes execution,
</TD></TR>
<TR><TD colspan=2>
<PRE>
         •    its unsaved local variables become undefined, and
<P>
         •    a variable of type C_PTR from the intrinsic module ISO_C_BINDING, whose value is the C
<P>
              address of an unsaved local variable of the BLOCK construct, becomes undefined.
<P>
</PRE>
(24) When execution of the host instance of the target of a variable of type C_FUNPTR from the intrinsic
</TD></TR>
<TR><TD colspan=2>
<PRE>
        module ISO_C_BINDING is completed by execution of a RETURN or END statement, the variable
<P>
        becomes undefined.
<P>
</PRE>
(25) Execution of an intrinsic assignment of the type C_PTR or C_FUNPTR from the intrinsic module
</TD></TR>
<TR><TD colspan=2>
<PRE>
        ISO_C_BINDING, or of the type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
<P>
        in which the variable and expr are not on the same image, causes the variable to become undefined.
<P>
</PRE>
⃝
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
527
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
        (26) An object with the VOLATILE attribute (8.5.19) might become undefined by means not specified by
<P>
              the program.
<P>
        (27) When a pointer becomes associated with a target that is undefined, the pointer becomes undefined.
<P>
        (28) When an image fails during execution of a segment, a data object on a nonfailed image becomes
<P>
              undefined if it is not a lock variable and it might become undefined by execution of a statement of
<P>
              the segment other than an invocation of an atomic subroutine with the object as an actual argument
<P>
              corresponding to the ATOM dummy argument.
<P>
        NOTE 19.12
<P>
        Execution of a defined assignment statement could leave all or part of the variable undefined.
<P>
  19.6.7      Variable definition context
<P>
</PRE>
1 Some variables are prohibited from appearing in a syntactic context that would imply definition or undefinition
</TD></TR>
<TR><TD colspan=2>
<PRE>
  of the variable (8.5.10, 8.5.15, 15.7). The following are the contexts in which the appearance of a variable implies
<P>
  such definition or undefinition of the variable:
<P>
         (1)    the variable of an assignment-stmt;
<P>
         (2)    a do-variable in a do-stmt or io-implied-do;
<P>
         (3)    an input-item in a read-stmt;
<P>
         (4)    a variable-name in a namelist-stmt if the namelist-group-name appears in a NML= specifier in a
<P>
                read-stmt;
<P>
         (5)    an internal-file-variable in a write-stmt;
<P>
         (6)    a SIZE= or IOMSG= specifier in an input/output statement;
<P>
         (7)    a specifier in an INQUIRE statement other than FILE=, ID=, and UNIT=;
<P>
         (8)    a NEWUNIT= specifier in an OPEN statement;
<P>
         (9)    a stat-variable, allocate-object, or errmsg-variable;
<P>
         (10) an actual argument in a reference to a procedure with an explicit interface if the corresponding
<P>
                dummy argument is not a pointer and has INTENT (OUT) or INTENT (INOUT);
<P>
         (11) a variable that is a selector in an ASSOCIATE, CHANGE TEAM, SELECT RANK, or SELECT
<P>
                TYPE construct if the corresponding associate name or any subobject thereof appears in a variable
<P>
                definition context;
<P>
         (12) an event-variable in an EVENT POST or EVENT WAIT statement;
<P>
         (13) a lock-variable in a LOCK or UNLOCK statement;
<P>
         (14) a scalar-logical-variable in an ACQUIRED_LOCK= specifier;
<P>
         (15) a team-variable in a FORM TEAM statement.
<P>
</PRE>
2 If a reference to a function appears in a variable definition context the result of the function reference shall be a
</TD></TR>
<TR><TD colspan=2>
<PRE>
  pointer that is associated with a definable target. That target is the variable that becomes defined or undefined.
<P>
  19.6.8      Pointer association context
<P>
</PRE>
1 Some pointers are prohibited from appearing in a syntactic context that would imply alteration of the pointer
</TD></TR>
<TR><TD colspan=2>
<PRE>
  association status (19.5.2.2, 8.5.10, 8.5.15, 15.7). The following are the contexts in which the appearance of a
<P>
  pointer implies such alteration of its pointer association status:
<P>
  528                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
  • a pointer-object in a nullify-stmt;
<P>
  • a data-pointer-object or proc-pointer-object in a pointer-assignment-stmt;
<P>
  • an allocate-object in an allocate-stmt or deallocate-stmt;
<P>
  • an actual argument in a reference to a procedure if the corresponding dummy argument is a pointer with
<P>
    the INTENT (OUT) or INTENT (INOUT) attribute.
<P>
</PRE>
⃝
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
529
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>530</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
                                                    Annex A
<P>
                                                     (Informative)
<P>
</PRE>
Processor dependencies
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>A.1</B> </TD><TD valign=bottom>
Unspecified items
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 This document does not specify the following:
</TD></TR>
<TR><TD colspan=2>
<PRE>
     • the properties excluded in 1;
<P>
     • a processor’s error detection capabilities beyond those listed in 4.2;
<P>
     • which additional intrinsic procedures or modules a processor provides (4.2);
<P>
     • the number and kind of companion processors (5.5.7);
<P>
     • the number of representation methods and associated kind type parameter values of the intrinsic types
<P>
       (7.4), except that there shall be at least two representation methods for type real, and a representation
<P>
       method of type complex that corresponds to each representation method for type real.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>A.2</B> </TD><TD valign=bottom>
Processor dependencies
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 According to this document, the following are processor dependent:
</TD></TR>
<TR><TD colspan=2>
<PRE>
     • the order of evaluation of the specification expressions within the specification part of an invoked Fortran
<P>
       procedure (5.3.5);
<P>
     • how soon an image terminates if another image initiates error termination (5.3.5);
<P>
     • the value of a reference to to a coindexed object on a failed image (5.3.6);
<P>
     • the conditions that cause an image to fail (5.3.6);
<P>
     • whether the processor supports a concept of process exit status, and if so, the process exit status on program
<P>
       termination (5.3.7);
<P>
     • the mechanism of a companion processor, and the means of selecting between multiple companion processors
<P>
       (5.5.7);
<P>
     • the processor character set (6.1);
<P>
     • the means for specifying the source form of a program unit (6.3);
<P>
     • the maximum number of characters allowed on a source line containing characters not of default kind (6.3.2,
<P>
       6.3.3);
<P>
     • the maximum depth of nesting of include lines (6.4);
<P>
     • the interpretation of the char-literal-constant in the include line (6.4);
<P>
     • the set of values supported by an intrinsic type, other than logical (7.1.3);
<P>
     • the kind type parameter value of a complex literal constant, if both the real part and imaginary part are of
<P>
       type real with the same precision, but have different kind type parameter values (7.4.3.3);
<P>
     • the kind of a character length type parameter (7.4.4.1);
<P>
     • the blank padding character for nondefault character kind (7.4.4.2)
<P>
</PRE>
⃝
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
531
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
  • whether particular control characters can appear within a character literal constant in fixed source form
<P>
    (7.4.4.3);
<P>
  • the collating sequence for each character set (7.4.4.4);
<P>
  • the order of finalization of components of objects of derived type (7.5.6.2);
<P>
  • the order of finalization when several objects are finalized as the consequence of a single event (7.5.6.2);
<P>
  • whether and when an object is finalized if it is allocated by pointer allocation and it later becomes un-
<P>
    reachable due to all pointers associated with the object having their pointer association status changed
<P>
    (7.5.6.3);
<P>
  • whether an object is finalized by a deallocation in which an error condition occurs (7.5.6.3);
<P>
  • the kind type parameter of each enumeration and its enumerators (7.6);
<P>
  • whether an array is contiguous, except as specified in 8.5.7;
<P>
  • the set of error conditions that can occur in ALLOCATE and DEALLOCATE statements (9.7.1, 9.7.3);
<P>
  • the allocation status of a variable after evaluation of an expression if the evaluation of a function would
<P>
    change the allocation status of the variable and if a reference to the function appears in the expression in
<P>
    which the value of the function is not needed to determine the value of the expression (9.7.1.3);
<P>
  • the order of deallocation when several objects are deallocated by a DEALLOCATE statement (9.7.3);
<P>
  • the order of deallocation when several objects are deallocated due to the occurence of an event described
<P>
    in 9.7.3.2;
<P>
  • whether an allocated allocatable subobject is deallocated when an error condition occurs in the deallocation
<P>
    of an object (9.7.3.2);
<P>
  • the positive integer values assigned to the stat-variable in a STAT= specifier as the result of an error
<P>
    condition (9.7.4, 11.6.11);
<P>
  • the allocation status or pointer association status of an allocate-object if an error condition occurs during
<P>
    execution of an ALLOCATE or DEALLOCATE statement (9.7.4);
<P>
  • the value assigned to the errmsg-variable in an ERRMSG= specifier as the result of an error condition
<P>
    (9.7.5, 11.6.11);
<P>
  • the kind type parameter value of the result of a numeric intrinsic binary operation where
<P>
       – both operands are of type integer but with different kind type parameters, and the decimal exponent
<P>
          ranges are the same,
<P>
       – one operand is of type real or complex and the other is of type real or complex with a different kind
<P>
          type parameter, and the decimal precisions are the same,
<P>
    and for a logical intrinsic binary operation where the operands have different kind type parameters (10.1.9.3);
<P>
  • the character assigned to the variable in an intrinsic assignment statement if the kind of the expression is
<P>
    different and the character is not representable in the kind of the variable (10.2.1.3);
<P>
  • the order of evaluation of the specification expressions within the specification part of a BLOCK construct
<P>
    when the construct is executed (11.1.4);
<P>
  • the pointer association status of a pointer that has its pointer association changed in more than one iteration
<P>
    of a DO CONCURRENT construct, on termination of the construct (11.1.7);
<P>
  • the ordering between records written by different iterations of a DO CONCURRENT construct if the records
<P>
    are written to a file connected for sequential access by more than one iteration (11.1.7);
<P>
  • the manner in which the stop code of a STOP or ERROR STOP statement is made available (11.4);
<P>
  • the mechanisms available for creating dependencies for cooperative synchronization (11.6.5);
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>532</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
• the value of the count of the event variable in an EVENT POST or EVENT WAIT statement if an error
</TD></TR>
<TR><TD colspan=2>
<PRE>
    condition occurs (11.6.7, 11.6.8);
<P>
</PRE>
• the image index value established for each image in a team by a FORM TEAM statement without a
</TD></TR>
<TR><TD colspan=2>
<PRE>
    NEW_INDEX= specifier (11.6.9);
<P>
</PRE>
• the set of error conditions that can occur in image control statements (11.6.11);
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
• the relationship between the file storage units when viewing a file as a stream file, and the records when
<P>
<PRE>
    viewing that file as a record file (12);
<P>
</PRE>
• whether particular control characters can appear in a formatted record or a formatted stream file (12.2.2);
<P>
• the form of values in an unformatted record (12.2.3);
<P>
• at any time, the set of allowed access methods, set of allowed forms, set of allowed actions, and set of
<P>
<PRE>
    allowed record lengths for a file (12.3);
<P>
</PRE>
• the set of allowable names for a file (12.3);
<P>
• whether a named file on one image is the same as a file with the same name on another image (12.3.1);
<P>
• the set of external files that exist for a program (12.3.2);
<P>
• the relationship between positions of successive file storage units in an external file that is connected for
<P>
<PRE>
    formatted stream access (12.3.3.4);
<P>
</PRE>
• the external unit preconnected for sequential formatted input and identified by an asterisk or the named
<P>
<PRE>
    constant INPUT_UNIT of the ISO_FORTRAN_ENV intrinsic module (12.5);
<P>
</PRE>
• the external unit preconnected for sequential formatted output and identified by an asterisk or the named
<P>
<PRE>
    constant OUTPUT_UNIT of the ISO_FORTRAN_ENV intrinsic module (12.5);
<P>
</PRE>
• the external unit preconnected for sequential formatted output and identified by the named constant ER-
<P>
<PRE>
    ROR_UNIT of the ISO_FORTRAN_ENV intrinsic module, and whether this unit is the same as OUT-
<P>
    PUT_UNIT (12.5);
<P>
</PRE>
• at any time, the set of external units that exist for an image (12.5.3);
<P>
• whether a unit can be connected to a file that is also connected to a C stream (12.5.4);
<P>
• whether a file can be connected to more than one unit at the same time (12.5.4);
<P>
• the effect of performing input/output operations on multiple units while they are connected to the same
<P>
<PRE>
    external file (12.5.4);
<P>
</PRE>
• the result of performing input/output operations on a unit connected to a file that is also connected to a C
<P>
<PRE>
    stream (12.5.4);
<P>
</PRE>
• whether the files connected to the units INPUT_UNIT, OUTPUT_UNIT, and ERROR_UNIT correspond
<P>
<PRE>
    to the predefined C text streams standard input, standard output, and standard error, respectively (12.5.4);
<P>
</PRE>
• the results of performing input/output operations on an external file both from Fortran and from a procedure
<P>
<PRE>
    defined by means other than Fortran (12.5.4);
<P>
</PRE>
• the default value for the ACTION= specifier in an OPEN statement (12.5.6.4);
<P>
• the encoding of a file opened with ENCODING=’DEFAULT’ (12.5.6.9);
<P>
• the file connected by an OPEN statement with STATUS=’SCRATCH’ (12.5.6.10);
<P>
• the interpretation of case in a file name (12.5.6.10, 12.10.2.2);
<P>
• the position of a file after executing an OPEN statement with a POSITION= specifier of ASIS, when the
<P>
<PRE>
    file previously existed but was not connected (12.5.6.14);
<P>
</PRE>
• the default value for the RECL= specifier in an OPEN statement (12.5.6.15);
<P>
• the effect of RECL= on a record containing any nondefault characters (12.5.6.15);
</TD></TR>
<TR><TD colspan=2>
⃝
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
533
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
  • the default input/output rounding mode (12.5.6.16);
<P>
  • the default sign mode (12.5.6.17);
<P>
  • the file status when STATUS=’UNKNOWN’ is specified in an OPEN statement (12.5.6.18);
<P>
  • the value assigned to the variable in the ID= specifier in an asynchronous data transfer statement when
<P>
    execution of the statement is successfully completed (12.6.2.9);
<P>
  • whether POS= is permitted with particular files, and whether POS= can position a particular file to a
<P>
    position prior to its current position (12.6.2.11);
<P>
  • the form in which a single value of derived type is treated in an unformatted input/output statement if the
<P>
    effective item is not processed by a defined input/output procedure (12.6.3);
<P>
  • the result of unformatted input when the value stored in the file has a different type or type parameters
<P>
    from that of the input list item (12.6.4.5.2);
<P>
  • the negative value of the unit argument to a defined input/output procedure if the parent data transfer
<P>
    statement accesses an internal file (12.6.4.8.2);
<P>
  • the manner in which the processor makes the value of the iomsg argument of a defined input/output
<P>
    procedure available if the procedure assigns a nonzero value to the iostat argument and the processor
<P>
    therefore terminates execution of the program (12.6.4.8.2);
<P>
  • the action caused by the flush operation, whether the processor supports the flush operation for the specified
<P>
    unit, and the negative value assigned to the IOSTAT= variable if the processor does not support the flush
<P>
    operation for the specified unit (12.9);
<P>
  • the case of characters assigned to the variable in a NAME= specifier in an INQUIRE statement (12.10.2.15);
<P>
  • which of the connected external unit numbers is assigned to the scalar-int-variable in the NUMBER=
<P>
    specifier in an INQUIRE by file statement, if more than one unit on an image is connected to the file
<P>
    (12.10.2.18);
<P>
  • the value of the variable in a POSITION= specifier in an INQUIRE statement if the file has been repositioned
<P>
    since connection (12.10.2.23);
<P>
  • the relationship between file size and the data stored in records in a sequential or direct access file
<P>
    (12.10.2.30);
<P>
  • the number of file storage units needed to store data in an unformatted file (12.10.3);
<P>
  • the set of error conditions that can occur in input/output statements (12.11.1);
<P>
  • when an input/output error condition occurs or is detected (12.11.1);
<P>
  • the positive integer value assigned to the variable in an IOSTAT= specifier as the result of an error condition
<P>
    (12.11.5);
<P>
  • the value assigned to the variable in an IOMSG= specifier as the result of an error condition (12.11.6);
<P>
  • the result of output of non-representable characters to a Unicode file (13.7.1);
<P>
  • the interpretation of the optional non-blank characters within the parentheses of a real NaN input field
<P>
    (13.7.2.3.2);
<P>
  • the interpretation of a sign in a NaN input field (13.7.2.3.2);
<P>
  • for output of an IEEE NaN, whether after the letters ’NaN’, the processor produces additional alphanumeric
<P>
    characters enclosed in parentheses (13.7.2.3.2);
<P>
  • the choice of binary exponent in EX output editing (13.7.2.3.6);
<P>
  • the effect of the input/output rounding mode PROCESSOR_DEFINED (13.7.2.3.8);
<P>
  • which value is chosen if the input/output rounding mode is NEAREST and the value to be converted is
<P>
    exactly halfway between the two nearest representable values in the result format (13.7.2.3.8);
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>534</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
• the field width, decimal part width, and exponent width used for the G0 edit descriptor (13.7.5);
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
• the file position when position editing skips a character of nondefault kind in an internal file of default
<P>
<PRE>
    character kind or an external unit that is not connected to a Unicode file (13.8.1.1);
<P>
</PRE>
• when the sign mode is PROCESSOR_DEFINED, whether a plus sign appears in a numeric output field
<P>
<PRE>
    for a nonnegative value (13.8.4);
<P>
</PRE>
• the results of list-directed output (13.10.4);
<P>
• the results of namelist output (13.11.4);
<P>
• the interaction between argument association and pointer association, (15.5.2.4);
<P>
• the values returned by some intrinsic functions (16);
<P>
• how the sequences of atomic actions in unordered segments interleave (16.5);
<P>
• the value assigned to a STAT argument in a reference to an atomic subroutine when an error condition
<P>
<PRE>
    occurs (16.5);
<P>
</PRE>
• the effect of calling EXECUTE_COMMAND_LINE on any image other than image 1 in the initial team
<P>
<PRE>
    (16.7);
<P>
</PRE>
• whether each image uses a separate random number generator, or if some or all images use common random
<P>
<PRE>
    number generators (16.7);
<P>
</PRE>
• whether the results returned from CPU_TIME, DATE_AND_TIME and SYSTEM_CLOCK are depend-
<P>
<PRE>
    ent on which image calls them (16.7);
<P>
</PRE>
• the set of error conditions that can occur in some intrinsic subroutines (16.9);
<P>
• the value assigned to a CMDSTAT, ERRMSG, EXITSTAT, STAT, or STATUS argument to indicate a
<P>
<PRE>
    processor-dependent error condition (16.9);
<P>
</PRE>
• the computed value of the the intrinsic subroutine CO_REDUCE (16.9.49) and the intrinsic subroutine
<P>
<PRE>
    CO_SUM (16.9.50);
<P>
</PRE>
• the value assigned to the TIME argument by the intrinsic subroutine CPU_TIME (16.9.57);
<P>
• whether date, clock, and time zone information is available (16.9.59);
<P>
• whether date, clock, and time zone information on one image is the same as that on another image (16.9.59);
<P>
• the value of command argument zero, if the processor does not support the concept of a command name
<P>
<PRE>
    (16.9.83);
<P>
</PRE>
• the order of command arguments (16.9.83);
<P>
• whether the significant length of a command argument includes trailing blanks (16.9.83);
<P>
• the interpretation of case for the NAME argument of the intrinsic subroutine GET_ENVIRONMENT_-
<P>
<PRE>
    VARIABLE (16.9.84);
<P>
</PRE>
• whether an environment variable that exists on an image also exists on another image, and if it does exist
<P>
<PRE>
    on both images, whether the values are the same or different (16.9.84);
<P>
</PRE>
• the value assigned to the pseudorandom number generator by the intrinsic subroutine RANDOM_INIT
<P>
<PRE>
    (16.9.155);
<P>
</PRE>
• the computation of the seed value used by the pseudorandom number generator (16.9.157);
<P>
• on images that use a common random number generator, the interleaving of values assigned by RANDOM_-
<P>
<PRE>
    NUMBER in unordered segments(16.7);
<P>
</PRE>
• the value assigned to the seed by the intrinsic subroutine RANDOM_SEED when no argument is present
<P>
<PRE>
    (16.9.157);
<P>
</PRE>
• the values assigned to its arguments by the intrinsic subroutine SYSTEM_CLOCK (16.9.186);
</TD></TR>
<TR><TD colspan=2>
⃝
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
535
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
  • the values of the named constants in the intrinsic module ISO_FORTRAN_ENV (16.10.2);
<P>
  • the values returned by the functions COMPILER_OPTIONS and COMPILER_VERSION in the intrinsic
<P>
    module ISO_FORTRAN_ENV (16.10.2);
<P>
  • the extent to which a processor supports IEEE arithmetic (17);
<P>
  • whether a flag that is quiet on entry to a scoping unit that does not access IEEE_FEATURES, IEEE_-
<P>
    EXCEPTIONS, or IEEE_ARITHMETIC is signaling on exit (17.1);
<P>
  • the conditions under which IEEE_OVERFLOW is raised in a calculation involving non-ISO/IEC/IEEE
<P>
    60559:2011 floating-point data (17.3);
<P>
  • the conditions under which IEEE_OVERFLOW and IEEE_DIVIDE_BY_ZERO are raised in a floating-
<P>
    point exponentiation operation (17.3);
<P>
  • the conditions under which IEEE_DIVIDE_BY_ZERO is raised in a calculation involving floating-point
<P>
    data that do not conform to ISO/IEC/IEEE 60559:2011 (17.3);
<P>
  • whether an exception signals at the end of a sequence of statements that has no invocations of IEEE_GET_-
<P>
    FLAG, IEEE_SET_FLAG, IEEE_GET_STATUS, IEEE_SET_STATUS, or IEEE_SET_HALTING_-
<P>
    MODE, in which execution of an operation would cause it to signal, if no value of a variable depends upon
<P>
    the result of the operation (17.3);
<P>
  • the initial rounding modes (17.4);
<P>
  • whether the processor supports a particular rounding mode (17.4);
<P>
  • the effect of the rounding mode IEEE_OTHER, if supported (17.4);
<P>
  • the initial underflow mode (17.5);
<P>
  • the initial halting mode (17.6);
<P>
  • whether IEEE_INT implements the convertToInteger{round} or convertToIntegerExact{round} operation
<P>
    specified by ISO/IEC/IEEE 60559:2011 (17.11.11);
<P>
  • which argument is the result value of IEEE_MAX_NUM, IEEE_MAX_NUM_MAG, IEEE_MIN_NUM,
<P>
    or IEEE_MIN_NUM_MAG when both arguments are quiet NaNs or are zeros (17.11.17, 17.11.18, 17.11.19,
<P>
    17.11.20);
<P>
  • the requirements on the storage sequence to be associated with the pointer FPTR by the C_F_POINTER
<P>
    subroutine (18.2.3.4);
<P>
  • the order of the members of the CFI_dim_t structure defined in the source file CFI_Fortran_binding.h
<P>
    (18.5.2);
<P>
  • members of the CFI_cdesc_t structure defined in the source file CFI_Fortran_binding.h beyond the re-
<P>
    quirements of 18.5.3;
<P>
  • the value of CFI_MAX_RANK in the source file CFI_Fortran_binding.h (18.5.4);
<P>
  • the value of CFI_VERSION in the source file CFI_Fortran_binding.h (18.5.4);
<P>
  • which error condition is detected if more than one error condition could be detected for an invocation of
<P>
    one of the functions declared in the source file CFI_Fortran_binding.h (18.5.5.1);
<P>
  • the values of the attribute specifier macros defined in the source file CFI_Fortran_binding.h (18.5.4);
<P>
  • the values of the type specifier macros defined in the source file CFI_Fortran_binding.h;
<P>
  • which additional type specifier values are defined in the source file CFI_Fortran_binding.h (18.5.4);
<P>
  • the values of the error code macros other than CFI_SUCCESS that are defined in the source file CFI_-
<P>
    Fortran_binding.h (18.5.4);
<P>
  • the base address of a zero-sized array (18.5.3);
<P>
  • the values of the floating-point exception flags on entry to a procedure defined by means other than Fortran
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>536</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                  c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                     ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
(18.10.3);
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
• whether a procedure defined by means other than Fortran is an asynchronous communication initiation or
<P>
<PRE>
    completion procedure (18.10.4).
<P>
</PRE>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
537
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                            (Blank page)
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>538</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                         c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
                                                   Annex B
<P>
                                                    (Informative)
<P>
</PRE>
Deleted and obsolescent features
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>B.1</B> </TD><TD valign=bottom>
Deleted features from Fortran 90
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 These deleted features are those features of Fortran 90 that were redundant and considered largely unused.
</TD></TR>
<TR><TD colspan=2>
2 The following Fortran 90 features are not required.
</TD></TR>
<TR><TD colspan=2>
<PRE>
        (1)   Real and double precision DO variables.
<P>
              In Fortran 77 and Fortran 90, a DO variable was allowed to be of type real or double precision
<P>
              in addition to type integer; this has been deleted. A similar result can be achieved by using a DO
<P>
              construct with no loop control and the appropriate exit test.
<P>
        (2)   Branching to an END IF statement from outside its block.
<P>
              In Fortran 77 and Fortran 90, it was possible to branch to an END IF statement from outside the
<P>
              IF construct; this has been deleted. A similar result can be achieved by branching to a CONTINUE
<P>
              statement that is immediately after the END IF statement.
<P>
        (3)   PAUSE statement.
<P>
              The PAUSE statement, provided in Fortran 66, Fortran 77, and Fortran 90, has been deleted.
<P>
              A similar result can be achieved by writing a message to the appropriate unit, followed by reading
<P>
              from the appropriate unit.
<P>
        (4)   ASSIGN and assigned GO TO statements, and assigned format specifiers.
<P>
              The ASSIGN statement and the related assigned GO TO statement, provided in Fortran 66,
<P>
              Fortran 77, and Fortran 90, have been deleted. Further, the ability to use an assigned integer as a
<P>
              format, provided in Fortran 77 and Fortran 90, has been deleted. A similar result can be achieved
<P>
              by using other control constructs instead of the assigned GO TO statement and by using a default
<P>
              character variable to hold a format specification instead of using an assigned integer.
<P>
        (5)   H edit descriptor.
<P>
              In Fortran 77 and Fortran 90, there was an alternative form of character string edit descriptor,
<P>
              which had been the only such form in Fortran 66; this has been deleted. A similar result can be
<P>
              achieved by using a character string edit descriptor.
<P>
        (6)   Vertical format control.
<P>
              In Fortran 66, Fortran 77, Fortran 90, and Fortran 95 formatted output to certain units resulted
<P>
              in the first character of each record being interpreted as controlling vertical spacing. There was no
<P>
              standard way to detect whether output to a unit resulted in this vertical format control, and no
<P>
              way to specify that it should be applied; this has been deleted. The effect can be achieved by
<P>
              post-processing a formatted file.
<P>
</PRE>
3 See ISO/IEC 1539:1991 for detailed rules of how these deleted features worked.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        539
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  B.2       Deleted features from Fortran 2008
<P>
</PRE>
1 These deleted features are those features of Fortran 2008 that were redundant and considered largely unused.
</TD></TR>
<TR><TD colspan=2>
2 The following Fortran 2008 features are not required.
</TD></TR>
<TR><TD colspan=2>
<PRE>
         (1)    Arithmetic IF statement.
<P>
                The arithmetic IF statement is incompatible with ISO/IEC/IEEE 60559:2011 and necessarily involves
<P>
                the use of statement labels; statement labels can hinder optimization, and make code hard to read
<P>
                and maintain. Similar logic can be more clearly encoded using other conditional statements.
<P>
         (2)    Nonblock DO construct
<P>
                The nonblock forms of the DO loop were confusing and hard to maintain. Shared termination and
<P>
                dual use of labeled action statements as do termination and branch targets were especially error-
<P>
                prone.
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>B.3</B> </TD><TD valign=bottom>
Obsolescent features
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>B.3.1</B> </TD><TD valign=bottom>
General
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 The obsolescent features are those features of Fortran 90 that were redundant and for which better methods were
<P>
<PRE>
  available in Fortran 90. Subclause 4.4.3 describes the nature of the obsolescent features. The obsolescent features
<P>
  in this document are the following.
<P>
         (1)    Alternate return — see B.3.2.
<P>
         (2)    Computed GO TO — see B.3.3.
<P>
         (3)    Statement functions — see B.3.4.
<P>
         (4)    DATA statements amongst executable statements — see B.3.5.
<P>
         (5)    Assumed length character functions — see B.3.6.
<P>
         (6)    Fixed form source — see B.3.7.
<P>
         (7)    CHARACTER* form of CHARACTER declaration — see B.3.8.
<P>
         (8)    ENTRY statements — see B.3.9.
<P>
         (9)    Label form of DO statement – see B.3.10.
<P>
         (10) COMMON and EQUIVALENCE statements, and the block data program unit – see B.3.11.
<P>
         (11) Specific names for intrinsic functions – see B.3.12.
<P>
         (12) FORALL construct and statement – see B.3.13
<P>
  B.3.2      Alternate return
<P>
</PRE>
1 An alternate return introduces labels into an argument list to allow the called procedure to direct the execution
<P>
<PRE>
  of the caller upon return. The same effect can be achieved with a return code that is used in a SELECT CASE
<P>
  construct on return. This avoids an irregularity in the syntax and semantics of argument association. For example,
<P>
      CALL SUBR_NAME (X, Y, Z, *100, *200, *300)
<P>
  can be replaced by
<P>
      CALL SUBR_NAME (X, Y, Z, RETURN_CODE)
<P>
      SELECT CASE (RETURN_CODE)
<P>
  540                                                                ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
           CASE (1)
<P>
              &#46;&#46;&#46;
<P>
           CASE (2)
<P>
              &#46;&#46;&#46;
<P>
           CASE (3)
<P>
              &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; CASE DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>B.3.3</B> </TD><TD valign=bottom>
Computed GO TO statement
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The computed GO TO statement has been superseded by the SELECT CASE construct, which is a generalized,
<P>
<PRE>
  easier to use, and clearer means of expressing the same computation.
<P>
  B.3.4      Statement functions
<P>
</PRE>
1 Statement functions are subject to a number of nonintuitive restrictions and are a potential source of error because
<P>
<PRE>
  their syntax is easily confused with that of an assignment statement.
<P>
</PRE>
2 The internal function is a more generalized form of the statement function and completely supersedes it.
<P>
<PRE>
  B.3.5      DATA statements among executables
<P>
</PRE>
1 The statement ordering rules allow DATA statements to appear anywhere in a program unit after the specific-
<P>
<PRE>
  ation statements. The ability to position DATA statements amongst executable statements is very rarely used,
<P>
  unnecessary, and a potential source of error.
<P>
  B.3.6      Assumed character length functions
<P>
</PRE>
1 Assumed character length for functions is an irregularity in the language in that elsewhere in Fortran the philo-
<P>
<PRE>
  sophy is that the attributes of a function result depend only on the actual arguments of the invocation and on
<P>
  any data accessible by the function through host or use association. Some uses of this facility can be replaced
<P>
  with an automatic character length function, where the length of the function result is declared in a specification
<P>
  expression. Other uses can be replaced by the use of a subroutine whose arguments correspond to the function
<P>
  result and the function arguments.
<P>
</PRE>
2 Note that dummy arguments of a function can have assumed character length.
<P>
<PRE>
  B.3.7      Fixed form source
<P>
</PRE>
1 Fixed form source was designed when the principal machine-readable input medium for new programs was punched
<P>
<PRE>
  cards. Now that new and amended programs are generally entered via keyboards with screen displays, it is an
<P>
  unnecessary overhead, and is potentially error-prone, to have to locate positions 6, 7, or 72 on a line. Free form
<P>
  source was designed expressly for this more modern technology.
<P>
</PRE>
2 It is a simple matter for a software tool to convert from fixed to free form source.
<P>
<PRE>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           541
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  B.3.8      CHARACTER* form of CHARACTER declaration
<P>
</PRE>
1 In addition to the CHARACTER*char-length form introduced in Fortran 77, Fortran 90 provided the CHAR-
<P>
<PRE>
  ACTER([ LEN = ] type-param-value) form. The older form (CHARACTER*char-length) is redundant.
<P>
  B.3.9      ENTRY statements
<P>
</PRE>
1 ENTRY statements allow more than one entry point to a subprogram, facilitating sharing of data items and
<P>
<PRE>
  executable statements local to that subprogram.
<P>
</PRE>
2 This can be replaced by a module containing the (private) data items, with a module procedure for each entry
<P>
<PRE>
  point and the shared code in a private module procedure.
<P>
  B.3.10      Label DO statement
<P>
</PRE>
1 The label in the DO statement is redundant with the construct name. Furthermore, the label allows unrestricted
<P>
<PRE>
  branches and, for its main purpose (the target of a conditional branch to skip the rest of the current iteration),
<P>
  is redundant with the CYCLE statement, which is clearer.
<P>
  B.3.11      COMMON and EQUIVALENCE statements and the block data program unit
<P>
</PRE>
1 Common blocks are error-prone and have largely been superseded by modules. EQUIVALENCE similarly is
<P>
<PRE>
  error-prone. Whilst use of these statements was invaluable prior to Fortran 90 they are now redundant and
<P>
  can inhibit performance. The block data program unit exists only to serve common blocks and hence is also
<P>
  redundant.
<P>
  B.3.12      Specific names for intrinsic functions
<P>
</PRE>
1 The specific names of the intrinsic functions are often obscure and hinder portability. They have been redundant
<P>
<PRE>
  since Fortran 90. Use generic names for references to intrinsic procedures.
<P>
  B.3.13      FORALL construct and statement
<P>
</PRE>
1 The FORALL construct and statement were added to the language in the expectation that they would enable
<P>
<PRE>
  highly efficient execution, especially on parallel processors. However, experience indicates that they are too
<P>
  complex and have too many restrictions for compilers to take advantage of them. They are redundant with the
<P>
  DO CONCURRENT construct, and many of the manipulations for which they might be used can be done more
<P>
  effectively using pointers, especially using pointer rank remapping.
<P>
  542                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
                                                    Annex C
<P>
                                                     (Informative)
<P>
                                             Extended notes
<P>
  C.1      Fortran 2008 features not mentioned in its Introduction
<P>
</PRE>
1 The following features were new in Fortran 2008 but not originally listed in its Introduction as being new features:
<P>
<PRE>
      • An array or object with a nonconstant length type parameter can have the VALUE attribute.
<P>
      • Multiple allocations are permitted in a single ALLOCATE statement with the SOURCE= specifier.
<P>
      • A PROCEDURE statement can have a double colon before the first procedure name.
<P>
      • An argument to a pure procedure can have default INTENT if it has the VALUE attribute.
<P>
      • The PROTECTED attribute can be specified by the procedure declaration statement.
<P>
      • A defined-operator can be used in a specification expression.
<P>
      • All transformational functions from the intrinsic modules IEEE_ARITHMETIC and IEEE_EXCEPTIONS
<P>
        can be used in constant expressions. All transformational functions from the intrinsic modules IEEE_-
<P>
        ARITHMETIC, IEEE_EXCEPTIONS, and ISO_C_BINDING can be used in specification expressions.
<P>
      • A contiguous array variable that is not interoperable but which has interoperable type and kind type
<P>
        parameter (if any), and a scalar character variable with length greater than 1 and kind C_CHAR in the
<P>
        intrinsic module ISO_C_BINDING, can be used as the argument of the function C_LOC in the intrinsic
<P>
        module ISO_C_BINDING, provided the variable has the POINTER or TARGET attribute.
<P>
      • The name of an external procedure that has a binding label is a local identifier and not a global identifier.
<P>
      • A procedure that is not a procedure pointer can be an actual argument that corresponds to a procedure
<P>
        pointer dummy argument with the INTENT (IN) attribute.
<P>
      • An interface body for an external procedure that does not exist in a program can be used to specify an
<P>
        explicit specific interface.
<P>
</PRE>
2 All but the last two of the above list were subsequently added to the Introduction by Technical Corrigenda.
<P>
<PRE>
  C.2      Clause 7 notes
<P>
  C.2.1     Selection of the approximation methods (7.4.3.2)
<P>
</PRE>
1 One can select the real approximation method for an entire program through the use of a module and the
<P>
<PRE>
  parameterized real type. This is accomplished by defining a named integer constant to have a particular kind
<P>
  type parameter value and using that named constant in all real, complex, and derived-type declarations. For
<P>
  example, the specification statements
<P>
           INTEGER, PARAMETER :: LONG_FLOAT = 8
<P>
           REAL (LONG_FLOAT) X, Y
<P>
           COMPLEX (LONG_FLOAT) Z
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          543
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  specify that the approximation method corresponding to a kind type parameter value of 8 is supplied for the data
<P>
  objects X, Y, and Z in the program unit. The kind type parameter value LONG_FLOAT can be made available
<P>
  to an entire program by placing the INTEGER specification statement in a module and accessing the named
<P>
  constant LONG_FLOAT with a USE statement. Note that by changing 8 to 4 once in the module, a different
<P>
  approximation method is selected.
<P>
</PRE>
2 To avoid the use of the processor-dependent values 4 or 8, replace 8 by KIND (0.0) or KIND (0.0D0). Another
<P>
<PRE>
  way to avoid these processor-dependent values is to select the kind value using the intrinsic function SELEC-
<P>
  TED_REAL_KIND (16.9.170). In the above specification statement, the 8 might be replaced by, for instance,
<P>
  SELECTED_REAL_KIND (10, 50), which requires an approximation method to be selected with at least 10
<P>
  decimal digits of precision and a range from 10−50 to 1050 . There are no magnitude or ordering constraints placed
<P>
  on kind values, in order that implementers have flexibility in assigning such values and can add new kinds without
<P>
  changing previously assigned kind values.
<P>
</PRE>
3 As kind values have no portable meaning, a good practice is to use them in programs only through named
<P>
<PRE>
  constants as described above (for example, SINGLE, IEEE_SINGLE, DOUBLE, and QUAD), rather than using
<P>
  the kind values directly.
<P>
  C.2.2      Type extension and component accessibility (7.5.2.2, 7.5.4)
<P>
</PRE>
1 The default accessibility of the components of an extended type can be specified in the type definition. The
<P>
<PRE>
  accessibility of its components can be specified individually. For example:
<P>
           module types
<P>
              type base_type
<P>
                 private                     !--  Sets default accessibility
<P>
                 integer :: i                !--  a private component
<P>
                 integer, private :: j       !--  another private component
<P>
                 integer, public :: k        !--  a public component
<P>
              end type base_type
<P>
              type, extends(base_type) ::       my_type
<P>
                 private                    !--  Sets default for components declared in my_type
<P>
                 integer :: l               !--  A private component.
<P>
                 integer, public :: m !--        A public component.
<P>
              end type my_type
<P>
           end module types
<P>
           subroutine sub
<P>
              use types
<P>
              type (my_type) :: x
<P>
              &#46;&#46;&#46;
<P>
              call another_sub( &
<P>
                 x%base_type,       &  !-- ok because base_type is a public subobject of x
<P>
                 x%base_type%k, &      !-- ok because x%base_type is ok and has k as a
<P>
  544                                                                 ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
                                     !-- public component.
<P>
               x%k,              &   !-- ok because it is shorthand for x%base_type%k
<P>
               x%base_type%i,    &   !-- Invalid because i is private.
<P>
               x%i)                  !-- Invalid because it is shorthand for x%base_type%i
<P>
          end subroutine sub
<P>
  C.2.3    Generic type-bound procedures (7.5.5)
<P>
  Example of a derived type with generic type-bound procedures:
<P>
</PRE>
1 The only difference between this example and the same thing rewritten to use generic interface blocks is that
<P>
<PRE>
  with type-bound procedures,
<P>
          USE rational_numbers, ONLY: rational
<P>
  does not block the type-bound procedures; the user still gets access to the defined assignment and extended
<P>
  operations.
<P>
          MODULE rational_numbers
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE,PUBLIC :: rational
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER n,d
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
! ordinary type-bound procedure
<P>
PROCEDURE :: real =&gt; rat_to_real
<P>
! specific type-bound procedures for generic support
<P>
PROCEDURE,PRIVATE :: rat_asgn_i, rat_plus_i, rat_plus_rat =&gt; rat_plus
<P>
PROCEDURE,PRIVATE,<B>PASS</B>(b) :: i_plus_rat
<P>
! generic type-bound procedures
<P>
GENERIC :: <B>ASSIGNMENT</B>(=) =&gt; rat_asgn_i
<P>
GENERIC :: <B>OPERATOR</B>(+) =&gt; rat_plus_rat, rat_plus_i, i_plus_rat
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
ELEMENTAL REAL FUNCTION <B>rat_to_real</B>(this) <B>RESULT</B>(r)
<P>
<PRE>
               CLASS(rational),INTENT(IN) :: this
<P>
               r = REAL(this%n)/this%d
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
ELEMENTAL SUBROUTINE <B>rat_asgn_i</B>(a,b)
<P>
<PRE>
               CLASS(rational),INTENT(OUT) :: a
<P>
               INTEGER,INTENT(IN) :: b
<P>
               a%n = b
<P>
               a%d = 1
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
ELEMENTAL <B>TYPE</B>(rational) FUNCTION <B>rat_plus_i</B>(a,b) <B>RESULT</B>(r)
<P>
<PRE>
               CLASS(rational),INTENT(IN) :: a
<P>
               INTEGER,INTENT(IN) :: b
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
545
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
               r%n = a%n + b*a%d
<P>
               r%d = a%d
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
ELEMENTAL <B>TYPE</B>(rational) FUNCTION <B>i_plus_rat</B>(a,b) <B>RESULT</B>(r)
<P>
<PRE>
               INTEGER,INTENT(IN) :: a
<P>
               CLASS(rational),INTENT(IN) :: b
<P>
               r%n = b%n + a*b%d
<P>
               r%d = b%d
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
ELEMENTAL <B>TYPE</B>(rational) FUNCTION <B>rat_plus</B>(a,b) <B>RESULT</B>(r)
<P>
<PRE>
               CLASS(rational),INTENT(IN) :: a,b
<P>
               r%n = a%n*b%d + b%n*a%d
<P>
               r%d = a%d*b%d
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.2.4</B> </TD><TD valign=bottom>
Abstract types (7.5.7.1)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The following illustrates how an abstract type can be used as the basis for a collection of related types, and how
<P>
<PRE>
  a non-abstract member of that collection can be created by type extension.
<P>
           TYPE, ABSTRACT :: DRAWABLE_OBJECT
<P>
              REAL, DIMENSION(3) :: RGB_COLOR = (/1.0,1.0,1.0/) ! White
<P>
              REAL, DIMENSION(2) :: POSITION = (/0.0,0.0/) ! Centroid
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<B>PROCEDURE</B>(RENDER_X), <B>PASS</B>(OBJECT), DEFERRED :: RENDER
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE DRAWABLE_OBJECT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ABSTRACT INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>RENDER_X</B>(OBJECT, WINDOW)
<P>
<PRE>
                  IMPORT DRAWABLE_OBJECT, X_WINDOW
<P>
                  CLASS(DRAWABLE_OBJECT), INTENT(IN) :: OBJECT
<P>
                  CLASS(X_WINDOW), INTENT(INOUT) :: WINDOW
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE RENDER_X</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
TYPE, <B>EXTENDS</B>(DRAWABLE_OBJECT) :: DRAWABLE_TRIANGLE ! Not ABSTRACT
<P>
<PRE>
              REAL, DIMENSION(2,3) :: VERTICES ! In relation to centroid
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
PROCEDURE, <B>PASS</B>(OBJECT) :: RENDER=&gt;RENDER_TRIANGLE_X
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE DRAWABLE_TRIANGLE</H4>
</A>
<BLOCKQUOTE>
<P>
2 The actual drawing procedure will draw a triangle in WINDOW with vertices at x and y coordinates at
<P>
<PRE>
  OBJECT%POSITION(1)+OBJECT%VERTICES(1,1:3) and OBJECT%POSITION(2)+OBJECT%VERTICES(2,1:3):
<P>
  546                                                             ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
           SUBROUTINE RENDER_TRIANGLE_X(OBJECT, WINDOW)
<P>
              CLASS(DRAWABLE_TRIANGLE), INTENT(IN) :: OBJECT
<P>
              CLASS(X_WINDOW), INTENT(INOUT) :: WINDOW
<P>
              &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE RENDER_TRIANGLE_X</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.2.5</B> </TD><TD valign=bottom>
Structure constructors and generic names (7.5.10)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 A generic name can be the same as a type name. This can be used to emulate user-defined structure constructors
<P>
<PRE>
  for that type, even if the type has private components. For example:
<P>
           MODULE mytype_module
<P>
             TYPE mytype
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
COMPLEX value
<P>
LOGICAL exact
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
INTERFACE mytype
<P>
<PRE>
                MODULE PROCEDURE int_to_mytype
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
! Operator definitions etc.
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(mytype) FUNCTION <B>int_to_mytype</B>(i)
<P>
<PRE>
                INTEGER,INTENT(IN) :: i
<P>
                int_to_mytype%value = i
<P>
                int_to_mytype%exact = .TRUE.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
! Procedures to support operators etc.
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
PROGRAM example
<P>
<PRE>
             USE mytype_module
<P>
             TYPE(mytype) x
<P>
             x = mytype(17)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
2 The type name can still be used as a generic name if the type has type parameters. For example:
<P>
<PRE>
           MODULE m
<P>
             TYPE t(kind)
<P>
                INTEGER, KIND :: kind
<P>
                COMPLEX(kind) value
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER,PARAMETER :: single = <B>KIND</B>(0.0), double = <B>KIND</B>(0d0)
<P>
INTERFACE t
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: INTERFACE t
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
547
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
          MODULE PROCEDURE real_to_t1, dble_to_t2, int_to_t1, int_to_t2
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(t(single)) FUNCTION <B>real_to_t1</B>(x)
<P>
<PRE>
          REAL(single) x
<P>
          real_to_t1%value = x
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(t(double)) FUNCTION <B>dble_to_t2</B>(x)
<P>
<PRE>
          REAL(double) x
<P>
          dble_to_t2%value = x
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(t(single)) FUNCTION <B>int_to_t1</B>(x,mold)
<P>
<PRE>
          INTEGER x
<P>
          TYPE(t(single)) mold
<P>
          int_to_t1%value = x
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(t(double)) FUNCTION <B>int_to_t2</B>(x,mold)
<P>
<PRE>
          INTEGER x
<P>
          TYPE(t(double)) mold
<P>
          int_to_t2%value = x
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
PROGRAM example
<P>
<PRE>
        USE m
<P>
        TYPE(t(single)) x
<P>
        TYPE(t(double)) y
<P>
        x = t(1.5)                !  References real_to_t1
<P>
        x = t(17,mold=x)          !  References int_to_t1
<P>
        y = t(1.5d0)              !  References dble_to_t2
<P>
        y = t(42,mold=y)          !  References int_to_t2
<P>
        y = t(kind(0d0)) ((0,1))  !  Uses the structure constructor for type t
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.2.6</B> </TD><TD valign=bottom>
Final subroutines (7.5.6, 7.5.6.2, 7.5.6.3, 7.5.6.4)
</TD></TR>
<TR></TR></TABLE>Example of a parameterized derived type with final subroutines:
<P>
<PRE>
      MODULE m
<P>
        TYPE t(k)
<P>
          INTEGER, KIND :: k
<P>
          REAL(k),POINTER :: vector(:) =&gt; NULL()
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
FINAL :: finalize_t1s, finalize_t1v, finalize_t2e
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>548</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>finalize_t1s</B>(x)
<P>
<PRE>
          TYPE(t(KIND(0.0))) x
<P>
          IF (ASSOCIATED(x%vector)) DEALLOCATE(x%vector)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>finalize_t1v</B>(x)
<P>
<PRE>
          TYPE(t(KIND(0.0))) x(:)
<P>
          DO i=LBOUND(x,1),UBOUND(x,1)
<P>
            IF (ASSOCIATED(x(i)%vector)) DEALLOCATE(x(i)%vector)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
ELEMENTAL SUBROUTINE <B>finalize_t2e</B>(x)
<P>
<PRE>
          TYPE(t(KIND(0.0d0))),INTENT(INOUT) :: x
<P>
          IF (ASSOCIATED(x%vector)) DEALLOCATE(x%vector)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>example</B>(n)
<P>
<PRE>
        USE m
<P>
        TYPE(t(KIND(0.0))) a,b(10),c(n,2)
<P>
        TYPE(t(KIND(0.0d0))) d(n,n)
<P>
        &#46;&#46;&#46;
<P>
        ! Returning from this subroutine will effectively do
<P>
        !     CALL finalize_t1s(a)
<P>
        !     CALL finalize_t1v(b)
<P>
        !     CALL finalize_t2e(d)
<P>
        ! No final subroutine will be called for variable C because the user
<P>
        ! omitted to define a suitable specific procedure for it.
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
Example of extended types with final subroutines:
<P>
<PRE>
     MODULE m
<P>
        TYPE t1
<P>
          REAL a,b
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE,EXTENDS</B>(t1) :: t2
<P>
<PRE>
          REAL,POINTER :: c(:),d(:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
FINAL :: t2f
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE,EXTENDS</B>(t2) :: t3
<P>
<PRE>
          REAL,POINTER :: e
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
FINAL :: t3f
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
549
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>t2f</B>(x) ! Finalizer for <B>TYPE</B>(t2)’s extra components
<P>
<PRE>
                TYPE(t2) :: x
<P>
                IF (ASSOCIATED(x%c)) DEALLOCATE(x%c)
<P>
                IF (ASSOCIATED(x%d)) DEALLOCATE(x%d)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>t3f</B>(y) ! Finalizer for <B>TYPE</B>(t3)’s extra components
<P>
<PRE>
                TYPE(t3) :: y
<P>
                IF (ASSOCIATED(y%e)) DEALLOCATE(y%e)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE example
<P>
<PRE>
              USE m
<P>
              TYPE(t1) x1
<P>
              TYPE(t2) x2
<P>
              TYPE(t3) x3
<P>
              &#46;&#46;&#46;
<P>
              ! Returning from this subroutine will effectively do
<P>
              !      ! Nothing to x1; it is not finalizable
<P>
              !      CALL t2f(x2)
<P>
              !      CALL t3f(x3)
<P>
              !      CALL t2f(x3%t2)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.3</B> </TD><TD valign=bottom>
Clause 8 notes: The VOLATILE attribute (8.5.19)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The following example shows the use of a variable with the VOLATILE attribute to communicate with an
<P>
<PRE>
  asynchronous process, in this case the operating system. The program detects a user keystroke on the terminal
<P>
  and reacts at a convenient point in its processing.
<P>
</PRE>
2 The VOLATILE attribute is necessary to prevent an optimizing compiler from storing the communication variable
<P>
<PRE>
  in a register or from doing flow analysis and deciding that the EXIT statement can never be executed.
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE TERMINATE_ITERATIONS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>LOGICAL, VOLATILE ::</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
USER_HIT_ANY_KEY
</TD></TR>
<TR><TD colspan=2>
! Have the OS start to look for a user keystroke and set the variable
</TD></TR>
<TR><TD colspan=2>
! "USER_HIT_ANY_KEY" to TRUE as soon as it detects a keystroke.
</TD></TR>
<TR><TD colspan=2>
! This call is operating system dependent.
</TD></TR>
<TR><TD colspan=2>
CALL <B>OS_BEGIN_DETECT_USER_KEYSTROKE</B>( USER_HIT_ANY_KEY )
</TD></TR>
<TR valign=top><TD colspan=2>
<B>USER_HIT_ANY_KEY = .FALSE.</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! This will ignore any recent keystrokes.
</TD></TR>
<TR></TR></TABLE>PRINT *, " Hit any key to terminate iterations!"
<P>
DO I = 1,100
<P>
<PRE>
                  &#46;&#46;&#46;                              ! Compute a value for R.
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>550</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
PRINT *, I, R
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>IF (USER_HIT_ANY_KEY)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EXIT
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; ENDDO</H4>
</A>
<BLOCKQUOTE>
<P>
! Have the OS stop looking for user keystrokes.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CALL OS_STOP_DETECT_USER_KEYSTROKE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE TERMINATE_ITERATIONS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.4</B> </TD><TD valign=bottom>
Clause 9 notes
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.4.1</B> </TD><TD valign=bottom>
Structure components (9.4.2)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Components of a structure are referenced by writing the components of successive levels of the structure hierarchy
<P>
<PRE>
  until the desired component is described. For example,
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE ID_NUMBERS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER SSN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER EMPLOYEE_NUMBER</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE ID_NUMBERS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE PERSON_ID</H4>
</A>
<BLOCKQUOTE>
<P>
CHARACTER (LEN=30) LAST_NAME
<P>
CHARACTER (LEN=1) MIDDLE_INITIAL
<P>
CHARACTER (LEN=30) FIRST_NAME
<P>
TYPE (ID_NUMBERS) NUMBER
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE PERSON_ID</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE PERSON</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER AGE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (PERSON_ID) ID
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE PERSON</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (PERSON) GEORGE, MARY
<TABLE cellpadding=3><!-- tsb: TYPE (PERSON) GEORGE, MARY
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>PRINT</B> </TD><TD valign=bottom>
*,  GEORGE  % AGE               ! Print the AGE component
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PRINT</B> </TD><TD valign=bottom>
*,  MARY %  ID % LAST_NAME      ! Print LAST_NAME of MARY
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PRINT</B> </TD><TD valign=bottom>
*,  MARY %  ID % NUMBER % SSN ! Print SSN of MARY
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>PRINT</B> </TD><TD valign=bottom>
*,  GEORGE  % ID % NUMBER ! Print SSN and EMPLOYEE_NUMBER of GEORGE
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
2 A structure component can be a data object of intrinsic type as in the case of GEORGE % AGE or it can be
<P>
<PRE>
  of derived type as in the case of GEORGE % ID % NUMBER. The resultant component can be a scalar or an
<P>
  array of intrinsic or derived type.
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE LARGE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER ELT (10)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER VAL</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
551
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE LARGE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>TYPE (LARGE) A (5)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! 5 element array, each of whose elements
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                          ! includes a 10 element array ELT and
<P>
                                          ! a scalar VAL.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRINT *, A (1)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Prints 10 element array ELT and scalar VAL.
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRINT *, A (1) % ELT (3) !</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Prints scalar element 3
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                          ! of array element 1 of A.
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRINT *, A (2:4) % VAL</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Prints scalar VAL for array elements
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                          ! 2 to 4 of A.
<P>
</PRE>
3 Components of an object of extensible type that are inherited from the parent type can be accessed as a whole
<P>
<PRE>
  by using the parent component name, or individually, either with or without qualifying them by the parent
<P>
  component name. For example:
<P>
          TYPE POINT                 ! A base type
<P>
             REAL :: X, Y
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE POINT</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE, <B>EXTENDS</B>(POINT) :: COLOR_POINT ! An extension of <B>TYPE</B>(POINT)
<P>
<PRE>
             ! Components X and Y, and component name POINT, inherited from parent
<P>
             INTEGER :: COLOR
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE COLOR_POINT</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(POINT) :: PV = <B>POINT</B>(1.0, 2.0)
<P>
<B>TYPE</B>(COLOR_POINT) :: CPV = <B>COLOR_POINT</B>(POINT=PV, COLOR=3)
<TABLE cellpadding=3><!-- tsb: <B>TYPE</B>(COLOR_POINT) :: CPV = <B>COLOR_POINT</B>(POINT=PV, COLOR=3)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>PRINT *, CPV%POINT</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Prints 1.0 and 2.0
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRINT *, CPV%POINT%X, CPV%POINT%Y</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! And this does, too
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRINT *, CPV%X, CPV%Y</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! And this does, too
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.4.2</B> </TD><TD valign=bottom>
Allocation with dynamic type (9.7.1)
<P>
1 The following example illustrates the use of allocation with the value and dynamic type of the allocated object
<P>
<PRE>
  given by another object. The example copies a list of objects of any type. It copies the list starting at IN_LIST.
<P>
  After copying, each element of the list starting at LIST_COPY has a polymorphic component, ITEM, for which
<P>
  both the value and type are taken from the ITEM component of the corresponding element of the list starting at
<P>
  IN_LIST.
<P>
          TYPE :: LIST ! A list of anything
<P>
             TYPE(LIST), POINTER :: NEXT =&gt; NULL()
<P>
             CLASS(*), ALLOCATABLE :: ITEM
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END TYPE LIST</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
<B>TYPE</B>(LIST), POINTER :: IN_LIST, LIST_COPY =&gt; <B>NULL</B>()
<P>
<B>TYPE</B>(LIST), POINTER :: IN_WALK, NEW_TAIL
<P>
! Copy IN_LIST to LIST_COPY
<P>
IF (ASSOCIATED(IN_LIST)) THEN
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: IF (ASSOCIATED(IN_LIST)) THEN
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>552</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
IN_WALK =&gt; IN_LIST
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
<B>ALLOCATE</B>(LIST_COPY)
<P>
NEW_TAIL =&gt; LIST_COPY
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; DO</H4>
</A>
<BLOCKQUOTE>
<P>
<B>ALLOCATE</B>(NEW_TAIL%ITEM, SOURCE=IN_WALK%ITEM)
<P>
IN_WALK =&gt; IN_WALK%NEXT
<P>
IF (.NOT. <B>ASSOCIATED</B>(IN_WALK)) EXIT
<P>
<B>ALLOCATE</B>(NEW_TAIL%NEXT)
<P>
NEW_TAIL =&gt; NEW_TAIL%NEXT
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.5</B> </TD><TD valign=bottom>
Clause 10 notes
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.5.1</B> </TD><TD valign=bottom>
Evaluation of function references (10.1.7)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 If more than one function reference appears in a statement, they can be executed in any order (subject to a
<P>
<PRE>
  function result being evaluated after the evaluation of its arguments) and their values cannot depend on the order
<P>
  of execution. This lack of dependence on order of evaluation enables parallel execution of the function references.
<P>
  C.5.2     Pointers in expressions (10.1.9.2)
<P>
</PRE>
1 A pointer is considered to be like any other variable when it is used as a primary in an expression. If a pointer
<P>
<PRE>
  is used as an operand to an operator that expects a value, the pointer will automatically deliver the value stored
<P>
  in the space described by the pointer, that is, the value of the target object associated with the pointer.
<P>
  C.5.3     Pointers in variable definition contexts (10.2.1.3, 19.6.7)
<P>
</PRE>
1 The appearance of a pointer in a context that requires its value is a reference to its target. Similarly, where a
<P>
<PRE>
  pointer appears in a variable definition context the variable that is defined is the target of the pointer.
<P>
</PRE>
2 Executing the program fragment
<P>
<PRE>
           REAL, POINTER :: A
<P>
           REAL, TARGET :: B = 10.0
<P>
           A =&gt; B
<P>
           A = 42.0
<P>
           PRINT ’(F4.1)’, B
<P>
</PRE>
produces “42.0” as output.
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: produces “42.0” as output.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.6</B> </TD><TD valign=bottom>
Clause 11 notes
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.6.1</B> </TD><TD valign=bottom>
The SELECT CASE construct (11.1.9)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 At most one case block is selected for execution within a SELECT CASE construct, and there is no fall-through
<P>
<PRE>
  from one block into another block within a SELECT CASE construct. Thus there is no requirement for the user
<P>
  to exit explicitly from a block.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         553
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C.6.2      Loop control (11.1.7)
<P>
</PRE>
1 Fortran provides several forms of loop control:
<P>
<PRE>
         (1)   With an iteration count and a DO variable. This is the classic Fortran DO loop.
<P>
         (2)   Test a logical condition before each execution of the loop (DO WHILE).
<P>
         (3)   DO “forever”.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.6.3</B> </TD><TD valign=bottom>
Examples of DO constructs (11.1.7)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The following are all valid examples of DO constructs.
<P>
<PRE>
  Example 1:
<P>
            SUM = 0.0
<P>
            READ (IUN) N
<P>
            OUTER: DO L = 1, N                 ! A DO with a construct name
<P>
               READ (IUN) IQUAL, M, ARRAY (1:M)
<P>
               IF (IQUAL &lt; IQUAL_MIN) CYCLE OUTER            ! Skip inner loop
<P>
               INNER: DO 40 I = 1, M           ! A DO with a label and a name
<P>
                   CALL CALCULATE (ARRAY (I), RESULT)
<P>
                   IF (RESULT &lt; 0.0) CYCLE
<P>
                   SUM = SUM + RESULT
<P>
                   IF (SUM &gt; SUM_MAX) EXIT OUTER
<P>
      40       END DO INNER
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END DO OUTER</H4>
</A>
<BLOCKQUOTE>
<P>
2 The outer loop has an iteration count of MAX (N, 0), and will execute that number of times or until SUM exceeds
<P>
<PRE>
  SUM_MAX, in which case the EXIT OUTER statement terminates both loops. The inner loop is skipped by
<P>
  the first CYCLE statement if the quality flag, IQUAL, is too low. If CALCULATE returns a negative RESULT,
<P>
  the second CYCLE statement prevents it from being summed. Both loops have construct names and the inner
<P>
  loop also has a label. A construct name is required in the EXIT statement in order to terminate both loops, but
<P>
  is optional in the CYCLE statements because each belongs to its innermost loop.
<P>
  Example 2:
<P>
            N = 0
<P>
            DO 50, I = 1, 10
<P>
               J = I
<P>
               DO K = 1, 5
<P>
                   L = K
<P>
                   N = N + 1 ! This statement executes 50 times
<P>
               END DO           ! Nonlabeled DO inside a labeled DO
<P>
      50    CONTINUE
<P>
</PRE>
3 After execution of the above program fragment, I = 11, J = 10, K = 6, L = 5, and N = 50.
<P>
<PRE>
  554                                                               ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
  Example 3:
<P>
           N = 0
<P>
           DO I = 1, 10
<P>
              J = I
<P>
              DO 60, K = 5, 1     ! This inner loop is never executed
<P>
                  L = K
<P>
                  N = N + 1
<P>
      60      CONTINUE            ! Labeled DO inside a nonlabeled DO
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
4 After execution of the above program fragment, I = 11, J = 10, K = 5, N = 0, and L is not defined by these
<P>
<PRE>
  statements.
<P>
  C.6.4     Examples of invalid DO constructs (11.1.7)
<P>
</PRE>
1 The following are all examples of invalid skeleton DO constructs:
<P>
<PRE>
  Example 1:
<P>
           DO I = 1, 10
<P>
              &#46;&#46;&#46;
<P>
           END DO LOOP     ! No matching construct name
<P>
  Example 2:
<P>
           LOOP: DO 1000 I = 1, 10        ! No matching construct name
<P>
              &#46;&#46;&#46;
<P>
           1000 CONTINUE
<P>
  Example 3:
<P>
           LOOP1: DO
<P>
              &#46;&#46;&#46;
<P>
           END DO LOOP2     ! Construct names don’t match
<P>
  Example 4:
<P>
           DO I = 1, 10     ! Label required or &#46;&#46;&#46;
<P>
              &#46;&#46;&#46;
<P>
           1010 CONTINUE    ! &#46;&#46;&#46; END DO required
<P>
  Example 5:
<P>
           DO 1020 I = 1, 10
<P>
              &#46;&#46;&#46;
<P>
           1021 END DO           ! Labels don’t match
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                 555
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  Example 6:
<P>
            FIRST: DO I = 1, 10
<P>
               SECOND: DO J = 1, 5
<P>
                   &#46;&#46;&#46;
<P>
               END DO FIRST      ! Improperly nested DOs
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO SECOND</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.6.5</B> </TD><TD valign=bottom>
Simple example using events
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 A tree is a graph in which every node except one has a single “parent” node to which it is connected by an edge.
<P>
<PRE>
  The node without a parent is the “root” of the tree. The nodes that have a particular node as their parent are
<P>
  the “children” of that node. The root is at level 1, its children are at level 2, and so on.
<P>
</PRE>
2 A multifrontal code to solve a sparse set of linear equations involves a tree. Work at a node can start after all of
<P>
<PRE>
  its children’s work is complete and their data have been passed to it.
<P>
</PRE>
3 Here we assume that each node has been assigned to an image. Each image has a list of its nodes and these
<P>
<PRE>
  are ordered in decreasing tree level (all those at level L preceding those at level L − 1). For each node, array
<P>
  elements hold the number of children, details about the parent, and an event variable. This allows the processing
<P>
  to proceed asynchronously subject to the rule that a parent has to wait for all its children.
<P>
  Outline of example code:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM TREE</H4>
</A>
<BLOCKQUOTE>
<P>
USE, INTRINSIC :: ISO_FORTRAN_ENV
<P>
INTEGER, ALLOCATABLE :: NODE (:) ! Tree nodes that this image handles.
<TABLE cellpadding=3><!-- tsb: INTEGER, ALLOCATABLE :: NODE (:) ! Tree nodes that this image handles.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>INTEGER, ALLOCATABLE :: NC (:)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! <B>NODE</B>(I) has <B>NC</B>(I) children.
</TD></TR>
<TR></TR></TABLE>INTEGER, ALLOCATABLE :: PARENT (:), SUB (:)
<P>
<PRE>
                   ! The parent of NODE (I) is NODE (SUB (I)) [PARENT (I)].
<P>
</PRE>
TYPE (EVENT_TYPE), ALLOCATABLE :: DONE (:) [:]
<P>
INTEGER :: I, J, STATUS
<P>
! Set up the tree, including allocation of all arrays.
<P>
DO I = 1, SIZE (NODE)
<P>
<PRE>
                 ! Wait for children to complete
<P>
                 IF (NC (I) &gt; 0) THEN
<P>
                   EVENT WAIT (DONE (I), UNTIL_COUNT=NC (I), STAT=STATUS)
<P>
                   IF (STATUS/=0) EXIT
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
! Process node, using data from children.
<P>
IF (PARENT (I)&gt;0) THEN
<P>
<PRE>
                   ! Node is not the root.
<P>
                   ! Place result on image PARENT (I) for node NODE (SUB) [PARENT (I)]
<P>
                   ! Tell PARENT (I) that this has been done.
<P>
                   EVENT POST (DONE (SUB (I)) [PARENT (I)], STAT=STATUS)
<P>
                   IF (STATUS/=0) EXIT
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM TREE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>556</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.6.6</B> </TD><TD valign=bottom>
Example using three teams
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The following example illustrates the structure of a routine that will compute fluxes based on surface properties
<P>
<PRE>
  over land, sea, and ice, each in a different team. Each image will deal with areas containing exactly one of the
<P>
  three surface types.
<P>
           SUBROUTINE COMPUTE_FLUXES (FLUX_MOM, FLUX_SENS, FLUX_LAT)
<P>
           USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
<P>
           REAL, INTENT (OUT) :: FLUX_MOM (:,:), FLUX_SENS (:,:), FLUX_LAT (:,:)
<P>
           INTEGER, PARAMETER :: LAND = 1, SEA = 2, ICE = 3
<P>
           CHARACTER (LEN=10) :: SURFACE_TYPE
<P>
           INTEGER                 :: MY_SURFACE_TYPE, N_IMAGE
<P>
           TYPE (TEAM_TYPE)        :: TEAM_SURFACE_TYPE
<P>
              CALL GET_SURFACE_TYPE(THIS_IMAGE (), SURFACE_TYPE)
<P>
              SELECT CASE (SURFACE_TYPE)
<P>
              CASE ("LAND")
<P>
                  MY_SURFACE_TYPE = LAND
<P>
              CASE ("SEA")
<P>
                  MY_SURFACE_TYPE = SEA
<P>
              CASE ("ICE")
<P>
                  MY_SURFACE_TYPE = ICE
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CASE DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ERROR STOP</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
FORM TEAM (MY_SURFACE_TYPE, TEAM_SURFACE_TYPE)
<P>
CHANGE TEAM (TEAM_SURFACE_TYPE)
<P>
<PRE>
                  SELECT CASE (TEAM_NUMBER ( ))
<P>
                  CASE (LAND)      ! Compute fluxes over land surface
<P>
                      CALL COMPUTE_FLUXES_LAND (FLUX_MOM, FLUX_SENS, FLUX_LAT)
<P>
                  CASE (SEA)       ! Compute fluxes over sea surface
<P>
                      CALL COMPUTE_FLUXES_SEA (FLUX_MOM, FLUX_SENS, FLUX_LAT)
<P>
                  CASE (ICE)       ! Compute fluxes over ice surface
<P>
                      CALL COMPUTE_FLUXES_ICE (FLUX_MOM, FLUX_SENS, FLUX_LAT)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CASE DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ERROR STOP</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TEAM</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE COMPUTE_FLUXES</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.6.7</B> </TD><TD valign=bottom>
Accessing coarrays in sibling teams
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The following program illustrates subdividing a 4 × 4 grid into 2 × 2 teams, and the denotation of sibling teams.
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM DEMO</H4>
</A>
<BLOCKQUOTE>
<P>
! Initial team : 16 images. Algorithm design is a 4 by 4 grid.
<P>
! Desire 4 teams, for the upper left (UL), upper right (UR),
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ! Desire 4 teams, for the upper left (UL), upper right (UR),
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
557
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
              !                             lower left (LL), lower right (LR)
<P>
              USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
<P>
              TYPE (TEAM_TYPE) :: T
<P>
              INTEGER, PARAMETER :: UL=11, UR=22, LL=33, LR=44
<P>
              REAL     :: A(10,10)[4,*]
<P>
              INTEGER :: MYPE, TEAMNUM, NEWPE
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; TYPE TRANS_T</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER :: NEW_TEAM (16), NEW_INDEX (16)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (TRANS_T) :: TRANS
<P>
TRANS = TRANS_T ([UL, UL, LL, LL, UL, UL, LL, LL, UR, UR, LR, LR, UR, UR, LR, LR], &
<P>
<PRE>
                                  [1, 2, 1, 2, 3, 4, 3, 4, 1, 2, 1, 2, 3, 4, 3, 4])
<P>
</PRE>
MYPE = THIS_IMAGE ()
<P>
FORM TEAM (TRANS%NEW_TEAM(MYPE), T, <B>NEW_INDEX=TRANS%NEW_INDEX</B>(MYPE))
<P>
A = 3.14
<P>
CHANGE TEAM (T, B[2,*] =&gt; A)
<P>
<PRE>
                 ! Inside change team, image pattern for B is a 2 by 2 grid.
<P>
                 B (5, 5) = B (1, 1)[2, 1]
<P>
                 ! Outside the team addressing:
<P>
                 NEWPE = THIS_IMAGE ()
<P>
                 SELECT CASE (TEAM_NUMBER ())
<P>
                 CASE (UL)
<P>
                    IF (NEWPE==3) THEN
<P>
                       ! Right column of UL gets left column of UR.
<P>
                        B (:, 10) = B (:, 1)[1, 1, TEAM_NUMBER=UR]
<P>
                    ELSE IF (NEWPE==4) THEN
<P>
                        B (:, 10) = B (:, 1)[2, 1, TEAM_NUMBER=UR]
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
CASE (LL)
<P>
<PRE>
                    ! Similar to complete column exchange across middle of the original grid.
<P>
                    &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TEAM</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM DEMO</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.6.8</B> </TD><TD valign=bottom>
Example involving failed images
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Parallel algorithms often use work sharing schemes based on a specific mapping between image indices and global
<P>
<PRE>
  data addressing. To allow such programs to continue when one or more images fail, spare images can be used
<P>
  to re-establish execution of the algorithm with the failed images replaced by spare images, while retaining the
<P>
  previous image mapping for nonfailed images.
<P>
  558                                                             ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The following example illustrates how this might be done. In this example, failure cannot be tolerated for image
<BLOCKQUOTE>
<P>
1 in the initial team.
<P>
<PRE>
           PROGRAM possibly_recoverable_simulation
<P>
              USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE, STAT_FAILED_IMAGE
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER, ALLOCATABLE :: failures (:)
<P>
INTEGER :: images_used, i, images_spare, status
<P>
INTEGER :: id [*], me [*]
<P>
TYPE (TEAM_TYPE) :: simulation_team
<P>
LOGICAL :: read_checkpoint, done [*]
<P>
! Keep 1% spare images if we have a lot, just 1 if 10-199 images, 0 if &lt;10.
<P>
images_spare = MAX (INT (0.01*NUM_IMAGES ()), 0, MIN (NUM_IMAGES () - 10, 1)
<P>
images_used = NUM_IMAGES () - images_spare
<P>
read_checkpoint = THIS_IMAGE () &gt; images_used
<P>
setup : DO
<P>
<PRE>
                 me = THIS_IMAGE ()
<P>
                 id = MERGE (1, 2, me&lt;=images_used)
<P>
                 !
<P>
                 ! Set up spare images as replacement for failed ones.
<P>
                 !
<P>
                 IF (IMAGE_STATUS (1) == STAT_FAILED_IMAGE) &
<P>
                      ERROR STOP "cannot recover"
<P>
                 IF (me == 1) THEN
<P>
                     failures = FAILED_IMAGES ()
<P>
                     k = images_used
<P>
                     DO i = 1, SIZE (failures)
<P>
                        DO k = k+1, NUM_IMAGES ()
<P>
                          IF (IMAGE_STATUS (k) == 0) EXIT
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
IF (k &gt; NUM_IMAGES ()) ERROR STOP "cannot recover"
<P>
me [k] = failures (i)
<P>
id [k] = 1
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
images_used = k
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Set up a simulation team of constant size.
<P>
! Team 2 is the set of spares, so does not participate in the simulation.
<P>
!
<P>
FORM TEAM (id, simulation_team, NEW_INDEX=me, STAT=status)
<P>
simulation : CHANGE TEAM (simulation_team, STAT=status)
<P>
<PRE>
                    IF (status == STAT_FAILED_IMAGE) EXIT simulation
<P>
                    IF (TEAM_NUMBER () == 1) THEN
<P>
                      iter : DO
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
559
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                         CALL simulation_procedure (read_checkpoint, status, done)
<P>
                         ! The simulation_procedure:
<P>
                         ! - sets up and performs some part of the simulation;
<P>
                         ! - resets to the last checkpoint if requested;
<P>
                         ! - sets status from its internal synchronizations;
<P>
                         ! - sets done to .TRUE. when the simulation has completed.
<P>
                         IF (status == STAT_FAILED_IMAGE) THEN
<P>
                            read_checkpoint = .TRUE.
<P>
                            EXIT simulation
<P>
                         ELSE IF (done)
<P>
                            EXIT iter
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
read_checkpoint = .FALSE.
</BLOCKQUOTE>
<P>
END DO iter
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
END TEAM simulation (STAT=status)
<P>
SYNC ALL (STAT=status)
<P>
IF (THIS_IMAGE () &gt; images_used) done = done[1]
<P>
IF (done) EXIT setup
</BLOCKQUOTE>
<P>
END DO setup
<BLOCKQUOTE>
<P>
END PROGRAM possibly_recoverable_simulation
</BLOCKQUOTE>
<P>
3 Supporting fault-tolerant execution imposes obligations on library writers who use the parallel language facilities.
<P>
<PRE>
  Every synchronization statement, allocation or deallocation of coarrays, or invocation of a collective procedure
<P>
  will need to be prepared to handle error conditions, and implicit deallocation of coarrays will need to be avoided.
<P>
  Also, coarray module variables that are allocated inside the team execution context are not persistent.
<P>
  C.6.9       EVENT_QUERY example that tolerates image failure
<P>
</PRE>
1 This example is an adaptation of the later EVENT_QUERY example of C.11.2 to make it able to execute in
<P>
<PRE>
  the presence of the failure of one or more of the worker images. The function create_work_item now accepts an
<P>
  integer argument to indicate which work item is required. It is assumed that the work items are indexed 1, 2,
<P>
  &#46;&#46;&#46; . It is also assumed that if an image fails while processing a work item, that work item can subsequently be
<P>
  processed by another image.
<P>
            PROGRAM work_share
<P>
                 USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: EVENT_TYPE
<P>
                 USE :: mod_work, ONLY:       & ! Module that creates work items
<P>
                         work,                & ! Type for holding a work item
<P>
                         create_work_item, & ! Function that creates work item
<P>
                         process_item,        & ! Function that processes an item
<P>
                         work_done               ! Logical function that returns true
<P>
                                                 ! if all work done
<P>
                 TYPE :: worker_type
<P>
                    TYPE (EVENT_TYPE), ALLOCATABLE :: free (:)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>560</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>TYPE (EVENT_TYPE) :: submit [*]</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Whether work ready for a worker
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TYPE (worker_type) :: worker [*]</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Whether worker is free
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TYPE (work)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: work_item [*] ! Holds the data for a work item
</TD></TR>
<TR></TR></TABLE>INTEGER :: count, i, k, kk, nbusy [*], np, status
<P>
INTEGER, ALLOCATABLE :: working (:) ! Items being worked on
<P>
INTEGER, ALLOCATABLE :: pending (:) ! Items pending after image failure
<P>
<PRE>
         IF (THIS_IMAGE () == 1) THEN
<P>
           ! Get started
<P>
           ALLOCATE (worker%free (2:NUM_IMAGES ()))
<P>
           ALLOCATE (working (2: NUM_IMAGES ()), pending(NUM_IMAGES ()-1))
<P>
           nbusy = 0               ! This holds the number of workers working
<P>
           k = 1                   ! Index of next work item
<P>
           np = 0                  ! Number of work items in array pending
<P>
           DO i = 2, NUM_IMAGES () ! Start the workers working
<P>
              IF (work_done ()) EXIT
<P>
              working (i) = 0
<P>
              IF (IMAGE_STATUS (i) == STAT_FAILED_IMAGE) CYCLE
<P>
              work_item [i] = create_work_item (k)
<P>
              working (i) = k
<P>
              k = k + 1
<P>
              nbusy = nbusy + 1
<P>
              EVENT POST (submit [i], STAT=status)
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
! Main work distribution loop
<P>
master : DO
<P>
<PRE>
              image : DO i = 2, NUM_IMAGES ()
<P>
                 IF (IMAGE_STATUS (i) == STAT_FAILED_IMAGE) THEN
<P>
                    IF (working (i)&gt;0) THEN            ! It failed while working
<P>
                       np = np + 1
<P>
                       pending (np) = working (i)
<P>
                       working (i) = 0
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
CYCLE image
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
CALL EVENT_QUERY (worker%free (i), count)
<TABLE cellpadding=3><!-- tsb: CALL EVENT_QUERY (worker%free (i), count)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>IF (count == 0) CYCLE image</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Worker is not free
</TD></TR>
<TR></TR></TABLE>EVENT WAIT (worker%free (i))
<P>
nbusy = nbusy - 1
<P>
IF (np&gt;0) THEN
<P>
<PRE>
                    kk = pending (np)
<P>
                    np = np - 1
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
IF (work_done ()) CYCLE image
<P>
kk = k
<P>
k = k + 1
</BLOCKQUOTE>
<P>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
561
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
nbusy = nbusy + 1
<P>
working (i) = kk
<P>
work_item [i] = create_work_item (kk)
<P>
EVENT POST (submit [i], STAT=status)
<P>
! If image i has failed, the failure will be handled on
<P>
! the next iteration of the master loop.
</BLOCKQUOTE>
<P>
END DO image
<BLOCKQUOTE>
<P>
IF ( nbusy==0 ) THEN ! All done. Exit on all images.
<P>
<PRE>
                            DO i = 2, NUM_IMAGES ()
<P>
                                EVENT POST (submit [i], STAT=status)
<P>
                                IF (status == STAT_FAILED_IMAGE) CYCLE
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
EXIT master
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
END DO master
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
! Work processing loop
<P>
worker : DO
<P>
<PRE>
                        EVENT WAIT (submit)
<P>
                        IF (nbusy [1] == 0) EXIT worker
<P>
                        CALL process_item(work_item)
<P>
                        EVENT POST (worker[1]%free (THIS_IMAGE ()))
<P>
</PRE>
END DO worker
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
END PROGRAM work_share
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END PROGRAM work_share
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.7</B> </TD><TD valign=bottom>
Clause 12 notes
<TABLE width=100% cellpadding=3><!-- tsb: Clause 12 notes
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.7.1</B> </TD><TD valign=bottom>
External files (12.3)
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 This document accommodates, but does not require, file cataloging. To do this, several concepts are introduced.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  C.7.1.1     File existence (12.3.2)
<P>
</PRE>
1 Totally independent of the connection state is the property of existence, this being a file property. The processor
</TD></TR>
<TR><TD colspan=2>
<PRE>
  “knows” of a set of files that exist at a given time for a given program. This set would include tapes ready to
<P>
  read, files in a catalog, a keyboard, a printer, etc. The set might exclude files inaccessible to the program because
<P>
  of security, because they are already in use by another program, etc. This document does not specify which
<P>
  files exist, hence wide latitude is available to a processor to implement security, locks, privilege techniques, etc.
<P>
  Existence is a convenient concept to designate all of the files that a program can potentially process.
<P>
  562                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 All four combinations of connection and existence can occur:
</TD></TR>
<TR><TD colspan=2>
<PRE>
                         Connect      Exist   Examples
<P>
                         Yes          Yes     A  card reader loaded and ready to be read
<P>
                         Yes          No      A  printer before the first line is written
<P>
                         No           Yes     A  file named ’JOAN’ in the catalog
<P>
                         No           No      A  file on a reel of tape, not known to the processor
<P>
</PRE>
3 Means are provided to create, delete, connect, and disconnect files.
</TD></TR>
<TR><TD colspan=2>
<PRE>
  C.7.1.2    File access (12.3.3)
<P>
</PRE>
1 This document does not address problems of security, protection, locking, and many other concepts that might
</TD></TR>
<TR><TD colspan=2>
<PRE>
  be part of the concept of “right of access”. Such concepts are considered to be in the province of an operating
<P>
  system.
<P>
</PRE>
2 The OPEN and INQUIRE statements can be extended naturally to consider these things.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
3 Possible access methods for a file are: sequential, stream and direct. The processor might implement three
<P>
<PRE>
  different types of files, each with its own access method. It might instead implement one type of file with three
<P>
  different access methods.
<P>
</PRE>
4 Direct access to files is of a simple and commonly available type, that is, fixed-length records. The key is a
<P>
<PRE>
  positive integer.
<P>
  C.7.1.3    File connection (12.5)
<P>
</PRE>
1 Before any input/output can be performed on a file, it needs to be connected to a unit. The unit then serves as a
<P>
<PRE>
  designator for that file as long as it is connected. To be connected does not imply that “buffers” have or have not
<P>
  been allocated, that “file-control tables” have or have not been filled, or that any other method of implementation
<P>
  has been used. Connection means that (barring some other fault) a READ or WRITE statement can be executed
<P>
  on the unit, hence on the file. Without a connection, a READ or WRITE statement cannot be executed.
<P>
  C.7.1.4    File names (12.5.6.10)
<P>
</PRE>
1 A file can have a name. The form of a file name is not specified. If a system does not have some form of cataloging
<P>
<PRE>
  or tape labeling for at least some of its files, all file names disappear at the termination of execution. This is a
<P>
  valid implementation. Nowhere does this document require names to survive for any period of time longer than
<P>
  the execution time span of a program. Therefore, this document does not impose cataloging as a prerequisite.
<P>
  The naming feature is intended to enable use of a cataloging system where one exists.
<P>
  C.7.2      Nonadvancing input/output (12.3.4.2)
<P>
</PRE>
1 Data transfer statements affect the positioning of an external file. In Fortran 77, if no error or end-of-file
<P>
<PRE>
  condition exists, the file is positioned after the record just read or written and that record becomes the preceding
<P>
  record. This document contains the ADVANCE= specifier in a data transfer statement that provides the capab-
<P>
  ility of maintaining a position within the current record from one formatted data transfer statement to the next
<P>
  data transfer statement. The value NO provides this capability. The value YES positions the file after the record
<P>
  just read or written. The default is YES.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           563
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The tab edit descriptor and the slash are still appropriate for use with this type of record access but the tab
<P>
<PRE>
   cannot reposition before the left tab limit.
<P>
</PRE>
3 A BACKSPACE of a file that is positioned within a record causes the specified unit to be positioned before the
<P>
<PRE>
   current record.
<P>
</PRE>
4 If the next input/output operation on a file after a nonadvancing write is a rewind, backspace, end file or close
<P>
<PRE>
   operation, the file is positioned implicitly after the current record before an ENDFILE record is written to the
<P>
   file, that is, a REWIND, BACKSPACE, or ENDFILE statement following a nonadvancing WRITE statement
<P>
   causes the file to be positioned at the end of the current output record before the endfile record is written to the
<P>
   file.
<P>
</PRE>
5 This document provides a SIZE= specifier to be used with formatted data transfer statements. The variable in
<P>
<PRE>
   the SIZE= specifier is assigned the count of the number of characters that make up the sequence of values read
<P>
   by the data edit descriptors in the input statement.
<P>
</PRE>
6 The count is especially helpful if there is only one list item in the input list because it is the number of characters
<P>
<PRE>
   that appeared for the item.
<P>
</PRE>
7 The EOR= specifier is provided to indicate when an EOR condition is encountered during a nonadvancing data
<P>
<PRE>
   transfer statement. The EOR condition is not an error condition. If this specifier appears, an input list item that
<P>
   requires more characters than the record contained is padded with blanks if PAD= ’YES’ is in effect. This means
<P>
   that the input list item completed successfully. The file is positioned after the current record. If the IOSTAT=
<P>
   specifier appears, the specified variable is defined with the value of the named constant IOSTAT_EOR from
<P>
   the intrinsic module ISO_FORTRAN_ENV and the data transfer statement is terminated. Program execution
<P>
   continues with the statement specified in the EOR= specifier. The EOR= specifier gives the capability of taking
<P>
   control of execution when the EOR condition is encountered. The do-variables in io-implied-dos retain their last
<P>
   defined value and any remaining items in the input-item-list retain their definition status when an EOR condition
<P>
   occurs. If the SIZE= specifier appears, the specified variable is assigned the number of characters read with the
<P>
   data edit descriptors during the READ statement.
<P>
</PRE>
8 For nonadvancing input, the processor is not required to read partial records. The processor could read the entire
<P>
<PRE>
   record into an internal buffer and make successive portions of the record available to successive input statements.
<P>
</PRE>
9 In an implementation of nonadvancing input/output in which a nonadvancing write to a terminal device causes
<P>
<PRE>
   immediate display of the output, such a write can be used as a mechanism to output a prompt. In this case, the
<P>
   statement
<P>
             WRITE (*, FMT=’(A)’, ADVANCE=’NO’) ’CONTINUE?(Y/N): ’
<P>
   would result in the prompt
<P>
             CONTINUE?(Y/N):
<P>
   being displayed with no subsequent line feed.
<P>
</PRE>
10 The response, which might be read by a statement of the form
<P>
<PRE>
             READ (*, FMT=’(A)’) ANSWER
<P>
</PRE>
can then be entered on the same line as the prompt as in
<P>
<PRE>
             CONTINUE?(Y/N): Y
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>564</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
11 This document does not require that an implementation of nonadvancing input/output operate in this manner.
</TD></TR>
<TR><TD colspan=2>
<PRE>
   For example, an implementation of nonadvancing output in which the display of the output is deferred until
<P>
   the current record is complete is also standard-conforming. Such an implementation will not, however, allow a
<P>
   prompting mechanism of this kind to operate.
<P>
   C.7.3      OPEN statement (12.5.6)
<P>
</PRE>
1 A file can become connected to a unit either by preconnection or by execution of an OPEN statement. Precon-
</TD></TR>
<TR><TD colspan=2>
<PRE>
   nection is performed prior to the beginning of execution of a program by means external to Fortran. For example,
<P>
   it could be done by job control action or by processor-established defaults. Execution of an OPEN statement is
<P>
   not required in order to access preconnected files (12.5.5).
<P>
</PRE>
2 The OPEN statement provides a means to access existing files that are not preconnected. An OPEN statement
</TD></TR>
<TR><TD colspan=2>
<PRE>
   can be used in either of two ways: with a file name (open-by-name) and without a file name (open-by-unit). A
<P>
   unit is given in either case. Open-by-name connects the specified file to the specified unit. Open-by-unit connects
<P>
   a processor-dependent default file to the specified unit. (The default file might or might not have a name.)
<P>
</PRE>
3 Therefore, there are three ways a file can become connected and hence processed: preconnection, open-by-name,
</TD></TR>
<TR><TD colspan=2>
<PRE>
   and open-by-unit. Once a file is connected, there is no means in standard Fortran to determine how it became
<P>
   connected.
<P>
</PRE>
4 An OPEN statement can also be used to create a new file. In fact, any of the foregoing three connection methods
</TD></TR>
<TR><TD colspan=2>
<PRE>
   can be performed on a file that does not exist. When a unit is preconnected, writing the first record creates the
<P>
   file. With the other two methods, execution of the OPEN statement creates the file.
<P>
</PRE>
5 When an OPEN statement is executed, the unit specified in the OPEN statement might or might not already be
</TD></TR>
<TR><TD colspan=2>
<PRE>
   connected to a file. If it is already connected to a file (either through preconnection or by prior execution of an
<P>
   OPEN statement), then omitting the FILE= specifier in the OPEN statement implies that the file is to remain
<P>
   connected to the unit. Such an OPEN statement can be used to change the values of the blank interpretation
<P>
   mode, decimal edit mode, pad mode, input/output rounding mode, delimiter mode, and sign mode.
<P>
</PRE>
6 If the value of the ACTION= specifier is WRITE, then a READ statement cannot refer to the connection.
</TD></TR>
<TR><TD colspan=2>
<PRE>
   ACTION = ’WRITE’ does not restrict positioning by a BACKSPACE statement or positioning specified by the
<P>
   POSITION= specifier with the value APPEND. However, a BACKSPACE statement or an OPEN statement
<P>
   containing POSITION = ’APPEND’ might fail if the processor needs to read the file to achieve the positioning.
<P>
</PRE>
7 The following examples illustrate these rules. In the first example, unit 10 is preconnected to a SCRATCH file;
</TD></TR>
<TR><TD colspan=2>
<PRE>
   the OPEN statement changes the value of PAD= to YES.
<P>
             CHARACTER (LEN = 20) CH1
<P>
             WRITE (10, ’(A)’) ’THIS IS RECORD 1’
<P>
             OPEN (UNIT = 10, STATUS = ’OLD’, PAD = ’YES’)
<P>
             REWIND 10
<P>
             READ (10, ’(A20)’) CH1         ! CH1 now has the value
<P>
                                            ! ’THIS IS RECORD 1          ’
<P>
</PRE>
8 In the next example, unit 12 is first connected to a file named FRED, with a status of OLD. The second OPEN
</TD></TR>
<TR><TD colspan=2>
<PRE>
   statement then opens unit 12 again, retaining the connection to the file FRED, but changing the value of the
<P>
   DELIM= specifier to QUOTE.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                         565
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
            CHARACTER (LEN = 25) CH2, CH3
<P>
            OPEN (12, FILE = ’FRED’, STATUS = ’OLD’, DELIM = ’NONE’)
<P>
            CH2 = ’"THIS STRING HAS QUOTES."’
<P>
                             ! Quotes in string CH2
<P>
            WRITE (12, *) CH2                  ! Written with no delimiters
<P>
            OPEN (12, DELIM = ’QUOTE’) ! Now quote is the delimiter
<P>
            REWIND 12
<P>
            READ (12, *) CH3 ! CH3 now has the value
<P>
                                   ! ’THIS STRING HAS QUOTES. ’
<P>
</PRE>
9 The next example is invalid because it attempts to change the value of the STATUS= specifier.
</TD></TR>
<TR><TD colspan=2>
<PRE>
            OPEN (10, FILE = ’FRED’, STATUS = ’OLD’)
<P>
            WRITE (10, *) A, B, C
<P>
            OPEN (10, STATUS = ’SCRATCH’)           ! Attempts to make FRED a SCRATCH file
<P>
</PRE>
10 The previous example could be made valid by closing the unit first, as in the next example.
</TD></TR>
<TR><TD colspan=2>
<PRE>
            OPEN (10, FILE = ’FRED’, STATUS = ’OLD’)
<P>
            WRITE (10, *) A, B, C
<P>
            CLOSE (10)
<P>
            OPEN (10, STATUS = ’SCRATCH’)           ! Opens a different SCRATCH file
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.7.4</B> </TD><TD valign=bottom>
Connection properties (12.5.4)
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
1 When a unit becomes connected to a file, either by execution of an OPEN statement or by preconnection, the
</TD></TR>
<TR><TD colspan=2>
<PRE>
   following connection properties, among others, are established.
<P>
          (1)   An access method, which is sequential, direct, or stream, is established for the connection (12.5.6.3).
<P>
          (2)   A form, which is formatted or unformatted, is established for a connection to a file that exists or
<P>
                is created by the connection. For a connection that results from execution of an OPEN statement,
<P>
                a default form (which depends on the access method, as described in 12.3.3) is established if no
<P>
                form is specified. For a preconnected file that exists, a form is established by preconnection. For a
<P>
                preconnected file that does not exist, a form might be established, or the establishment of a form
<P>
                might be delayed until the file is created (for example, by execution of a formatted or unformatted
<P>
                WRITE statement) (12.5.6.11).
<P>
          (3)   A record length might be established. If the access method is direct, the connection establishes a
<P>
                record length that specifies the length of each record of the file. A direct access file can only contain
<P>
                records that are all of equal length.
<P>
          (4)   A sequential file can contain records of varying lengths. In this case, the record length established
<P>
                specifies the maximum length of a record in the file (12.5.6.15).
<P>
</PRE>
2 A processor has wide latitude in adapting these concepts and actions to its own cataloging and job control
</TD></TR>
<TR><TD colspan=2>
<PRE>
   conventions. Some processors might need job control action to specify the set of files that exist or that will
<P>
   be created by a program. Some processors might not need any job control action prior to execution. This
<P>
   document enables processors to perform dynamic open, close, or file creation operations, but it does not require
<P>
   such capabilities of the processor.
<P>
   566                                                                ⃝
<P>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 The meaning of “open” in contexts other than Fortran might include such things as mounting a tape, console
</TD></TR>
<TR><TD colspan=2>
<PRE>
  messages, spooling, label checking, security checking, etc. These actions might occur upon job control action
<P>
  external to Fortran, upon execution of an OPEN statement, or upon execution of the first read or write of the
<P>
  file. The OPEN statement describes properties of the connection to the file and might or might not cause physical
<P>
  activities to take place.
<P>
  C.7.5      Asynchronous input/output (12.6.2.5)
<P>
</PRE>
1 Rather than limit support for asynchronous input/output to what has been traditionally provided by facilities
</TD></TR>
<TR><TD colspan=2>
<PRE>
  such as BUFFERIN/BUFFEROUT, this document builds upon existing Fortran syntax. This permits alternative
<P>
  approaches for implementing asynchronous input/output, and simplifies the task of adapting existing standard-
<P>
  conforming programs to use asynchronous input/output.
<P>
</PRE>
2 Not all processors actually perform input/output asynchronously, nor will every processor that does be able to
</TD></TR>
<TR><TD colspan=2>
<PRE>
  handle data transfer statements with complicated input/output item lists in an asynchronous manner. Such
<P>
  processors can still be standard-conforming.
<P>
</PRE>
3 This document allows for at least two different conceptual models for asynchronous input/output.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
4 Model 1: the processor performs asynchronous input/output when the item list is simple (perhaps one contiguous
<P>
<PRE>
  named array) and the input/output is unformatted. The implementation cost is reduced, and this is the scenario
<P>
  most likely to be beneficial on traditional “big-iron” machines.
<P>
</PRE>
5 Model 2: The processor is free to do any of the following:
<P>
<PRE>
         (1)    on output, create a buffer inside the input/output library, completely formatted, and then start an
<P>
                asynchronous write of the buffer, and immediately return to the next statement in the program. The
<P>
                processor is free to wait for previously issued WRITEs, or not, or
<P>
         (2)    pass the input/output list addresses to another processor/process, which processes the list items
<P>
                independently of the processor that executes the user’s code. The addresses of the list items will
<P>
                need to be computed before the asynchronous READ/WRITE statement completes. There is still
<P>
                an ordering requirement on list item processing to handle things like READ (&#46;&#46;&#46;) N,(a(i),i=1,N).
<P>
</PRE>
6 A program can issue a large number of asynchronous input/output requests, without waiting for any of them to
<P>
<PRE>
  complete, and then wait for any or all of them. That does not constitute a requirement for the processor to keep
<P>
  track of each individual request separately.
<P>
</PRE>
7 It is not necessary for all requests to be tracked by the runtime library. If an ID= specifier does not appear in on a
<P>
<PRE>
  READ or WRITE statement, the runtime library can forget about this particular request once it has successfully
<P>
  completed. If an error or end-of-file condition occurs for a request, the processor can report this during any
<P>
  input/output operation to that unit. If an ID= specifier appears, the processor’s runtime input/output library
<P>
  will need to keep track of any end-of-file or error conditions for that particular input/output request. However, if
<P>
  the input/output request succeeds without any exceptional conditions occurring, then the runtime can forget that
<P>
  ID= value. A runtime library might only keep track of the last request made, or perhaps a very few. Then, when
<P>
  a user WAITs for a particular request, either the library will know about it (and does the right thing with respect
<P>
  to error handling, etc.), or can assume it is a request that successfully completed and was forgotten about (and
<P>
  will just return without signaling any end-of-file or error condition). A standard-conforming program can only
<P>
  pass valid ID= values, but there is no requirement on the processor to detect invalid ID= values. There might
<P>
  be a processor dependent limit on how many outstanding input/output requests that generate an end-of-file or
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                            567
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  error condition can be handled before the processor runs out of memory to keep track of such conditions. The
<P>
  restrictions on the SIZE= variables are designed to enable the processor to update such variables at any time
<P>
  (after the request has been processed, but before the wait operation), and then forget about them. Only error and
<P>
  end-of-file conditions are expected to be tracked by individual request by the runtime, and then only if an ID=
<P>
  specifier appears. The END= and EOR= specifiers have not been added to all statements that can perform wait
<P>
  operations. Instead, the IOSTAT variable can be queried after a wait operation to handle this situation. This
<P>
  choice was made because the WAIT statement is expected to be the usual method of waiting for input/output
<P>
  to complete (and WAIT does support the END= and EOR= specifiers). This particular choice is philosophical,
<P>
  and was not based on significant technical difficulties.
<P>
</PRE>
8 The requirement to set the IOSTAT variable correctly means that a processor will need to remember which
<P>
<PRE>
  input/output requests encountered an end-of-record condition, so that a subsequent wait operation can return
<P>
  the correct IOSTAT value. Therefor there might be a processor defined limit on the number of outstanding
<P>
  nonadvancing input/output requests that have encountered an end-of-record condition (constrained by available
<P>
  memory to keep track of this information, similar to end-of-file and error conditions).
<P>
  C.8       Clause 13 notes
<P>
  C.8.1      Number of records (13.4, 13.5, 13.8.2)
<P>
</PRE>
1 The number of records read by an explicitly formatted advancing input statement can be determined from the
<P>
<PRE>
  following rule: a record is read at the beginning of the format scan (even if the input list is empty unless the most
<P>
  recently previous operation on the unit was not a nonadvancing read operation), at each slash edit descriptor
<P>
  encountered in the format, and when a format rescan occurs at the end of the format.
<P>
</PRE>
2 The number of records written by an explicitly formatted advancing output statement can be determined from
<P>
<PRE>
  the following rule: a record is written when a slash edit descriptor is encountered in the format, when a format
<P>
  rescan occurs at the end of the format, and at completion of execution of an advancing output statement (even if
<P>
  the output list is empty). Thus, the occurrence of n successive slashes between two other edit descriptors causes
<P>
  n − 1 blank lines if the records are printed. The occurrence of n slashes at the beginning or end of a complete
<P>
  format specification causes n blank lines if the records are printed. However, a complete format specification
<P>
  containing n slashes (n &gt; 0) and no other edit descriptors causes n + 1 blank lines if the records are printed. For
<P>
  example, the statements
<P>
         PRINT 3
<P>
      3 FORMAT (/)
<P>
  will write two records that cause two blank lines if the records are printed.
<P>
  C.8.2      List-directed input (13.10.3)
<P>
</PRE>
1 The following examples illustrate list-directed input. A blank character is represented by b.
<P>
2 Example 1:
<P>
<PRE>
  Program:
<P>
            J = 3
<P>
            READ *, I
<P>
            READ *, J
<P>
  568                                                                ⃝
<P>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
  Sequential input file:
<P>
            record 1:    b1b,4bbbbb
<P>
            record 2:    ,2bbbbbbbb
<P>
</PRE>
3 Result: I = 1, J = 3.
<P>
4 Explanation: The second READ statement reads the second record. The initial comma in the record designates
<P>
<PRE>
  a null value; therefore, J is not redefined.
<P>
</PRE>
5 Example 2:
<P>
<PRE>
  Program:
<P>
        CHARACTER A *8, B *1
<P>
        READ *, A, B
<P>
  Sequential input file:
<P>
        record 1:     ’bbbbbbbb’
<P>
        record 2:     ’QXY’b’Z’
<P>
</PRE>
6 Result: A = ’bbbbbbbb’, B = ’Q’
<P>
7 Explanation: In the first record, the rightmost apostrophe is interpreted as delimiting the constant (it cannot
<P>
<PRE>
  be the first of a pair of embedded apostrophes representing a single apostrophe because this would involve
<P>
  the prohibited “splitting” of the pair by the end of a record); therefore, A is assigned the character constant
<P>
  ’bbbbbbbb’. The end of a record acts as a blank, which in this case is a value separator because it occurs between
<P>
  two constants.
<P>
  C.9       Clause 14 notes
<P>
  C.9.1      Main program and block data program unit (14.1, 14.3)
<P>
</PRE>
1 The name of the main program or of a block data program unit has no explicit use within the Fortran language.
<P>
<PRE>
  It is available for documentation and for possible use by a processor.
<P>
</PRE>
2 A processor might implement an unnamed program unit by assigning it a global identifier that is not used
<P>
<PRE>
  elsewhere in the program. This could be done by using a default name that does not satisfy the rules for Fortran
<P>
  names.
<P>
  C.9.2      Dependent compilation (14.2)
<P>
</PRE>
1 This document, like its predecessors, is intended to enable the implementation of conforming processors in which
<P>
<PRE>
  a program can be broken into multiple units, each of which can be separately translated in preparation for
<P>
  execution. Such processors are commonly described as supporting separate compilation. There is an important
<P>
  difference between the way separate compilation can be implemented under this document and the way it could be
<P>
  implemented under the Fortran 77 International Standard. Under the Fortran 77 standard, any information
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                         569
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  required to translate a program unit was specified in that program unit. Each translation was thus totally
<P>
  independent of all others. Under this document, a program unit can use information that was specified in a
<P>
  separate module and thus can be dependent on that module. The implementation of this dependency in a
<P>
  processor might be that the translation of a program unit depends on the results of translating one or more
<P>
  modules. Processors implementing the dependency this way are commonly described as supporting dependent
<P>
  compilation.
<P>
</PRE>
2 The dependencies involved here are new only in the sense that the Fortran processor is now aware of them. The
<P>
<PRE>
  same information dependencies existed under the Fortran 77 International Standard, but it was the program-
<P>
  mer’s responsibility to transport the information necessary to resolve them by making redundant specifications of
<P>
  the information in multiple program units. The availability of separate but dependent compilation offers several
<P>
  potential advantages over the redundant textual specification of information.
<P>
         (1)   Specifying information at a single place in the program ensures that different program units using that
<P>
               information are translated consistently. Redundant specification leaves the possibility that different
<P>
               information can be erroneously be specified. Even if an INCLUDE line is used to ensure that the
<P>
               text of the specifications is identical in all involved program units, the presence of other specifications
<P>
               (for example, an IMPLICIT statement) could change the interpretation of that text.
<P>
         (2)   During the revision of a program, it is possible for a processor to assist in determining whether differ-
<P>
               ent program units have been translated using different (incompatible) versions of a module, although
<P>
               there is no requirement that a processor provide such assistance. Inconsistencies in redundant textual
<P>
               specification of information, on the other hand, tend to be much more difficult to detect.
<P>
         (3)   Putting information in a module provides a way of packaging it. Without modules, redundant spe-
<P>
               cifications frequently are interleaved with other specifications in a program unit, making convenient
<P>
               packaging of such information difficult.
<P>
         (4)   Because a processor can be implemented such that the specifications in a module are translated once
<P>
               and then repeatedly referenced, there is the potential for greater efficiency than when the processor
<P>
               translates redundant specifications of information in multiple program units.
<P>
</PRE>
3 The exact meaning of the requirement that the public portions of a module be available at the time of reference
<P>
<PRE>
  is processor dependent. For example, a processor could consider a module to be available only after it has been
<P>
  compiled and require that if the module has been compiled separately, the result of that compilation be identified
<P>
  to the compiler when compiling program units that use it.
<P>
  C.9.2.1    USE statement and dependent compilation (14.2.2)
<P>
</PRE>
1 Another benefit of the USE statement is its enhanced facilities for name management. If one needs to use only
<P>
<PRE>
  selected entities in a module, one can do so without having to worry about the names of all the other entities
<P>
  in that module. If one needs to use two different modules that happen to contain entities with the same name,
<P>
  there are several ways to deal with the conflict. If none of the entities with the same name are to be used, they
<P>
  can simply be ignored. If the name happens to refer to the same entity in both modules (for example, if both
<P>
  modules obtained it from a third module), then there is no confusion about what the name denotes and the name
<P>
  can be freely used. If the entities are different and one or both is to be used, the local renaming facility in the
<P>
  USE statement makes it possible to give those entities different names in the program unit containing the USE
<P>
  statements.
<P>
</PRE>
2 A benefit of using the ONLY option consistently, as compared to USE without it, is that the module from which
<P>
<PRE>
  each accessed entity is accessed is explicitly specified in each program unit. This means that one need not search
<P>
  other program units to find where each one is defined. This reduces maintenance costs.
<P>
  570                                                                   ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 A typical implementation of dependent but separate compilation might involve storing the result of translating a
<P>
<PRE>
  module in a file whose name is derived from the name of the module. Note, however, that the name of a module
<P>
  is limited only by the Fortran rules and not by the names allowed in the file system. Thus the processor might
<P>
  have to provide a mapping between Fortran names and file system names.
<P>
</PRE>
4 The result of translating a module could reasonably either contain only the information textually specified in the
<P>
<PRE>
  module (with “pointers” to information originally textually specified in other modules) or contain all information
<P>
  specified in the module (including copies of information originally specified in other modules). Although the former
<P>
  approach would appear to save on storage space, the latter approach can greatly simplify the logic necessary to
<P>
  process a USE statement and can avoid the necessity of imposing a limit on the logical “nesting” of modules via
<P>
  the USE statement.
<P>
</PRE>
5 There is an increased potential for undetected errors in a scoping unit that uses both implicit typing and the
<P>
<PRE>
  USE statement. For example, in the program fragment
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE MY_MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
IMPLICIT INTEGER (I-N), REAL (A-H, O-Z)
<P>
X = F (B)
<P>
A = G (X) + H (X + 1)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
X could be either an implicitly typed real variable or a variable obtained from the module MY_MODULE and
<P>
might change from one to the other because of changes in MY_MODULE unrelated to the action performed by
<P>
SUB. Logic errors resulting from this kind of situation can be extremely difficult to locate. Thus, the use of these
<P>
features together is discouraged.
<TABLE cellpadding=3><!-- tsb: features together is discouraged.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.9.2.2</B> </TD><TD valign=bottom>
Accessibility attributes (8.5.2)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The PUBLIC and PRIVATE attributes, which can be declared only in modules, divide the entities in a module
<P>
<PRE>
  into those that are actually relevant to a scoping unit referencing the module and those that are not. This
<P>
  information might be used to improve the performance of a Fortran processor. For example, it might be possible
<P>
  to discard much of the information about the private entities once a module has been translated, thus saving on
<P>
  both storage and the time to search it. Similarly, it might be possible to recognize that two versions of a module
<P>
  differ only in the private entities they contain and avoid retranslating program units that use that module when
<P>
  switching from one version of the module to the other.
<P>
  C.9.3      Examples of the use of modules (14.2.1)
<P>
  C.9.3.1    Global data (14.2.1)
<P>
</PRE>
1 A module could contain only data objects, for example:
<A name=>

    <H4>&nbsp; &nbsp; MODULE DATA_MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SAVE</H4>
</A>
<BLOCKQUOTE>
<P>
REAL A (10), B, C (20,20)
<P>
INTEGER :: I=0
<P>
INTEGER, PARAMETER :: J=10
<P>
COMPLEX D (J,J)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE DATA_MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
571
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
</BLOCKQUOTE>
<P>
2 Data objects made global in this manner can have any combination of data types.
<BLOCKQUOTE>
<P>
3 Access to some of these can be made by a USE statement with the ONLY option, such as:
<P>
<PRE>
           USE DATA_MODULE, ONLY: A, B, D
<P>
</PRE>
and access to all of them can be made by the following USE statement:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE DATA_MODULE</H4>
</A>
<BLOCKQUOTE>
<P>
4 Access to all of them with some renaming to avoid name conflicts can be made by, for example:
<P>
<PRE>
      USE DATA_MODULE, AMODULE =&gt; A, DMODULE =&gt; D
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.9.3.2</B> </TD><TD valign=bottom>
Derived types (14.2.1)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 A derived type can be defined in a module and accessed in a number of program units. For example,
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE SPARSE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE NONZERO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; REAL A</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER I, J
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE NONZERO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE SPARSE</H4>
</A>
<BLOCKQUOTE>
<P>
defines a type consisting of a real component and two integer components for holding the numerical value of a
<P>
nonzero matrix element and its row and column indices.
<TABLE cellpadding=3><!-- tsb: nonzero matrix element and its row and column indices.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.9.3.3</B> </TD><TD valign=bottom>
Global allocatable arrays (14.2.1)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Many programs need large global allocatable arrays whose sizes are not known before program execution. A
<P>
<PRE>
  simple form for such a program is:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM GLOBAL_WORK</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>CALL CONFIGURE_ARRAYS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Perform the appropriate allocations
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CALL COMPUTE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Use the arrays in computations
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM GLOBAL_WORK</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>MODULE WORK_ARRAYS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! An example set of work arrays
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER N</H4>
</A>
<BLOCKQUOTE>
<P>
REAL, ALLOCATABLE :: A (:), B (:, :), C (:, :, :)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE WORK_ARRAYS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>SUBROUTINE CONFIGURE_ARRAYS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Process to set up work arrays
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE WORK_ARRAYS</H4>
</A>
<BLOCKQUOTE>
<P>
READ (*, *) N
<P>
ALLOCATE (A (N), B (N, N), C (N, N, 2 * N))
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE CONFIGURE_ARRAYS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE COMPUTE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE WORK_ARRAYS</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46; ! Computations involving arrays A, B, and C
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE COMPUTE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>572</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 Typically, many subprograms need access to the work arrays, and all such subprograms would contain the
<P>
<PRE>
  statement
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; USE WORK_ARRAYS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.9.3.4</B> </TD><TD valign=bottom>
Procedure libraries (14.2.2)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Interface bodies for external procedures in a library can be gathered into a module. An interface body specifies
<P>
<PRE>
  an explicit interface (15.4.2.2).
<P>
</PRE>
2 An example is the following library module:
<A name=>

    <H4>&nbsp; &nbsp; MODULE LIBRARY_LLS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE LLS (X, A, F, FLAG)
<P>
<PRE>
                      REAL X (:, :)
<P>
                      ! The SIZE in the next statement is an intrinsic function
<P>
                      REAL, DIMENSION (SIZE (X, 2)) :: A, F
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER FLAG</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE LLS</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE LIBRARY_LLS</H4>
</A>
<BLOCKQUOTE>
<P>
3 This module provides an explicit interface that is necessary for the subroutine LLS to be invoked. for example:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE LIBRARY_LLS</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
CALL LLS (X = ABC, A = D, F = XX, FLAG = IFLAG)
<P>
<PRE>
               &#46;&#46;&#46;
<P>
</PRE>
4 Because dummy argument names in an interface body for an external procedure are not required to be the same
<P>
<PRE>
  as in the procedure definition, different versions can be constructed for different applications using argument
<P>
  keywords appropriate to each application.
<P>
  C.9.3.5   Operator extensions (14.2.2)
<P>
</PRE>
1 In order to extend an intrinsic operator symbol to have an additional meaning, an interface block specifying that
<P>
<PRE>
  operator symbol in the OPERATOR option of the INTERFACE statement could be placed in a module.
<P>
</PRE>
2 For example, // can be extended to perform concatenation of two derived-type objects serving as varying length
<P>
<PRE>
  character strings and + can be extended to specify matrix addition for type MATRIX or interval arithmetic
<P>
  addition for type INTERVAL.
<P>
</PRE>
3 A module might contain several such interface blocks. An operator can be defined by an external function (either
<P>
<PRE>
  in Fortran or some other language) and its procedure interface placed in the module.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                        573
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C.9.3.6    Data abstraction (14.2.2)
<P>
</PRE>
1 In addition to providing a portable means of avoiding the redundant specification of information in multiple
<P>
<PRE>
  program units, a module provides a convenient means of “packaging” related entities, such as the definitions of
<P>
  the representation and operations of an abstract data type. The following example of a module defines a data
<P>
  abstraction for a SET type where the elements of each set are of type integer. The usual set operations of UNION,
<P>
  INTERSECTION, and DIFFERENCE are provided. The CARDINALITY function returns the cardinality of
<P>
  (number of elements in) its set argument. Two functions returning logical values are included, ELEMENT and
<P>
  SUBSET. ELEMENT defines the operator .IN. and SUBSET extends the operator &lt;=. ELEMENT determines
<P>
  if a given scalar integer value is an element of a given set, and SUBSET determines if a given set is a subset of
<P>
  another given set. (Two sets can be checked for equality by comparing cardinality and checking that one is a
<P>
  subset of the other, or checking to see if each is a subset of the other.)
<P>
</PRE>
2 The transfer function SETF converts a vector of integer values to the corresponding set, with duplicate values
<P>
<PRE>
  removed. Thus, a vector of constant values can be used as set constants. An inverse transfer function VECTOR
<P>
  returns the elements of a set as a vector of values in ascending order. In this SET implementation, set data
<P>
  objects have a maximum cardinality of 200.
<P>
</PRE>
3 Here is the example module:
<A name=>

    <H4>&nbsp; &nbsp; MODULE INTEGER_SETS</H4>
</A>
<BLOCKQUOTE>
<P>
! This module is intended to illustrate use of the module facility
<P>
! to define a new type, along with suitable operators.
<P>
INTEGER, PARAMETER :: MAX_SET_CARD = 200
<TABLE cellpadding=3><!-- tsb: INTEGER, PARAMETER :: MAX_SET_CARD = 200
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>TYPE SET</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Define SET type
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER CARD</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER ELEMENT (MAX_SET_CARD)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE SET</H4>
</A>
<BLOCKQUOTE>
<P>
INTERFACE OPERATOR (.IN.)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE PROCEDURE ELEMENT</H4>
</A>
<BLOCKQUOTE>
<P>
END INTERFACE OPERATOR (.IN.)
<P>
INTERFACE OPERATOR (&lt;=)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE PROCEDURE SUBSET</H4>
</A>
<BLOCKQUOTE>
<P>
END INTERFACE OPERATOR (&lt;=)
<P>
INTERFACE OPERATOR (+)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE PROCEDURE UNION</H4>
</A>
<BLOCKQUOTE>
<P>
END INTERFACE OPERATOR (+)
<P>
INTERFACE OPERATOR (-)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE PROCEDURE DIFFERENCE</H4>
</A>
<BLOCKQUOTE>
<P>
END INTERFACE OPERATOR (-)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END INTERFACE OPERATOR (-)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>574</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
INTERFACE OPERATOR (*)
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; MODULE PROCEDURE INTERSECTION</H4>
</A>
<BLOCKQUOTE>
<P>
END INTERFACE OPERATOR (*)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTEGER FUNCTION CARDINALITY (A)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Returns cardinality of set A
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        TYPE (SET), INTENT (IN) :: A
<P>
        CARDINALITY = A % CARD
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION CARDINALITY</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>LOGICAL FUNCTION ELEMENT (X, A)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Determines if
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        INTEGER, INTENT(IN) :: X                ! element X is in set A
<P>
        TYPE (SET), INTENT(IN) :: A
<P>
        ELEMENT = ANY (A % ELEMENT (1 : A % CARD) == X)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION ELEMENT</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>FUNCTION UNION (A, B)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Union of sets A and B
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        TYPE (SET) UNION
<P>
        TYPE (SET), INTENT(IN) :: A, B
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER J</H4>
</A>
<BLOCKQUOTE>
<P>
UNION = A
<P>
DO J = 1, B % CARD
<P>
<PRE>
           IF (.NOT. (B % ELEMENT (J) .IN. A)) THEN
<P>
               IF (UNION % CARD &lt; MAX_SET_CARD) THEN
<P>
                  UNION % CARD = UNION % CARD + 1
<P>
                  UNION % ELEMENT (UNION % CARD) = B % ELEMENT (J)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
! Maximum set size exceeded . . .
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION UNION</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>FUNCTION DIFFERENCE (A, B)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Difference of sets A and B
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
        TYPE (SET) DIFFERENCE
<P>
        TYPE (SET), INTENT(IN) :: A, B
<P>
        INTEGER J, X
<P>
        DIFFERENCE % CARD = 0              ! The empty set
<P>
        DO J = 1, A % CARD
<P>
           X = A % ELEMENT (J)
<P>
           IF (.NOT. (X .IN. B)) DIFFERENCE = DIFFERENCE + SET (1, X)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION DIFFERENCE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>FUNCTION INTERSECTION (A, B)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Intersection of sets A and B
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
575
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
         TYPE (SET) INTERSECTION
<P>
         TYPE (SET), INTENT(IN) :: A, B
<P>
         INTERSECTION = A - (A - B)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION INTERSECTION</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>LOGICAL FUNCTION SUBSET (A, B)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Determines if set A is
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         TYPE (SET), INTENT(IN) :: A, B        ! a subset of set B
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTEGER I</H4>
</A>
<BLOCKQUOTE>
<P>
SUBSET = A % CARD &lt;= B % CARD
<TABLE cellpadding=3><!-- tsb: SUBSET = A % CARD &lt;= B % CARD
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>IF (.NOT. SUBSET) RETURN</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! For efficiency
</TD></TR>
<TR></TR></TABLE>DO I = 1, A % CARD
<P>
<PRE>
            SUBSET = SUBSET .AND. (A % ELEMENT (I) .IN. B)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION SUBSET</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>TYPE (SET) FUNCTION SETF (V)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Transfer function between a vector
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         INTEGER V (:)                  ! of elements and a set of elements
<P>
         INTEGER J                      ! removing duplicate elements
<P>
         SETF % CARD = 0
<P>
         DO J = 1, SIZE (V)
<P>
            IF (.NOT. (V (J) .IN. SETF)) THEN
<P>
                IF (SETF % CARD &lt; MAX_SET_CARD) THEN
<P>
                   SETF % CARD = SETF % CARD + 1
<P>
                   SETF % ELEMENT (SETF % CARD) = V (J)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
! Maximum set size exceeded . . .
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION SETF</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>FUNCTION VECTOR (A)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Transfer the values of set A
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
         TYPE (SET), INTENT (IN) :: A ! into a vector in ascending order
<P>
         INTEGER, POINTER :: VECTOR (:)
<P>
         INTEGER I, J, K
<P>
         ALLOCATE (VECTOR (A % CARD))
<P>
         VECTOR = A % ELEMENT (1 : A % CARD)
<P>
         DO I = 1, A % CARD - 1          ! Use a better sort if
<P>
            DO J = I + 1, A % CARD       ! A % CARD is large
<P>
                IF (VECTOR (I) &gt; VECTOR (J)) THEN
<P>
                   K = VECTOR (J); VECTOR (J) = VECTOR (I); VECTOR (I) = K
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION VECTOR</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE INTEGER_SETS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>576</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                      c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
4 Examples of using INTEGER_SETS (A, B, and C are variables of type SET; X is an integer variable):
</TD></TR>
<TR><TD colspan=2>
<PRE>
           ! Check to see if A has more than 10 elements
<P>
           IF (CARDINALITY (A) &gt; 10) &#46;&#46;&#46;
<P>
           ! Check for X an element of A but not of B
<P>
           IF (X .IN. (A - B)) &#46;&#46;&#46;
<P>
           ! C is the union of A and the result of B intersected
<P>
           ! with the integers 1 to 100
<P>
           C = A + B * SETF ([(I, I = 1, 100)])
<P>
           ! Does A have any even numbers in the range 1:100?
<P>
           IF (CARDINALITY (A * SETF ([(I, I = 2, 100, 2)])) &gt; 0) &#46;&#46;&#46;
<P>
           PRINT *, VECTOR (B) ! Print out the elements of set B, in ascending order
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.9.3.7</B> </TD><TD valign=bottom>
Public entities renamed (14.2.2)
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 At times it might be necessary to rename entities that are accessed with USE statements.
<P>
2 The following example illustrates renaming features of the USE statement.
<P>
<PRE>
           MODULE J; REAL JX, JY, JZ; END MODULE J
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE K</H4>
</A>
<BLOCKQUOTE>
<P>
USE J, ONLY : KX =&gt; JX, KY =&gt; JY
<P>
! KX and KY are local names to module K
<TABLE cellpadding=3><!-- tsb: ! KX and KY are local names to module K
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>REAL KZ</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! KZ is local name to module K
</TD></TR>
<TR valign=top><TD colspan=2>
<B>REAL JZ</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! JZ is local name to module K
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE K</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM RENAME</H4>
</A>
<BLOCKQUOTE>
<P>
USE J; USE K
<P>
! Module J’s entity JX is accessible under names JX and KX
<P>
! Module J’s entity JY is accessible under names JY and KY
<P>
! Module K’s entity KZ is accessible under name KZ
<P>
! Module J’s entity JZ and K’s entity JZ are different entities
<P>
! and cannot be referenced
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM RENAME</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.9.4</B> </TD><TD valign=bottom>
Modules with submodules (14.2.3)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 Each submodule specifies that it is the child of exactly one parent module or submodule. Therefore, a module
<P>
<PRE>
  and all of its descendant submodules stand in a tree-like relationship one to another.
<P>
</PRE>
2 A separate module procedure that is declared in a module to have public accessibility can be accessed by use
<P>
<PRE>
  association even if it is defined in a submodule. No other entity in a submodule can be accessed by use association.
<P>
  Each program unit that references a module by use association depends on it, and each submodule depends on
<P>
  its ancestor module. Therefore, if one changes a separate module procedure body in a submodule but does not
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          577
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  change its corresponding module procedure interface, a tool for automatic program translation would not need
<P>
  to reprocess program units that reference the module by use association. This is so even if the tool exploits the
<P>
  relative modification times of files as opposed to comparing the result of translating the module to the result of
<P>
  a previous translation.
<P>
</PRE>
3 By constructing taller trees, one can put entities at intermediate levels that are shared by submodules at lower
<P>
<PRE>
  levels; changing these entities cannot change the interpretation of anything that is accessible from the module
<P>
  by use association. Developers of modules that embody large complicated concepts can exploit this possibility
<P>
  to organize components of the concept into submodules, while preserving the privacy of entities that are shared
<P>
  by the submodules and that ought not to be exposed to users of the module. Putting these shared entities at an
<P>
  intermediate level also prevents cascades of reprocessing and testing if some of them are changed.
<P>
</PRE>
4 The following example illustrates a module, color_points, with a submodule, color_points_a, that in turn has
<P>
<PRE>
  a submodule, color_points_b. Public entities declared within color_points can be accessed by use association.
<P>
  The submodules color_points_a and color_points_b can be changed without causing retranslation of program
<P>
  units that reference the module color_points.
<P>
</PRE>
5 The module color_points does not have a module-subprogram-part, but a module-subprogram-part is not pro-
<P>
<PRE>
  hibited. The module could be published as definitive specification of the interface, without revealing trade secrets
<P>
  contained within color_points_a or color_points_b. Of course, a similar module without the module prefix in
<P>
  the interface bodies would serve equally well as documentation – but the procedures would be external procedures.
<P>
  It would make little difference to the consumer, but the developer would forfeit all of the advantages of modules.
<P>
           module color_points
<P>
              type color_point
<P>
                private
<P>
                real :: x, y
<P>
                integer :: color
<P>
              end type color_point
<P>
              interface                    ! Interfaces for procedures with separate
<P>
                                           ! bodies in the submodule color_points_a
<P>
                module subroutine color_point_del ( p ) ! Destroy a color_point object
<P>
                  type(color_point), allocatable :: p
<P>
                end subroutine color_point_del
<P>
                ! Distance between two color_point objects
<P>
                real module function color_point_dist ( a, b )
<P>
                  type(color_point), intent(in) :: a, b
<P>
                end function color_point_dist
<P>
                module subroutine color_point_draw ( p ) ! Draw a color_point object
<P>
                  type(color_point), intent(in) :: p
<P>
                end subroutine color_point_draw
<P>
                module subroutine color_point_new ( p ) ! Create a color_point object
<P>
                  type(color_point), allocatable :: p
<P>
                end subroutine color_point_new
<P>
              end interface
<P>
           end module color_points
<P>
  578                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 The only entities within color_points_a that can be accessed by use association are the separate module
<P>
<PRE>
  procedures that were declared in color_points. If the procedures are changed but their interfaces are not, the
<P>
  interface from program units that access them by use association is unchanged. If the module and submodule are
<P>
  in separate files, utilities that examine the time of modification of a file would notice that changes in the module
<P>
  could affect the translation of its submodules or of program units that reference the module by use association,
<P>
  but that changes in submodules could not affect the translation of the parent module or program units that
<P>
  reference it by use association.
<P>
</PRE>
7 The variable instance_count in the following example is not accessible by use association of color_points, but
<P>
<PRE>
  is accessible within color_points_a, and its submodules.
<P>
           submodule ( color_points ) color_points_a ! Submodule of color_points
<P>
              integer :: instance_count = 0
<P>
              interface                           ! Interface for a procedure with a separate
<P>
                                                  ! body in submodule color_points_b
<P>
                module subroutine inquire_palette ( pt, pal )
<P>
                   use palette_stuff              ! palette_stuff, especially submodules thereof,
<P>
                                                  ! can reference color_points by use association
<P>
                                                  ! without causing a circular dependence during
<P>
                                                  ! translation because this use is not in the module.
<P>
                                                  ! Furthermore, changes in the module palette_stuff
<P>
                                                  ! do not affect the translation of color_points.
<P>
                   type(color_point), intent(in) :: pt
<P>
                   type(palette), intent(out) :: pal
<P>
                end subroutine inquire_palette
<P>
              end interface
<P>
           contains ! Invisible bodies for public separate module procedures
<P>
                       ! declared in the module
<P>
              module subroutine color_point_del ( p )
<P>
                type(color_point), allocatable :: p
<P>
                instance_count = instance_count - 1
<P>
                deallocate ( p )
<P>
              end subroutine color_point_del
<P>
              real module function color_point_dist ( a, b ) result ( dist )
<P>
                type(color_point), intent(in) :: a, b
<P>
                dist = SQRT ( (b%x - a%x)**2 + (b%y - a%y)**2 )
<P>
              end function color_point_dist
<P>
              module subroutine color_point_new ( p )
<P>
                type(color_point), allocatable :: p
<P>
                instance_count = instance_count + 1
<P>
                allocate ( p )
<P>
              end subroutine color_point_new
<P>
           end submodule color_points_a
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                           579
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
8 The subroutine inquire_palette is accessible within color_points_a because its interface is declared therein.
<P>
<PRE>
  It is not, however, accessible by use association, because its interface is not declared in the module, color_points.
<P>
  Since the interface is not declared in the module, changes in the interface cannot affect the translation of program
<P>
  units that reference the module by use association.
<P>
            module palette_stuff
<P>
               type :: palette ; &#46;&#46;&#46; ; end type palette
<P>
            contains
<P>
               subroutine test_palette ( p )
<P>
               ! Draw a color wheel using procedures from the color_points module
<P>
                 use color_points ! This does not cause a circular dependency because
<P>
                                      ! the "use palette_stuff" that is logically within
<P>
                                      ! color_points is in the color_points_a submodule.
<P>
                 type(palette), intent(in) :: p
<P>
                 &#46;&#46;&#46;
<P>
               end subroutine test_palette
<P>
            end module palette_stuff
<P>
            submodule ( color_points:color_points_a ) color_points_b ! Subsidiary**2 submodule
<P>
            contains
<P>
               ! Invisible body for interface declared in the ancestor module
<P>
               module subroutine color_point_draw ( p )
<P>
                 use palette_stuff, only: palette
<P>
                 type(color_point), intent(in) :: p
<P>
                 type(palette) :: MyPalette
<P>
                 &#46;&#46;&#46;; call inquire_palette ( p, MyPalette ); ...
<P>
               end subroutine color_point_draw
<P>
               ! Invisible body for interface declared in the parent submodule
<P>
               module procedure inquire_palette
<P>
                 &#46;&#46;&#46; implementation of inquire_palette
<P>
               end procedure inquire_palette
<P>
               subroutine private_stuff ! not accessible from color_points_a
<P>
                 &#46;&#46;&#46;
<P>
               end subroutine private_stuff
<P>
            end submodule color_points_b
<P>
</PRE>
9 There is a use palette_stuff in color_points_a, and a use color_points in palette_stuff. The use
<P>
<PRE>
  palette_stuff would cause a circular reference if it appeared in color_points. In this case, it does not cause
<P>
  a circular dependence because it is in a submodule. Submodules cannot be referenced by use association, and
<P>
  therefore what would be a circular appearance of use palette_stuff is not accessed.
<P>
  580                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
            program main
<P>
               use color_points
<P>
               ! "instance_count" and "inquire_palette" are not accessible here
<P>
               ! because they are not declared in the "color_points" module.
<P>
               ! "color_points_a" and "color_points_b" cannot be referenced by
<P>
               ! use association.
<P>
               interface draw                            ! just to demonstrate it’s possible
<P>
                 module procedure color_point_draw
<P>
               end interface
<P>
               type(color_point) :: C_1, C_2
<P>
               real :: RC
<P>
               &#46;&#46;&#46;
<P>
               call color_point_new (c_1)                ! body in color_points_a, interface in color_points
<P>
               &#46;&#46;&#46;
<P>
               call draw (c_1)                           ! body in color_points_b, specific interface
<P>
                                                         ! in color_points, generic interface here.
<P>
               &#46;&#46;&#46;
<P>
               rc = color_point_dist (c_1, c_2) ! body in color_points_a, interface in color_points
<P>
               &#46;&#46;&#46;
<P>
               call color_point_del (c_1)                ! body in color_points_a, interface in color_points
<P>
               &#46;&#46;&#46;
<P>
            end program main
<P>
</PRE>
10 A multilevel submodule system can be used to package and organize a large and interconnected concept without
<P>
<PRE>
   exposing entities of one subsystem to other subsystems.
<P>
</PRE>
11 Consider a Plasma module from a Tokomak simulator. A plasma simulation requires attention at least to fluid
<P>
<PRE>
   flow, thermodynamics, and electromagnetism. Fluid flow simulation requires simulation of subsonic, supersonic,
<P>
   and hypersonic flow. This problem decomposition can be reflected in the submodule structure of the Plasma
<P>
   module:
<P>
                                                      Plasma module
<P>
                         Flow submodule                  Thermal submodule      Electromagnetics submodule
<P>
               Subsonic     Supersonic    Hypersonic
<P>
             submodule      submodule     submodule
<P>
</PRE>
12 Entities can be shared among the Subsonic, Supersonic, and Hypersonic submodules by putting them within
<P>
<PRE>
   the Flow submodule. One then need not worry about accidental use of these entities by use association or by the
<P>
   Thermal or Electromagnetics submodules, or the development of a dependency of correct operation of those
<P>
   subsystems upon the representation of entities of the Flow subsystem as a consequence of maintenance. Since
<P>
   these entities are not accessible by use association, if any of them are changed, the new values cannot be accessed
<P>
   in program units that reference the Plasma module by use association; the answer to the question “where are
<P>
   these entities used” is therefore confined to the set of descendant submodules of the Flow submodule.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                          581
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.10</B> </TD><TD valign=bottom>
Clause 15 notes
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.10.1</B> </TD><TD valign=bottom>
Portability problems with external procedures (15.4.3.5)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 There is a potential portability problem in a scoping unit that references an external procedure without explicitly
<P>
<PRE>
  declaring it to have the EXTERNAL attribute (8.5.9). On a different processor, the name of that procedure
<P>
  might be the name of a nonstandard intrinsic procedure and in such a case the processor would interpret those
<P>
  procedure references as references to that intrinsic procedure. (On that processor, the program would also be
<P>
  viewed as not conforming to this document because of the references to the nonstandard intrinsic procedure.)
<P>
  Declaration of the EXTERNAL attribute causes the references to be to the external procedure regardless of the
<P>
  availability of an intrinsic procedure with the same name. Note that declaration of the type of a procedure is not
<P>
  enough to make it external, even if the type is inconsistent with the type of the result of an intrinsic procedure
<P>
  of the same name.
<P>
  C.10.2      Procedures defined by means other than Fortran (15.6.3)
<P>
</PRE>
1 A processor is not required to provide any means other than Fortran for defining external procedures. Among the
<P>
<PRE>
  means that might be supported are the machine assembly language, other high level languages, the Fortran lan-
<P>
  guage extended with nonstandard features, and the Fortran language as supported by another Fortran processor
<P>
  (for example, a previously existing Fortran 77 processor). The means other than Fortran for defining external
<P>
  procedures, including any restrictions on the structure or organization of those procedures, are not specified by
<P>
  this document.
<P>
</PRE>
2 A Fortran processor might limit its support of procedures defined by means other than Fortran such that these
<P>
<PRE>
  procedures can affect entities in the Fortran environment only on the same basis as procedures written in Fortran.
<P>
  For example, it might not support the value of a local variable from being changed by a procedure reference unless
<P>
  that variable were one of the arguments to the procedure.
<P>
  C.10.3      Abstract interfaces and procedure pointer components (15.4, 7.5)
<P>
</PRE>
1 This is an example of a library module providing lists of callbacks that the user can register and invoke.
<P>
<PRE>
           MODULE callback_list_module
<P>
              !
<P>
              ! Type for users to extend with their own data, if they so desire
<P>
              !
<P>
              TYPE callback_data
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Abstract interface for the callback procedures
<P>
!
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ABSTRACT INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>callback_procedure</B>(data)
<P>
<PRE>
                   IMPORT callback_data
<P>
                   CLASS(callback_data),OPTIONAL :: data
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
!
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: !
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>582</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                     c ISO/IEC 2017 – All rights reserved
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
! The callback list type.
<P>
!
<P>
TYPE callback_list
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>CLASS</B>(callback_record),POINTER :: first =&gt; <B>NULL</B>()
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Internal: each callback registration creates one of these
<P>
!
<P>
TYPE,PRIVATE :: callback_record
<P>
<PRE>
         PROCEDURE(callback_procedure),POINTER,NOPASS :: proc
<P>
         CLASS(callback_record),POINTER :: next
<P>
         CLASS(callback_data),POINTER :: data =&gt; NULL();
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
PRIVATE invoke,forward_invoke
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Register a callback procedure with optional data
<P>
!
<P>
SUBROUTINE <B>register_callback</B>(list, entry, data)
<P>
<PRE>
         TYPE(callback_list),INTENT(INOUT) :: list
<P>
         PROCEDURE(callback_procedure) :: entry
<P>
         CLASS(callback_data),OPTIONAL :: data
<P>
         TYPE(callback_record),POINTER :: new,last
<P>
         ALLOCATE(new)
<P>
         new%proc =&gt; entry
<P>
         IF (PRESENT(data)) ALLOCATE(new%data,SOURCE=data)
<P>
         new%next =&gt; list%first
<P>
         list%first =&gt; new
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Internal: Invoke a single callback and destroy its record
<P>
!
<P>
SUBROUTINE <B>invoke</B>(callback)
<P>
<PRE>
         TYPE(callback_record),POINTER :: callback
<P>
         IF (ASSOCIATED(callback%data) THEN
<P>
           CALL callback%proc(list%first%data)
<P>
           DEALLOCATE(callback%data)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
CALL callback%proc
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
<B>DEALLOCATE</B>(callback)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Call the procedures in reverse order of registration
<P>
!
</BLOCKQUOTE>
<P>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
583
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
             SUBROUTINE invoke_callback_reverse(list)
<P>
               TYPE(callback_list),INTENT(INOUT) :: list
<P>
               TYPE(callback_record),POINTER :: next,current
<P>
               current =&gt; list%first
<P>
               NULLIFY(list%first)
<P>
               DO WHILE (ASSOCIATED(current))
<P>
                  next =&gt; current%next
<P>
                  CALL invoke(current)
<P>
                  current =&gt; next
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Internal: Forward mode invocation
<P>
!
<P>
SUBROUTINE <B>forward_invoke</B>(callback)
<P>
<PRE>
               IF (ASSOCIATED(callback%next)) CALL forward_invoke(callback%next)
<P>
               CALL invoke(callback)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
!
<P>
! Call the procedures in forward order of registration
<P>
!
<P>
SUBROUTINE <B>invoke_callback_forward</B>(list)
<P>
<PRE>
               TYPE(callback_list),INTENT(INOUT) :: list
<P>
               IF (ASSOCIATED(list%first)) CALL forward_invoke(list%first)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.10.4</B> </TD><TD valign=bottom>
Pointers and targets as arguments (15.5.2.4, 15.5.2.6, 15.5.2.7)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 If a dummy argument is declared to be a pointer, the corresponding actual argument could be a pointer or could
<P>
<PRE>
  be a nonpointer variable or procedure. Consider the two cases separately.
<P>
  Case (i):     The actual argument is a pointer. When procedure execution commences the pointer association
<P>
                status of the dummy argument becomes the same as that of the actual argument. If the pointer
<P>
                association status of the dummy argument is changed, the pointer association status of the actual
<P>
                argument changes in the same way.
<P>
  Case (ii):    The actual argument is not a pointer. This only occurs when the actual argument has the TARGET
<P>
                attribute or is a procedure, and the dummy argument has the INTENT (IN) attribute. The dummy
<P>
                argument becomes pointer associated with the actual argument.
<P>
</PRE>
2 When execution of a procedure completes, any pointer that remains defined and that is associated with a dummy
<P>
<PRE>
  argument that has the TARGET attribute and is either a scalar or an assumed-shape array, remains associated
<P>
  with the corresponding actual argument if the actual argument has the TARGET attribute and is not an array
<P>
  section with a vector subscript.
<P>
  584                                                              ⃝
<P>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
3 For example, consider:
<P>
<PRE>
          REAL, POINTER          :: PBEST
<P>
          REAL, TARGET           :: B (10000)
<P>
          CALL BEST (PBEST, B)                   ! Upon return PBEST is associated
<P>
              &#46;&#46;&#46;                                ! with the ‘‘best’’ element of B
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE BEST (P, A)
<P>
<PRE>
               REAL, POINTER, INTENT (OUT) :: P
<P>
               REAL, TARGET, INTENT (IN)          :: A (:)
<P>
                   &#46;&#46;&#46;                           ! Find the ‘‘best’’ element A(I)
<P>
               P =&gt; A (I)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; RETURN</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE BEST</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
When procedure BEST completes, the pointer PBEST is associated with an element of B.
</BLOCKQUOTE>
<P>
4 An actual argument without the TARGET attribute can become associated with a dummy argument with the
<P>
<PRE>
  TARGET attribute. This enables a pointer to become associated with the dummy argument during execution of
<P>
  the procedure that contains the dummy argument. For example:
<P>
          INTEGER LARGE(100,100)
<P>
          CALL SUB (LARGE)
<P>
              &#46;&#46;&#46;
<P>
          CALL SUB ()
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>SUB</B>(ARG)
<P>
<PRE>
               INTEGER, TARGET, OPTIONAL :: ARG(100,100)
<P>
               INTEGER, POINTER, DIMENSION(:,:) :: PARG
<P>
               IF (PRESENT(ARG)) THEN
<P>
                  PARG =&gt; ARG
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
ALLOCATE (PARG(100,100))
<P>
PARG = 0
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ENDIF</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46; ! Code with lots of references to PARG
</BLOCKQUOTE>
<P>
IF (.NOT. <B>PRESENT</B>(ARG)) <B>DEALLOCATE</B>(PARG)
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SUB</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END</H4>
</A>
<BLOCKQUOTE>
<P>
Within subroutine SUB the pointer PARG is either associated with the dummy argument ARG or it is associated
<P>
with an allocated target. The bulk of the code can reference PARG without further calls to the intrinsic function
<P>
PRESENT.
</BLOCKQUOTE>
<P>
5 If a nonpointer dummy argument has the TARGET attribute and the corresponding actual argument does not,
<P>
<PRE>
  any pointers that become associated with the dummy argument, and therefore with the actual argument, during
<P>
  execution of the procedure, become undefined when execution of the procedure completes.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                       585
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
  C.10.5     Polymorphic Argument Association (15.5.2.9)
<P>
</PRE>
1 The following example illustrates the polymorphic argument association rules using the derived types defined in
<P>
<PRE>
  NOTE 7.55.
<P>
           TYPE(POINT) :: T2
<P>
           TYPE(COLOR_POINT) :: T3
<P>
           CLASS(POINT) :: P2
<P>
           CLASS(COLOR_POINT) :: P3
<P>
           ! Dummy argument is polymorphic and actual argument is of fixed type
<P>
           SUBROUTINE SUB2 ( X2 ); CLASS(POINT) :: X2; &#46;&#46;&#46;
<P>
           SUBROUTINE SUB3 ( X3 ); CLASS(COLOR_POINT) :: X3; &#46;&#46;&#46;
<P>
           CALL SUB2 ( T2 ) ! Valid -- The declared type of T2 is the same as the
<P>
                               !            declared type of X2.
<P>
           CALL SUB2 ( T3 ) ! Valid -- The declared type of T3 is extended from
<P>
                               !            the declared type of X2.
<P>
           CALL SUB3 ( T2 ) ! Invalid -- The declared type of T2 is neither the
<P>
                               !            same as nor extended from the declared type
<P>
                               !            type of X3.
<P>
           CALL SUB3 ( T3 ) ! Valid -- The declared type of T3 is the same as the
<P>
                               !            declared type of X3.
<P>
           ! Actual argument is polymorphic and dummy argument is of fixed type
<P>
           SUBROUTINE TUB2 ( D2 ); TYPE(POINT) :: D2; &#46;&#46;&#46;
<P>
           SUBROUTINE TUB3 ( D3 ); TYPE(COLOR_POINT) :: D3; &#46;&#46;&#46;
<P>
           CALL TUB2 ( P2 ) ! Valid -- The declared type of P2 is the same as the
<P>
                               !            declared type of D2.
<P>
           CALL TUB2 ( P3 ) ! Invalid -- The declared type of P3 differs from the
<P>
                               !            declared type of D2.
<P>
           CALL TUB2 ( P3%POINT ) ! Valid alternative to the above
<P>
           CALL TUB3 ( P2 ) ! Invalid -- The declared type of P2 differs from the
<P>
                               !            declared type of D3.
<P>
           SELECT TYPE ( P2 ) ! Valid conditional alternative to the above
<P>
           CLASS IS ( COLOR_POINT ) ! Works if the dynamic type of P2 is the same
<P>
             CALL TUB3 ( P2 )           ! as the declared type of D3, or a type
<P>
                                        ! extended therefrom.
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; CLASS DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
! Cannot work if not.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
CALL TUB3 ( P3 ) ! Valid -- The declared type of P3 is the same as the
<P>
<PRE>
                               !            declared type of D3.
<P>
</PRE>
! Both the actual and dummy arguments are of polymorphic type.
<P>
CALL SUB2 ( P2 ) ! Valid -- The declared type of P2 is the same as the
<P>
<PRE>
                               !            declared type of X2.
<P>
</PRE>
CALL SUB2 ( P3 ) ! Valid -- The declared type of P3 is extended from
<P>
<PRE>
                               !            the declared type of X2.
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>586</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
CALL SUB3 ( P2 ) ! Invalid -- The declared type of P2 is neither the
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                 !             same as nor extended from the declared
<P>
                                 !             type of X3.
<P>
</PRE>
SELECT TYPE ( P2 ) ! Valid conditional alternative to the above
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
CLASS IS ( COLOR_POINT ) ! Works if the dynamic type of P2 is the
<P>
<PRE>
              CALL SUB3 ( P2 )             ! same as the declared type of X3, or a
<P>
                                           ! type extended therefrom.
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; CLASS DEFAULT</H4>
</A>
<BLOCKQUOTE>
<P>
! Cannot work if not.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SELECT</H4>
</A>
<BLOCKQUOTE>
<P>
CALL SUB3 ( P3 ) ! Valid -- The declared type of P3 is the same as the
<P>
<PRE>
                                 !             declared type of X3.
<P>
</PRE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.10.6</B> </TD><TD valign=bottom>
Rules ensuring unambiguous generics (15.4.3.4.5)
<P>
1 The rules in 15.4.3.4.5 are intended to ensure
<P>
<PRE>
      • that it is possible to reference each specific procedure or binding in the generic collection,
<P>
      • that for any valid generic procedure reference, the determination of the specific procedure referenced is
<P>
         unambiguous, and
<P>
      • that the determination of the specific procedure or binding referenced can be made before execution of the
<P>
         program begins (during compilation).
<P>
</PRE>
2 Interfaces of specific procedures or bindings are distinguished by fixed properties of their arguments, specifically
<P>
<PRE>
  type, kind type parameters, rank, and whether the dummy argument has the POINTER or ALLOCATABLE
<P>
  attribute. A valid reference to one procedure in a generic collection will differ from another because it has an
<P>
  argument that the other cannot accept, because it is missing an argument that the other requires, or because one
<P>
  of these fixed properties is different.
<P>
</PRE>
3 Although the declared type of a data entity is a fixed property, polymorphic variables allow for a limited degree
<P>
<PRE>
  of type mismatch between dummy arguments and actual arguments, so the requirement for distinguishing two
<P>
  dummy arguments is type incompatibility, not merely different types. (This is illustrated in the BAD6 example
<P>
  later in this note.)
<P>
</PRE>
4 That same limited type mismatch means that two dummy arguments that are not type incompatible can be
<P>
<PRE>
  distinguished on the basis of the values of the kind type parameters they have in common; if one of them has a
<P>
  kind type parameter that the other does not, that is irrelevant in distinguishing them.
<P>
</PRE>
5 Rank is a fixed property, but some forms of array dummy arguments allow rank mismatches when a procedure is
<P>
<PRE>
  referenced by its specific name. In order to allow rank to always be usable in distinguishing generics, such rank
<P>
  mismatches are disallowed for those arguments when the procedure is referenced as part of a generic. Additionally,
<P>
  the fact that elemental procedures can accept array arguments is not taken into account when applying these rules,
<P>
  so apparent ambiguity between elemental and nonelemental procedures is possible; in such cases, the reference is
<P>
  interpreted as being to the nonelemental procedure.
<P>
</PRE>
6 For procedures referenced as operators or defined-assignment, syntactically distinguished arguments are mapped
<P>
<PRE>
  to specific positions in the argument list, so the rule for distinguishing such procedures is that it be possible to
<P>
  distinguish the arguments at one of the argument positions.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          587
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
7 For defined input/output procedures, only the dtv argument corresponds to something explicitly written in the
<P>
<PRE>
   program, so it is the dtv that is required to be distinguished. Because dtv arguments are required to be scalar,
<P>
   they cannot differ in rank. Thus this rule effectively involves only type and kind type parameters.
<P>
</PRE>
8 For generic procedure names, the rules are more complicated because optional arguments can be omitted and
<P>
<PRE>
   because arguments can be specified either positionally or by name.
<P>
</PRE>
9 In the special case of type-bound procedures with passed-object dummy arguments, the passed-object argument
<P>
<PRE>
   is syntactically distinguished in the reference, so rule (3) in 15.4.3.4.5 can be applied. The type of passed-object
<P>
   arguments is constrained in ways that prevent passed-object arguments in the same scoping unit from being type
<P>
   incompatible. Thus this rule effectively involves only kind type parameters and rank.
<P>
</PRE>
10 The primary means of distinguishing named generics is rule (4). The most common application of that rule is a
<P>
<PRE>
   single argument satisfying both (4a) and (4b):
<P>
            INTERFACE GOOD1
<P>
               FUNCTION F1A(X)
<P>
                 REAL :: F1A,X
<P>
               END FUNCTION F1A
<P>
               FUNCTION F1B(X)
<P>
                 INTEGER :: F1B,X
<P>
               END FUNCTION F1B
<P>
            END INTERFACE GOOD1
<P>
</PRE>
11 Whether one writes <B>GOOD1</B>(1.0) or <B>GOOD1</B>(X=1.0), the reference is to F1A because F1B would require an integer
<P>
<PRE>
   argument whereas these references provide the real constant 1.0.
<P>
</PRE>
12 This example and those that follow are expressed using interface bodies, with type as the distinguishing property.
<P>
<PRE>
   This was done to make it easier to write and describe the examples. The principles being illustrated are equally
<P>
   applicable when the procedures get their explicit interfaces in some other way or when kind type parameters or
<P>
   rank are the distinguishing property.
<P>
</PRE>
13 Another common variant is the argument that satisfies (4a) and (4b) by being required in one specific and
<P>
<PRE>
   completely missing in the other:
<P>
            INTERFACE GOOD2
<P>
               FUNCTION F2A(X)
<P>
                 REAL :: F2A,X
<P>
               END FUNCTION F2A
<P>
               FUNCTION F2B(X,Y)
<P>
                 COMPLEX :: F2B
<P>
                 REAL :: X,Y
<P>
               END FUNCTION F2B
<P>
            END INTERFACE GOOD2
<P>
</PRE>
14 Whether one writes <B>GOOD2</B>(0.0,1.0), <B>GOOD2</B>(0.0,Y=1.0), or <B>GOOD2</B>(Y=1.0,X=0.0), the reference is to F2B,
<P>
<PRE>
   because F2A has no argument in the second position or with the name Y. This approach is used as an alternative
<P>
   to optional arguments when one wants a function to have different result type, kind type parameters, or rank,
<P>
   depending on whether the argument is present. In many of the intrinsic functions, the DIM argument works this
<P>
   way.
<P>
   588                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
15 It is possible to construct cases where different arguments are used to distinguish positionally and by name:
<P>
<PRE>
            INTERFACE GOOD3
<P>
               SUBROUTINE S3A(W,X,Y,Z)
<P>
                  REAL :: W,Y
<P>
                  INTEGER :: X,Z
<P>
               END SUBROUTINE S3A
<P>
               SUBROUTINE S3B(X,W,Z,Y)
<P>
                  REAL :: W,Z
<P>
                  INTEGER :: X,Y
<P>
               END SUBROUTINE S3B
<P>
            END INTERFACE GOOD3
<P>
</PRE>
16 If one writes <B>GOOD3</B>(1.0,2,3.0,4) to reference S3A, then the third and fourth arguments are consistent with a
<P>
<PRE>
   reference to S3B, but the first and second are not. If one switches to writing the first two arguments as keyword
<P>
   arguments in order for them to be consistent with a reference to S3B, the latter two arguments will also need
<P>
   to be written as keyword arguments, GOOD3(X=2,W=1.0,Z=4,Y=3.0), and the named arguments Y and Z are
<P>
   distinguished.
<P>
</PRE>
17 The ordering requirement in rule (4) is critical:
<P>
<PRE>
            INTERFACE BAD4 ! this interface is invalid !
<P>
               SUBROUTINE S4A(W,X,Y,Z)
<P>
                  REAL :: W,Y
<P>
                  INTEGER :: X,Z
<P>
               END SUBROUTINE S4A
<P>
               SUBROUTINE S4B(X,W,Z,Y)
<P>
                  REAL :: X,Y
<P>
                  INTEGER :: W,Z
<P>
               END SUBROUTINE S4B
<P>
            END INTERFACE BAD4
<P>
</PRE>
18 In this example, the positionally distinguished arguments are Y and Z, and it is W and X that are distinguished by
<P>
<PRE>
   name. In this order it is possible to write BAD4(1.0,2,Y=3.0,Z=4), which is a valid reference for both S4A and
<P>
   S4B.
<P>
</PRE>
19 Rule (1) can be used to distinguish some cases that are not covered by rule (4):
<P>
<PRE>
            INTERFACE GOOD5
<P>
               SUBROUTINE S5A(X)
<P>
                  REAL :: X
<P>
               END SUBROUTINE S5A
<P>
               SUBROUTINE S5B(Y,X)
<P>
                  REAL :: Y,X
<P>
               END SUBROUTINE S5B
<P>
            END INTERFACE GOOD5
<P>
</PRE>
20 In attempting to apply rule (4), position 2 and name Y are distinguished, but they are in the wrong order, just like
<P>
<PRE>
   the BAD4 example. However, when we try to construct a similarly ambiguous reference, we get GOOD5(1.0,X=2.0),
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                         589
<P>
<P>
   ISO/IEC DIS 1539-1:2017 (E)
<P>
   which can’t be a reference to S5A because it would be attempting to associate two different actual arguments
<P>
   with the dummy argument X. Rule (4) catches this case by recognizing that S5B requires two real arguments, and
<P>
   S5A cannot possibly accept more than one.
<P>
</PRE>
21 The application of rule (1) becomes more complicated when extensible types are involved. If FRUIT is an extensible
<P>
<PRE>
   type, PEAR and APPLE are extensions of FRUIT, and BOSC is an extension of PEAR, then
<P>
            INTERFACE BAD6 ! this interface is invalid !
<P>
               SUBROUTINE S6A(X,Y)
<P>
                 CLASS(PEAR) :: X,Y
<P>
               END SUBROUTINE S6A
<P>
               SUBROUTINE S6B(X,Y)
<P>
                 CLASS(FRUIT) :: X
<P>
                 CLASS(BOSC) :: Y
<P>
               END SUBROUTINE S6B
<P>
            END INTERFACE BAD6
<P>
   might, at first glance, seem distinguishable this way, but because of the limited type mismatching allowed,
<P>
   BAD6(A_PEAR,A_BOSC) is a valid reference to both S6A and S6B.
<P>
</PRE>
22 It is important to try rule (1) for each type that appears:
<P>
<PRE>
            INTERFACE GOOD7
<P>
               SUBROUTINE S7A(X,Y,Z)
<P>
                 CLASS(PEAR) :: X,Y,Z
<P>
               END SUBROUTINE S7A
<P>
               SUBROUTINE S7B(X,Z,W)
<P>
                 CLASS(FRUIT) :: X
<P>
                 CLASS(BOSC) :: Z
<P>
                 CLASS(APPLE),OPTIONAL :: W
<P>
               END SUBROUTINE S7B
<P>
            END INTERFACE GOOD7
<P>
</PRE>
23 Looking at the most general type, S7A has a minimum and maximum of 3 FRUIT arguments, while S7B has a
<P>
<PRE>
   minimum of 2 and a maximum of three. Looking at the most specific, S7A has a minimum of 0 and a maximum
<P>
   of 3 BOSC arguments, while S7B has a minimum of 1 and a maximum of 2. However, when we look at the
<P>
   intermediate, S7A has a minimum and maximum of 3 PEAR arguments, while S7B has a minimum of 1 and a
<P>
   maximum of 2. Because S7A’s minimum exceeds S7B’s maximum, they can be distinguished.
<P>
</PRE>
24 In identifying the minimum number of arguments with a particular set of properties, we exclude optional argu-
<P>
<PRE>
   ments and test TKR compatibility, so the corresponding actual arguments are required to have those properties.
<P>
   In identifying the maximum number of arguments with those properties, we include the optional arguments and
<P>
   test not distinguishable, so we include actual arguments which could have those properties but are not required
<P>
   to have them.
<P>
</PRE>
25 These rules are sufficient to ensure that references to procedures that meet them are unambiguous, but there
<P>
<PRE>
   remain examples that fail to meet these rules but which can be shown to be unambiguous:
<P>
            INTERFACE BAD8 ! this interface is invalid !
<P>
               ! despite the fact that it is unambiguous !
<P>
   590                                                             ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
               SUBROUTINE S8A(X,Y,Z)
<P>
                 REAL,OPTIONAL :: X
<P>
                 INTEGER :: Y
<P>
                 REAL :: Z
<P>
               END SUBROUTINE S8A
<P>
               SUBROUTINE S8B(X,Z,Y)
<P>
                 INTEGER,OPTIONAL :: X
<P>
                 INTEGER :: Z
<P>
                 REAL :: Y
<P>
               END SUBROUTINE S8B
<P>
            END INTERFACE BAD8
<P>
</PRE>
26 This interface fails rule (4) because there are no required arguments that can be distinguished from the positionally
<P>
<PRE>
   corresponding argument, but in order for the mismatch of the optional arguments not to be relevant, the later
<P>
   arguments need to be specified as keyword arguments, so distinguishing by name does the trick. This interface is
<P>
   nevertheless invalid so a standard-conforming Fortran processor is not required to do such reasoning. The rules
<P>
   to cover all cases are too complicated to be useful.
<P>
</PRE>
27 If one dummy argument has the POINTER attribute and a corresponding argument in the other interface body
<P>
<PRE>
   has the ALLOCATABLE attribute the generic interface is not ambiguous. If one dummy argument has either the
<P>
   POINTER or ALLOCATABLE attribute and a corresponding argument in the other interface body has neither
<P>
   attribute, the generic interface might be ambiguous.
<P>
   C.11        Clause 16 notes
<P>
   C.11.1      Atomic memory consistency
<P>
   C.11.1.1    Relaxed memory model
<P>
</PRE>
1 Parallel programs sometimes have apparently impossible behavior because data transfers and other messages can
<P>
<PRE>
   be delayed, reordered and even repeated, by hardware, communication software, and caching and other forms
<P>
   of optimization. Requiring processors to deliver globally consistent behavior is incompatible with performance
<P>
   on many systems. This document specifies that all ordered actions will be consistent (5.3.5 and 11.6), but all
<P>
   consistency between unordered segments is deliberately left processor dependent. Depending on the hardware,
<P>
   this can be observed even when only two images and one mechanism are involved.
<P>
   C.11.1.2    Examples with atomic operations
<P>
</PRE>
1 When variables are being referenced (atomically) from segments that are unordered with respect to the segment
<P>
<PRE>
   that is atomically defining or redefining the variables, the results are processor dependent. This supports use
<P>
   of so-called “relaxed memory model” architectures, which can enable more efficient execution on some hardware
<P>
   implementations.
<P>
</PRE>
2 The following examples assume these declarations:
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; MODULE EXAMPLE</H4>
</A>
<BLOCKQUOTE>
<P>
USE,INTRINSIC :: ISO_FORTRAN_ENV
<P>
<B>INTEGER</B>(ATOMIC_INT_KIND) :: X [*] = 0, Y [*] = 0, TMP
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <B>INTEGER</B>(ATOMIC_INT_KIND) :: X [*] = 0, Y [*] = 0, TMP
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
591
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
</TD></TR>
<TR></TR></TABLE>3 Example 1
<P>
<PRE>
  With X [j] and Y [j] still in their initial state (both zero), image j executes the following sequence of statements:
<P>
           CALL ATOMIC_DEFINE (X, 1)
<P>
           CALL ATOMIC_DEFINE (Y, 1)
<P>
  and a different image, k, executes the following sequence of statements:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; DO</H4>
</A>
<BLOCKQUOTE>
<P>
CALL ATOMIC_REF (TMP, Y [j ])
<P>
IF (TMP==1) EXIT
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
CALL ATOMIC_REF (TMP, X [j ])
<P>
PRINT *, TMP
</BLOCKQUOTE>
<P>
4 The final value of TMP on image k could be either 0 or 1. That is, even though image j thinks that it defined X
<P>
<PRE>
  [j] before it defined Y [j], this ordering is not guaranteed to be observed on image k. There are many aspects of
<P>
  hardware and software implementation that can cause this effect, but conceptually this example can be thought
<P>
  of as the change in the value of Y propagating faster through the inter-image connections than the change in the
<P>
  value of X.
<P>
</PRE>
5 Even if image j executed the sequence
<P>
<PRE>
           CALL ATOMIC_DEFINE (X, 1)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; SYNC MEMORY</H4>
</A>
<BLOCKQUOTE>
<P>
CALL ATOMIC_DEFINE (Y, 1)
</BLOCKQUOTE>
<P>
the same effect could be seen. That is because even though X and Y are defined in ordered segments, the
<BLOCKQUOTE>
<P>
references from image k are both from a segment that is unordered with respect to image j.
</BLOCKQUOTE>
<P>
6 Only if the reference on image k to Y [j] is in a segment that is ordered after the segment on image j that defined
<P>
<PRE>
  Y, will TMP be guaranteed to have the value 1.
<P>
</PRE>
7 Example 2:
<P>
<PRE>
  With the initial state of X and Y on image j (i.e. X [j] and Y [j]) still being zero, execution of
<P>
           CALL ATOMIC_REF (TMP, X [j ])
<P>
           CALL ATOMIC_DEFINE (Y [j ], 1)
<P>
           PRINT *, TMP
<P>
  on image k1 , and execution of
<P>
           CALL ATOMIC_REF (TMP, Y [j ])
<P>
           CALL ATOMIC_DEFINE (X [j ], 1)
<P>
           PRINT *, TMP
<P>
  on image k2 , in unordered segments, might print the value 1 both times.
<P>
</PRE>
8 This can happen by such mechanisms as “load buffering”; one might imagine that what is happening is that
<P>
<PRE>
  the definitions (ATOMIC_DEFINE) are overtaking the references (ATOMIC_REF). On some processors it is
<P>
  592                                                                  ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
   possible that insertion of SYNC MEMORY statements between the calls to ATOMIC_REF and ATOMIC_-
<P>
   DEFINE might be sufficient to make the output print the value 1 at most one time (or even exactly one time),
<P>
   but this is still processor dependent unless the SYNC MEMORY statement executions cause the relevant segments
<P>
   on images k1 and k2 to be ordered.
<P>
</PRE>
9 Example 3:
<P>
<PRE>
   Because there are no segment boundaries implied by collective subroutines, with the initial state as before,
<P>
   execution of
<P>
            IF (THIS_IMAGE ()==1) THEN
<P>
               CALL ATOMIC_DEFINE (X [3], 23)
<P>
               Y = 42
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
CALL CO_BROADCAST (Y, 1)
<P>
IF (THIS_IMAGE ()==2) THEN
<P>
<PRE>
               CALL ATOMIC_REF (TMP, X [3])
<P>
               PRINT *, Y, TMP
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
could print the values 42 and 0.
</BLOCKQUOTE>
<P>
10 Example 4:
<P>
<PRE>
   Assuming the declarations
<P>
            INTEGER (ATOMIC_INT_KIND) :: X [*] = 0, Z = 0
<P>
   the statements
<P>
            CALL ATOMIC_ADD (X [1], 1)                 ! (A)
<P>
            IF (THIS_IMAGE() == 2) THEN
<P>
               wait: DO
<P>
                     CALL ATOMIC_REF (Z, X [1])        ! (B)
<P>
                     IF (Z == NUM_IMAGES ()) EXIT wait
<P>
               END DO wait                             ! (C)
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
will execute the “wait” loop on image 2 until all images have completed statement (A). The updates of X [1] are
<P>
performed by each image in the same manner, but in an arbitrary order. Because the result from the complete
<P>
set of updates will eventually become visible by execution of statement (B) for some loop iteration on image 2,
<P>
the termination condition is guaranteed to be eventually fulfilled, provided that no image failure occurs, every
<P>
image executes the above code, and no other code is executed in an unordered segment that performs an update
<P>
to X [1]. Furthermore, if two SYNC MEMORY statements are inserted in the above code before statement (A)
<P>
and after statement (C), respectively, the segment started by the second SYNC MEMORY on image 2 is ordered
<P>
after the segments on all images that end with the first SYNC MEMORY.
<TABLE cellpadding=3><!-- tsb: after the segments on all images that end with the first SYNC MEMORY.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.11.2</B> </TD><TD valign=bottom>
EVENT_QUERY example
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The following example illustrates the use of events via a program in which image 1 acts as the master image,
<P>
<PRE>
   distributing work items to the other images. Only one work item at a time can be active on a worker image, and
<P>
   each deals with the result (e.g. via input/output) without directly feeding data back to the master image.
<P>
   ⃝c ISO/IEC 2017 – All rights reserved                                                                       593
<P>
<P>
</PRE>
ISO/IEC DIS 1539-1:2017 (E)
<BLOCKQUOTE>
<P>
2 Because the work items are not expected to be balanced, the master keeps cycling through all images to find one
<P>
<PRE>
  that is waiting for work.
<P>
</PRE>
3 An event is posted by each worker to indicate that it has completed its work item. Since the corresponding
<P>
<PRE>
  variables are needed only on the master, we place them in an allocatable array component of a coarray. An event
<P>
  on each worker is needed for the master to post the fact that it has made a work item available for it.
<P>
  Example code:
<P>
           PROGRAM work_share
<P>
             USE, INTRINSIC :: ISO_FORTRAN_ENV,        ONLY: EVENT_TYPE
<P>
             USE :: mod_work, ONLY:                    & ! Module that creates work items
<P>
                                 work,                 & ! Type for holding a work item
<P>
                                 create_work_item,     & ! Function that creates work item
<P>
                                 process_item,         & ! Function that processes an item
<P>
                                 work_done               ! Logical function that returns true
<P>
                                                         ! if all work has been done.
<P>
             TYPE :: worker_type
<P>
                TYPE (EVENT_TYPE), ALLOCATABLE ::       free (:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>TYPE (EVENT_TYPE) :: submit [*]</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Post when work ready for a worker
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TYPE (worker_type) :: worker [*]</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Post when worker is free
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TYPE (work)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: work_item [*]    ! Holds the data for a work item
</TD></TR>
<TR></TR></TABLE>INTEGER :: count, i, nbusy [*]
<P>
IF (THIS_IMAGE ()==1) THEN
<P>
<PRE>
                ! Get started
<P>
                ALLOCATE (worker%free (2:NUM_IMAGES ()))
<P>
                nbusy = 0 ! This holds the number of workers working
<P>
                DO i = 2, NUM_IMAGES () ! Start the workers working
<P>
                  IF (work_done ()) EXIT
<P>
                  nbusy = nbusy + 1
<P>
                  work_item [i] = create_work_item ()
<P>
                  EVENT POST (submit [i])
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
! Main work distribution loop
</BLOCKQUOTE>
<P>
master: DO
<P>
<PRE>
          image: DO i = 2, NUM_IMAGES ()
<P>
                     CALL EVENT_QUERY (worker%free (i), count)
<P>
                     IF (count==0) CYCLE image ! Worker is not free
<P>
                     EVENT WAIT (worker%free (i))
<P>
                     nbusy = nbusy - 1
<P>
                     IF (work_done ()) CYCLE
<P>
                     nbusy = nbusy + 1
<P>
                     work_item [i] = create_work_item ()
<P>
                     EVENT POST (submit [i])
<P>
                  END DO image
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>594</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                        ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
IF (nbusy==0) THEN
<P>
<PRE>
                    ! All done. Exit on all images.
<P>
                    DO i = 2, NUM_IMAGES ()
<P>
                      EVENT POST (submit [i])
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END DO</H4>
</A>
<BLOCKQUOTE>
<P>
EXIT master
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
END DO master
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
! Work processing loop
</BLOCKQUOTE>
<P>
worker: DO
<P>
<PRE>
                  EVENT WAIT (submit)
<P>
                  IF (nbusy[1] == 0) EXIT
<P>
                  CALL process_item (work_item)
<P>
                  EVENT POST (worker [1]%free (THIS_IMAGE ()))
<P>
</PRE>
END DO worker
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
END PROGRAM work_share
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END PROGRAM work_share
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.11.3</B> </TD><TD valign=bottom>
Collective subroutine examples
<P>
1 The following example computes a dot product of two scalar coarrays using CO_SUM to store the result in a
<P>
<PRE>
  noncoarray scalar variable.
<P>
          SUBROUTINE codot (x, y, x_dot_y)
<P>
              REAL :: x [*], y [*], x_dot_y
<P>
              x_dot_y = x*y
<P>
              CALL CO_SUM (x_dot_y)
<P>
          END SUBROUTINE codot
<P>
</PRE>
2 The function below demonstrates passing a noncoarray dummy argument to CO_MAX. The function uses CO_-
<P>
<PRE>
  MAX to find the maximum value of the dummy argument across all images. Then the function flags all images
<P>
  that hold values matching the maximum. The function then returns the maximum image index for an image that
<P>
  holds the maximum value.
<P>
          FUNCTION find_max (j) RESULT (j_max_location)
<P>
             INTEGER, INTENT (IN) :: j
<P>
             INTEGER j_max, j_max_location
<P>
             j_max = j
<P>
             CALL CO_MAX (j_max)
<P>
             ! Flag images that hold the maximum j.
<P>
             IF (j==j_max) THEN
<P>
                j_max_location = THIS_IMAGE ()
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; ELSE</H4>
</A>
<BLOCKQUOTE>
<P>
j_max_location = 0
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
! Return highest image index associated with a maximal j.
<P>
CALL <B>CO_MAX</B>(j_max_location)
</BLOCKQUOTE>
<P>
END FUNCTION find_max
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END FUNCTION find_max
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
595
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.12</B> </TD><TD valign=bottom>
Clause 18 notes
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.12.1</B> </TD><TD valign=bottom>
Runtime environments (18.1)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 This document allows programs to contain procedures defined by means other than Fortran. That raises the
<P>
<PRE>
  issues of initialization of and interaction between the runtime environments involved.
<P>
</PRE>
2 Implementations are free to solve these issues as they see fit, provided that
<P>
<PRE>
      • heap allocation/deallocation (e.g., (DE)ALLOCATE in a Fortran subprogram and malloc/free in a C func-
<P>
        tion) can be performed without interference,
<P>
      • input/output to and from external files can be performed without interference, as long as procedures defined
<P>
        by different means do not do input/output with the same external file,
<P>
      • input/output preconnections exist as required by the respective standards, and
<P>
      • initialized data are initialized according to the respective standards.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.12.2</B> </TD><TD valign=bottom>
Example of Fortran calling C (18.3)
</TD></TR>
<TR></TR></TABLE>C Function Prototype:
<P>
<PRE>
           int C_Library_Function(void* sendbuf, int sendcount, int *recvcounts);
<P>
</PRE>
Fortran Module:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MODULE CLIBFUN_INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER (C_INT) FUNCTION C_LIBRARY_FUNCTION (SENDBUF, SENDCOUNT, RECVCOUNTS) &
<P>
<PRE>
                                        BIND(C, NAME=’C_Library_Function’)
<P>
</PRE>
USE, INTRINSIC :: ISO_C_BINDING
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (C_PTR), VALUE :: SENDBUF
<P>
INTEGER (C_INT), VALUE :: SENDCOUNT
<P>
INTEGER (C_INT) :: <B>RECVCOUNTS</B>(*)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION C_LIBRARY_FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END MODULE CLIBFUN_INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
1 The module CLIBFUN_INTERFACE contains the declaration of the Fortran dummy arguments, which corres-
<P>
<PRE>
  pond to the C formal parameters. The NAME= is used in the BIND attribute in order to handle the case-sensitive
<P>
  name change between Fortran and C from “c_library_function” to “C_Library_Function”.
<P>
</PRE>
2 The first C formal parameter is the pointer to void sendbuf, which corresponds to the Fortran dummy argument
<P>
<PRE>
  SENDBUF, which has the type C_PTR and the VALUE attribute.
<P>
</PRE>
3 The second C formal parameter is the int sendcount, which corresponds to the Fortran dummy argument
<P>
<PRE>
  SENDCOUNT, which has the type INTEGER (C_INT) and the VALUE attribute.
<P>
</PRE>
4 The third C formal parameter is the pointer to int recvcounts, which corresponds to the Fortran dummy
<P>
<PRE>
  argument RECVCOUNTS, which is an assumed-size array of type INTEGER (C_INT).
<P>
  596                                                                 ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
5 This example shows how C_Library_Function might be referenced in a Fortran program unit:
<P>
<PRE>
           USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT, C_FLOAT, C_LOC
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE CLIBFUN_INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
<P>
REAL (C_FLOAT), TARGET :: <B>SEND</B>(100)
<TABLE cellpadding=3><!-- tsb: REAL (C_FLOAT), TARGET :: <B>SEND</B>(100)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>INTEGER (C_INT)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: SENDCOUNT, RET
</TD></TR>
<TR></TR></TABLE>INTEGER (C_INT), ALLOCATABLE :: <B>RECVCOUNTS</B>(:)
<P>
&#46;&#46;&#46;
<P>
<B>ALLOCATE</B>( <B>RECVCOUNTS</B>(100) )
<P>
&#46;&#46;&#46;
<P>
RET = <B>C_LIBRARY_FUNCTION</B>(C_LOC(SEND), SENDCOUNT, RECVCOUNTS)
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
6 The first Fortran actual argument is a reference to the function C_LOC which returns the value of the C address
<P>
<PRE>
  of its argument, SEND. This value becomes the value of the first formal parameter, the pointer sendbuf, in
<P>
  C_Library_Function.
<P>
</PRE>
7 The second Fortran actual argument is SENDCOUNT of type INTEGER (C_INT). Its value becomes the initial
<P>
<PRE>
  value of the second formal parameter, the int sendcount, in C_Library_Function.
<P>
</PRE>
8 The third Fortran actual argument is the allocatable array RECVCOUNTS of type INTEGER (C_INT). The
<P>
<PRE>
  base C address of this array becomes the value of the third formal parameter, the pointer recvcounts, in
<P>
  C_Library_Function. Note that interoperability is based on the characteristics of the dummy arguments in
<P>
  the specified interface and not on those of the actual arguments. Thus, the fact that the actual argument is
<P>
  allocatable is not relevant here.
<P>
  C.12.3      Example of C calling Fortran (18.3)
<P>
  Fortran Code:
<P>
           SUBROUTINE SIMULATION(ALPHA, BETA, GAMMA, DELTA, ARRAYS) BIND(C)
<P>
               USE, INTRINSIC :: ISO_C_BINDING
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTEGER (C_LONG), VALUE</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: ALPHA
</TD></TR>
<TR valign=top><TD colspan=2>
<B>REAL (C_DOUBLE), </B><B>INTENT</B>(INOUT) </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: BETA
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INTEGER (C_LONG), </B><B>INTENT</B>(OUT) </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: GAMMA
</TD></TR>
<TR></TR></TABLE>REAL (C_DOUBLE),<B>DIMENSION</B>(*),<B>INTENT</B>(IN) :: DELTA
<P>
TYPE, <B>BIND</B>(C) :: PASS
<P>
<PRE>
                 INTEGER (C_INT) :: LENC, LENF
<P>
                 TYPE (C_PTR)       :: C, F
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE PASS</H4>
</A>
<BLOCKQUOTE>
<P>
TYPE (PASS), <B>INTENT</B>(INOUT) :: ARRAYS
<P>
REAL (C_FLOAT), ALLOCATABLE, TARGET, SAVE :: <B>ETA</B>(:)
<P>
REAL (C_FLOAT), POINTER :: <B>C_ARRAY</B>(:)
<P>
&#46;&#46;&#46;
<P>
! Associate C_ARRAY with an array allocated in C
<P>
CALL C_F_POINTER (ARRAYS%C, C_ARRAY, [ ARRAYS%LENC ])
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: CALL C_F_POINTER (ARRAYS%C, C_ARRAY, [ ARRAYS%LENC ])
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
597
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
               &#46;&#46;&#46;
<P>
               ! Allocate an array and make it available in C
<P>
               ARRAYS%LENF = 100
<P>
               ALLOCATE (ETA(ARRAYS%LENF))
<P>
               ARRAYS%F = C_LOC(ETA)
<P>
               &#46;&#46;&#46;
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE SIMULATION</H4>
</A>
<BLOCKQUOTE>
<P>
C Struct Declaration:
<P>
<PRE>
           struct pass {
<P>
              int lenc, lenf;
<P>
              float *c, *f;
<P>
           };
<P>
</PRE>
C Function Prototype:
<P>
<PRE>
           void simulation(long alpha, double *beta, long *gamma, double delta[],
<P>
                              struct pass *arrays);
<P>
</PRE>
C Calling Sequence:
<P>
<PRE>
           simulation(alpha, beta, gamma, delta, arrays);
<P>
</PRE>
1 The above-listed Fortran code specifies a subroutine SIMULATION. This subroutine corresponds to the C void
<P>
<PRE>
  function simulation.
<P>
</PRE>
2 The Fortran subroutine references the intrinsic module ISO_C_BINDING.
</BLOCKQUOTE>
<P>
3 The first Fortran dummy argument of the subroutine is ALPHA, which has the type <B>INTEGER</B>(C_LONG) and
<P>
<PRE>
  the VALUE attribute. This dummy argument corresponds to the C formal parameter alpha, which is a long.
<P>
  The C actual argument is also a long.
<P>
</PRE>
4 The second Fortran dummy argument of the subroutine is BETA, which has the type <B>REAL</B>(C_DOUBLE) and
<P>
<PRE>
  the INTENT (INOUT) attribute. This dummy argument corresponds to the C formal parameter beta, which is
<P>
  a pointer to double. An address is passed as the C actual argument.
<P>
</PRE>
5 The third Fortran dummy argument of the subroutine is GAMMA, which has the type <B>INTEGER</B>(C_LONG)
<P>
<PRE>
  and the INTENT (OUT) attribute. This dummy argument corresponds to the C formal parameter gamma, which
<P>
  is a pointer to long. An address is passed as the C actual argument.
<P>
</PRE>
6 The fourth Fortran dummy argument is the assumed-size array DELTA, which has the type REAL (C_DOUBLE)
<P>
<PRE>
  and the INTENT (IN) attribute. This dummy argument corresponds to the C formal parameter delta, which is
<P>
  a double array. The C actual argument is also a double array.
<P>
</PRE>
7 The fifth Fortran dummy argument is ARRAYS, which is a structure for accessing an array allocated in C and
<P>
<PRE>
  an array allocated in Fortran. The lengths of these arrays are held in the components LENC and LENF; their C
<P>
  addresses are held in components C and F.
<P>
  598                                                              ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
  C.12.4     Example of calling C functions with noninteroperable data (18.10)
<P>
</PRE>
1 Many Fortran processors support 16-byte real numbers, which might not be supported by the C processor.
<P>
<PRE>
  Assume a Fortran programmer wants to use a C procedure from a message passing library for an array of these
<P>
  reals. The C prototype of this procedure is
<P>
           void ProcessBuffer(void *buffer, int n_bytes);
<P>
  with the corresponding Fortran interface
<P>
           USE, INTRINSIC :: ISO_C_BINDING
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>PROCESS_BUFFER</B>(BUFFER,N_BYTES) <B>BIND</B>(C,NAME="ProcessBuffer")
<P>
<PRE>
                  IMPORT :: C_PTR, C_INT
<P>
                  TYPE(C_PTR), VALUE :: BUFFER ! The ‘‘C address’’ of the array buffer
<P>
                  INTEGER (C_INT), VALUE :: N_BYTES ! Number of bytes in buffer
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE PROCESS_BUFFER</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
2 This can be done using C_LOC if the particular Fortran processor specifies that C_LOC returns an appropriate
<P>
<PRE>
  address:
<P>
           REAL(R_QUAD), DIMENSION(:), ALLOCATABLE, TARGET :: QUAD_ARRAY
<P>
           &#46;&#46;&#46;
<P>
           CALL PROCESS_BUFFER(C_LOC(QUAD_ARRAY), INT(16*SIZE(QUAD_ARRAY),C_INT))
<P>
           ! One quad real takes 16 bytes on this processor
<P>
  C.12.5     Example of opaque communication between C and Fortran (18.3)
<P>
</PRE>
1 The following example demonstrates how a Fortran processor can make a modern object-oriented random number
<P>
<PRE>
  generator written in Fortran available to a C program.
<P>
           USE, INTRINSIC :: ISO_C_BINDING
<P>
               ! Assume this code is inside a module
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE RANDOM_STREAM</H4>
</A>
<BLOCKQUOTE>
<P>
! A (uniform) random number generator (URNG)
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
<B>PROCEDURE</B>(RANDOM_UNIFORM), DEFERRED, <B>PASS</B>(STREAM) :: NEXT
<P>
! Generates the next number from the stream
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE RANDOM_STREAM</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; ABSTRACT INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
! Abstract interface of Fortran URNG
<P>
SUBROUTINE <B>RANDOM_UNIFORM</B>(STREAM, NUMBER)
<P>
<PRE>
                  IMPORT :: RANDOM_STREAM, C_DOUBLE
<P>
                  CLASS(RANDOM_STREAM), INTENT(INOUT) :: STREAM
<P>
                  REAL(C_DOUBLE), INTENT(OUT) :: NUMBER
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE RANDOM_UNIFORM</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
599
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
</BLOCKQUOTE>
<P>
2 A polymorphic object with declared type RANDOM_STREAM is not interoperable with C. However, we can
<P>
<PRE>
  make such a random number generator available to C by packaging it inside another nonpolymorphic, nonpara-
<P>
  meterized derived type:
<P>
           TYPE :: URNG_STATE ! No BIND(C), as this type is not interoperable
<P>
              CLASS(RANDOM_STREAM), ALLOCATABLE :: STREAM
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE URNG_STATE</H4>
</A>
<BLOCKQUOTE>
<P>
3 The following two procedures will enable a C program to use our Fortran uniform random number generator:
<P>
<PRE>
           ! Initialize a uniform random number generator:
<P>
           SUBROUTINE INITIALIZE_URNG(STATE_HANDLE, METHOD) &
<P>
                          BIND(C, NAME="InitializeURNG")
<P>
               TYPE(C_PTR), INTENT(OUT) :: STATE_HANDLE
<P>
                 ! An opaque handle for the URNG
<P>
               CHARACTER(C_CHAR), DIMENSION(*), INTENT(IN) :: METHOD
<P>
                 ! The algorithm to be used
<P>
               TYPE(URNG_STATE), POINTER :: STATE
<P>
                 ! An actual URNG object
<P>
               ALLOCATE(STATE)
<P>
                 ! There needs to be a corresponding finalization
<P>
                 ! procedure to avoid memory leaks, not shown in this example
<P>
               ! Allocate STATE%STREAM with a dynamic type depending on METHOD
<P>
               &#46;&#46;&#46;
<P>
               STATE_HANDLE=C_LOC(STATE)
<P>
                 ! Obtain an opaque handle to return to C
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE INITIALIZE_URNG</H4>
</A>
<BLOCKQUOTE>
<P>
! Generate a random number:
<P>
SUBROUTINE <B>GENERATE_UNIFORM</B>(STATE_HANDLE, NUMBER) &
<P>
<PRE>
                        BIND(C, NAME="GenerateUniform")
<P>
</PRE>
<B>TYPE</B>(C_PTR), <B>INTENT</B>(IN), VALUE :: STATE_HANDLE
<P>
<PRE>
                 ! An opaque handle: Obtained via a call to INITIALIZE_URNG
<P>
</PRE>
<B>REAL</B>(C_DOUBLE), <B>INTENT</B>(OUT) :: NUMBER
<BLOCKQUOTE>
<P>
<B>TYPE</B>(URNG_STATE), POINTER :: STATE
<P>
<PRE>
                 ! A pointer to the actual URNG
<P>
</PRE>
CALL <B>C_F_POINTER</B>(CPTR=STATE_HANDLE, FPTR=STATE)
<P>
<PRE>
                  ! Convert the opaque handle into a usable pointer
<P>
</PRE>
CALL <B>STATE%STREAM%NEXT</B>(NUMBER)
<P>
<PRE>
                  ! Use the type-bound procedure NEXT to generate NUMBER
<P>
</PRE>
</BLOCKQUOTE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE GENERATE_UNIFORM</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>600</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.12.6</B> </TD><TD valign=bottom>
Using assumed type to interoperate with C
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C.12.6.1</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Overview
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 The mechanism for handling unlimited polymorphic entities whose dynamic type is interoperable with C is
<P>
<PRE>
  designed to handle the following two situations:
<P>
         (1)    A formal parameter that is a C pointer to void. This is an address, and no further information
<P>
                about the entity is provided. The formal parameter corresponds to a dummy argument that is a
<P>
                nonallocatable nonpointer scalar or is an assumed-size array.
<P>
         (2)    A formal parameter that is the address of a C descriptor. Additional information on the status, type,
<P>
                size, and shape is implicitly provided. The formal parameter corresponds to a dummy argument that
<P>
                is assumed-shape or assumed-rank.
<P>
</PRE>
2 In the first situation, it is the programmer’s responsibility to explicitly provide any information needed on the
<P>
<PRE>
  status, type, size, and shape of the entity.
<P>
  C.12.6.2    Mapping of interfaces with void * C parameters to Fortran
<P>
</PRE>
1 A C interface for message passing or input/output functionality could be provided in the form
<P>
<PRE>
            int EXAMPLE_send(const void *buffer, size_t buffer_size, const HANDLE_t *handle);
<P>
</PRE>
where the buffer_size argument is given in units of bytes, and the handle argument (which is of a type aliased
<BLOCKQUOTE>
<P>
to int) provides information about the target the buffer is to be transferred to. In this example, type resolution
<P>
is not required.
</BLOCKQUOTE>
<P>
2 The first method provides a thin binding; a call to EXAMPLE_send from Fortran directly invokes the C function.
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER (C_INT) FUNCTION <B>example_send</B>(buffer, buffer_size, handle) &
<P>
<B>BIND</B>(C, NAME=’EXAMPLE_send’)
<P>
<PRE>
                    USE, INTRINSIC :: ISO_C_BINDING
<P>
                    TYPE(*), INTENT (IN) :: buffer(*)
<P>
                    INTEGER (C_SIZE_T), VALUE :: buffer_size
<P>
                    INTEGER (C_INT), INTENT (IN) :: handle
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END FUNCTION</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
3 It is assumed that this interface is declared in the specification part of the module MOD_EXAMPLE_OLD. An
<P>
<PRE>
  example of its use follows:
<P>
            USE, INTRINSIC :: ISO_C_BINDING
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; USE MOD_EXAMPLE_OLD</H4>
</A>
<BLOCKQUOTE>
<P>
<B>REAL</B>(C_FLOAT) :: <B>x</B>(100)
<P>
<B>INTEGER</B>(C_INT) :: <B>y</B>(10,10)
<P>
<B>REAL</B>(C_DOUBLE) :: z
<P>
<B>INTEGER</B>(C_INT) :: status, handle
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: &#46;&#46;&#46;
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
601
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
           ! Assign values to x, y, z and initialize handle.
<P>
           &#46;&#46;&#46;
<P>
           ! Send values in x, y, and z using EXAMPLE_send.
<P>
           status = example_send(x, C_SIZEOF(x), handle)
<P>
           status = example_send(y, C_SIZEOF(y), handle)
<P>
           status = example_send([ z ], C_SIZEOF(z), handle)
<P>
</PRE>
4 In those invocations, x and y are passed directly with sequence association, but it is necessary to make an array
<P>
<PRE>
  expression containing the value of z to pass it.
<P>
</PRE>
5 The second method provides a Fortran interface which is easier to use, but requires writing a separate C wrapper
<P>
<PRE>
  routine. With this method, a C descriptor is created because the buffer is assumed-rank in the Fortran interface;
<P>
  the use of an optional argument is also demonstrated.
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>example_send</B>(buffer, handle, status) <B>BIND</B>(C, NAME="EG_send_fortran")
<P>
<PRE>
                  USE, INTRINSIC :: ISO_C_BINDING
<P>
                  TYPE(*), CONTIGUOUS, INTENT (IN) :: buffer(..)
<P>
                  INTEGER (C_INT), INTENT (IN) :: handle
<P>
                  INTEGER (C_INT), INTENT(OUT), OPTIONAL :: status
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
6 It is assumed that this interface is declared in the specification part of a module MOD_EXAMPLE_NEW.
<P>
<PRE>
  Example invocations from Fortran are then
<P>
           USE, INTRINSIC :: iso_c_binding
<P>
           USE mod_example_new
<P>
           TYPE, BIND(C) :: my_derived
<P>
               INTEGER(C_INT) :: len_used
<P>
               REAL(C_FLOAT) :: stuff(100)
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(my_derived) :: <B>w</B>(3)
<P>
<B>REAL</B>(C_FLOAT) :: <B>x</B>(100)
<P>
<B>INTEGER</B>(C_INT) :: <B>y</B>(10,10)
<P>
<B>REAL</B>(C_DOUBLE) :: z
<P>
<B>INTEGER</B>(C_INT) :: status, handle
<P>
&#46;&#46;&#46;
<P>
! Assign values to w, x, y, z and initialize handle.
<P>
&#46;&#46;&#46;
<P>
! Send values in w, x, y, and z using example_send.
<P>
CALL <B>example_send</B>(w, handle, status)
<P>
CALL <B>example_send</B>(x, handle)
<P>
CALL <B>example_send</B>(y, handle)
<P>
CALL <B>example_send</B>(z, handle)
<P>
CALL <B>example_send</B>(<B>y</B>(:,5), handle) ! Fifth column of y.
<P>
CALL <B>example_send</B>(<B>y</B>(1,5), handle) ! Scalar <B>y</B>(1,5) passed by descriptor.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: CALL <B>example_send</B>(<B>y</B>(1,5), handle) ! Scalar <B>y</B>(1,5) passed by descriptor.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>602</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
7 The wrapper routine can be written in C as follows.
</TD></TR>
<TR><TD colspan=2>
<PRE>
         #include "ISO_Fortran_binding.h"
<P>
         void EXAMPLE_send_fortran(const CFI_cdesc_t *buffer, const HANDLE_t *handle,
<P>
                                       int *status)
<P>
         {
<P>
            int status_local;
<P>
            size_t buffer_size;
<P>
            int i;
<P>
            buffer_size = buffer-&gt;elem_len;
<P>
            for (i=0; i&lt;buffer-&gt;rank; i++) {
<P>
              buffer_size *= buffer-&gt;dim[i].extent;
<P>
            }
<P>
            status_local = EXAMPLE_send(buffer-&gt;base_addr,buffer_size, handle);
<P>
            if (status != NULL) *status = status_local;
<P>
         }
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>C.12.7</B> </TD><TD valign=bottom>
Using assumed-type variables in Fortran
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR></TR></TABLE>1 An assumed-type dummy argument in a Fortran procedure can be used as an actual argument corresponding to an
<P>
<PRE>
  assumed-type dummy in a call to another procedure. In the following example, the Fortran subroutine SIMPLE_-
<P>
  SEND serves as a wrapper to hide the complications associated with calls to a C function named ACTUAL_Send.
<P>
  Module COMM_INFO contains node and address information for the current data transfer operations.
<P>
         SUBROUTINE SIMPLE_SEND(buffer, nbytes)
<P>
            USE comm_info, ONLY: my_node, r_node, r_addr
<P>
            USE, INTRINSIC :: ISO_C_BINDING
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; IMPLICIT NONE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>TYPE</B>(*), INTENT (IN) :: <B>buffer</B>(*)
<TABLE cellpadding=3><!-- tsb: <B>TYPE</B>(*), INTENT (IN) :: <B>buffer</B>(*)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>INTEGER</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:: nbytes, ierr
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>actual_Send</B>(buffer, nbytes, node, addr, ierr) &
<P>
<B>BIND</B>(C, NAME="ACTUAL_Send")
<P>
<PRE>
                  IMPORT :: C_SIZE_T, C_INT, C_INTPTR_T
<P>
                  TYPE(*), INTENT (IN)              :: buffer(*)
<P>
                  INTEGER(C_SIZE_T), VALUE          :: nbytes
<P>
                  INTEGER(C_INT), VALUE             :: node
<P>
                  INTEGER(C_INTPTR_T), VALUE :: addr
<P>
                  INTEGER(C_INT), INTENT(OUT) :: ierr
<P>
</PRE>
END SUBROUTINE actual_Send
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
CALL <B>actual_Send</B>(buffer, <B>INT</B>(nbytes, C_SIZE_T), r_node, r_addr, ierr)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: CALL <B>actual_Send</B>(buffer, <B>INT</B>(nbytes, C_SIZE_T), r_node, r_addr, ierr)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
603
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
             IF (ierr /= 0) THEN
<P>
                  PRINT *, "Error sending from node", my_node, "to node", r_node
<P>
                  PRINT *, "Program Aborting" ! Or call a recovery procedure
<P>
                  ERROR STOP                         ! Omit in the recovery case
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END IF</H4>
</A>
<BLOCKQUOTE>
<P>
END SUBROUTINE simple_Send
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END SUBROUTINE simple_Send
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.12.8</B> </TD><TD valign=bottom>
Simplifying interfaces for arbitrary rank procedures
<P>
1 There are situations where an assumed-rank dummy argument can be useful in Fortran, although a Fortran
<P>
<PRE>
  procedure cannot itself access its value. For example, the IEEE inquiry functions in Clause 14 could be written
<P>
  using an assumed-rank dummy argument instead of writing 16 separate specific routines, one for each possible
<P>
  rank.
<P>
</PRE>
2 In particular, the specific procedures for the IEEE_SUPPORT_DIVIDE function could possibly be implemented
<P>
<PRE>
  in Fortran as follows:
<P>
           INTERFACE ieee_support_divide
<P>
               MODULE PROCEDURE ieee_support_divide_noarg, ieee_support_divide_onearg_r, &
<P>
                                    ieee_support_divide_onearg_d
<P>
           END INTERFACE ieee_support_divide
<P>
           &#46;&#46;&#46;
<P>
           LOGICAL FUNCTION ieee_support_divide_noarg ()
<P>
               ieee_support_divide_noarg = .TRUE.
<P>
           END FUNCTION ieee_support_divide_noarg
<P>
           LOGICAL FUNCTION ieee_support_divide_onearg_r (x)
<P>
               REAL, INTENT (IN) :: x(..)
<P>
               ieee_support_divide_onearg_r4 = .TRUE.
<P>
           END FUNCTION ieee_support_divide_onearg_r
<P>
           LOGICAL FUNCTION ieee_support_divide_onearg_d (x)
<P>
               DOUBLE PRECISION, INTENT (IN) :: x(..)
<P>
               ieee_support_divide_onearg_r8 = .TRUE.
<P>
           END FUNCTION ieee_support_divide_onearg_d
<P>
  C.12.9      Processing assumed-shape arrays in C
<P>
</PRE>
1 The example shown below calculates the product of individual elements of arrays A and B and returns the result
<P>
<PRE>
  in array C. The Fortran interface of elemental_mult will accept arguments of any type and rank. However, the
<P>
  C function will return an error code if any argument is not a two-dimensional int array. Note that the arguments
<P>
  are permitted to be array sections, so the C function does not assume that any argument is contiguous.
<P>
  604                                                               ⃝
<P>
                                                                    c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                     ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
2 The Fortran interface is:
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
FUNCTION <B>elemental_mult</B>(a, b, c) <B>BIND</B>(C, NAME="elemental_mult_c") <B>RESULT</B>(err)
<P>
<PRE>
                  USE, INTRINSIC :: ISO_C_BINDING
<P>
                  INTEGER(C_INT) :: err
<P>
                  TYPE(*), DIMENSION(..) :: a, b, c
<P>
</PRE>
END FUNCTION elemental_mult
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
3 The definition of the C function is:
<P>
<PRE>
          #include "ISO_Fortran_binding.h"
<P>
          int elemental_mult_c(CFI_cdesc_t * a_desc, CFI_cdesc_t * b_desc, CFI_cdesc_t * c_desc)
<P>
          {
<P>
             size_t i, j, ni, nj;
<P>
             int err = 1;     /* this error code represents all errors */
<P>
             char  * a_col  = (char*) a_desc-&gt;base_addr;
<P>
             char  * b_col  = (char*) b_desc-&gt;base_addr;
<P>
             char  * c_col  = (char*) c_desc-&gt;base_addr;
<P>
             char  *a_elt,  *b_elt, *c_elt;
<P>
             /* Only support int. */
<P>
             if (a_desc-&gt;type != CFI_type_int || b_desc-&gt;type != CFI_type_int ||
<P>
                  c_desc-&gt;type != CFI_type_int) {
<P>
                return err;
<P>
             }
<P>
             /* Only support two dimensions. */
<P>
             if (a_desc-&gt;rank != 2 || b_desc-&gt;rank != 2 || c_desc-&gt;rank != 2) {
<P>
                return err;
<P>
             }
<P>
             ni = a_desc-&gt;dim[0].extent;
<P>
             nj = a_desc-&gt;dim[1].extent;
<P>
             /* Ensure the shapes conform. */
<P>
             if (ni != b_desc-&gt;dim[0].extent || ni != c_desc-&gt;dim[0].extent) return err;
<P>
             if (nj != b_desc-&gt;dim[1].extent || nj != c_desc-&gt;dim[1].extent) return err;
<P>
             /* Multiply the elements of the two arrays. */
<P>
             for (j = 0; j &lt; nj; j++) {
<P>
               a_elt = a_col;
<P>
               b_elt = b_col;
<P>
               c_elt = c_col;
<P>
</PRE>
⃝
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: ⃝
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
605
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
                for (i = 0; i &lt; ni; i++) {
<P>
                  *(int*)a_elt = *(int*)b_elt * *(int*)c_elt;
<P>
                  a_elt += a_desc-&gt;dim[0].sm;
<P>
                  b_elt += b_desc-&gt;dim[0].sm;
<P>
                  c_elt += c_desc-&gt;dim[0].sm;
<P>
                }
<P>
                a_col += a_desc-&gt;dim[1].sm;
<P>
                b_col += b_desc-&gt;dim[1].sm;
<P>
                c_col += c_desc-&gt;dim[1].sm;
<P>
</PRE>
}
<BLOCKQUOTE>
<P>
return 0;
</BLOCKQUOTE>
<P>
}
<TABLE cellpadding=3><!-- tsb: }
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.12.10</B> </TD><TD valign=bottom>
Creating a contiguous copy of an array
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
1 A C function might need to create a contiguous copy of an array section, for example, to pass the array section
<P>
<PRE>
  as an actual argument corresponding to a dummy argument with the CONTIGUOUS attribute. The following
<P>
  example provides functions that can be used to copy an array described by a CFI_cdesc_t descriptor to a
<P>
  contiguous buffer. The input array need not be contiguous.
<P>
</PRE>
2 The C functions are:
<P>
<PRE>
          #include "ISO_Fortran_binding.h"
<P>
          /* Other necessary includes omitted. */
<P>
          /*
<P>
            * Returns the number of elements in the object described by desc.
<P>
            * If it is an array, it need not be contiguous.
<P>
            * (The number of elements could be zero).
<P>
            */
<P>
          size_t numElements(const CFI_cdesc_t * desc)
<P>
          {
<P>
               CFI_rank_t r;
<P>
               size_t num = 1;
<P>
               for (r = 0; r &lt; desc-&gt;rank; r++) {
<P>
                  num *= desc-&gt;dim[r].extent;
<P>
               }
<P>
               return num;
<P>
          }
<P>
          /*
<P>
            * Auxiliary recursive function to copy an array of a given rank.
<P>
            * Recursion is useful because an array of rank n is composed of an
<P>
            * ordered set of arrays of rank n-1.
<P>
            */
<P>
          static void *_copyToContiguous (const CFI_cdesc_t *vald, void *output,
<P>
                                               const void *input, CFI_rank_t rank)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>606</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
{
<P>
<PRE>
              CFI_index_t e;
<P>
              if (rank == 0) {
<P>
                  /* Copy scalar element. */
<P>
                  memcpy (output, input, vald-&gt;elem_len);
<P>
                  output = (void *)((char *)output + vald-&gt;elem_len);
<P>
              }
<P>
              else {
<P>
                  for (e = 0; e &lt; vald-&gt;dim[rank-1].extent; e++) {
<P>
                     /* Recurse on subarrays of lesser rank. */
<P>
                     output = _copyToContiguous (vald, output, input, rank-1);
<P>
                     input = (void *) ((char *)input + vald-&gt;dim[rank].sm);
<P>
                  }
<P>
              }
<P>
              return output;
<P>
</PRE>
}
<BLOCKQUOTE>
<P>
/*
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: /*
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
General routine to copy the elements in the array described by vald
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
to buffer, as done by sequence association. The array itself can
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
be non-contiguous. This is not the most efficient approach.
</TD></TR>
<TR></TR></TABLE>*/
</BLOCKQUOTE>
<P>
void copyToContiguous (void * buffer, const CFI_cdesc_t * vald) {
<P>
<PRE>
              _copyToContiguous (vald, buffer, vald-&gt;base_addr, vald-&gt;rank);
<P>
</PRE>
}
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: }
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.12.11</B> </TD><TD valign=bottom>
Changing the attributes of an array
<P>
1 A C programmer might want to call more than one Fortran procedure and the attributes of an array involved
<P>
<PRE>
  might differ between the procedures. In this case, it is necessary to set up more than one C descriptor for the
<P>
  array. For example, this code fragment initializes the first C descriptor for an allocatable entity of rank 2, calls
<P>
  a procedure that allocates the array described by the first C descriptor, constructs the second C descriptor by
<P>
  invoking CFI_section with the value CFI_attribute_other for the attribute parameter, then calls a procedure
<P>
  that expects an assumed-shape array.
<P>
          CFI_CDESC_T(2) loc_alloc, loc_assum;
<P>
          CFI_cdesc_t * desc_alloc = (CFI_cdesc_t *)&loc_alloc,
<P>
                        * desc_assum = (CFI_cdesc_t *)&loc_assum;
<P>
          CFI_index_t extents[2];
<P>
          CFI_rank_t rank = 2;
<P>
          int flag;
<P>
          flag = CFI_establish(desc_alloc,
<P>
                                   NULL,
<P>
                                   CFI_attribute_allocatable,
<P>
                                   CFI_type_double,
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                          607
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
                                    sizeof(double),
<P>
                                    rank,
<P>
                                    NULL);
<P>
           Fortran_factor (desc_alloc, &#46;&#46;&#46;); /* Allocates array described by desc_alloc. */
<P>
           /* Extract extents from descriptor. */
<P>
           extents[0] = desc_alloc-&gt;dim[0].extent;
<P>
           extents[1] = desc_alloc-&gt;dim[1].extent;
<P>
           flag = CFI_establish(desc_assum,
<P>
                                    desc_alloc-&gt;base_addr,
<P>
                                    CFI_attribute_other,
<P>
                                    CFI_type_double,
<P>
                                    sizeof(double),
<P>
                                    rank,
<P>
                                    extents);
<P>
           Fortran_solve (desc_assum, &#46;&#46;&#46;); /* Uses array allocated in Fortran_factor. */
<P>
</PRE>
2 After invocation of the second CFI_establish, the lower bounds stored in the dim member of desc_assum will
<P>
<PRE>
  have the value 0 even if the corresponding entries in desc_alloc have different values.
<P>
  C.12.12      Creating an array section in C using CFI_section
<P>
</PRE>
1 The C function set_odd sets every second element of an array to a specific value, beginning with the first element.
<P>
<PRE>
  If does this by making an array section descriptor for the elements to be set, and calling a Fortran subroutine
<P>
  SET_ALL that sets every element of an assumed-shape array to a specific value. An interface block for set_odd
<P>
  permits it to be also called from Fortran.
<P>
           SUBROUTINE set_all(int_array, val) BIND(C)
<P>
             INTEGER(C_INT) :: int_array(:)
<P>
             INTEGER(C_INT), VALUE :: val
<P>
             int_array = val
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>set_odd</B>(int_array, val) <B>BIND</B>(C)
<P>
<PRE>
                USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT
<P>
                INTEGER(C_INT) :: int_array(:)
<P>
                INTEGER(C_INT), VALUE :: val
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
#include "ISO_Fortran_binding.h"
<P>
void <B>set_odd</B>(CFI_cdesc_t *int_array, int val)
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: void <B>set_odd</B>(CFI_cdesc_t *int_array, int val)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>608</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
{
</TD></TR>
<TR><TD colspan=2>
<PRE>
               CFI_index_t lower_bound[1], upper_bound[1], stride[1];
<P>
               CFI_CDESC_T(1) array;
<P>
               int status;
<P>
               /* Create a new descriptor which will contain the section. */
<P>
               status = CFI_establish((CFI_cdesc_t *)&array,
<P>
                                           NULL,
<P>
                                           CFI_attribute_other,
<P>
                                           int_array-&gt;type,
<P>
                                           int_array-&gt;elem_len,
<P>
                                           /* rank */ 1,
<P>
                                           /* extents is ignored */NULL);
<P>
               lower_bound[0] = int_array-&gt;dim[0].lower_bound;
<P>
               upper_bound[0] = lower_bound[0] + (int_array-&gt;dim[0].extent - 1);
<P>
               stride[0] = 2;
<P>
               status = CFI_section((CFI_cdesc_t *)&array,
<P>
                                        int_array,
<P>
                                        lower_bound,
<P>
                                        upper_bound,
<P>
                                        stride);
<P>
               set_all( (CFI_cdesc_t *) &array, val);
<P>
               /* Here one could make use of int_array and access all its data. */
<P>
</PRE>
}
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
2 The set_odd procedure can be called from Fortran as follows:
<P>
<PRE>
            INTEGER(C_INT) :: d(5)
<P>
            d = (/ 1, 2, 3, 4, 5 /)
<P>
            CALL set_odd(d, -1)
<P>
            PRINT *, d
<P>
</PRE>
3 This program will print something like:
<P>
<PRE>
              -1      2    -1     4   -1
<P>
</PRE>
4 During execution of the subroutine SET_ALL, its dummy argument INT_ARRAY would have size (and upper
<P>
<PRE>
  bound) 3.
<P>
</PRE>
5 It is also possible to invoke <B>set_odd</B>() from C. However, it would be the C programmer’s responsibility to make
<P>
<PRE>
  sure that all members of the C descriptor have the correct value on entry to the function. Inserting additional
<P>
  checking into the function could alleviate this problem.
<P>
</PRE>
6 Following is an example C function that dynamically generates a C descriptor for an assumed-shape array and
<P>
<PRE>
  calls set_odd.
<P>
  ⃝c ISO/IEC 2017 – All rights reserved                                                                     609
<P>
<P>
  ISO/IEC DIS 1539-1:2017 (E)
<P>
           #include &lt;stdio.h&gt;
<P>
           #include &lt;stdlib.h&gt;
<P>
           #include "ISO_Fortran_binding.h"
<P>
           #define ARRAY_SIZE 5
<P>
           void example_of_calling_set_odd(void)
<P>
           {
<P>
             CFI_CDESC_T(1) d;
<P>
             CFI_index_t extent[1];
<P>
             CFI_index_t subscripts[1];
<P>
             void *base;
<P>
             int i, status;
<P>
             base = malloc(ARRAY_SIZE*sizeof(int));
<P>
             extent[0] = ARRAY_SIZE;
<P>
             status = CFI_establish((CFI_cdesc_t *)&d,
<P>
                                        base,
<P>
                                        CFI_attribute_other,
<P>
                                        CFI_type_int,
<P>
                                        /* element length is ignored */ 0,
<P>
                                        /* rank */ 1,
<P>
                                        extent);
<P>
             set_odd((CFI_cdesc_t *)&d, -1);
<P>
             for (i=0; i&lt;ARRAY_SIZE; i++) {
<P>
                subscripts[0] = i;
<P>
                printf(" %d",*((int *)CFI_address((CFI_cdesc_t *)&d, subscripts)));
<P>
             }
<P>
             putc(10, stdout);
<P>
             free(base);
<P>
           }
<P>
  The above C function will print similar output to that of the preceding Fortran program.
<P>
  C.12.13       Use of CFI_setpointer
<P>
</PRE>
1 The C function change_target modifies a pointer to an integer variable to become associated with a global
<P>
<PRE>
  variable defined inside C:
<P>
           #include "ISO_Fortran_binding.h"
<P>
           int y = 2;
<P>
           void change_target(CFI_cdesc_t *ip) {
<P>
               CFI_CDESC_T(0) yp;
<P>
               int status;
<P>
  610                                                             ⃝c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
               /* Make local yp point at y. */
<P>
               status = CFI_establish((CFI_cdesc_t *)&yp,
<P>
                                         &y,
<P>
                                         CFI_attribute_pointer,
<P>
                                         CFI_type_int,
<P>
                                         /* elem_len is ignored */ sizeof(int),
<P>
                                         /* rank */ 0,
<P>
                                         /* extents are ignored */ NULL);
<P>
               /* Pointer-associate ip with (the target of) yp. */
<P>
               status = CFI_setpointer(ip, (CFI_cdesc_t *)&yp, NULL);
<P>
               if (status != CFI_SUCCESS) {
<P>
                  &#46;&#46;&#46; report run time error...
<P>
               }
<P>
           }
<P>
</PRE>
2 The restrictions on the use of CFI_establish prohibit direct modification of the incoming pointer entity ip by
<P>
<PRE>
  invoking that function on it.
<P>
</PRE>
3 The following program illustrates the usage of change_target from Fortran.
<P>
<PRE>
           PROGRAM change_target_example
<P>
              USE, INTRINSIC :: ISO_C_BINDING
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>change_target</B>(ip) <B>BIND</B>(C)
<P>
<PRE>
                   IMPORT :: C_INT
<P>
                   INTEGER(C_INT), POINTER :: ip
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>INTEGER</B>(C_INT), TARGET :: it = 1
<P>
<B>INTEGER</B>(C_INT), POINTER :: it_ptr
<P>
it_ptr =&gt; it
<P>
WRITE (*,*) it_ptr
<P>
CALL <B>change_target</B>(it_ptr)
<P>
WRITE (*,*) it_ptr
</BLOCKQUOTE>
<P>
4 This will print something similar to
<BLOCKQUOTE>
<P>
1
<P>
2
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: 2
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>C.12.14</B> </TD><TD valign=bottom>
Mapping of MPI interfaces to Fortran
<P>
1 The Message Passing Interface (MPI) specifies procedures for exchanging data between MPI processes. This
<P>
<PRE>
  example shows the usage of MPI_Send and is similar to the second variant of EXAMPLE_Send in C.12.6.2. It also
<P>
  shows the usage of assumed-length character dummy arguments and optional dummy arguments.
<P>
</PRE>
2 MPI_Send has the C prototype:
<P>
<PRE>
           int MPI_Send(void *buf, int count, MPI_Datatype datatype, int dest, int tag,
<P>
                          MPI_Comm comm);
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
611
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
where MPI_Datatype and MPI_Comm are opaque handles. Most MPI C functions return an error code, which in
<P>
Fortran is the last dummy argument to the corresponding subroutine and can be made optional. Thus, the use
<P>
of a Fortran subroutine requires a wrapper function, declared as
<P>
<PRE>
           void MPI_Send_f(CFI_cdesc_t *buf, int count, MPI_Datatype_f datatype, int dest,
<P>
                             int tag, MPI_Datatype_f comm, int *ierror);
<P>
</PRE>
3 This wrapper function will convert MPI_Datatype_f and MPI_Comm_f to MPI_Datatype and MPI_Comm, and pro-
<P>
<PRE>
  duce a contiguous void * buffer from CFI_cdesc_t *buf (if necessary).
<P>
</PRE>
4 Similarly, the wrapper function for MPI_Comm_set_name could have the C prototype:
<P>
<PRE>
           void MPI_Comm_set_name_f(MPI_Comm comm, CFI_cdesc_t *comm_name, int *ierror);
<P>
</PRE>
5 The Fortran handle types and interfaces are defined in the module MPI_F08. For example,
<P>
<PRE>
           MODULE mpi_f08
<P>
              &#46;&#46;&#46;
<P>
              TYPE, BIND(C) :: mpi_comm
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; PRIVATE</H4>
</A>
<BLOCKQUOTE>
<P>
<B>INTEGER</B>(C_INT) :: mpi_val
</BLOCKQUOTE>
<P>
END TYPE mpi_comm
<A name=>

    <H4>&nbsp; &nbsp; INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
SUBROUTINE <B>MPI_SEND</B>(buf,count,datatype,dest,tag,comm,ierror) &
<P>
<B>BIND</B>(C, NAME=’MPI_Send_f’)
<P>
<PRE>
                  USE, INTRINSIC :: ISO_C_BINDING
<P>
                  IMPORT :: MPI_Datatype, MPI_Comm
<P>
                  TYPE(*), DIMENSION(..), INTENT (IN) :: buf
<P>
                  INTEGER(C_INT), VALUE, INTENT (IN) :: count, dest, tag
<P>
                  TYPE(mpi_datatype), INTENT (IN) :: datatype
<P>
                  TYPE(mpi_comm), INTENT (IN) :: comm
<P>
                  INTEGER(C_INT), OPTIONAL, INTENT (OUT) :: ierror
<P>
</PRE>
END SUBROUTINE mpi_send
<P>
SUBROUTINE <B>mpi_comm_set_name</B>(comm,comm_name,ierror) &
<P>
<B>BIND</B>(C, NAME=’MPI_Comm_set_name_f’)
<P>
<PRE>
                  USE, INTRINSIC :: ISO_C_BINDING
<P>
                  IMPORT :: mpi_comm
<P>
                  TYPE(mpi_comm), INTENT (IN) :: comm
<P>
                  CHARACTER(KIND=C_CHAR, LEN=*), INTENT (IN) :: comm_name
<P>
                  INTEGER(C_INT), OPTIONAL, INTENT (OUT) :: ierror
<P>
</PRE>
END SUBROUTINE mpi_comm_set_name
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<P>
END MODULE mpi_f08
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: END MODULE mpi_f08
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>612</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                           ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
6 Some examples of invocation from Fortran are:
<P>
<PRE>
           USE, INTRINSIC :: ISO_C_BINDING
<P>
           USE :: MPI_f08
<P>
           TYPE(mpi_comm) :: comm
<P>
           REAL :: x(100)
<P>
           INTEGER :: y(10,10)
<P>
           REAL(KIND(1.0d0)) :: z
<P>
           INTEGER :: dest, tag, ierror
<P>
           &#46;&#46;&#46;
<P>
           ! Assign values to x, y, z and initialize MPI variables.
<P>
           &#46;&#46;&#46;
<P>
           ! Set the name of the communicator.
<P>
           CALL mpi_comm_set_name(comm, "Communicator Name", ierror)
<P>
           ! Send values in x, y, and z.
<P>
           CALL mpi_send(x, 100, MPI_REAL, dest, tag, comm, ierror)
<P>
           IF (ierror/=0) PRINT *, ’WARNING: X send error’, ierror
<P>
           CALL mpi_send(y(3,:), 10, MPI_INTEGER, dest, tag, comm)
<P>
           CALL mpi_send(z, 1, MPI_DOUBLE_PRECISION, dest, tag, comm)
<P>
</PRE>
7 The first example sends the entire array X and includes the optional error argument return value. The second
<P>
<PRE>
  example sends a noncontiguous subarray (the third row of Y) and the third example sends a scalar Z. Note the
<P>
  differences between the calls in this example and those in C.12.6.2.
<P>
  C.13       Clause 19 notes : Examples of host association (19.5.1.4)
<P>
</PRE>
1 The first two examples are examples of valid host association. The third example is an example of invalid host
<P>
<PRE>
  association.
<P>
  Example 1:
<P>
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM A</H4>
</A>
<BLOCKQUOTE>
<P>
INTEGER I, J
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE B</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTEGER I</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Declaration of I hides
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                ! program A’s declaration of I
<P>
</PRE>
&#46;&#46;&#46;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>I = J</B> </TD><TD valign=bottom>
! Use of variable J from program A
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                ! through host association
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE B</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM A</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
613
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
Example 2:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM A</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE T</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE T</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE B</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>IMPLICIT TYPE (T) (C)</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Refers to type T declared below
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                            ! in subroutine B, not type T
<P>
                                            ! declared above in program A
<P>
</PRE>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TYPE T</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END TYPE T</H4>
</A>
<BLOCKQUOTE>
<P>
&#46;&#46;&#46;
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE B</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM A</H4>
</A>
<BLOCKQUOTE>
<P>
Example 3:
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; PROGRAM Q</H4>
</A>
<BLOCKQUOTE>
<P>
REAL (KIND = 1) :: C
<P>
<PRE>
                  &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CONTAINS</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; SUBROUTINE R</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>REAL (KIND = KIND (C)) :: D</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
! Invalid declaration
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                   ! See below
<P>
</PRE>
REAL (KIND = 2) :: C
<P>
<PRE>
                     &#46;&#46;&#46;
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END SUBROUTINE R</H4>
</A>
<BLOCKQUOTE>
<P>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; END PROGRAM Q</H4>
</A>
<BLOCKQUOTE>
<P>
2 In the declaration of D in subroutine R, the use of C would refer to the declaration of C in subroutine R, not
<P>
<PRE>
  program Q. However, it is invalid because the declaration of C is required to occur before it is used in the
<P>
  declaration of D (10.1.12).
<P>
  614                                                            ⃝
<P>
                                                                 c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
                                                     Index
<P>
</PRE>
In the index, entries in italics denote BNF terms, and page numbers in bold face denote primary text or
<P>
definitions.
<TABLE cellpadding=3><!-- tsb: definitions.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>Symbols</B> <!-- Consumed .TP -->
<BR>
<B>−, 155</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
A edit descriptor, 278
</TD></TR>
<TR valign=top><TD colspan=2>
<B>&lt;, 159, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ABS, 350, 449
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>&lt;=, 159</B> </TD><TD valign=bottom>
ABSTRACT, 69, 70, 85, 302, 303
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>&gt;, 159</B> </TD><TD valign=bottom>
ABSTRACT attribute, 23, 69, 85
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>&gt;=, 159</B> </TD><TD valign=bottom>
abstract interface, 15, 15, 294, 301, 303, 309, 328, 510,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>*, 55, 58, 60, 65, 100, 104, 114, 138, 155, 240, 241, 271,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
514
</TD></TR>
<TR><TD colspan=2>
<PRE>
          283, 288, 311, 330                               abstract interface block, 15, 15, 303
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>**, 155</B> </TD><TD valign=bottom>
abstract type, 23, 59, 82, 85, 85, 88, 131, 139
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>+, 155</B> </TD><TD valign=bottom>
ac-do-variable (R776), 93, 93, 164, 166, 512
</TD></TR>
<TR valign=top><TD colspan=2>
<B></B><B>-stmt</B>, 20 </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ac-implied-do (R774), 93, 93, 153, 512
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.AND., 150, 151, 154, 158, 158, 352</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ac-implied-do-control (R775), 93, 93, 153, 164–166, 512
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.EQ., 149, 151, 154, 158, 159, 159, 161, 302, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ac-spec (R770), 92, 93
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.EQV., 150, 151, 154, 158, 158</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ac-value (R773), 93, 93
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.FALSE., 68, 479</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
access-id (R828), 111, 111
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.GE., 149, 151, 154, 158, 159, 161, 302, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
access-name, 111
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.GT., 149, 151, 154, 158, 159, 161, 302, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
access-spec (R807), 69, 74, 75, 80–83, 95, 98, 98, 111,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.LE., 149, 151, 154, 158, 159, 161, 302, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
112, 304, 308
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.LT., 149, 151, 154, 158, 159, 161, 302, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
access-stmt (R827), 36, 98, 111, 111, 112
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.NE., 149, 151, 154, 158, 159, 159, 161, 302, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ACCESS= specifier, 226, 227, 254, 255
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.NEQV., 150, 151, 154, 158, 158, 413</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
accessibility attribute, 98, 111, 294
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.NOT., 150, 151, 154, 158, 158</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
accessibility statement, 111
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.OR., 150, 151, 154, 158, 158, 353</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ACHAR, 68, 169, 350
</TD></TR>
<TR valign=top><TD colspan=2>
<B>.TRUE., 68, 479</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ACOS, 350
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>/, 155</B> </TD><TD valign=bottom>
ACOSH, 350
</TD></TR>
<TR valign=top><TD colspan=2>
<B>/ edit descriptor, 281</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ACQUIRED_LOCK= specifier, 213, 525, 528
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>//, 157</B> </TD><TD valign=bottom>
action, 218
</TD></TR>
<TR valign=top><TD colspan=2>
<B>/=, 159, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
action-stmt (R515), 7, 37, 37, 153, 196, 204
</TD></TR>
<TR valign=top><TD colspan=2>
<B>: edit descriptor, 281</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ACTION= specifier, 226, 228, 254, 255, 565
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>;, 54</B> </TD><TD valign=bottom>
active image, 14, 41, 140, 144, 145, 186, 213, 216, 341,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>&lt;=, 446</B> </TD><TD valign=bottom>
407
</TD></TR>
<TR valign=top><TD colspan=2>
<B>==, 159, 446</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
actual argument, 5, 16, 30, 31, 41, 45–47, 60, 63, 72,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>&gt;, 446</B> </TD><TD valign=bottom>
84, 85, 103–108, 131, 133, 141, 143, 153, 162,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>&gt;=, 446</B> </TD><TD valign=bottom>
163, 193, 246, 305–307, 310–324, 332–338, 342,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>&, 54, 288</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
348, 349, 370, 394, 395, 411, 420, 433–435, 438,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
615
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
          450, 483, 484, 486, 489–491, 513, 517–519, 522,   ancestor-module-name, 297
<P>
          527–529, 541, 543, 584, 585, 587, 590             and-op (R1019), 51, 150, 150
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>actual-arg (R1524), 311, 311</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
and-operand (R1014), 150, 150
</TD></TR>
<TR valign=top><TD colspan=2>
<B>actual-arg-spec (R1523), 88, 311, 311</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ANINT, 352
</TD></TR>
<TR valign=top><TD colspan=2>
<B>add-op (R1009), 51, 148, 148</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ANY, 353
</TD></TR>
<TR valign=top><TD colspan=2>
<B>add-operand (R1005), 148, 148, 151, 152</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
arg-name, 75, 77, 82
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ADJUSTL, 351</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
argument
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ADJUSTR, 351</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy, 316
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ADVANCE= specifier, 232, 233, 234, 245, 563</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
argument association, 6, 6, 23, 58, 66, 76, 77, 100, 103,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>advancing input/output statement, 221</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
110, 111, 143, 144, 299, 313, 314, 323, 330,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>AIMAG, 351</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
513, 519, 521, 522, 540, 586
</TD></TR>
<TR valign=top><TD colspan=2>
<B>AINT, 351</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
argument keyword, 12, 16, 47, 301, 304, 313, 337, 342,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ALL, 120, 352</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
450, 510, 511, 512, 573
</TD></TR>
<TR valign=top><TD colspan=2>
<B>alloc-opt (R928), 138, 138, 139, 144</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
arithmetic IF statement, 540
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocatable, 5, 5, 20, 31, 45, 46, 58, 60, 61, 71, 76, 77,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array, 5, 7, 13, 20, 46, 102–104, 133–136
</TD></TR>
<TR><TD colspan=2>
<PRE>
          79, 84, 87, 89, 90, 96, 100, 103–106, 110, 113,        assumed-shape, 5, 60, 101, 103, 122, 123, 136, 137,
<P>
          124, 125, 131, 132, 138, 139, 141–144, 163, 165,            301, 315–319, 321, 322, 328, 479, 489, 491, 503,
<P>
          167–170, 172, 173, 193, 207, 237, 238, 243, 285,            584, 601, 607, 609
<P>
          300, 301, 311, 315, 317, 321, 329, 335, 337, 352,      assumed-size, 5, 104, 105, 110, 123, 133, 134, 147,
<P>
          369, 379, 394–396, 407, 408, 410, 411, 421, 424,            164, 167, 189, 200, 237, 315, 316, 320, 395,
<P>
          426, 428, 431, 434, 435, 444, 450, 479, 484,                424, 426, 427, 434, 484, 488, 493, 496, 500,
<P>
          486–488, 493, 500, 502–504, 516, 517, 526                   502, 503, 596, 598, 601
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ALLOCATABLE attribute, 5, 58–60, 68, 69, 74, 75, 98,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
deferred-shape, 5, 103
</TD></TR>
<TR><TD colspan=2>
<PRE>
          98–100, 103, 108, 110, 112, 131, 134, 183, 189,        explicit-shape, 5, 60, 76, 100, 103, 166, 315, 320,
<P>
          199, 200, 298, 301, 306, 307, 317, 320, 328,                488
<P>
          336, 488, 516, 522, 523, 587, 591                 array bound, 7, 76, 78, 97, 165
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ALLOCATABLE statement, 112</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array constructor, 92, 92
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocatable-decl (R830), 112, 112</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array element, 5, 45, 134
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocatable-stmt (R829), 36, 112, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array element order, 134–135
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ALLOCATE statement, 58, 59, 66, 101, 103, 138, 141,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array pointer, 5, 101, 103, 104, 163, 354, 488
</TD></TR>
<TR><TD colspan=2>
<PRE>
          144, 145, 172, 206, 438, 497, 498, 517, 518,      array section, 5, 101, 113, 114, 132, 134–137, 183, 223,
<P>
          525–527, 532, 543                                           315, 316, 321, 322, 516, 519
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocate-coarray-spec (R936), 138, 138, 139</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array-constructor (R769), 92, 93, 147
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocate-coshape-spec (R937), 138, 138, 139</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array-element (R917), 113, 114, 124, 129, 130, 133
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocate-object (R932), 66, 138, 138–145, 206, 438, 440,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array-name, 115, 514
</TD></TR>
<TR><TD colspan=2>
<PRE>
          528, 529, 532                                     array-section (R918), 5, 129, 133, 134, 135
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocate-shape-spec (R933), 138, 138–141</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
array-spec (R815), 28, 95–97, 102, 102–105, 112, 115,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocate-stmt (R927), 37, 138, 529</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
117, 125
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ALLOCATED, 75, 141, 145, 352</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASCII character, 5, 65, 68, 167, 223, 238, 270, 284,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocation (R931), 138, 138–141</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
350, 365, 386, 389, 396–398, 409, 422
</TD></TR>
<TR valign=top><TD colspan=2>
<B>allocation status, 46, 87, 89, 90, 106, 109, 110, 141,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASCII collating sequence, 68, 350, 365, 386, 389, 397,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          141–145, 193, 207, 210, 317, 321, 352, 407, 411,            398, 409
<P>
          504, 522, 526                                     ASIN, 353
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>alphanumeric-character (R601), 49, 49, 50</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASINH, 354
</TD></TR>
<TR valign=top><TD colspan=2>
<B>alt-return-spec (R1525), 7, 204, 311, 311</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASSIGN statement, 539
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ancestor component, 86</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
assigned format, 539
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>616</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                                ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>assigned GO TO statement, 539</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
123–125, 164, 165, 172, 294, 293–297, 303,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ASSIGNMENT, 82, 170, 171, 302, 306, 307</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
331, 334, 511–514, 517
</TD></TR>
<TR valign=top><TD colspan=2>
<B>assignment, 167–179</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
association (R1104), 182, 182
</TD></TR>
<TR><TD colspan=2>
<PRE>
     defined, 81, 170, 306                                    association status, see pointer association status
<P>
     elemental, 12, 171                                       assumed type parameter, 24, 24, 58, 315, 317
<P>
     elemental array (FORALL), 177                            assumed-implied-spec (R821), 104, 104, 105
<P>
     masked array (WHERE), 175                                assumed-rank dummy data object, 6, 45, 60, 83, 84, 101,
<P>
     pointer, 171                                                       102, 136, 199, 200, 300, 301, 307, 315–317, 321,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>assignment statement, 17, 31, 44, 58, 84, 167, 179, 475,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
322, 328, 393–395, 418, 424, 426, 427, 434, 479,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          524                                                           484, 489, 491, 601, 602, 604
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>assignment-stmt (R1032), 37, 167, 167, 175, 177, 178,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
assumed-rank-spec (R825), 102, 105
</TD></TR>
<TR><TD colspan=2>
<PRE>
          528                                                 assumed-shape array, 5, 60, 101, 103, 122, 123, 136, 137,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ASSOCIATE construct, 46, 182, 185, 321, 512, 513,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
301, 315–319, 321, 322, 328, 479, 489, 491, 503,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          516, 528                                                      584, 601, 607, 609
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>associate name, 6, 6, 24, 58, 61, 88, 99, 143, 182, 183,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
assumed-shape-spec (R819), 102, 103, 103
</TD></TR>
<TR><TD colspan=2>
<PRE>
          185, 202, 513, 516, 517, 522, 528                   assumed-size array, 5, 104, 105, 110, 123, 133, 134, 147,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ASSOCIATE statement, 46, 182, 516</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
164, 167, 189, 200, 237, 315, 316, 320, 395,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>associate-construct (R1102), 37, 182, 182</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
424, 426, 427, 434, 484, 488, 493, 496, 500,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>associate-construct-name, 182</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
502, 503, 596, 598, 601
</TD></TR>
<TR valign=top><TD colspan=2>
<B>associate-name, 182, 199–203, 512</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
assumed-size-spec (R822), 102, 104, 104
</TD></TR>
<TR valign=top><TD colspan=2>
<B>associate-stmt (R1103), 7, 182, 182, 204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
assumed-type, 7, 59, 60, 315, 328, 489, 603
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ASSOCIATED, 75, 142, 145, 338, 354</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASYNCHRONOUS attribute, 98, 98, 99, 112, 183, 192,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>associating entity, 6, 46, 66, 137, 182, 183, 185, 187,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
235, 294, 296, 300, 301, 316, 317, 367, 418, 504,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          203, 330, 522, 522                                            505, 507, 514
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>association, 6</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
asynchronous communication, 98, 507
</TD></TR>
<TR><TD colspan=2>
<PRE>
     argument, 6, 6, 23, 58, 66, 76, 77, 100, 103, 110,       asynchronous input/output, 98, 226, 228, 230, 234–236,
<P>
          111, 143, 144, 299, 313, 314, 323, 330, 513,                  239, 240, 247, 250, 251, 253, 255, 257, 258
<P>
          519, 521, 522, 540, 586                             ASYNCHRONOUS statement, 112, 184, 298, 512, 514
<P>
     common, 126                                              asynchronous-stmt (R831), 36, 112
<P>
     construct, 6, 6, 143, 144, 513, 516, 519, 522            ASYNCHRONOUS= specifier, 227, 228, 232, 233, 234,
<P>
     equivalence, 124                                                   254, 255
<P>
     host, 6, 6, 39, 59, 60, 66, 98, 111, 113, 118, 126, 164, ATAN, 355
<P>
          165, 172, 297, 299, 320, 333–335, 511, 513–516,     ATAN2, 32, 355
<P>
          519, 522, 613                                       ATANH, 356
<P>
     inheritance, 6, 6, 9, 47, 86, 88, 519, 522               atomic subroutine, 22, 41, 207, 208, 337, 340, 342, 356–
<P>
     linkage, 6, 6, 506, 513, 516, 516                                  360, 377, 437, 441, 528
<P>
     name, 6, 6, 47, 513, 519                                 ATOMIC_ADD, 356, 438
<P>
     pointer, 6, 6, 12, 22, 23, 44, 47, 85, 87, 89, 101,      ATOMIC_AND, 356
<P>
          106, 108, 110, 111, 131, 143, 145, 171, 173,        ATOMIC_CAS, 357
<P>
          174, 193, 207, 210, 240, 300, 314, 316, 318,        ATOMIC_DEFINE, 357, 592, 593
<P>
          320, 321, 329, 330, 343, 354, 407, 411, 482,        ATOMIC_FETCH_ADD, 357
<P>
          483, 517–520, 522, 528                              ATOMIC_FETCH_AND, 358
<P>
     sequence, 320                                            ATOMIC_FETCH_OR, 358
<P>
     storage, 6, 6, 46, 47, 123–125, 331, 334, 429, 519–      ATOMIC_FETCH_XOR, 359
<P>
          522                                                 ATOMIC_INT_KIND, 356–360, 437
<P>
     use, 6, 6, 31, 39, 47, 60, 66, 86, 98, 109, 111, 118,    ATOMIC_LOGICAL_KIND, 357, 360, 437
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
617
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_OR, 359</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
PASS, 75, 77, 82, 311
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_REF, 359, 592, 593</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
POINTER, 5, 17, 58–60, 68, 69, 74, 75, 96, 103,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ATOMIC_XOR, 360</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
105, 108, 108, 110, 115, 117, 131, 134, 142,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>attr-spec (R802), 95, 95–97, 117</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
172, 183, 192, 199, 200, 299–301, 303, 306, 307,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>attribute, 7, 59, 68, 72, 95–111, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
309, 317, 320–323, 328, 334, 336, 484, 488, 503,
</TD></TR>
<TR><TD colspan=2>
<PRE>
     ABSTRACT, 23, 69, 85                                           516, 519, 522, 523, 543, 587, 591
<P>
     accessibility, 98, 111, 294                                PRIVATE, 71, 86, 98, 98, 111, 123, 335, 571
<P>
     ALLOCATABLE, 5, 58–60, 68, 69, 74, 75, 98, 98–             PROTECTED, 31, 109, 109, 117, 124, 192, 295,
<P>
          100, 103, 108, 110, 112, 131, 134, 183, 189,              543
<P>
          199, 200, 298, 301, 306, 307, 317, 320, 328,          PUBLIC, 86, 98, 98, 111, 123, 571
<P>
          336, 488, 516, 522, 523, 587, 591                     SAVE, 19, 24, 33, 46, 78, 85, 97, 99, 100, 109, 109,
<P>
     ASYNCHRONOUS, 98, 98, 99, 112, 183, 192, 235,                  110, 113, 117, 124, 126, 144, 192, 309, 334, 518
<P>
          294, 296, 300, 301, 316, 317, 367, 418, 504,          SEQUENCE, 19, 69, 71, 71, 72, 85, 125, 172, 173,
<P>
          505, 507, 514                                             202, 486
<P>
     BIND, 6, 7, 44, 69–71, 85, 90, 99, 99, 110, 112,           TARGET, 6, 22, 31, 78, 108, 110, 110, 117, 124,
<P>
          124, 125, 172, 173, 192, 202, 298, 300, 301,              126, 142, 143, 172, 183, 192, 193, 200, 301, 307,
<P>
          327, 329, 486, 487, 489, 504–506, 516, 523, 596           315, 316, 318, 321–323, 367, 407, 418, 481, 484,
<P>
     CODIMENSION, 60, 75, 96, 99, 99, 105, 113                      504, 505, 517–519, 527, 543, 584, 585
<P>
     CONTIGUOUS, 75, 77, 101, 101, 102, 113, 136,               VALUE, 60, 77, 83, 105, 110, 110, 118, 192, 240,
<P>
          137, 173, 192, 300, 315, 317–319, 321, 322, 489,          300, 301, 303, 305, 306, 314–318, 328, 334, 336,
<P>
          491, 520                                                  367, 418, 489, 490, 507, 519, 543, 596, 598
<P>
                                                                VOLATILE, 31, 110, 110, 111, 118, 172, 173, 183,
<P>
     DEFERRED, 81, 82, 85
<P>
                                                                    192, 294, 296, 300, 301, 316–318, 334, 514, 519,
<P>
     DIMENSION, 75, 96, 102, 102, 115, 125
<P>
                                                                    525, 528, 550
<P>
     EXTENDS, 23, 85, 85, 487
<P>
                                                           attribute specification statements, 111–127
<P>
     EXTERNAL, 17, 29, 30, 105, 105, 108, 117, 118,
<P>
                                                           automatic data object, 7, 32, 96, 97, 100, 110, 113, 124,
<P>
          120, 172, 294, 298, 300, 303, 308, 320, 324,
<P>
                                                                    125, 525, 541
<P>
          326, 514, 515, 582
<P>
     INTENT, 105, 105–107, 116, 192, 543                   B
<P>
     INTENT (IN), 105, 106, 107, 111, 189, 305–307,        B edit descriptor, 277
<P>
          315, 318, 320–322, 334, 335, 338, 356–360,       BACKSPACE statement, 218, 221, 247, 250, 251, 252,
<P>
          365–368, 377, 378, 383, 384, 408, 416, 451,               564, 565
<P>
          481–483, 503, 504, 543, 584, 598                 backspace-stmt (R1224), 37, 251, 335
<P>
     INTENT (INOUT), 30, 105, 106, 107, 110, 193,          base object, 7, 98, 101, 124, 131, 137, 164, 235, 321,
<P>
          306, 316, 318, 324, 335, 336, 356–360, 365–368,           334, 336
<P>
          378, 382–384, 407, 408, 438, 440, 528, 529, 598  BESSEL_J0, 360
<P>
     INTENT (OUT), 31, 60, 83–85, 104, 105, 105–           BESSEL_J1, 360
<P>
          107, 110, 143, 164, 306, 316, 318, 324, 334–336, BESSEL_JN, 361
<P>
          356–360, 365–368, 370, 372, 377, 378, 382–384,   BESSEL_Y0, 361
<P>
          407, 408, 416, 430, 453–455, 481, 483, 503, 504, BESSEL_Y1, 361
<P>
          517–519, 524, 525, 527–529, 598                  BESSEL_YN, 362
<P>
     INTRINSIC, 105, 107, 107, 108, 294, 310, 324, 325,    BGE, 362
<P>
          515                                              BGT, 362
<P>
     NON_OVERRIDABLE, 81, 82                               binary-constant (R765), 92, 92
<P>
     NON_RECURSIVE, 301, 327, 327, 331, 332                BIND (C), see BIND attribute
<P>
     OPTIONAL, 108, 108, 110, 116, 164, 183, 189, 301      BIND attribute, 6, 7, 44, 69–71, 85, 90, 99, 99, 110, 112,
<P>
     PARAMETER, 9, 44, 91, 97, 108, 108, 116, 130                   124, 125, 172, 173, 192, 202, 298, 300, 301, 327,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>618</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>329, 486, 487, 489, 504–506, 516, 523, 596</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
362–365, 373–375, 387, 389, 391, 392, 403, 404,
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>BIND statement, 112, 298, 505, 511</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
418
<TABLE width=100% cellpadding=3><!-- tsb: 418
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>bind-entity (R833), 112, 112</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
branch, 204, 332, 539
</TD></TR>
<TR valign=top><TD colspan=2>
<B>bind-stmt (R832), 37, 112</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
branch target statement, 7, 40, 52, 175, 192, 204, 204,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>binding, 7, 81, 82, 82, 86, 87, 160, 171, 243, 249, 307,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
205, 227, 231, 232, 250, 251, 253, 255, 312, 332
</TD></TR>
<TR><TD colspan=2>
<PRE>
          326, 510, 511                                  BTEST, 364
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>binding label, 7, 99, 301, 309, 327, 329, 505–507, 509,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
BZ edit descriptor, 282
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
          510, 543
<P>
</PRE>
binding name, 7, 81, 82, 86, 311, 511
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; C</H4>
</A>
<BLOCKQUOTE>
<P>
C address, 7, 481–484, 486, 487, 492, 497, 499, 526, 527,
</BLOCKQUOTE>
<P>
binding-attr (R752), 81, 82, 82
<P>
<PRE>
                                                                  598
<P>
</PRE>
binding-name, 81, 82, 311, 326, 511
<P>
<PRE>
                                                         C descriptor, 8, 143, 490–505
<P>
</PRE>
binding-private-stmt (R747), 81, 81, 83
<P>
<PRE>
                                                         C_ALERT, 480
<P>
</PRE>
bit model, 338
<P>
<PRE>
                                                         C_ASSOCIATED, 480
<P>
</PRE>
BIT_SIZE, 339, 363, 408
<P>
<PRE>
                                                         C_BACKSPACE, 480
<P>
</PRE>
blank common, 8, 96, 113, 125, 126, 519, 521
<P>
<PRE>
                                                         C_BOOL, 479, 480
<P>
</PRE>
blank interpretation mode, 228
<P>
<PRE>
                                                         C_CARRIAGE_RETURN, 480
<P>
</PRE>
blank-interp-edit-desc (R1318), 267, 268
<P>
<PRE>
                                                         C_CHAR, 480, 543
<P>
</PRE>
BLANK= specifier, 227, 228, 232, 233, 235, 247, 254,
<P>
<PRE>
                                                         C_DOUBLE, 479
<P>
</PRE>
255, 282
<P>
<PRE>
                                                         C_DOUBLE_COMPLEX, 480
<P>
</PRE>
BLE, 363
<P>
<PRE>
                                                         C_F_POINTER, 480, 481
<P>
</PRE>
block, 7
<P>
<PRE>
                                                         C_F_PROCPOINTER, 483
<P>
</PRE>
interface, 295
<P>
<PRE>
                                                         C_FLOAT, 479
<P>
</PRE>
block (R1101), 7, 181, 182, 184–188, 190, 191, 194–196,
<P>
<PRE>
                                                         C_FLOAT_COMPLEX, 480
<P>
</PRE>
199, 201
<P>
<PRE>
                                                         C_FORM_FEED, 480
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>BLOCK construct, 19, 31, 41, 43, 84, 97, 99, 101, 103,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_FUNLOC, 483, 483, 506
</TD></TR>
<TR><TD colspan=2>
<PRE>
          109, 111, 118, 120–122, 143, 164, 183, 334,    C_FUNPTR, 74, 85, 99, 131, 139, 140, 170, 479, 480,
<P>
          512, 518, 519, 525, 527, 532                            483, 486, 487, 527
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block data program unit, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_HORIZONTAL_TAB, 480
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BLOCK DATA statement, 53, 293, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block scoping unit, 14, 19</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT16_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BLOCK statement, 97, 101, 103, 184, 525</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT32_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block-construct (R1107), 37, 184, 184</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT64_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block-construct-name, 184</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT8_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block-data (R1420), 35, 120, 297, 298</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_FAST16_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block-data-name, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_FAST32_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block-data-stmt (R1421), 35, 297, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_FAST64_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block-specification-part (R1109), 20, 184, 184</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_FAST8_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>block-stmt (R1108), 7, 184, 184, 204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_LEAST16_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BLT, 363</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_LEAST32_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>BN edit descriptor, 282</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_LEAST64_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>bound, 5, 7, 7, 45, 46, 75, 87, 90, 103, 138, 140, 144,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INT_LEAST8_T, 479
</TD></TR>
<TR><TD colspan=2>
<PRE>
          145, 173, 207, 407, 513                        C_INTMAX_T, 479
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>bounds, 102–105, 133–136</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_INTPTR_T, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>bounds-remapping (R1036), 171, 172, 172, 173</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_LOC, 60, 105, 335, 484, 543
</TD></TR>
<TR valign=top><TD colspan=2>
<B>bounds-spec (R1035), 171, 172, 172, 173</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_LONG, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>boz-literal-constant (R764), 51, 92, 92, 115, 277, 339,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
C_LONG_DOUBLE, 479
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
619
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>C_LONG_DOUBLE_COMPLEX, 480</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
char-variable (R905), 129, 129, 223
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_LONG_LONG, 479</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
character context, 8, 49, 53–55, 67
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_NEW_LINE, 480</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
character literal constant, 66
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_NULL_CHAR, 480</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
character sequence type, 20, 71, 124–126, 521, 525
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_NULL_FUNPTR, 479, 480</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
character set, 49
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_NULL_PTR, 479, 480</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
character storage unit, 21, 21, 104, 124, 126, 437, 520,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_PTR, 74, 85, 99, 131, 139, 140, 170, 479–481, 484,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
524, 526
</TD></TR>
<TR><TD colspan=2>
<PRE>
          486, 487, 490, 526, 527, 596                  character string edit descriptor, 266, 283
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_SHORT, 479</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
character type, 65–68
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_SIGNED_CHAR, 479</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CHARACTER_KINDS, 437
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_SIZE_T, 479</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CHARACTER_STORAGE_SIZE, 437
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_SIZEOF, 105, 164, 484</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
characteristics, 8, 86, 174, 243, 244, 300, 301, 303, 309,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>C_VERTICAL_TAB, 480</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
310, 319, 324, 327, 329, 331, 349, 411
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CALL statement, 22, 204, 207, 299, 311, 324, 332, 407</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy argument, 300
</TD></TR>
<TR valign=top><TD colspan=2>
<B>call-stmt (R1521), 37, 311, 312, 313</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
procedure, 300
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CASE statement, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
child data transfer statement, 222, 223, 234–236, 239,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>case-construct (R1140), 37, 196, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
245, 243–247, 262, 286
</TD></TR>
<TR valign=top><TD colspan=2>
<B>case-construct-name, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CLASS, 59, 59, 60, 243
</TD></TR>
<TR valign=top><TD colspan=2>
<B>case-expr (R1144), 197, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CLASS DEFAULT statement, 202
</TD></TR>
<TR valign=top><TD colspan=2>
<B>case-selector (R1145), 197, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CLASS IS statement, 202, 379
</TD></TR>
<TR valign=top><TD colspan=2>
<B>case-stmt (R1142), 196, 197, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CLOSE statement, 218, 219, 223, 225, 226, 230, 230,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>case-value (R1147), 197, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
247, 250, 564
</TD></TR>
<TR valign=top><TD colspan=2>
<B>case-value-range (R1146), 197, 197</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
close-spec (R1209), 231, 231
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CEILING, 364</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
close-stmt (R1208), 37, 231, 335
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_address, 496</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CMPLX, 169, 339, 365, 445
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_allocate, 497, 504</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CO_BROADCAST, 365
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_cdesc_t, 8, 489–491, 492, 492–494, 496–502, 504</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CO_MAX, 366
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_deallocate, 494, 498, 504</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CO_MIN, 366
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_establish, 498</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CO_REDUCE, 367, 535
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_is_contiguous, 500</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CO_SUM, 368, 535
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_section, 500</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
coarray, 8, 8, 10, 31, 41, 45, 46, 70, 75, 76, 84, 99–101,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_select_part, 501</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
106, 108, 110, 111, 124, 125, 132, 138–141, 144,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CFI_setpointer, 502</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
145, 167, 168, 170, 172, 173, 183, 185–187, 189,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CHANGE TEAM construct, 22, 46, 137, 183, 185, 191,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
206–208, 294, 301, 311, 316, 318, 319, 321, 322,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          204, 512, 513, 528                                      324, 328, 341, 342, 345, 347, 356–360, 369, 390,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CHANGE TEAM statement, 22, 40, 46, 185, 206, 215,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
395, 407, 431, 432, 434, 435, 440, 488
</TD></TR>
<TR><TD colspan=2>
<PRE>
          341, 516                                           established, 8, 46, 186
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>change-team-construct (R1111), 37, 185, 185</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
coarray-association (R1113), 46, 185, 185
</TD></TR>
<TR valign=top><TD colspan=2>
<B>change-team-stmt (R1112), 185, 185</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
coarray-name, 113, 185, 512, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>changeable mode, 224</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
coarray-spec (R809), 74–76, 95, 96, 99, 99, 100, 112,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CHAR, 67, 364</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
113, 117
</TD></TR>
<TR valign=top><TD colspan=2>
<B>char-length (R723), 65, 65, 66, 74, 75, 95–97, 542</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
cobound, 8, 45, 46, 99–101, 137, 140, 165, 183, 187, 319,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>char-literal-constant (R724), 51, 55, 56, 66, 246, 267,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
345, 347, 395, 407, 434, 435, 513
</TD></TR>
<TR><TD colspan=2>
<PRE>
          268, 531                                      codimension, 8, 8, 10, 45, 101, 137, 183, 300, 369, 395,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>char-selector (R721), 61, 65, 66</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
435
</TD></TR>
<TR valign=top><TD colspan=2>
<B>char-string-edit-desc (R1321), 266, 268</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CODIMENSION attribute, 60, 75, 96, 99, 99, 105, 113
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>620</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>codimension-decl (R835), 113, 113, 183, 185, 186, 512</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
component definition statement, 74
</TD></TR>
<TR valign=top><TD colspan=2>
<B>codimension-stmt (R834), 37, 113, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
component keyword, 16, 47, 80, 89, 511
</TD></TR>
<TR valign=top><TD colspan=2>
<B>coindexed object, 8, 31, 41, 45, 46, 78, 113, 131, 137,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
component order, 9, 80, 89, 238
</TD></TR>
<TR><TD colspan=2>
<PRE>
          139, 167, 168, 170, 172, 173, 182, 208, 212, 311, component-array-spec (R740), 74, 74–76
<P>
          312, 315–318, 321, 322, 334, 356–360, 365–368,    component-attr-spec (R738), 74, 74, 75, 77, 78
<P>
          377, 407, 441, 481, 483, 484                      component-data-source (R758), 88, 88, 89
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>coindexed-named-object (R914), 129, 130, 132, 132</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
component-decl (R739), 66, 74, 74–76, 78
</TD></TR>
<TR valign=top><TD colspan=2>
<B>collating sequence, 8, 67, 68, 159, 270, 350, 364, 365,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
component-def-stmt (R736), 9, 74, 74, 75
</TD></TR>
<TR><TD colspan=2>
<PRE>
          386, 389, 397, 398, 401–406, 409                  component-initialization (R743), 74, 77, 78
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>collective subroutine, 22, 337, 341, 342, 365–368, 380,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
component-name, 74, 78
</TD></TR>
<TR><TD colspan=2>
<PRE>
          428, 441                                          component-part (R735), 69, 74, 80, 83
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>COMMAND_ARGUMENT_COUNT, 166, 368, 383</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
component-spec (R757), 88, 88, 165
</TD></TR>
<TR valign=top><TD colspan=2>
<B>comment, 54, 55, 290</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
computed GO TO statement, 7, 204, 205, 540, 541
</TD></TR>
<TR valign=top><TD colspan=2>
<B>common association, 126</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
computed-goto-stmt (R1158), 38, 205, 205
</TD></TR>
<TR valign=top><TD colspan=2>
<B>common block, 8, 33, 38, 44, 96, 97, 99, 109, 110, 112,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
concat-op (R1011), 51, 149, 149
</TD></TR>
<TR><TD colspan=2>
<PRE>
          113, 124–127, 164, 297, 298, 505, 506, 509–512,   CONCURRENT, 188
<P>
          516, 519–521, 526, 542                            concurrent-control (R1126), 177, 178, 189, 189, 190
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>common block storage sequence, 126</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
concurrent-header (R1125), 177–179, 188, 189, 189, 512
</TD></TR>
<TR valign=top><TD colspan=2>
<B>COMMON statement, 8, 125, 125–127, 184, 296, 298,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
concurrent-limit (R1127), 153, 178, 189, 189–191
</TD></TR>
<TR><TD colspan=2>
<PRE>
          511, 521, 540                                     concurrent-locality (R1129), 188, 189, 189
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>common-block-name, 112, 117, 125, 184, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
concurrent-step (R1128), 153, 178, 189, 189–191
</TD></TR>
<TR valign=top><TD colspan=2>
<B>common-block-object (R874), 125, 125, 296, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
conformable, 9, 45, 141, 153, 161, 167, 171, 324, 336,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>common-stmt (R873), 37, 125, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
380, 387, 388, 392, 401, 402, 404, 405, 413,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>companion processor, 7, 9, 15, 42, 47, 48, 69, 91, 99,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
415, 429, 435, 465
</TD></TR>
<TR><TD colspan=2>
<PRE>
          479, 484, 506, 507                                CONJG, 368
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>compatibility</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
connect-spec (R1205), 226, 226, 227
</TD></TR>
<TR><TD colspan=2>
<PRE>
     Fortran 77, 32                                         connected, 9, 13, 16, 18, 218–222, 225, 226, 228–231,
<P>
     Fortran 2003, 31                                                236, 240, 242, 243
<P>
     Fortran 2008, 30                                       connection mode, 224
<P>
     Fortran 90, 32                                         constant, 9, 44, 51, 57
<P>
     Fortran 95, 31                                             integer, 62
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>COMPILER_OPTIONS, 164, 437</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
named, 116
</TD></TR>
<TR valign=top><TD colspan=2>
<B>COMPILER_VERSION, 164, 437</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
constant (R604), 51, 51, 114, 130, 147
</TD></TR>
<TR valign=top><TD colspan=2>
<B>completion step, 42, 231</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
constant expression, 7, 10, 24, 32, 57, 58, 66, 73, 75, 76,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>complex part designator, 11, 43, 132</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
78, 93, 97, 101, 103, 104, 113, 114, 116, 124,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>complex type, 64–65</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
164, 165, 166, 166, 234, 300, 301, 321, 338,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>complex-literal-constant (R718), 51, 64</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
350, 351, 353, 364, 365, 369, 370, 380, 381, 386,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>complex-part-designator (R915), 129, 132, 132, 133, 137</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
389, 391, 394–396, 399–401, 405, 409, 418, 420,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>component, 9, 10, 15, 16, 20, 21, 69–71, 74, 89, 118,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
422, 424, 426, 428, 434–436, 488, 543
</TD></TR>
<TR><TD colspan=2>
<PRE>
          511                                               constant-expr (R1029), 24, 58, 77, 78, 96, 97, 104, 105,
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>direct, 9, 9, 69, 78, 316, 444, 486</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
108, 116, 166, 166, 197
</TD></TR>
<TR valign=top><TD colspan=2>
<B>parent, 6, 9, 80, 84, 86, 89, 522, 552</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
constant-subobject (R847), 114, 114
</TD></TR>
<TR valign=top><TD colspan=2>
<B>potential subobject, 9, 69, 70, 335</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
construct
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ultimate, 9, 31, 68–70, 75, 99, 101, 104, 105, 110,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASSOCIATE, 46, 181, 182, 185, 199, 321, 512, 513,
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
          124, 125, 139, 142, 166, 167, 243, 315, 316,               516, 528
<P>
          334, 520                                              BLOCK, xix, 14, 19, 20, 31, 41, 43, 84, 97, 99,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
621
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
          101, 103, 109, 111, 118, 120–122, 143, 164, 181,            435, 513
<P>
          183, 334, 512, 518, 519, 525, 527, 532           COS, 369
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>CHANGE TEAM, xx, 22, 46, 137, 181, 183, 185,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
COSH, 369
</TD></TR>
<TR><TD colspan=2>
<PRE>
          191, 204, 512, 513, 528                          COSHAPE, 369
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CRITICAL, 181, 187, 187, 191, 204, 341</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
cosubscript, 10, 45, 46, 101, 137, 345, 347, 390, 431,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DO, 41, 52, 93, 181, 188, 204, 238, 539, 554, 555</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
432, 435
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DO CONCURRENT, xviii, 30, 31, 188, 191, 195,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
cosubscript (R925), 131, 137, 137
</TD></TR>
<TR><TD colspan=2>
<PRE>
          204, 335, 512, 519, 525, 527, 532, 542           COUNT, 338, 370
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FORALL, 177, 335, 512, 525, 540, 542</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CPU_TIME, 370
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IF, 41, 181, 195, 452, 539</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CRITICAL construct, 187, 191, 204
</TD></TR>
<TR valign=top><TD colspan=2>
<B>nonblock DO, xviii, 540</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CRITICAL statement, 161, 187, 206, 207, 216
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SELECT CASE, 41, 181, 196, 540, 541, 553</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
critical-construct (R1116), 37, 187, 187
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SELECT RANK, xviii, 41, 46, 104, 105, 181, 183,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
critical-construct-name, 187
</TD></TR>
<TR><TD colspan=2>
<PRE>
          199, 321, 528                                    critical-stmt (R1117), 7, 187, 187, 204
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SELECT TYPE, 41, 46, 58, 59, 181, 183, 201, 321,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CSHIFT, 371
</TD></TR>
<TR><TD colspan=2>
<PRE>
          512, 513, 516, 528                               current record, 221
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>WHERE, 17, 175</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
current team, 22, 84, 137, 140, 141, 144, 145, 185, 186,
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>construct association, 6, 6, 143, 144, 513, 516, 519, 522</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
208, 209, 211–213, 215, 341, 365, 380, 385, 390,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>construct entity, 6, 10, 111, 121, 182, 184, 185, 189,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
407, 412, 428, 431, 432, 435, 438, 441
</TD></TR>
<TR><TD colspan=2>
<PRE>
          192, 201, 509, 510, 512, 519                     CURRENT_TEAM, 385, 438
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>construct-name, 204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
CYCLE statement, 182, 188, 191, 192, 542
</TD></TR>
<TR valign=top><TD colspan=2>
<B>constructor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
cycle-stmt (R1133), 37, 191, 191
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
     array, 92
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; D</H4>
</A>
<BLOCKQUOTE>
<P>
derived-type, 88
<P>
<PRE>
                                                           d (R1310), 267, 267, 272–276, 279, 280, 286
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>structure, 88</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
D edit descriptor, 273
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>CONTAINS statement, 39, 40, 81, 332</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data edit descriptor, 266, 270–280
<TABLE width=100% cellpadding=3><!-- tsb: data edit descriptor, 266, 270–280
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>contains-stmt (R1543), 36, 81, 294, 332</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data entity, 8, 9, 10, 17–19, 25, 43–45
</TD></TR>
<TR valign=top><TD colspan=2>
<B>contiguous, 10, 20, 30, 71, 77, 101, 130, 137, 173, 174,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data object, 7–9, 10, 10, 11, 19, 21, 24, 38–40, 43–46
</TD></TR>
<TR><TD colspan=2>
<PRE>
          183, 193, 235, 242, 393, 484, 520, 543           data object designator, 11, 19, 45, 129
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CONTIGUOUS attribute, 75, 77, 101, 101, 102, 113,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data object reference, 19, 44, 46
</TD></TR>
<TR><TD colspan=2>
<PRE>
          136, 137, 173, 192, 300, 315, 317–319, 321, 322, data pointer, 17, 17, 46, 481, 493, 503, 520
<P>
          489, 491, 520                                    DATA statement, 32, 33, 40, 92, 97, 113, 126, 298, 411,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CONTIGUOUS statement, 113</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
512, 515, 523, 540, 541
</TD></TR>
<TR valign=top><TD colspan=2>
<B>contiguous-stmt (R836), 37, 113</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data transfer, 241
</TD></TR>
<TR valign=top><TD colspan=2>
<B>continuation, 54, 55</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data transfer input statement, 231
</TD></TR>
<TR valign=top><TD colspan=2>
<B>CONTINUE statement, 205, 539</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data transfer output statement, 231
</TD></TR>
<TR valign=top><TD colspan=2>
<B>continue-stmt (R1159), 37, 189, 205</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data transfer statement, 33, 52, 217–223, 225, 231, 236,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>control character, 49, 67, 217, 220</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
239–241, 246, 250, 252, 260–263, 265, 266, 277,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>control edit descriptor, 266, 280–283</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
282, 284–286, 288, 290, 439, 524, 526, 534, 563,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>control information list, 232</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
564, 567, 568
</TD></TR>
<TR valign=top><TD colspan=2>
<B>control mask, 176</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data type, 23, see type
</TD></TR>
<TR valign=top><TD colspan=2>
<B>control-edit-desc (R1313), 266, 267</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data-component-def-stmt (R737), 74, 74–76
</TD></TR>
<TR valign=top><TD colspan=2>
<B>conversion</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data-edit-desc (R1307), 266, 267
</TD></TR>
<TR><TD colspan=2>
<PRE>
     numeric, 169                                          data-i-do-object (R841), 113, 113, 114
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>corank, 10, 45, 46, 76, 99, 100, 102, 131, 137, 139, 147,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data-i-do-variable (R842), 113, 113, 114, 166, 512
</TD></TR>
<TR><TD colspan=2>
<PRE>
          183, 187, 300, 318, 369, 390, 395, 407, 431,     data-implied-do (R840), 113, 113, 114, 166, 512
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>622</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>data-pointer-component-name, 171, 172</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
260
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-pointer-initialization compatible, 77</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
default-initialized, 10, 78, 106, 328, 517–519, 523, 525,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-pointer-object (R1034), 171, 171–173, 178, 354,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
527
</TD></TR>
<TR><TD colspan=2>
<PRE>
          529                                                DEFERRED attribute, 81, 82, 85
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-ref (R911), 7, 130, 131–133, 172, 235, 311, 313,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
deferred type parameter, 24, 24, 31, 58, 66, 90, 108,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          321, 326                                                     126, 132, 139–141, 144, 145, 167, 168, 173,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-stmt (R837), 36, 113, 303, 334, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
193, 207, 285, 300, 317, 396, 411, 428, 481,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-stmt-constant (R845), 92, 114, 114, 115</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
483, 489, 517, 522
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-stmt-object (R839), 113, 113–115</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
deferred-coshape-spec (R810), 74, 99, 100, 100
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-stmt-repeat (R844), 114, 114</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
deferred-shape array, 5, 103
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-stmt-set (R838), 113, 113</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
deferred-shape-spec (R820), 5, 74, 102, 103, 103, 116
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-stmt-value (R843), 113, 114, 114</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
definable, 10, 106–109, 136, 168, 183, 237, 314, 316,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>data-target (R1037), 88, 89, 109, 171, 172, 172, 173,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
318, 323, 519, 528
</TD></TR>
<TR><TD colspan=2>
<PRE>
          178, 321, 334, 354, 520                            defined, 10, 11, 25, 44, 46
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DATE_AND_TIME, 372</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
defined assignment, 11, 22, 167, 170, 171, 175, 178, 299,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DBLE, 339, 373</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
306, 311, 316, 335
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DC edit descriptor, 283</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
defined assignment statement, 31, 171, 324, 528
</TD></TR>
<TR valign=top><TD colspan=2>
<B>dealloc-opt (R941), 142, 142, 144</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
defined input/output, 11, 224, 229, 237–239, 243, 245,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DEALLOCATE statement, 142, 144, 145, 206, 438,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
246, 246, 247, 243–249, 260, 280, 286, 287,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          498, 532                                                     291, 299, 305, 307, 311, 324, 335, 439, 588
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>deallocate-stmt (R940), 37, 142, 529</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
defined operation, 11, 19, 151, 160, 161–163, 189, 299,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>decimal edit descriptor, 283</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
305, 311, 324, 335
</TD></TR>
<TR valign=top><TD colspan=2>
<B>decimal edit mode, 228</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
defined-binary-op (R1023), 17, 52, 150, 150, 151, 160,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>decimal symbol, 10, 228, 235, 255, 270–276, 283, 284</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
295
</TD></TR>
<TR valign=top><TD colspan=2>
<B>decimal-edit-desc (R1320), 267, 268</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
defined-io-generic-spec (R1509), 11, 82, 243, 244, 249,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DECIMAL= specifier, 227, 228, 232, 233, 235, 247,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
302, 302, 305, 307
</TD></TR>
<TR><TD colspan=2>
<PRE>
          254, 255, 283                                      defined-operator (R609), 52, 82, 296, 302, 543
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>declaration, 10, 39, 95–127</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
defined-unary-op (R1003), 17, 52, 148, 148, 151, 160,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>declaration-construct (R507), 36, 36, 184</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
295
</TD></TR>
<TR valign=top><TD colspan=2>
<B>declaration-type-spec (R703), 59, 59, 66, 74, 75, 95, 97,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
definition, 10, 11
</TD></TR>
<TR><TD colspan=2>
<PRE>
          118, 164, 308, 309, 327, 330                       definition of variables, 523
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>declared type, 23, 60, 61, 77, 89, 90, 93, 95, 130, 132,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
deleted features, 29, 30, 32, 33, 539, 540
</TD></TR>
<TR><TD colspan=2>
<PRE>
          139, 140, 142, 160, 162, 167, 170–173, 182, 202,   DELIM= specifier, 227, 228, 232, 233, 235, 247, 254,
<P>
          203, 249, 306, 311, 314, 317, 326, 333, 379, 403,            256, 289, 291, 565
<P>
          407, 421, 438, 440, 513                            delimiter mode, 228
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DEFAULT, 189, 197, 202</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
derived type, 11, 21, 23, 42, 43, 46, 57, 68–90, 93, 486,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>default character, 65</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
487
</TD></TR>
<TR valign=top><TD colspan=2>
<B>default complex, 64</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
derived type definition statement, see TYPE statement
</TD></TR>
<TR><TD colspan=2>
default initialization, 10, 10, 76–79, 88, 89, 97, 104, 105, derived type determination, 71
</TD></TR>
<TR><TD colspan=2>
<PRE>
          113, 124, 125, 127, 316, 411, 517, 522, 526        derived-type type specifier, 59
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>default real, 63</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
derived-type-def (R726), 36, 59, 60, 69, 70, 73, 487
</TD></TR>
<TR valign=top><TD colspan=2>
<B>default-char-constant-expr (R1030), 99, 166, 166, 232,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
derived-type-spec (R754), 24, 59, 60, 66, 87, 88, 202,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          233                                                          243, 511
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>default-char-expr (R1025), 162, 162, 166, 205, 226–232,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
derived-type-stmt (R727), 69, 69, 70, 73, 98, 514
</TD></TR>
<TR><TD colspan=2>
<PRE>
          234–236                                            descendant, 11, 39, 70, 80, 81, 83, 109, 297, 510
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>default-char-variable (R906), 129, 129, 138, 227, 254–</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
designator, 8, 11, 11, 47, 104, 105, 110, 113, 124, 125,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
623
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
           133, 133, 162, 164, 165, 288, 320, 321, 334,                88, 96, 98–100, 103–108, 110, 111, 113, 116,
<P>
           336                                                         118, 122, 124, 125, 139–141, 143, 144, 160, 163,
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>data object, 129</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
164, 170, 189, 193, 207, 240, 245, 246, 299–308,
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>designator (R901), 78, 113, 114, 129, 129, 131, 132,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
310, 311, 313–321, 328, 331, 332, 334–336, 438,
</TD></TR>
<TR><TD colspan=2>
<PRE>
           147, 172, 182, 287, 334, 369, 390, 395, 431,                489–491, 511–513, 519, 528, 529, 543, 573, 584
<P>
           435                                                    characteristics of, 300
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>designator, 147</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
restrictions, 321
</TD></TR>
<TR valign=top><TD colspan=2>
<B>digit, 27, 28, 49, 49, 52, 62, 92, 285</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy data object, 6, 8, 12, 60, 77, 97, 104–106, 110,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>digit-string (R711), 62, 62, 63, 271, 272, 278</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
300, 305–307
</TD></TR>
<TR valign=top><TD colspan=2>
<B>digit-string, 62</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
assumed-rank, 6, 45, 60, 83, 84, 101, 102, 136, 199,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DIGITS, 373</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
200, 300, 301, 307, 315–317, 321, 322, 328,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DIM, 373</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
393–395, 418, 424, 426, 427, 434, 479, 484, 489,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DIMENSION attribute, 75, 96, 102, 102, 115, 125</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
491, 601, 602, 604
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DIMENSION statement, 115, 298</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy function, 12, 66, 96
</TD></TR>
<TR valign=top><TD colspan=2>
<B>dimension-spec (R814), 102</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy procedure, 8, 12, 14, 18, 105, 118, 121, 123, 165,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>dimension-stmt (R848), 37, 115, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
172, 299, 300, 302–304, 308, 309, 312, 319, 320,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>direct access, 219</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
326, 328, 330, 334, 507, 510, 515
</TD></TR>
<TR valign=top><TD colspan=2>
<B>direct access data transfer statement, 236</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy-arg (R1536), 330, 330–332
</TD></TR>
<TR valign=top><TD colspan=2>
<B>direct component, 9, 9, 69, 78, 316, 444, 486</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy-arg-name (R1531), 116, 117, 299, 328, 328, 330,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DIRECT= specifier, 254, 256</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
333, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>disassociated, 11, 12, 24, 46, 61, 77–79, 97, 103, 115,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dynamic type, 17, 23, 24, 60, 61, 84, 85, 87, 90, 93,
</TD></TR>
<TR><TD colspan=2>
<PRE>
           142, 144, 145, 163, 171, 173, 309, 321, 337,                110, 140, 142, 144, 160, 162, 168, 170, 171,
<P>
           346, 379, 410, 411, 421, 428, 450, 517, 518,                173, 183, 201, 202, 207, 210, 249, 311, 317,
<P>
           520, 527                                                    326, 347, 379, 403, 407, 421, 429, 490, 513,
<P>
                                                                       517, 522, 552, 601
<P>
</PRE>
distinguishable, 307
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DO CONCURRENT construct, 30, 31, 188, 191, 195,</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
           204, 335, 512, 519, 525, 527, 532, 542            e (R1311), 267, 267, 273–276, 279, 280, 286
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DO CONCURRENT statement, 59, 178, 188</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
E edit descriptor, 273
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DO construct, 41, 52, 93, 188, 204, 238, 539, 554, 555</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
edit descriptor, 266
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DO statement, 188, 524, 540, 542</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
/, 281
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DO WHILE statement, 188</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
:, 281
</TD></TR>
<TR valign=top><TD colspan=2>
<B>do-construct (R1119), 37, 188, 190, 191, 204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
A, 278
</TD></TR>
<TR valign=top><TD colspan=2>
<B>do-construct-name, 188–191</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
B, 277
</TD></TR>
<TR valign=top><TD colspan=2>
<B>do-stmt (R1120), 7, 188, 188, 190, 204, 528</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
BN, 282
</TD></TR>
<TR valign=top><TD colspan=2>
<B>do-variable (R1124), 93, 113, 188, 188–190, 237, 260,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
BZ, 282
</TD></TR>
<TR><TD colspan=2>
<PRE>
           261, 263, 285, 524, 526, 528, 564                      character string, 266, 283
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DOT_PRODUCT, 373</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
control, 266, 280–283
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DOUBLE PRECISION, 53, 61, 63, 69</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
D, 273
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DP edit descriptor, 283</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data, 266, 270–280
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DPROD, 374</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
DC, 283
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DSHIFTL, 374</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
decimal, 283
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DSHIFTR, 375</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
DP, 283
</TD></TR>
<TR valign=top><TD colspan=2>
<B>DT edit descriptor, 280</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
DT, 280
</TD></TR>
<TR valign=top><TD colspan=2>
<B>dtv-type-spec (R1221), 243</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
E, 273
</TD></TR>
<TR valign=top><TD colspan=2>
<B>dummy argument, 5, 6, 8, 12, 12, 16–18, 24, 25, 30,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EN, 274
</TD></TR>
<TR><TD colspan=2>
<PRE>
           41, 46, 47, 50, 58–61, 66, 72, 75, 77, 82–84, 86,      ES, 275
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>624</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>EX, 276</B> </TD><TD valign=bottom>
else-stmt (R1137), 195, 195
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>F, 272</B> </TD><TD valign=bottom>
ELSEWHERE statement, 53, 175
</TD></TR>
<TR valign=top><TD colspan=2>
<B>G, 278, 279</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
elsewhere-stmt (R1048), 175, 175
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>H, 539</B> </TD><TD valign=bottom>
EN edit descriptor, 274
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>I, 271</B> </TD><TD valign=bottom>
ENCODING= specifier, 227, 228, 254, 256, 533
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>L, 278</B> </TD><TD valign=bottom>
END ASSOCIATE statement, 53, 182
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>O, 277</B> </TD><TD valign=bottom>
END BLOCK DATA statement, 53, 297
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>P, 282</B> </TD><TD valign=bottom>
END BLOCK statement, 53, 144, 184
</TD></TR>
<TR valign=top><TD colspan=2>
<B>position, 280</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
END CRITICAL statement, 53, 161, 187, 206, 207
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RC, 282</B> </TD><TD valign=bottom>
END DO statement, 53, 189
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RD, 282</B> </TD><TD valign=bottom>
END ENUM statement, 53, 90
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RN, 282</B> </TD><TD valign=bottom>
END FORALL statement, 53, 177
</TD></TR>
<TR valign=top><TD colspan=2>
<B>round, 282</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
END FUNCTION statement, 53, 328
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RP, 282</B> </TD><TD valign=bottom>
END IF statement, 53, 195, 539
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RU, 282</B> </TD><TD valign=bottom>
END INTERFACE statement, 53, 302
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>RZ, 282</B> </TD><TD valign=bottom>
END MODULE statement, 53, 294
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>S, 282</B> </TD><TD valign=bottom>
END PROCEDURE statement, 53, 331
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SP, 282</B> </TD><TD valign=bottom>
END PROGRAM statement, 53, 293
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>SS, 282</B> </TD><TD valign=bottom>
END SELECT statement, 53, 197, 202
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>T, 281</B> </TD><TD valign=bottom>
END statement, 13, 40, 40, 41, 53, 55, 84, 85, 109, 126,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>TL, 281</B> </TD><TD valign=bottom>
143, 144, 207, 482, 527
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>TR, 281</B> </TD><TD valign=bottom>
END SUBMODULE statement, 53, 297
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>X, 281</B> </TD><TD valign=bottom>
END SUBROUTINE statement, 53, 330
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>Z, 277</B> </TD><TD valign=bottom>
END TEAM statement, 40, 53, 185, 206, 215, 341
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>effective argument, 5, 6, 12, 24, 58, 60, 61, 66, 101–106,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
END TYPE statement, 53, 70
</TD></TR>
<TR><TD colspan=2>
<PRE>
           207, 314–317, 319, 320, 323, 326, 418, 482, 490, END WHERE statement, 53, 175
<P>
           513, 519, 522, 524, 527                          end-associate-stmt (R1106), 7, 182, 182, 204
<P>
</PRE>
effective item, 12, 238, 241, 242, 246, 247, 249, 261, 268, end-block-data-stmt (R1422), 13, 35, 40, 297, 297
</TD></TR>
<TR><TD colspan=2>
<PRE>
           269, 281, 284, 285, 289                          end-block-stmt (R1110), 7, 184, 184, 204
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>effective position, 308</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-change-team-stmt (R1114), 185, 185, 186
</TD></TR>
<TR valign=top><TD colspan=2>
<B>element sequence, 320</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-critical-stmt (R1118), 7, 187, 187, 204
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ELEMENTAL, 13, 327, 327, 328, 332, 334, 336</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-do (R1131), 188, 189, 190, 192
</TD></TR>
<TR><TD colspan=2>
elemental, 12, 22, 45, 66, 84, 86, 160, 161, 166, 171, 174, end-do-stmt (R1132), 7, 189, 189, 190, 204
</TD></TR>
<TR><TD colspan=2>
<PRE>
           175, 177, 299–301, 309, 316, 319, 324, 325, 332, end-enum-stmt (R763), 90, 90
<P>
           336, 337, 342, 361, 362, 408, 450–452            end-forall-stmt (R1054), 177, 177, 178
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>elemental array assignment (FORALL), 177</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-function-stmt (R1533), 7, 13, 20, 35, 40, 204, 302,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>elemental assignment, 12, 171</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
328, 328, 329, 332
</TD></TR>
<TR valign=top><TD colspan=2>
<B>elemental operation, 12, 153, 163, 177</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-if-stmt (R1138), 7, 195, 195, 204
</TD></TR>
<TR valign=top><TD colspan=2>
<B>elemental operator, 12, 153, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-interface-stmt (R1504), 302, 302
</TD></TR>
<TR valign=top><TD colspan=2>
<B>elemental procedure, 12, 45, 163, 173, 309, 312, 321,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-module-stmt (R1406), 13, 35, 40, 294, 294
</TD></TR>
<TR><TD colspan=2>
<PRE>
           325, 327, 335, 335–338                           end-mp-subprogram-stmt (R1540), 7, 13, 20, 36, 40, 204,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>elemental reference, 13, 177, 316, 324–326, 336</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
330, 331, 331, 332
</TD></TR>
<TR valign=top><TD colspan=2>
<B>elemental subprogram, 13, 327, 328, 335, 336</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-program-stmt (R1403), 7, 13, 20, 35, 40, 42, 85, 204,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ELSE IF statement, 53, 195</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
205, 293, 293
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ELSE statement, 195</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-select-rank-stmt (R1151), 7, 199, 199, 200, 204
</TD></TR>
<TR valign=top><TD colspan=2>
<B>else-if-stmt (R1136), 195, 195</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
end-select-stmt (R1143), 7, 196, 197, 197, 204
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
625
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>end-select-type-stmt (R1155), 7, 201, 202, 202–204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
error indicator, 496
</TD></TR>
<TR valign=top><TD colspan=2>
<B>end-submodule-stmt (R1419), 13, 35, 40, 297, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ERROR STOP statement, 41, 42, 205, 532
</TD></TR>
<TR><TD colspan=2>
end-subroutine-stmt (R1537), 7, 13, 20, 35, 40, 204, 302, error termination, 42, 85, 141, 143, 205, 246, 260, 261,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          330, 330, 332                                              341, 356–360, 377, 378, 407, 419, 531, 534
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>end-type-stmt (R730), 69, 70</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
error-stop-stmt (R1161), 37, 85, 205
</TD></TR>
<TR valign=top><TD colspan=2>
<B>end-where-stmt (R1049), 175, 175</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ERROR_UNIT, 224, 225, 229, 438
</TD></TR>
<TR valign=top><TD colspan=2>
<B>END= specifier, 7, 232, 233, 250, 251, 261</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ES edit descriptor, 275
</TD></TR>
<TR valign=top><TD colspan=2>
<B>endfile record, 218</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
established coarray, 8, 46, 137, 186
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ENDFILE statement, 53, 218, 219, 221, 228, 247, 250,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
evaluation
</TD></TR>
<TR><TD colspan=2>
<PRE>
          252, 564                                             operations, 153
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>endfile-stmt (R1225), 37, 251, 335</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
optional, 161
</TD></TR>
<TR valign=top><TD colspan=2>
<B>entity-decl (R803), 66, 75, 95, 96, 96, 97, 165, 166, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
parentheses, 162
</TD></TR>
<TR valign=top><TD colspan=2>
<B>entity-name, 112, 117</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EVENT POST statement, 206, 207, 211, 212, 215, 377,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ENTRY statement, 12, 40, 160, 170, 294, 299, 303, 327,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
438, 525, 528, 533
</TD></TR>
<TR><TD colspan=2>
<PRE>
          328, 331, 511, 521, 540, 542                    event variable, 25, 41, 207, 212, 215, 377, 438, 525
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>entry-name, 328, 331, 511</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EVENT WAIT statement, 206, 207, 212, 212, 215, 438,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>entry-stmt (R1541), 36, 294, 297, 303, 331, 331, 511,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
525, 528, 533
</TD></TR>
<TR><TD colspan=2>
<PRE>
          514                                             event-post-stmt (R1170), 37, 211
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ENUM statement, 90</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
event-variable (R1171), 211, 211, 212, 215, 438, 528
</TD></TR>
<TR valign=top><TD colspan=2>
<B>enum-def (R759), 36, 90, 90, 91</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
event-wait-spec (R1173), 212, 212
</TD></TR>
<TR valign=top><TD colspan=2>
<B>enum-def-stmt (R760), 90, 90</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
event-wait-stmt (R1172), 37, 212, 212
</TD></TR>
<TR valign=top><TD colspan=2>
<B>enumeration, 90</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EVENT_QUERY, xx, 377, 560, 594
</TD></TR>
<TR valign=top><TD colspan=2>
<B>enumerator, 90</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EVENT_TYPE, 25, 70, 106, 139, 140, 211, 438
</TD></TR>
<TR valign=top><TD colspan=2>
<B>enumerator (R762), 90, 90</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EX edit descriptor, 276
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ENUMERATOR statement, 90</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
executable construct, 181
</TD></TR>
<TR valign=top><TD colspan=2>
<B>enumerator-def-stmt (R761), 90, 90</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
executable statement, 20, 20, 39
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EOR= specifier, 7, 232, 233, 250, 251, 261, 261, 564</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
executable-construct (R514), 20, 36, 37, 331
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EOSHIFT, 375</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EXECUTE_COMMAND_LINE, 347, 378
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EPSILON, 376</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
execution control, 181
</TD></TR>
<TR valign=top><TD colspan=2>
<B>equiv-op (R1021), 51, 150, 150</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
execution-part (R509), 35, 36, 36, 293, 328–330
</TD></TR>
<TR valign=top><TD colspan=2>
<B>equiv-operand (R1016), 150, 150</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
execution-part-construct (R510), 36, 36, 181
</TD></TR>
<TR valign=top><TD colspan=2>
<B>equivalence association, 124</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
exist, 218, 225
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EQUIVALENCE statement, 123, 123–126, 184, 296,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EXIST= specifier, 254, 256
</TD></TR>
<TR><TD colspan=2>
<PRE>
          298, 521, 540, 542                              EXIT statement, 182, 192, 204
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>equivalence-object (R872), 124, 124, 125, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
exit-stmt (R1156), 37, 204, 204
</TD></TR>
<TR valign=top><TD colspan=2>
<B>equivalence-set (R871), 124, 124</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
EXP, 378
</TD></TR>
<TR valign=top><TD colspan=2>
<B>equivalence-stmt (R870), 37, 124, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
explicit formatting, 265–283
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ERF, 376</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
explicit initialization, 13, 78, 79, 96, 97, 113, 517, 522,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ERFC, 376</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
523
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ERFC_SCALED, 377</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
explicit interface, 15, 31, 77, 81, 118, 123, 174, 300–304,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ERR= specifier, 7, 227, 231, 232, 250, 251, 253–255,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
309–311, 313, 319, 320, 333, 334, 510, 511, 528,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          260                                                        543, 573
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>errmsg-variable (R929), 138, 138, 140, 142, 143, 145,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
explicit-coshape-spec (R811), 99, 100, 100
</TD></TR>
<TR><TD colspan=2>
<PRE>
          208, 209, 212, 214–216, 528, 532                explicit-shape array, 5, 60, 76, 100, 103, 166, 315, 320,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ERRMSG= specifier, xix, 138, 141–143, 145, 187, 208,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
488
</TD></TR>
<TR><TD colspan=2>
<PRE>
          215, 525, 532                                   explicit-shape-spec (R816), 5, 74, 75, 97, 102, 102–104,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>626</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>125</B> </TD><TD valign=bottom>
FAIL IMAGE statement, 206
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EXPONENT, 378, 457</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
fail-image-stmt (R1163), 37, 206
<TABLE width=100% cellpadding=3><!-- tsb: fail-image-stmt (R1163), 37, 206
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>exponent (R717), 63, 63</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
failed image, 14, 41, 138, 140, 144, 145, 186, 214, 341,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>exponent-letter (R716), 63, 63</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
407
</TD></TR>
<TR><TD colspan=2>
expr (R1022), 28, 84, 88, 89, 93, 138, 147, 150, 150, 162, FAILED_IMAGES, 380
</TD></TR>
<TR><TD colspan=2>
<PRE>
         163, 166–173, 177, 178, 182, 185, 197, 237, 311,  field, 268
<P>
         312, 333, 334, 475, 527                           file
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>expression, 147, 147–166</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
connected, 225
</TD></TR>
<TR><TD colspan=2>
<PRE>
     constant, 7, 10, 24, 32, 57, 58, 66, 73, 75, 76, 78,        external, 13, 13, 32, 217–222, 224–226, 230, 234,
<P>
         93, 97, 101, 103, 104, 113, 114, 116, 124, 164,              253, 270, 280, 289, 335, 506, 563, 596
<P>
         165, 166, 166, 234, 300, 301, 321, 338, 350,            internal, 16, 16, 217, 223, 224, 226, 234, 238, 241,
<P>
         351, 353, 364, 365, 369, 370, 380, 381, 386, 389,            243, 245, 247, 260, 262, 280, 281, 524, 526
<P>
         391, 394–396, 399–401, 405, 409, 418, 420, 422,   file access method, 218–220
<P>
         424, 426, 428, 434–436, 488                       file connection, 223–231
<P>
     specification, 20, 24, 41, 73, 75, 84, 98, 133, 164,  file inquiry statement, 253
<P>
         165, 165, 184, 332, 445, 541                      file position, 218, 221
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>extended real model, 340</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
file positioning statement, 218, 251
</TD></TR>
<TR valign=top><TD colspan=2>
<B>extended type, 6, 9, 15, 23, 23, 73, 80, 84–86, 522, 544,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
file storage unit, 13, 21, 217, 220–223, 229, 234, 236,
</TD></TR>
<TR><TD colspan=2>
<PRE>
         549                                                          242, 252, 258–260, 439, 520
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>extended-intrinsic-op (R610), 52, 52</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
file-name-expr (R1206), 227, 227, 228, 254–256
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EXTENDS attribute, 23, 85, 85, 487</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
file-unit-number (R1202), 223, 223, 224, 226, 227, 231,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>EXTENDS_TYPE_OF, 75, 379</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
233, 245, 250, 251, 253–260, 335, 439
</TD></TR>
<TR valign=top><TD colspan=2>
<B>extensible type, 23, 59, 70, 77, 85, 243, 379, 421, 552,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
FILE= specifier, 226, 227, 228, 229, 230, 254, 255, 255,
</TD></TR>
<TR><TD colspan=2>
<PRE>
         590                                                          528, 565
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>extension operation, 151</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
FILE_STORAGE_SIZE, 439
</TD></TR>
<TR><TD colspan=2>
extension type, 23, 60, 85, 87, 202, 317, 379, 590
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           FINAL statement, 13, 83
<P>
</PRE>
extent, 13, 45, 316
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           final subroutine, 7, 13, 13, 31, 82–85, 136, 164, 315,
<P>
</PRE>
EXTERNAL attribute, 17, 29, 30, 105, 105, 108, 117,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      548, 549
<P>
</PRE>
118, 120, 172, 294, 298, 300, 303, 308, 320,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           final-procedure-stmt (R753), 81, 83
<P>
</PRE>
324, 326, 514, 515, 582
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           final-subroutine-name, 83
<P>
</PRE>
external file, 13, 13, 32, 217–222, 224–226, 230, 234,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           finalizable, 13, 31, 83, 84, 104, 105, 143, 189
<P>
</PRE>
253, 270, 280, 289, 335, 506, 563, 596
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           finalization, 13, 19, 84, 85, 136, 178, 299, 311, 324, 334,
<P>
</PRE>
external input/output unit, 13, 509
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      335
<P>
</PRE>
external linkage, 99, 479, 505–507
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           FINDLOC, 380
<P>
</PRE>
external procedure, 18, 29, 38, 81, 105, 118, 121, 172,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           fixed source form, 54, 54
<P>
</PRE>
211, 299, 300, 302–304, 308, 309, 312, 320, 326,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           FLOOR, 381
<P>
</PRE>
509, 510, 514, 515, 543, 573, 578, 582
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           FLUSH statement, 219, 250, 253, 262
<P>
</PRE>
EXTERNAL statement, 105, 308
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           flush-spec (R1229), 253, 253
<P>
</PRE>
external subprogram, 18, 22, 38, 299
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           flush-stmt (R1228), 37, 253, 335
<P>
</PRE>
external unit, 13, 224–226, 240, 245–247, 257, 262, 438–
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           FMT= specifier, 232, 233
<P>
</PRE>
440
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           FORALL construct, 177, 335, 512, 525, 540, 542
<P>
</PRE>
external-name, 308
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           FORALL statement, 59, 153, 179, 512, 524
<P>
</PRE>
external-stmt (R1511), 37, 308
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           forall-assignment-stmt (R1053), 153, 177, 177–179, 335
<P>
</PRE>
external-subprogram (R503), 35, 35, 120, 331
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           forall-body-construct (R1052), 177, 177–179
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>F</B> </TD><TD valign=bottom>
forall-construct (R1050), 37, 177, 177, 178
</TD></TR>
<TR valign=top><TD colspan=2>
<B>F edit descriptor, 272</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
forall-construct-name, 177, 178
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
627
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>forall-construct-stmt (R1051), 7, 177, 177, 178, 204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
511, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>forall-stmt (R1055), 38, 177, 178, 179, 179, 204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
function-subprogram (R1529), 21, 35, 36, 294, 328, 330
</TD></TR>
<TR><TD colspan=2>
FORM TEAM statement, 22, 40, 137, 186, 206, 207,
</TD></TR>
<TR><TD colspan=2>
<PRE>
           212, 215, 525, 528, 533                        G
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>form-team-spec (R1178), 212, 212</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
G edit descriptor, 278, 279
</TD></TR>
<TR valign=top><TD colspan=2>
<B>form-team-stmt (R1175), 37, 212</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
GAMMA, 382
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FORM= specifier, 227, 229, 254, 256</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic identifier, 14, 15, 294, 303–305, 307, 325, 337,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>format (R1215), 231–233, 234, 234, 241, 265, 266</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
509, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>format control, 268</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic interface, 15, 82, 86, 90, 107, 160, 170, 171, 249,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>format descriptor, see edit descriptor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
295, 296, 304, 304–306, 325, 510, 591
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FORMAT statement, 29, 40, 52, 234, 265, 265, 294</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic interface block, 15, 15, 303, 304, 307
</TD></TR>
<TR valign=top><TD colspan=2>
<B>format-item (R1304), 266, 266</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic procedure reference, 307
</TD></TR>
<TR valign=top><TD colspan=2>
<B>format-items (R1303), 265, 266, 266</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
GENERIC statement, 81, 82, 304, 304, 307, 324
</TD></TR>
<TR valign=top><TD colspan=2>
<B>format-specification (R1302), 265, 265</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic-name, 81, 82, 302, 511, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>format-stmt (R1301), 36, 265, 265, 294, 297, 303</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
generic-spec (R1508), 15, 81, 82, 86, 111, 160, 171, 295,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FORMATTED, 243, 244, 302</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
296, 302, 302–304, 324, 511, 514
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                          generic-stmt (R1510), 36, 304
<P>
</PRE>
formatted data transfer, 242
<P>
<PRE>
                                                          GET_COMMAND, 382
<P>
</PRE>
formatted input/output statement, 217, 233
<P>
<PRE>
                                                          GET_COMMAND_ARGUMENT, 383
<P>
</PRE>
formatted record, 217
<P>
<PRE>
                                                          GET_ENVIRONMENT_VARIABLE, 384, 535
<P>
</PRE>
FORMATTED= specifier, 254, 256
<P>
<PRE>
                                                          GET_TEAM, 385, 438–440
<P>
</PRE>
formatting
<P>
<PRE>
                                                          global entity, 509
<P>
</PRE>
explicit, 265–283
<P>
<PRE>
                                                          global identifier, 509
<P>
</PRE>
list-directed, 243, 283–287
<P>
<PRE>
                                                          GO TO statement, 7, 53, 204, 204
<P>
</PRE>
namelist, 243, 287–291
<P>
<PRE>
                                                          goto-stmt (R1157), 37, 204, 204
<P>
</PRE>
forms, 218
<P>
<PRE>
                                                          graphic character, 49, 67, 290
<P>
</PRE>
Fortran 2003 compatibility, 31
<P>
Fortran 2008 compatibility, 30
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; H</H4>
</A>
<BLOCKQUOTE>
<P>
Fortran 77 compatibility, 32
<P>
<PRE>
                                                          halting mode, 443, 448, 448, 451, 453, 454, 465, 471,
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>Fortran 90 compatibility, 32</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
472, 507, 536
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Fortran 95 compatibility, 31</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
hex-constant (R767), 92, 92
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Fortran character set, 49, 65</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
hex-digit (R768), 92, 92, 278
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FRACTION, 381</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
hex-digit-string (R1322), 278, 278
</TD></TR>
<TR valign=top><TD colspan=2>
<B>free source form, 53, 53</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
host, 14, 14, 38, 297, 333, 511, 514, 515
</TD></TR>
<TR valign=top><TD colspan=2>
<B>function, 13</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
host association, 6, 6, 17, 39, 59, 60, 66, 98, 111, 113,
</TD></TR>
<TR><TD colspan=2>
<PRE>
     intrinsic, 337                                                 118, 126, 164, 165, 172, 297, 299, 320, 333–335,
<P>
     intrinsic elemental, 337                                       511, 513–516, 519, 522, 613
<P>
     intrinsic inquiry, 337                               host instance, 14, 174, 312, 313, 320, 330, 354, 514, 518,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>function reference, 19, 43, 44, 324</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
522, 527
</TD></TR>
<TR><TD colspan=2>
function result, 13, 31, 66, 95, 118, 124, 125, 143, 300, host scoping unit, 14, 38, 118, 121, 324, 325, 515, 522
</TD></TR>
<TR><TD colspan=2>
<PRE>
           329, 331, 336, 489, 511, 521, 527              HUGE, 386
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>FUNCTION statement, 12, 59, 60, 118, 160, 164, 293,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
HYPOT, 386
</TD></TR>
<TR><TD colspan=2>
<PRE>
           327, 328, 331, 332, 511
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>function-name, 96, 303, 328, 329, 331, 333, 511, 514</B> <!-- Consumed .TP -->
<BR>
<B>function-reference (R1520), 88, 96, 129, 147, 311, 313,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
I edit descriptor, 271
</TD></TR>
<TR><TD colspan=2>
<PRE>
           324                                            IACHAR, 68, 169, 386
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>function-stmt (R1530), 35, 302, 303, 327, 328, 328, 329,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IALL, 386
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>628</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                  c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                    ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IAND, 356, 387</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_MAX_NUM, 457, 458
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IANY, 387</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_MAX_NUM_MAG, 458
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IBCLR, 388</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_MIN_NUM, 458, 459
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IBITS, 388</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_MIN_NUM_MAG, 459
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IBSET, 389</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_MODES_TYPE, 444, 448, 454, 465, 466
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ICHAR, 67, 68, 389</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NAN, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>id-variable (R1214), 232, 232</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NEAREST, 444, 447
</TD></TR>
<TR><TD colspan=2>
ID= specifier, 232, 233, 235, 250, 254, 255, 256, 528, IEEE_NEGATIVE_DENORMAL, 444
</TD></TR>
<TR><TD colspan=2>
<PRE>
          567, 568                                     IEEE_NEGATIVE_INF, 444
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE infinity, 14</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NEGATIVE_NORMAL, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE NaN, 14, 160, 445, 446, 467</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NEGATIVE_SUBNORMAL, 444, 444, 452,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_ALL, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
456, 457
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_ARITHMETIC, 164, 166, 349, 443–475, 543</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NEGATIVE_ZERO, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_AWAY, 447, 454</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NEXT_AFTER, 459
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_CLASS, 452, 452</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NEXT_DOWN, 460, 460
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_CLASS_TYPE, 444, 452, 475</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_NEXT_UP, 460
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_COPY_SIGN, 449, 452</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_OTHER, 444, 447
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_DATATYPE, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_OTHER_VALUE, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_DENORMAL, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_OVERFLOW, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_DIVIDE, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_POSITIVE_DENORMAL, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_DIVIDE_BY_ZERO, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_POSITIVE_INF, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_DOWN, 444, 447</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_POSITIVE_NORMAL, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_EXCEPTIONS, 164, 166, 192, 443–475, 543</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_POSITIVE_SUBNORMAL, 444, 444, 452, 456
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_FEATURES, 443–444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_POSITIVE_ZERO, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_FEATURES_TYPE, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_QUIET_EQ, 460
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_FLAG_TYPE, 444, 453, 454, 465, 471</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_QUIET_GE, 461
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_FMA, 453</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_QUIET_GT, 461
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_FLAG, 192, 446, 453, 476, 477, 536</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_QUIET_LE, 461
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_HALTING_MODE, 192, 453, 454</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_QUIET_LT, 462
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_MODES, 448, 454, 454, 466</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_QUIET_NAN, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_ROUNDING_MODE, 447, 454, 455, 466</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_QUIET_NE, 462
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_STATUS, 446, 455, 455, 466, 467, 476,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_REAL, 463
</TD></TR>
<TR><TD colspan=2>
<PRE>
          536                                          IEEE_REM, 449, 463
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_GET_UNDERFLOW_MODE, 455, 467</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_RINT, 449, 463
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_HALTING, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_ROUND_TYPE, 444, 454, 455, 463, 466, 473
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_INEXACT, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_ROUNDING, 444
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_INEXACT_FLAG, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_SCALB, 464
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_INF, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_SELECTED_REAL_KIND, 464
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_INT, 455</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_SET_FLAG, 446, 455, 465, 467, 476, 477, 536
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_INVALID, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_SET_HALTING_MODE, 192, 446, 454, 465,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_INVALID_FLAG, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
471, 476, 477, 536
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_FINITE, 456</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_SET_MODES, 448, 454, 465, 466
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_NAN, 456</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_SET_ROUNDING_MODE, 447, 454, 455, 466,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_NEGATIVE, 456</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
466
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_IS_NORMAL, 457</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IEEE_SET_STATUS, 446, 447, 455, 466, 467, 477,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_LOGB, 449, 457</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
536
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
629
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SET_UNDERFLOW_MODE, 454, 455, 466,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
322, 324, 337, 341, 346–348, 356–360, 370, 372,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          467                                                         384, 390, 407, 411, 412, 416, 430–432, 435, 441,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_EQ, 467</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
448, 509, 517, 518, 525, 527
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_GE, 468</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
active, 14, 145
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_GT, 468</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
failed, 14, 140, 144, 145, 214, 407
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_LE, 468</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
stopped, 14, 140, 144, 145, 407
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_LT, 469</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
image control statement, 14, 41, 161, 187, 192, 206,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_NAN, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
206–208, 210, 215, 216, 324, 335, 341, 342, 380,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNALING_NE, 469</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
428, 441
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SIGNBIT, 469</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
image index, 14, 40, 45, 137, 138, 209, 213, 218, 319,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SQRT, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
345, 347, 390, 431, 435, 509
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_STATUS_TYPE, 444, 448, 455, 466, 467, 476</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
image-selector (R924), 8, 10, 40, 130–132, 137, 137,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUBNORMAL, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
138, 287
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_DATATYPE, 444, 445, 452, 453,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
image-selector-spec (R926), 137, 137
</TD></TR>
<TR><TD colspan=2>
<PRE>
          455, 458–464, 466–469, 470, 470, 474, 475         image-set (R1167), 209, 209
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_DENORMAL, 470</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IMAGE_INDEX, 390
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_DIVIDE, 471, 474</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IMAGE_STATUS, 390
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_FLAG, 471, 474</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
imaginary part, 64
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_HALTING, 471, 474</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implicit interface, 15, 75, 174, 294, 309–311, 319, 483,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_INF, 448, 449, 460, 472, 474, 475</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
515
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_IO, 472</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IMPLICIT NONE statement, 118
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_NAN, 445, 446, 448, 472, 474, 475</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IMPLICIT statement, 40, 118, 123, 298
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_ROUNDING, 466, 473, 474</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implicit-none-spec (R866), 118, 118
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_SQRT, 473, 474</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implicit-part (R505), 36, 36
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_STANDARD, 473</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implicit-part-stmt (R506), 36, 36
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_SUBNORMAL, 448, 449, 452, 460,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implicit-spec (R864), 118, 118
</TD></TR>
<TR><TD colspan=2>
<PRE>
          470, 474, 474, 475                                implicit-stmt (R863), 36, 118, 118
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_SUPPORT_UNDERFLOW_CONTROL, 474</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implied-shape array, 104
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_TO_ZERO, 444, 447</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implied-shape-or-assumed-size-spec (R823), 102, 104,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_UNDERFLOW, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
104
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_UNDERFLOW_FLAG, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implied-shape-spec (R824), 102, 104, 105
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_UNORDERED, 449, 475</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IMPORT statement, 40, 120, 509, 515
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_UP, 444, 447</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
import-name, 120, 121
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_USUAL, 444</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
import-stmt (R867), 36, 120, 184
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEEE_VALUE, 458, 459, 475</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IMPURE, 327, 327, 332, 334, 336
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IEOR, 360, 389</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IN, 106
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IF construct, 41, 195, 539</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INCLUDE line, 53, 55
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IF statement, 153, 196</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
inclusive scope, 14, 184, 204, 205, 227, 231, 232, 234,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>if-construct (R1134), 37, 195, 195</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
250, 251, 253, 255, 312, 332, 509, 510
</TD></TR>
<TR valign=top><TD colspan=2>
<B>if-construct-name, 195</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INDEX, 391
</TD></TR>
<TR valign=top><TD colspan=2>
<B>if-stmt (R1139), 37, 196, 196</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
index-name, 178, 179, 188–191, 512, 525
</TD></TR>
<TR valign=top><TD colspan=2>
<B>if-then-stmt (R1135), 7, 195, 195, 204</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
inherit, 6, 9, 15, 70, 81, 82, 84–87, 522, 552
</TD></TR>
<TR valign=top><TD colspan=2>
<B>imag-part (R720), 64, 64</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
inheritance association, 6, 6, 9, 47, 86, 88, 519, 522
</TD></TR>
<TR valign=top><TD colspan=2>
<B>image, 1, 14, 14, 22, 40–42, 45, 46, 84, 100, 138–141,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
initial team, 22, 46, 137, 224, 347, 385, 390, 412, 431,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          144, 170, 172, 173, 186–188, 205–211, 213–216,              439
<P>
          218, 219, 224, 225, 257, 311, 315, 318, 319, 321, initial-data-target (R744), 31, 77, 78, 78, 96, 97, 109,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>630</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>114, 115</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INT8, 439
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>initial-proc-target (R1518), 78, 309, 309, 310</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
integer constant, 62
<TABLE width=100% cellpadding=3><!-- tsb: integer constant, 62
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>INITIAL_TEAM, 385, 439</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
integer editing, 271
</TD></TR>
<TR valign=top><TD colspan=2>
<B>initialization, 97</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
integer model, 340
</TD></TR>
<TR><TD colspan=2>
<PRE>
      default, 10, 10, 76–79, 88, 89, 97, 104, 105, 113,     integer type, 61–62
<P>
           124, 125, 127, 316, 517, 522, 526                 integer-type-spec (R705), 59, 61, 61, 73, 93, 113, 189,
<P>
      explicit, 13, 78, 79, 96, 97, 113, 517, 522, 523                 512
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>initialization (R805), 96, 96, 97, 166</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INTEGER_KINDS, 439
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INOUT, 53, 106</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INTENT (IN) attribute, 105, 106, 107, 111, 189, 305–
</TD></TR>
<TR valign=top><TD colspan=2>
<B>input statement, 231</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
307, 315, 318, 320–322, 334, 335, 338, 356–
</TD></TR>
<TR valign=top><TD colspan=2>
<B>input-item (R1216), 231, 232, 237, 237, 249, 263, 528</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
360, 365–368, 377, 378, 383, 384, 408, 416, 451,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>input/output editing, 265–291</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
481–483, 503, 504, 543, 584, 598
</TD></TR>
<TR valign=top><TD colspan=2>
<B>input/output list, 236</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INTENT (INOUT) attribute, 30, 105, 106, 107, 110,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>input/output statement, 524</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
193, 306, 316, 318, 324, 335, 336, 356–360,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>input/output statements, 217–262</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
365–368, 378, 382–384, 407, 408, 438, 440, 528,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>input/output unit, 16, 24, 40</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
529, 598
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INPUT_UNIT, 224, 225, 229, 245, 439</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INTENT (OUT) attribute, 31, 60, 83–85, 104, 105,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INQUIRE statement, 32, 219, 220, 222, 223, 225, 226,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
105–107, 110, 143, 164, 306, 316, 318, 324,
</TD></TR>
<TR><TD colspan=2>
<PRE>
           235, 236, 246, 247, 250, 253, 262, 263, 439,                334–336, 356–360, 365–368, 370, 372, 377, 378,
<P>
           524, 526–528, 534, 563                                      382–384, 407, 408, 416, 430, 453–455, 481, 483,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>inquire-spec (R1231), 254, 254, 255, 263</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
503, 504, 517–519, 524, 525, 527–529, 598
</TD></TR>
<TR valign=top><TD colspan=2>
<B>inquire-stmt (R1230), 37, 254, 335</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INTENT attribute, 105, 105–107, 116, 192, 543
</TD></TR>
<TR valign=top><TD colspan=2>
<B>inquiry function, 15, 22, 100, 103, 105, 131, 141, 164,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
INTENT statement, 116, 184
</TD></TR>
<TR><TD colspan=2>
<PRE>
           314, 315, 337–339, 342, 352, 354, 363, 369, 373,  intent-spec (R826), 95, 106, 116, 309
<P>
           376, 379, 386, 390, 393–396, 401, 404, 409, 414,  intent-stmt (R849), 37, 116
<P>
           415, 417, 421, 424, 426, 428, 432, 434, 443, 444, interface, 15, 15, 39, 44, 47, 75, 82, 107, 243–245, 280,
<P>
           446–450, 470–474, 484                                       300, 301, 311, 319, 320, 324, 325, 331–334,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>inquiry, type parameter, 132</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
489–491, 506, 507, 573
</TD></TR>
<TR valign=top><TD colspan=2>
<B>instance, 330</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
abstract, 15, 15, 294, 301, 303, 309, 328, 510, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INT, 115, 169, 339, 374, 375, 387, 389, 391, 392, 404</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
explicit, 15, 31, 77, 81, 118, 123, 174, 300–304,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-constant (R607), 51, 51, 114</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
309–311, 313, 319, 320, 333, 334, 510, 511, 528,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-constant-expr (R1031), 61, 65, 73, 90, 91, 113, 166,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
543, 573
</TD></TR>
<TR><TD colspan=2>
<PRE>
           166, 199, 200                                          generic, 15, 82, 86, 90, 107, 160, 170, 171, 249, 295,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-constant-name, 62</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
296, 304, 304–306, 325, 510
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-constant-subobject (R846), 114, 114</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
implicit, 15, 75, 174, 294, 309–311, 319, 483, 515
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-expr (R1026), 40, 58, 93, 130, 133, 137, 138, 153,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
procedure, 301
</TD></TR>
<TR><TD colspan=2>
<PRE>
           162, 162, 164–166, 188–190, 205, 209, 212,             specific, 15, 249, 303, 303, 304, 309, 325, 543
<P>
           213, 223, 224, 227, 232, 237, 239, 250, 254,      interface block, 15, 39, 243, 249, 295, 302–304, 324, 325,
<P>
           332                                                         573
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-literal-constant (R708), 51, 62, 62, 65, 266, 267</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
interface body, 15, 19, 40, 101, 103, 105, 118, 164, 302,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-variable (R907), 129, 129, 144, 227, 232, 233, 254,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
302, 327, 328, 331, 332, 491, 511, 514, 573
</TD></TR>
<TR><TD colspan=2>
<PRE>
           257–261, 534                                      INTERFACE statement, 302, 573
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>int-variable-name, 188</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
interface-block (R1501), 36, 302, 302
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INT16, 439</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
interface-body (R1505), 302, 302, 303
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INT32, 439</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
interface-name (R1516), 81, 82, 308, 309, 309
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INT64, 439</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
interface-specification (R1502), 302, 302, 303
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
631
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>interface-stmt (R1503), 302, 302–305, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
261, 262, 524
</TD></TR>
<TR valign=top><TD colspan=2>
<B>internal file, 16, 16, 217, 223, 224, 226, 234, 238, 241,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IOR, 359, 392
</TD></TR>
<TR><TD colspan=2>
<PRE>
          243, 245, 247, 260, 262, 280, 281, 524, 526       IOSTAT= specifier, 227, 231, 232, 246, 250, 251, 253,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>internal procedure, 14, 18, 38, 172, 299–302, 312, 320,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
254, 260, 261, 262, 394, 439, 524, 534, 564
</TD></TR>
<TR><TD colspan=2>
<PRE>
          326, 328, 330, 354, 507, 510, 511, 514            IOSTAT_END, 246, 262, 439
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>internal subprogram, 22, 38, 40, 118, 299, 324, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IOSTAT_EOR, 246, 262, 439
</TD></TR>
<TR valign=top><TD colspan=2>
<B>internal unit, 16, 16, 224, 226, 240, 245, 246, 255, 262,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IOSTAT_INQUIRE_INTERNAL_UNIT, 246, 262,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          439                                                         439, 442
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>internal-file-variable (R1203), 223, 223, 224, 233, 263,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IPARITY, 392
</TD></TR>
<TR><TD colspan=2>
<PRE>
          528                                               IS_CONTIGUOUS, 60, 393
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>internal-subprogram (R512), 36, 36</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IS_IOSTAT_END, 394
</TD></TR>
<TR valign=top><TD colspan=2>
<B>internal-subprogram-part (R511), 35, 36, 36, 293, 328–</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
IS_IOSTAT_EOR, 394
</TD></TR>
<TR><TD colspan=2>
<PRE>
          330                                               ISHFT, 393
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>interoperable, 15, 90, 91, 99, 328, 333, 481, 483–491,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ISHFTC, 393
</TD></TR>
<TR><TD colspan=2>
<PRE>
          505, 506                                          ISO 10646 character, 16, 65, 68, 167, 223, 228, 238,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>interoperate, 485</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
270, 284, 409, 422
</TD></TR>
<TR valign=top><TD colspan=2>
<B>intrinsic, 9, 12, 14, 15, 16, 17, 18, 22, 23, 42, 43, 45,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ISO_C_BINDING, 60, 74, 85, 99, 105, 131, 139, 140,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          47, 58, 60, 84, 92, 105, 301, 318, 325, 326, 436,           164, 170, 335, 436, 479–486, 526, 527, 543
<P>
          510, 512                                          ISO_Fortran_binding.h, 491
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>intrinsic assignment statement, 31, 89, 143, 145, 163,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ISO_FORTRAN_ENV, 25, 30, 70, 74, 99, 106, 131,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          167, 171, 173, 216, 253, 262, 289, 334, 335,                138–140, 145, 164, 170, 185, 205, 211, 212,
<P>
          524, 532                                                    214–216, 222, 224, 229, 240, 245, 246, 262, 341,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INTRINSIC attribute, 105, 107, 107, 108, 294, 310,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
356–360, 380, 385, 390, 391, 407, 412, 428, 429,
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
          324, 325, 515                                               431, 436–441, 527, 536, 564
<P>
</PRE>
intrinsic function, 337
<P>
intrinsic operation, 153–160
</TD></TR>
<TR></TR></TABLE><A name=>

    <H4>&nbsp; &nbsp; K</H4>
</A>
<BLOCKQUOTE>
<P>
k (R1314), 267, 267, 274, 279, 282
</BLOCKQUOTE>
<P>
intrinsic procedure, 337–436
<P>
<PRE>
                                                            keyword, 16
<P>
</PRE>
INTRINSIC statement, 298, 310
<P>
<PRE>
                                                                 argument, 12, 16, 47, 301, 304, 313, 337, 342, 450,
<P>
</PRE>
intrinsic subroutines, 337
<P>
<PRE>
                                                                      510, 511, 512, 573
<P>
</PRE>
intrinsic type, 9, 23, 42, 43, 57, 61–68, 490, 494
<P>
<PRE>
                                                                 component, 16, 47, 80, 89, 511
<P>
</PRE>
intrinsic-operator (R608), 17, 51, 52, 148, 150, 153, 154,
<P>
<PRE>
                                                                 statement, 16, 47
<P>
</PRE>
160, 305
<P>
<PRE>
                                                                 type parameter, 16, 47, 88
<P>
</PRE>
intrinsic-procedure-name, 310, 514
<P>
<PRE>
                                                            keyword (R516), 47, 47, 87, 88, 311
<P>
</PRE>
intrinsic-stmt (R1519), 37, 310, 514
<P>
<PRE>
                                                            KIND, 61–65, 68, 73, 91, 132, 169, 394
<P>
</PRE>
intrinsic-type-spec (R704), 59, 61, 66
<P>
<PRE>
                                                            kind type parameter, 24, 29, 42, 58, 61–66, 68, 73, 83,
<P>
</PRE>
io-control-spec (R1213), 231, 232, 232, 233, 236, 245,
<P>
<PRE>
                                                                      84, 91, 93, 165–169, 287, 306, 315, 328, 374,
<P>
</PRE>
263
<P>
<PRE>
                                                                      379, 421, 439, 479, 480, 485, 543
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>io-implied-do (R1218), 237, 237, 238, 241, 263, 524,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
kind-param (R709), 62, 62, 63, 65–68
</TD></TR>
<TR><TD colspan=2>
<PRE>
          526, 528, 564                                     kind-selector (R706), 28, 61, 61, 62, 68
<P>
</PRE>
io-implied-do-control (R1220), 237, 237, 239
</TD></TR>
<TR valign=top><TD colspan=2>
<B>io-implied-do-object (R1219), 237, 237, 241</B> <!-- Consumed .TP -->
<BR>
<B>io-unit (R1201), 24, 223, 223, 224, 232, 233, 335</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
L edit descriptor, 278
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IOLENGTH= specifier, 222, 253, 260</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
label, see statement label
</TD></TR>
<TR valign=top><TD colspan=2>
<B>iomsg-variable (R1207), 227, 227, 231, 232, 250, 251,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
label (R611), 7, 52, 52, 188, 190, 204, 205, 227, 231,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          253, 254, 261, 262, 524                                     232, 234, 250, 251, 253–255, 261, 311, 312
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>IOMSG= specifier, 227, 231, 232, 250, 251, 253, 254,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
label-do-stmt (R1121), 188, 188, 190
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>632</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>language-binding-spec (R808), 95, 99, 112, 328</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
LOCK_TYPE, 25, 31, 70, 106, 139, 140, 214, 440
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LBOUND, 60, 168, 173, 183, 200, 394</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
LOG, 32, 398
</TD></TR>
<TR valign=top><TD colspan=2>
<B>lbracket (R771), 74, 92, 93, 95, 96, 112, 113, 117,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
137, LOG10, 399
</TD></TR>
<TR><TD colspan=2>
<PRE>
           138                                             LOG_GAMMA, 398
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LCOBOUND, 395</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
LOGICAL, 399
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LEADZ, 395</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
logical intrinsic operation, 157
</TD></TR>
<TR valign=top><TD colspan=2>
<B>left tab limit, 281</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
logical type, 68
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LEN, 132, 396</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
logical-expr (R1024), 162, 162, 175, 188, 190–192, 195,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LEN_TRIM, 396</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
196, 205
</TD></TR>
<TR valign=top><TD colspan=2>
<B>length type parameter, 24, 24, 42, 58, 68, 77, 93,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
108, logical-literal-constant (R725), 51, 68, 148, 150
</TD></TR>
<TR><TD colspan=2>
<PRE>
           141, 167, 168, 315, 396, 484, 485, 543          logical-variable (R904), 129, 129, 213–215, 254, 256,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>length-selector (R722), 28, 65, 65, 66</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
257, 528
</TD></TR>
<TR valign=top><TD colspan=2>
<B>letter, 49, 49, 50, 52, 118, 148, 150</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
LOGICAL_KINDS, 440
</TD></TR>
<TR valign=top><TD colspan=2>
<B>letter-spec (R865), 118, 118</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
loop-control (R1123), 188, 188, 190, 191, 194
</TD></TR>
<TR valign=top><TD colspan=2>
<B>level-1-expr (R1002), 148, 148, 151</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
lower-bound (R817), 102, 102–105
</TD></TR>
<TR valign=top><TD colspan=2>
<B>level-2-expr (R1006), 148, 148, 149, 151, 152</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
lower-bound-expr (R934), 138, 138, 172
</TD></TR>
<TR valign=top><TD colspan=2>
<B>level-3-expr (R1010), 149, 149</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
lower-cobound (R812), 100, 101, 101
</TD></TR>
<TR><TD colspan=2>
level-4-expr (R1012), 149, 149, 150
</TD></TR>
<TR valign=top><TD colspan=2>
<B>level-5-expr (R1017), 150, 150</B> <!-- Consumed .TP -->
<BR>
<B>lexical token, 14, 16, 27, 50, 52</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
m (R1309), 267, 267, 271, 272, 277, 278
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LGE, 68, 396</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
main program, 16, 18, 22, 38, 41, 43
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LGT, 68, 397</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
main-program (R1401), 35, 38, 120, 293, 293
</TD></TR>
<TR valign=top><TD colspan=2>
<B>line, 16, 53–56</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
mask-expr (R1046), 175, 175–179, 189, 191
</TD></TR>
<TR valign=top><TD colspan=2>
<B>linkage association, 6, 6, 506, 513, 516, 516</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
masked array assignment, 17, 175, 524
</TD></TR>
<TR valign=top><TD colspan=2>
<B>list-directed formatting, 243, 283–287</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
masked array assignment (WHERE), 175
</TD></TR>
<TR valign=top><TD colspan=2>
<B>list-directed input/output statement, 234</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
masked-elsewhere-stmt (R1047), 175, 175, 176, 178
</TD></TR>
<TR valign=top><TD colspan=2>
<B>literal constant, 9, 44, 130, 162</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MASKL, 399
</TD></TR>
<TR valign=top><TD colspan=2>
<B>literal-constant (R605), 51, 51, 147</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MASKR, 399
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LLE, 68, 397</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MATMUL, 400
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LLT, 68, 398</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MAX, 336, 338, 401
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LOCAL, 189, 192, 193, 195, 512, 519, 527</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MAXEXPONENT, 401
</TD></TR>
<TR valign=top><TD colspan=2>
<B>local identifier, 509, 510</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MAXLOC, 338, 401
</TD></TR>
<TR valign=top><TD colspan=2>
<B>local procedure pointer, 17, 330</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MAXVAL, 402
</TD></TR>
<TR><TD colspan=2>
local variable, 17, 25, 31, 43, 44, 97, 99, 101, 103, 109, MERGE, 403
</TD></TR>
<TR><TD colspan=2>
<PRE>
           111, 141, 143, 312, 330, 334                    MERGE_BITS, 403
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>local-defined-operator (R1414), 295, 295, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MIN, 404
</TD></TR>
<TR valign=top><TD colspan=2>
<B>local-name, 295, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MINEXPONENT, 404
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LOCAL_INIT, 189, 192, 193, 512, 519, 525, 527</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MINLOC, 404
</TD></TR>
<TR valign=top><TD colspan=2>
<B>locality, 192, 193, 512, 519, 525, 527</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MINVAL, 405
</TD></TR>
<TR valign=top><TD colspan=2>
<B>locality-spec (R1130), 189, 189</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
MOD, 32, 406
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LOCK statement, 206, 207, 213, 216, 440, 441,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
525, mode
</TD></TR>
<TR><TD colspan=2>
<PRE>
           528                                                  blank interpretation, 228
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>lock variable, 25, 41, 216, 440, 441, 525, 528</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
changeable, 224
</TD></TR>
<TR valign=top><TD colspan=2>
<B>lock-stat (R1180), 213, 213</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
connection, 224
</TD></TR>
<TR valign=top><TD colspan=2>
<B>lock-stmt (R1179), 37, 213</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
decimal edit, 228
</TD></TR>
<TR valign=top><TD colspan=2>
<B>lock-variable (R1182), 213, 213–215, 440, 528</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
delimiter, 228
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
633
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
    halting, 443, 448, 448, 451, 453, 454, 465, 471, 472, named-constant (R606), 51, 51, 55, 64, 90, 116, 514
<P>
         507, 536                                         named-constant-def (R852), 116, 116, 514
<P>
    IEEE rounding, 443, 444, 447, 448, 449                NAMED= specifier, 254, 257
<P>
    input/output rounding, 224, 230, 236, 259, 277,       namelist formatting, 243, 287–291
<P>
         282, 472                                         namelist input/output statement, 234
<P>
    pad, 229                                              NAMELIST statement, 123, 184, 288, 296
<P>
    sign, 230, 282                                        namelist-group-name, 123, 232–234, 240–242, 265, 288,
<P>
    underflow, 447, 448, 451, 455, 467, 474, 475, 536               291, 296, 514, 528
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>model</B> </TD><TD valign=bottom>
namelist-group-object (R869), 123, 123, 241, 243, 249,
</TD></TR>
<TR><TD colspan=2>
<PRE>
    bit, 338                                                        263, 287, 288, 296
<P>
    extended real, 340                                    namelist-stmt (R868), 37, 123, 514, 528
<P>
    integer, 340                                          NaN, 17, 272–276, 279, 349, 379, 382, 420, 424, 427,
<P>
    real, 340                                                       445, 448, 449, 452, 453, 456, 472, 473
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MODULE, 302, 303, 327, 327, 330</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NEAREST, 408
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module, 16, 17, 18, 19, 21, 22, 38, 39, 43, 293</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NEW_INDEX= specifier, 212, 533
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module (R1404), 35, 120, 294</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NEW_LINE, 278, 279, 409
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module procedure, 18, 81, 122, 172, 299–304, 309, 312,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NEWUNIT= specifier, 224, 227, 229, 245, 525, 528
</TD></TR>
<TR><TD colspan=2>
<PRE>
         320, 326, 327, 330, 331, 333, 436, 510, 511      NEXTREC= specifier, 254, 257
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module procedure interface body, 121, 303</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NINT, 409
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module reference, 19, 294</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NML= specifier, 232, 234, 528
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MODULE statement, 293, 294</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NON_INTRINSIC, 295
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module subprogram, 22, 38, 40, 118, 324</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NON_OVERRIDABLE attribute, 81, 82
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module-name, 294, 295, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NON_RECURSIVE, 327, 327
</TD></TR>
<TR valign=top><TD colspan=2>
<B>module-nature (R1410), 295, 295</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NON_RECURSIVE attribute, 301, 327, 327, 331, 332
</TD></TR>
<TR><TD colspan=2>
module-stmt (R1405), 35, 294, 294
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          nonadvancing input/output statement, 221
<P>
</PRE>
module-subprogram (R1408), 36, 294, 294, 331
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          nonblock DO construct, 540
<P>
</PRE>
module-subprogram-part (R1407), 35, 83, 87, 294, 294,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          NONE, 118, 120, 189
<P>
</PRE>
297, 578
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          nonexecutable statement, 20, 39
<P>
</PRE>
MODULO, 32, 406
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          nonlabel-do-stmt (R1122), 188, 188, 190
<P>
</PRE>
MOLD= specifier, 138
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          nonstandard intrinsic, xviii, 16, 29, 582
<P>
</PRE>
MOVE_ALLOC, 141, 207, 337, 407
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          NOPASS, 75, 77, 82
<P>
</PRE>
mp-subprogram-stmt (R1539), 36, 330, 330, 331
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          NOPASS attribute, see PASS attribute
<P>
</PRE>
mult-op (R1008), 51, 148, 148
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          NORM2, 410
<P>
</PRE>
mult-operand (R1004), 148, 148, 151
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          normal number, 448
<P>
</PRE>
MVBITS, 337, 338, 408
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          normal termination, 14, 40, 41, 42, 85, 205, 218, 230,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>N</B> </TD><TD valign=bottom>
231, 391, 428, 441
</TD></TR>
<TR valign=top><TD colspan=2>
<B>n (R1316), 267, 267, 268, 281</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NOT,   410
</TD></TR>
<TR valign=top><TD colspan=2>
<B>name, 17, 46, 50, 509</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
not-op (R1018), 51, 150, 150
</TD></TR>
<TR><TD colspan=2>
name (R603), 28, 47, 50, 50, 51, 96, 117, 129, 202, 241, NULL, 89, 96, 163, 165, 166, 320, 338, 410, 517, 518
</TD></TR>
<TR><TD colspan=2>
<PRE>
         309, 328                                         null-init (R806), 77, 78, 96, 96, 97, 114, 115, 309
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>name association, 6, 6, 47, 513, 519</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
NULLIFY statement, 142
</TD></TR>
<TR valign=top><TD colspan=2>
<B>name-value subsequence, 287, 288</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
nullify-stmt (R938), 37, 142, 529
</TD></TR>
<TR><TD colspan=2>
NAME= specifier, 95, 99, 112, 254, 255, 256, 309, 309, NUM_IMAGES, 166, 411, 435
</TD></TR>
<TR><TD colspan=2>
<PRE>
         328, 506                                         NUMBER= specifier, 254, 257
<P>
</PRE>
named constant, 9, 24, 44, 46, 50, 58, 62, 64, 66, 104, numeric conversion, 169
</TD></TR>
<TR><TD colspan=2>
<PRE>
         105, 108, 111, 114, 116, 124, 130, 333           numeric editing, 271
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>634</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>numeric</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
intrinsic operation, 154                      optional-stmt (R850), 37, 116
</TD></TR>
<TR valign=top><TD colspan=2>
<B>numeric</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
sequence type, 20, 71, 124–126, 521, 525      or-op (R1020), 51, 150, 150
</TD></TR>
<TR valign=top><TD colspan=2>
<B>numeric</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
storage unit, 21, 21, 126, 440, 520, 524, 526 or-operand (R1015), 150, 150
</TD></TR>
<TR valign=top><TD colspan=2>
<B>numeric</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type, 23, 61–65, 154–156, 158, 162, 169, 373, other-specification-stmt (R513), 36, 36
</TD></TR>
<TR><TD colspan=2>
<PRE>
           374, 400, 415, 429                           OUT, 106
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>numeric-expr (R1027), 162, 162</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
OUT_OF_RANGE, 412
</TD></TR>
<TR valign=top><TD colspan=2>
<B>NUMERIC_STORAGE_SIZE, 440</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
output statement, 231
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                        output-item (R1217), 231, 232, 237, 237, 249, 254
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>O</B> </TD><TD valign=bottom>
OUTPUT_UNIT, 224, 225, 229, 245, 440
</TD></TR>
<TR></TR></TABLE>O edit descriptor, 277
<P>
<PRE>
                                                        override, 78, 86, 95, 96, 118, 243, 271, 522
<P>
</PRE>
object, 10, 10, 42–45
<P>
object designator, 11, 43, 44, 110, 114, 130, 164, 287
<P>
object-name (R804), 96, 96, 112, 113, 116–118, 129,
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; P</H4>
</A>
<BLOCKQUOTE>
<P>
P edit descriptor, 282
</BLOCKQUOTE>
<P>
136, 514
<P>
<PRE>
                                                        PACK, 413
<P>
</PRE>
obsolescent feature, 29, 30, 33, 540–542
<P>
<PRE>
                                                        pad mode, 229
<P>
</PRE>
octal-constant (R766), 92, 92
<P>
<PRE>
                                                        PAD= specifier, 32, 33, 227, 229, 232, 233, 236, 247,
<P>
</PRE>
ONLY, 120, 121, 122, 295, 295, 296, 516, 570, 572
<P>
<PRE>
                                                                  254, 257
<P>
</PRE>
only (R1412), 295, 295, 296
<P>
<PRE>
                                                        padding, 339, 339, 391, 418
<P>
</PRE>
only-use-name (R1413), 295, 295, 296
<P>
<PRE>
                                                        PARAMETER attribute, 9, 44, 91, 97, 108, 108, 116,
<P>
</PRE>
OPEN statement, 33, 218, 219, 223–225, 226, 226, 230,
<P>
<PRE>
                                                                  130
<P>
</PRE>
234, 242, 243, 247, 256, 260, 277, 289, 525,
<P>
<PRE>
                                                        PARAMETER statement, 40, 116, 118, 298
<P>
</PRE>
528, 533, 534, 563, 565–567
<P>
<PRE>
                                                        parameter-stmt (R851), 36, 116, 514
<P>
</PRE>
open-stmt (R1204), 37, 226, 335
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: open-stmt (R1204), 37, 226, 335
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>OPENED= specifier, 254, 257</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
parent component, 6, 9, 80, 84, 86, 89, 522, 552
</TD></TR>
<TR valign=top><TD colspan=2>
<B>operand, 17</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
parent data transfer statement, 236, 245, 243–247, 262,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>operation, 57</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
286
</TD></TR>
<TR><TD colspan=2>
<PRE>
     defined, 11, 19, 81, 151, 160, 161–163, 189, 299,  parent team, 22, 22, 46, 137, 186, 211, 212, 380, 385,
<P>
           305, 311, 324, 335                                     390, 412, 428, 431, 440
<P>
     elemental, 12, 153, 163, 177                       parent type, 9, 23, 70, 73, 80, 84–86, 307, 552
<P>
     intrinsic, 153–160                                 parent-identifier (R1418), 297, 297
<P>
        logical, 157                                    parent-string (R909), 101, 130, 130
<P>
        numeric , 154                                   parent-submodule-name, 297
<P>
        relational, 158                                 parent-type-name, 69, 70
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>OPERATOR, 57, 82, 160, 295, 302, 305, 573</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
PARENT_TEAM, 385, 440
</TD></TR>
<TR valign=top><TD colspan=2>
<B>operator, 17, 51</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
parentheses, 162
</TD></TR>
<TR><TD colspan=2>
<PRE>
     character, 149                                     PARITY, 413
<P>
     defined binary, 150                                part-name, 7, 130–133, 136, 137
<P>
     defined unary, 148                                 part-ref (R912), 101, 114, 124, 130, 130–133, 135, 137,
<P>
     elemental, 12, 153, 444                                      369, 390, 395, 431, 435
<P>
     logical, 150                                       partially associated, 521
<P>
     numeric, 148                                       PASS attribute, 75, 77, 82, 311
<P>
     relational, 149                                    passed-object dummy argument, 17, 77, 81, 82, 86, 308,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>operator precedence, 151</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
313, 588
</TD></TR>
<TR valign=top><TD colspan=2>
<B>OPTIONAL attribute, 108, 108, 110, 116, 164, 183,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
PAUSE statement, 539
</TD></TR>
<TR><TD colspan=2>
<PRE>
           189, 301                                     pending affector, 98, 235, 240, 507, 508
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>optional dummy argument, 321</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
PENDING= specifier, 254, 255, 257
</TD></TR>
<TR valign=top><TD colspan=2>
<B>OPTIONAL statement, 116, 184</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
POINTER, 74, 75, 77
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
635
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<BLOCKQUOTE>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>pointer, 6, 11, 12, 17, 20, 22, 24, 46, 71, 76, 136, 142–</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
preconnection, 226
</TD></TR>
<TR><TD colspan=2>
<PRE>
          144, 166, 300, 301, 316, 334, 428, 479, 491,      prefix (R1526), 327, 327, 328, 330
<P>
          502, 517, 584                                     prefix-spec (R1527), 327, 327, 328, 334, 336
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>procedure, 483</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
PRESENT, 60, 75, 108, 164, 321, 338, 414, 585
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer assignment, 17, 103, 105, 142, 170, 171, 172,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
present, 320
</TD></TR>
<TR><TD colspan=2>
<PRE>
          321, 518                                          primary, 147
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer assignment statement, 17, 22, 58, 77, 89, 163,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
primary (R1001), 147, 147, 148, 333
</TD></TR>
<TR><TD colspan=2>
<PRE>
          171, 173, 179, 348, 354                           PRINT statement, 219, 228, 231, 240, 245, 246, 250
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer association, 6, 6, 12, 22, 23, 44, 47, 85, 87, 89,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
print-stmt (R1212), 37, 232, 335
</TD></TR>
<TR><TD colspan=2>
<PRE>
          101, 106, 108, 110, 111, 131, 143, 145, 171,      PRIVATE attribute, 71, 86, 98, 98, 111, 123, 335, 571
<P>
          173, 174, 193, 207, 210, 240, 300, 314, 316,      PRIVATE statement, 80, 81, 83, 111, 296
<P>
          318, 320, 321, 329, 330, 343, 354, 407, 411,      private-components-stmt (R745), 70, 80, 80
<P>
          482, 483, 517–520, 522, 528, 584                  private-or-sequence (R729), 69, 70, 70
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer association context, 106, 109, 334, 528</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
proc-attr-spec (R1514), 308, 308, 309
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer association status, 517</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
proc-component-attr-spec (R742), 75, 75, 77
</TD></TR>
<TR valign=top><TD colspan=2>
<B>POINTER attribute, 5, 17, 58–60, 68, 69, 74, 75, 96,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
proc-component-def-stmt (R741), 74, 75, 75
</TD></TR>
<TR><TD colspan=2>
<PRE>
          103, 105, 108, 108, 110, 115, 117, 131, 134,      proc-component-ref (R1039), 172, 172, 311, 321
<P>
          142, 172, 183, 192, 199, 200, 299–301, 303, 306,  proc-decl (R1515), 75, 78, 308, 309, 309
<P>
          307, 309, 317, 320–323, 328, 334, 336, 484, 488,  proc-entity-name, 116, 117
<P>
          503, 516, 519, 522, 523, 543, 587, 591            proc-interface (R1513), 75, 308, 308, 309
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>POINTER statement, 116, 298</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
proc-language-binding-spec (R1528), 308, 309, 328, 328,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer-assignment-stmt (R1033), 37, 171, 177, 178,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
330, 333, 489
</TD></TR>
<TR><TD colspan=2>
<PRE>
          334, 529                                          proc-pointer-init (R1517), 309, 309
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer-decl (R854), 116, 116</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
proc-pointer-name (R858), 117, 117, 142, 172
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer-object (R939), 142, 142, 529</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
proc-pointer-object (R1038), 171, 172, 173, 178, 354,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer-stmt (R853), 37, 116, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
529
</TD></TR>
<TR valign=top><TD colspan=2>
<B>polymorphic, 17, 31, 60, 61, 77, 90, 104, 105, 131, 142,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
proc-target (R1040), 88, 89, 171, 172, 173, 178, 321,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          162, 167, 168, 173, 182, 183, 189, 192, 201, 203,           354, 520
<P>
          237, 243, 300, 301, 311, 314–317, 334, 335, 379,  PROCEDURE, 75, 81, 308, 330
<P>
          403, 407, 421, 428, 517, 522                      procedure, 11, 18, 19, 47, 48, 108, 302
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>POPCNT, 414</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
characteristics of, 300
</TD></TR>
<TR valign=top><TD colspan=2>
<B>POPPAR, 414</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
dummy, 8, 12, 14, 18, 105, 118, 121, 123, 165, 172,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>POS= specifier, 220–222, 232, 233, 236, 236, 254, 258,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
299, 300, 302–304, 308, 309, 312, 319, 320, 326,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          534                                                         328, 334, 507, 510, 515
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>position edit descriptor, 280</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
elemental, 12, 45, 163, 173, 309, 312, 321, 325, 327,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>position-edit-desc (R1315), 267, 267</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
335, 335–338
</TD></TR>
<TR valign=top><TD colspan=2>
<B>position-spec (R1227), 251, 251</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
external, 18, 29, 38, 81, 105, 118, 121, 172, 211,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>POSITION= specifier, 226, 227, 229, 254, 258, 565</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
299, 300, 302–304, 308, 309, 312, 320, 326, 509,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>positional arguments, 337</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
510, 514, 515, 543, 573, 578, 582
</TD></TR>
<TR valign=top><TD colspan=2>
<B>potential subobject component, 9, 31, 69, 70, 139, 335,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
internal, 14, 18, 38, 172, 299–302, 312, 320, 326,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          438, 440                                                    328, 330, 354, 507, 510, 511, 514
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>power-op (R1007), 51, 148, 148</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
intrinsic, 337–436
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pre-existing, 522</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
module, 18, 81, 122, 172, 299–304, 309, 312, 320,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>precedence of operators, 151</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
326, 327, 330, 331, 333, 436, 510, 511
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRECISION, 62, 414, 464</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
non-Fortran, 332
</TD></TR>
<TR valign=top><TD colspan=2>
<B>preconnected, 18, 219, 224–226, 229, 234, 240, 438–440</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
pure, 18, 31, 178, 189, 333, 335, 337, 342, 407,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>636</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                              ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>418, 436, 444, 450, 483</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>type-bound, 7, 15, 17, 18, 68, 70, 77, 82, 82–86,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
QUIET= specifier, 205
</TD></TR>
<TR><TD colspan=2>
<PRE>
          170, 249, 295, 305, 311, 313, 315, 326, 510,
<P>
          511                                              R
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>procedure declaration statement, 40, 105, 301, 303, 308,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
r (R1306), 266, 266–268
</TD></TR>
<TR><TD colspan=2>
<PRE>
          332, 348, 511, 543                               RADIX, 62, 415, 444, 464
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>procedure designator, 11, 19, 45</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
RANDOM_INIT, 348, 416, 535
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RANDOM_NUMBER, 348, 416, 417
<P>
</PRE>
procedure interface, 301
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RANDOM_SEED, 338, 348, 416
<P>
</PRE>
procedure pointer, 8, 14, 17, 17, 38, 96, 105, 106, 108,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RANGE, 61, 62, 417, 464
<P>
</PRE>
125, 172, 174, 299, 300, 303, 304, 308, 312,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RANK, 60, 417
<P>
</PRE>
313, 319–321, 326, 330, 483, 511, 514, 543, 584
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           rank, 18, 20, 43–46, 76, 77, 83, 84, 88, 89, 95, 99, 101–
<P>
</PRE>
procedure reference, 5, 19, 31, 44, 108, 133, 246, 299,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      105, 116, 126, 131–135, 137, 139, 141, 160, 162,
<P>
</PRE>
305, 311, 313
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      163, 167–169, 171–175, 183, 209, 300, 305–307,
<P>
</PRE>
generic, 307
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      316, 317, 320, 321, 325, 336, 347, 352, 353,
<P>
</PRE>
resolving, 324
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      369–371, 375, 376, 380, 381, 387, 388, 392, 394,
<P>
</PRE>
type-bound, 326
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      395, 400–407, 410, 411, 413, 415, 416, 419, 424,
<P>
</PRE>
PROCEDURE statement, 302, 304, 543
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      426, 427, 429, 431, 433–435, 476, 482, 488, 513,
<P>
</PRE>
procedure-component-name, 172
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      520, 587, 588
<P>
</PRE>
procedure-declaration-stmt (R1512), 36, 308, 309
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RANK ( * ), 104, 199
<P>
</PRE>
procedure-designator (R1522), 311, 311, 321, 326
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RANK DEFAULT, 105, 199
<P>
</PRE>
procedure-entity-name, 309, 310
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           rbracket (R772), 74, 92, 93, 95, 96, 112, 113, 117, 137,
<P>
</PRE>
procedure-name, 81, 82, 172, 174, 302, 303, 309, 311,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                      138
<P>
</PRE>
312, 330, 331
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RC edit descriptor, 282
<P>
</PRE>
procedure-stmt (R1506), 302, 302, 303
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           RD edit descriptor, 282
<P>
</PRE>
processor, 18, 29, 30, 47, 48
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           READ (FORMATTED), 243, 302
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>processor dependent, 18, 30, 47, 531–537</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
READ (UNFORMATTED), 243, 244, 302
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRODUCT, 415</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
READ statement, 33, 44, 220, 224, 228, 231, 240, 245,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>program, 18, 29, 30, 38</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
246, 250, 253, 261, 527, 563–565, 567, 569
</TD></TR>
<TR valign=top><TD colspan=2>
<B>program (R501), 35</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
read-stmt (R1210), 37, 231, 232, 335, 528
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PROGRAM statement, 293</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
READ= specifier, 254, 258
</TD></TR>
<TR valign=top><TD colspan=2>
<B>program unit, 16, 17, 18, 18, 19, 21, 29, 35, 38–40, 42,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
READWRITE= specifier, 254, 258
</TD></TR>
<TR><TD colspan=2>
<PRE>
          46, 49, 50, 52–55, 72, 109, 118, 224, 230, 293,  REAL, 169, 339, 418, 445
<P>
          297, 385, 505, 509, 517, 541, 544, 570–572, 574, real and complex editing, 272
<P>
          577–581, 597                                     real model, 340
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>program-name, 293</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
real part, 64
</TD></TR>
<TR valign=top><TD colspan=2>
<B>program-stmt (R1402), 35, 293, 293</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
real type, 62–64, 64
</TD></TR>
<TR valign=top><TD colspan=2>
<B>program-unit (R502), 28, 35, 35, 38</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
real-literal-constant (R714), 51, 63, 63
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PROTECTED attribute, 31, 109, 109, 117, 124, 192,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
real-part (R719), 64, 64
</TD></TR>
<TR><TD colspan=2>
<PRE>
          295, 543                                         REAL128, 441
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PROTECTED statement, 117</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
REAL32, 441
</TD></TR>
<TR valign=top><TD colspan=2>
<B>protected-stmt (R855), 37, 117</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
REAL64, 441
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PUBLIC attribute, 86, 98, 98, 111, 123, 571</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
REAL_KINDS, 440
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PUBLIC statement, 111, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
REC= specifier, 221, 232, 233, 236
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PURE, 327, 327, 332, 334</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
RECL= specifier, 227, 229, 242, 243, 254, 258, 260,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pure procedure, 18, 31, 178, 189, 333, 335, 337, 342,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
526, 533
</TD></TR>
<TR><TD colspan=2>
<PRE>
          407, 418, 436, 444, 450, 483, 543                record, 18, 217
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
637
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>record file, 13, 19, 217, 219, 221–223</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
save-stmt (R856), 37, 117, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>record number, 219</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
saved, 19, 517, 523
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RECURSIVE, 66, 327, 332</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
saved-entity (R857), 117, 117, 184
</TD></TR>
<TR valign=top><TD colspan=2>
<B>recursive input/output statement, 262</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
scalar, 19, 19, 21, 335
</TD></TR>
<TR valign=top><TD colspan=2>
<B>REDUCE, 418</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
scalar-xyz (R403), 28, 28
</TD></TR>
<TR valign=top><TD colspan=2>
<B>reference, 19, 45</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SCALE, 421
</TD></TR>
<TR><TD colspan=2>
<PRE>
     procedure, 31                                        scale factor, 267, 282
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>rel-op (R1013), 51, 149, 149, 159, 445</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SCAN, 422
</TD></TR>
<TR valign=top><TD colspan=2>
<B>relational intrinsic operation, 158</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
scoping unit, 6, 14, 19, 25, 38, 40, 41, 43, 47, 66, 71,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>rename (R1411), 295, 295, 296, 510</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
72, 81, 84, 88, 97–99, 105, 107, 110, 111, 117,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>rep-char, 66, 67, 268, 284, 289</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
118, 120–123, 125, 126, 143, 165, 172, 184, 185,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>REPEAT, 419</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
189, 192, 193, 235, 238, 294–296, 301, 303, 307,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>repeat specification, 266</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
324–328, 331, 333, 443, 445, 505, 510–516, 519,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>representation method, 61, 62, 65, 68</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
521, 522, 526, 571, 582, 588
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RESHAPE, 94, 420</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
section subscript, 135
</TD></TR>
<TR valign=top><TD colspan=2>
<B>resolving procedure reference, 324</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
section-subscript (R920), 25, 130, 131, 133, 133, 135–
</TD></TR>
<TR valign=top><TD colspan=2>
<B>resolving procedure references</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
137
</TD></TR>
<TR><TD colspan=2>
<PRE>
     defined input/output, 249                            segment, 207
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>restricted expression, 164</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SELECT CASE construct, 41, 196, 541, 553
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RESULT, 328, 328, 329, 331, 332</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SELECT CASE statement, 53, 196
</TD></TR>
<TR valign=top><TD colspan=2>
<B>result-name, 328, 329, 331, 332, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SELECT RANK construct, 41, 46, 104, 105, 183, 199,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RETURN statement, 41, 85, 109, 126, 143, 144, 185,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
321, 528
</TD></TR>
<TR><TD colspan=2>
<PRE>
          187, 192, 332, 482, 527                         SELECT RANK statement, 46, 105, 199, 516
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>return-stmt (R1542), 38, 40, 332, 332</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SELECT TYPE construct, 41, 46, 58, 59, 183, 201,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>REWIND statement, 218, 219, 221, 247, 250, 252, 252,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
321, 512, 513, 516, 528
</TD></TR>
<TR><TD colspan=2>
<PRE>
          564                                             SELECT TYPE statement, 46, 53, 201, 516
<P>
</PRE>
rewind-stmt (R1226), 38, 251, 335
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          select-case-stmt (R1141), 7, 196, 197, 197, 204
<P>
</PRE>
RN edit descriptor, 282
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          select-construct-name, 199–202
<P>
</PRE>
round edit descriptor, 282
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          select-rank-case-stmt (R1150), 199, 199, 200
<P>
</PRE>
round-edit-desc (R1319), 267, 268
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          select-rank-construct (R1148), 37, 199, 199, 200
<P>
</PRE>
ROUND= specifier, 227, 230, 232, 233, 236, 247, 254,
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          select-rank-stmt (R1149), 7, 199, 199, 200, 204
<P>
</PRE>
259, 283
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          select-type-construct (R1152), 37, 201, 202
<P>
</PRE>
rounding mode
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          select-type-stmt (R1153), 7, 201, 201, 202, 204
<P>
</PRE>
IEEE, 443, 444, 447, 448, 449, 454, 463, 466, 473
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          SELECTED_CHAR_KIND, 65, 422
<P>
</PRE>
input/output, 224, 230, 236, 259, 277, 282, 472
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          SELECTED_INT_KIND, 61, 73, 423
<P>
</PRE>
RP edit descriptor, 282
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          SELECTED_REAL_KIND, 62, 338, 423, 544
<P>
</PRE>
RRSPACING, 420
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          selector, 182
<P>
</PRE>
RU edit descriptor, 282
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                          selector (R1105), 182, 182, 183, 185, 186, 199, 201–203,
<P>
</PRE>
RZ edit descriptor, 282
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                    321, 517, 528
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>S</B> </TD><TD valign=bottom>
separate module procedure, 330
</TD></TR>
<TR valign=top><TD colspan=2>
<B>S edit descriptor, 282</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
separate module subprogram statement, 330
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SAME_TYPE_AS, 75, 421</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
separate-module-subprogram (R1538), 36, 294, 330,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SAVE attribute, 19, 24, 33, 46, 78, 85, 97, 99, 100, 109,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
330, 331
</TD></TR>
<TR><TD colspan=2>
<PRE>
          109, 110, 113, 117, 124, 126, 144, 192, 309, sequence, 19
<P>
          334, 518                                        sequence association, 320
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SAVE statement, 117, 184, 298, 511</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SEQUENCE attribute, 19, 69, 71, 71, 72, 85, 125, 172,
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>638</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
<PRE>
                                                                             ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>173, 202, 486</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
specification expression, 20, 24, 41, 73, 75, 84, 98, 133,
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SEQUENCE statement, 71</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
164, 165, 165, 184, 332, 445, 541, 543
<TABLE width=100% cellpadding=3><!-- tsb: 164, 165, 165, 184, 332, 445, 541, 543
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>sequence structure, 19</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
specification function, 165
</TD></TR>
<TR valign=top><TD colspan=2>
<B>sequence type, 19, 19, 31, 69, 71, 71, 124, 487, 520</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
specification inquiry, 164
</TD></TR>
<TR><TD colspan=2>
<PRE>
     character, 20, 71, 124–126, 521, 525                 specification-construct (R508), 36, 36, 184
<P>
     numeric, 20, 71, 124–126, 521, 525                   specification-expr (R1028), 7, 59, 66, 97, 101, 102, 164,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>sequence-stmt (R731), 70, 71</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
164, 336
</TD></TR>
<TR valign=top><TD colspan=2>
<B>sequential access, 219</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
specification-part (R504), 35, 36, 36, 41, 81, 98, 99, 111,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>sequential access data transfer statement, 236</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
165, 166, 293, 294, 297, 298, 302, 328, 330, 334,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SEQUENTIAL= specifier, 254, 259</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
336
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SET_EXPONENT, 424</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SPREAD, 427
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SHAPE, 60, 424</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SQRT, 32, 428, 449, 473
</TD></TR>
<TR valign=top><TD colspan=2>
<B>shape, 20, 45, 207</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SS edit descriptor, 282
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SHARED, 189, 192, 193</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
standard intrinsic, xviii, 16, 29, 436
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SHIFTA, 424</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
standard-conforming program, 20, 29
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SHIFTL, 425</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
stat-variable (R942), 41, 137, 138, 140, 142, 143, 144,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SHIFTR, 425</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
144, 145, 208, 209, 212–216, 227, 231, 232, 250,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SIGN, 32, 33, 63, 425</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
251, 253, 254, 260–262, 394, 528, 532
</TD></TR>
<TR valign=top><TD colspan=2>
<B>sign (R712), 62, 62, 63, 272</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STAT= specifier, xix, 137, 138, 141–143, 144, 187, 208,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>sign mode, 230, 271, 282</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
215, 441, 525, 532
</TD></TR>
<TR valign=top><TD colspan=2>
<B>sign-edit-desc (R1317), 267, 268</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STAT_FAILED_IMAGE, 41, 138, 145, 215, 216, 341,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SIGN= specifier, 227, 230, 232, 233, 236, 254, 259,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
380, 407, 408, 441, 442
</TD></TR>
<TR><TD colspan=2>
<PRE>
          282                                             STAT_LOCKED, 216, 441, 442
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>signed-digit-string (R710), 62, 63, 271–273</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STAT_LOCKED_OTHER_IMAGE, 216, 441, 442
</TD></TR>
<TR valign=top><TD colspan=2>
<B>signed-int-literal-constant (R707), 62, 62, 64, 114, 267</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STAT_STOPPED_IMAGE, 145, 215, 216, 341, 407,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>signed-real-literal-constant (R713), 63, 64, 114</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
408, 428, 441, 442
</TD></TR>
<TR valign=top><TD colspan=2>
<B>significand (R715), 63, 63</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STAT_UNLOCKED, 216, 441, 442
</TD></TR>
<TR valign=top><TD colspan=2>
<B>simply contiguous, 20, 136, 137, 137, 173, 315, 317,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STAT_UNLOCKED_FAILED_IMAGE, 216, 441,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          318, 490, 491                                             442
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SIN, 426</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statement, 20, 53
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SINH, 426</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
accessibility, 111
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SIZE, 60, 426</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ALLOCATABLE, 112
</TD></TR>
<TR valign=top><TD colspan=2>
<B>size, 20, 45</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ALLOCATE, 58, 59, 66, 101, 103, 138, 141, 144,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>size of a common block, 126</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
145, 172, 206, 438, 497, 498, 517, 518, 525–527,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SIZE= specifier, 232, 236, 254, 259, 261, 524, 527, 564</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
532, 543
</TD></TR>
<TR valign=top><TD colspan=2>
<B>source-expr (R930), 138, 138–142, 334, 517–519</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
arithmetic IF, 540
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SOURCE= specifier, 138, 140, 142, 334, 438, 525–527,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASSIGN, 539
</TD></TR>
<TR><TD colspan=2>
<PRE>
          543                                                  assigned GO TO, 539
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SP edit descriptor, 282</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
assignment, 17, 31, 44, 58, 84, 167, 179, 475, 524
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SPACING, 427</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASSOCIATE, 46, 182, 516
</TD></TR>
<TR valign=top><TD colspan=2>
<B>special character, 49</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
ASYNCHRONOUS, 112, 184, 298, 512, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>specific interface, 15, 249, 303, 303, 304, 309, 325, 543</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
attribute specification, 111–127
</TD></TR>
<TR valign=top><TD colspan=2>
<B>specific interface block, 15, 15, 303</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
BACKSPACE, 218, 221, 247, 250, 251, 252, 564,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>specific name, 20</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
565
</TD></TR>
<TR valign=top><TD colspan=2>
<B>specific-procedure (R1507), 302, 302, 304</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
BIND, 112, 298, 505, 511
</TD></TR>
<TR valign=top><TD colspan=2>
<B>specification, 95–127</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
BLOCK, 97, 101, 103, 184, 525
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
639
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
    BLOCK DATA, 53, 293, 297                              END PROCEDURE, 53, 331
<P>
    CALL, 22, 204, 207, 299, 311, 324, 332, 407           END PROGRAM, 53, 293
<P>
    CASE, 197                                             END SELECT, 53, 197, 202
<P>
    CHANGE TEAM, 22, 40, 46, 185, 206, 215, 341,          END SUBMODULE, 53, 297
<P>
         516                                              END SUBROUTINE, 53, 330
<P>
    CLASS DEFAULT, 202                                    END TEAM, 40, 53, 185, 206, 215, 341
<P>
    CLASS IS, 202, 379                                    END TYPE, 53, 70
<P>
    CLOSE, 218, 219, 223, 225, 226, 230, 230, 247,        END WHERE, 53, 175
<P>
         250, 564                                         ENDFILE, 53, 218, 219, 221, 228, 247, 250, 252,
<P>
    COMMON, 8, 125, 125–127, 184, 296, 298, 511,                564
<P>
         521, 540                                         ENTRY, 12, 40, 160, 170, 294, 299, 303, 327, 328,
<P>
    component definition, 74                                    331, 511, 521, 540, 542
<P>
    computed GO TO, 7, 204, 205, 540, 541                 ENUM, 90
<P>
    CONTAINS, 39, 40, 81, 332                             ENUMERATOR, 90
<P>
    CONTIGUOUS, 113                                       EQUIVALENCE, 123, 123–126, 184, 296, 298, 521,
<P>
    CONTINUE, 205, 539                                          540, 542
<P>
    CRITICAL, 161, 187, 206, 207, 216                     ERROR STOP, 41, 42, 205, 532
<P>
    CYCLE, 182, 188, 191, 192, 542                        EVENT POST, 206, 207, 211, 212, 215, 377, 438,
<P>
    DATA, 32, 33, 40, 92, 97, 113, 126, 298, 411, 512,          525, 528, 533
<P>
         515, 523, 540, 541                               EVENT WAIT, 206, 207, 212, 212, 215, 438, 525,
<P>
    data transfer, 33, 52, 217–223, 225, 231, 236, 239–         528, 533
<P>
         241, 246, 250, 252, 260–263, 265, 266, 277, 282, executable, 20, 20, 39
<P>
         284–286, 288, 290, 439, 524, 526, 534, 563, 564, EXIT, 182, 192, 204
<P>
         567, 568                                         EXTERNAL, 105, 308
<P>
    DEALLOCATE, 142, 144, 145, 206, 438, 498, 532         FAIL IMAGE, 206
<P>
    defined assignment, 31, 170, 171, 324, 528            file inquiry, 253
<P>
    derived type definition, see statement, TYPE          file positioning, 218, 251
<P>
    DIMENSION, 115, 298                                   FINAL, 13, 83
<P>
    DO, 188, 524, 540, 542                                FLUSH, 219, 250, 253, 262
<P>
    DO CONCURRENT, 59, 178, 188                           FORALL, 59, 153, 179, 512, 524
<P>
    DO WHILE, 188                                         FORM TEAM, 22, 40, 137, 186, 206, 207, 212,
<P>
    ELSE, 195                                                   215, 525, 528, 533
<P>
    ELSE IF, 53, 195                                      FORMAT, 29, 40, 52, 234, 265, 265, 294
<P>
    ELSEWHERE, 53, 175                                    formatted input/output, 217, 233
<P>
    END, 13, 40, 109, 126, 143, 144, 207, 482, 527        FUNCTION, 12, 59, 60, 118, 160, 164, 293, 327,
<P>
    END ASSOCIATE, 53, 182                                      328, 331, 332, 511
<P>
    END BLOCK, 53, 144, 184                               GENERIC, 81, 82, 304, 304, 307, 324
<P>
    END BLOCK DATA, 53, 297                               GO TO, 7, 53, 204, 204
<P>
    END CRITICAL, 53, 161, 187, 206, 207                  IF, 153, 196
<P>
    END DO, 53, 189                                       IMPLICIT, 40, 118, 123, 298
<P>
    END ENUM, 53, 90                                      IMPLICIT NONE, 118
<P>
    END FORALL, 53, 177                                   IMPORT, 40, 120, 509, 515
<P>
    END FUNCTION, 53, 328                                 input/output, 217–262, 524
<P>
    END IF, 53, 195, 539                                  INQUIRE, 32, 219, 220, 222, 223, 225, 226, 235,
<P>
    END INTERFACE, 53, 302                                      236, 246, 247, 250, 253, 262, 263, 439, 524,
<P>
    END MODULE, 53, 294                                         526–528, 534, 563
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>640</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                              c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                          ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>INTENT, 116, 184</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SYNC ALL, 186, 206, 208, 209, 210, 215, 216
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INTERFACE, 302, 573</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SYNC IMAGES, 206, 209, 215, 216
</TD></TR>
<TR valign=top><TD colspan=2>
<B>INTRINSIC, 298, 310</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SYNC MEMORY, 206, 207, 210, 215, 216, 593
</TD></TR>
<TR valign=top><TD colspan=2>
<B>intrinsic assignment, 31, 89, 143, 145, 163, 167,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SYNC TEAM, 186, 206, 211, 215, 216
</TD></TR>
<TR><TD colspan=2>
<PRE>
         171, 173, 216, 253, 262, 289, 334, 335, 524,       TARGET, 117, 298
<P>
         532                                                TYPE, 69, 73, 98, 514
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>list-directed input/output, 234</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type declaration, 40, 59, 60, 78, 95, 95–97, 105,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>LOCK, 206, 207, 213, 216, 440, 441, 525, 528</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
118, 123, 126, 165, 294, 298, 329, 331, 333,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>MODULE, 293, 294</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
523
</TD></TR>
<TR valign=top><TD colspan=2>
<B>NAMELIST, 123, 184, 288, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type guard, 66, 202
</TD></TR>
<TR valign=top><TD colspan=2>
<B>namelist input/output, 234</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
TYPE IS, 202, 421
</TD></TR>
<TR valign=top><TD colspan=2>
<B>nonexecutable, 20, 39</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type parameter definition, 73
</TD></TR>
<TR valign=top><TD colspan=2>
<B>NULLIFY, 142</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type-bound procedure, 81, 82
</TD></TR>
<TR valign=top><TD colspan=2>
<B>OPEN, 33, 218, 219, 223–225, 226, 226, 230, 234,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
unformatted input/output, 218, 233
</TD></TR>
<TR><TD colspan=2>
<PRE>
         242, 243, 247, 256, 260, 277, 289, 525, 528,       UNLOCK, 206, 207, 213, 216, 440, 441, 525, 528
<P>
         533, 534, 563, 565–567                             USE, 6, 19, 40, 72, 111, 294, 298, 324–326, 510,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>OPTIONAL, 116, 184</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
512, 513, 516, 570–572, 577
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PARAMETER, 40, 116, 118, 298</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
VALUE, 117, 184
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PAUSE, 539</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
VOLATILE, 118, 184, 298, 512, 514
</TD></TR>
<TR valign=top><TD colspan=2>
<B>POINTER, 116, 298</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
WAIT, 225, 235, 250, 250, 567, 568
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pointer assignment, 17, 22, 58, 77, 89, 163, 171,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
WHERE, 17, 153, 175
</TD></TR>
<TR><TD colspan=2>
<PRE>
         173, 179, 348, 354                                 WRITE, 219, 224, 228, 231, 240, 245, 246, 250,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRINT, 219, 228, 231, 240, 245, 246, 250</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
262, 524, 563, 564, 566, 567
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PRIVATE, 80, 81, 83, 111, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statement entity, 21, 192, 509, 510, 512
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PROCEDURE, 302, 304, 543</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statement function, 333, 541
</TD></TR>
<TR><TD colspan=2>
procedure declaration, 40, 105, 301, 303, 308, 332, statement function statement, 12, 40, 66, 184, 294, 324,
</TD></TR>
<TR><TD colspan=2>
<PRE>
         348, 511, 543                                            332, 333, 512, 513, 541
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PROGRAM, 293</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statement keyword, 16, 47
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PROTECTED, 117</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statement label, 7, 21, 52, 52–55, 312, 509
</TD></TR>
<TR valign=top><TD colspan=2>
<B>PUBLIC, 111, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
statement order, 39
</TD></TR>
<TR valign=top><TD colspan=2>
<B>READ, 33, 44, 220, 224, 228, 231, 240, 245, 246,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STATUS= specifier, 226–229, 230, 231, 231, 533, 534,
</TD></TR>
<TR><TD colspan=2>
<PRE>
         250, 253, 261, 527, 563–565, 567, 569                    566
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RETURN, 41, 85, 109, 126, 143, 144, 185, 187, 192,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
stmt-function-stmt (R1544), 36, 294, 297, 303, 333, 514
</TD></TR>
<TR><TD colspan=2>
<PRE>
         332, 482, 527                                 STOP statement, 41, 42, 205, 207, 335, 532
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>REWIND, 218, 219, 221, 247, 250, 252, 252, 564</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
stop-code (R1162), 205, 205, 206
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SAVE, 117, 184, 298, 511</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
stop-stmt (R1160), 38, 85, 205
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SELECT CASE, 53, 196</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
stopped image, 14, 41, 140, 144, 145, 341, 407
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SELECT RANK, 46, 105, 199, 516</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
STOPPED_IMAGES, 428
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SELECT TYPE, 46, 53, 201, 516</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
storage association, 6, 6, 46, 47, 123–127, 331, 334, 429,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>separate module subprogram, 330</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
519–522
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SEQUENCE, 71</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
storage sequence, 21, 69, 71, 124–127, 298, 354, 520,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>statement function, 12, 40, 66, 184, 294, 324, 332,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
520, 521
</TD></TR>
<TR><TD colspan=2>
<PRE>
         333, 512, 513, 541                            storage unit, 21, 21, 123–127, 235, 239, 247, 250, 298,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>STOP, 41, 42, 205, 207, 335, 532</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
320, 354, 520–522
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SUBMODULE, 293, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
character, 21, 21, 104, 124, 126, 437, 520, 524, 526
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SUBROUTINE, 12, 170, 293, 327, 330, 331, 332</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
file, 13, 21, 217, 220–223, 229, 234, 236, 242, 252,
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
641
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<P>
<PRE>
          258–260, 439, 520                                subscript (R919), 114, 133, 133, 136, 239
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>numeric, 21, 21, 126, 440, 520, 524, 526</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
subscript triplet, 135
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unspecified, 21, 21, 520, 524, 526</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
subscript-triplet (R921), 133, 133–136
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .TP -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
<B>STORAGE_SIZE, 92, 428</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
substring, 130
</TD></TR>
<TR valign=top><TD colspan=2>
<B>stream access, 220</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
substring (R908), 124, 129, 130
</TD></TR>
<TR valign=top><TD colspan=2>
<B>stream access data transfer statement, 236</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
substring ending point., 130
</TD></TR>
<TR valign=top><TD colspan=2>
<B>stream file, 13, 21, 217, 220, 222, 260</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
substring starting point, 130
</TD></TR>
<TR valign=top><TD colspan=2>
<B>STREAM= specifier, 254, 259</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
substring-range (R910), 101, 130, 130, 132–134, 137,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>stride (R922), 133, 133, 135, 136, 239</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
239
</TD></TR>
<TR valign=top><TD colspan=2>
<B>structure, 9, 21, 42, 43, 69</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
suffix (R1532), 328, 328, 331
</TD></TR>
<TR valign=top><TD colspan=2>
<B>structure component, 21, 114, 130–132, 486, 551</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SUM, 429
</TD></TR>
<TR valign=top><TD colspan=2>
<B>structure constructor, 9, 16, 21, 43, 47, 57, 80, 88, 89,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SYNC ALL statement, 186, 206, 208, 209, 210, 215,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          114, 115, 162, 164, 165, 411, 440, 511, 547                216
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>structure-component (R913), 113, 114, 129, 130, 131,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SYNC IMAGES statement, 206, 209, 215, 216
</TD></TR>
<TR><TD colspan=2>
<PRE>
          136, 138, 142                                    SYNC MEMORY statement, 206, 207, 210, 215, 216,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>structure-constructor (R756), 21, 88, 88, 114, 147, 334</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
593
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subcomponent, 9, 10, 78, 88, 172, 517–519, 523, 525–</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
SYNC TEAM statement, 186, 206, 211, 215, 216
</TD></TR>
<TR><TD colspan=2>
<PRE>
          527                                              sync-all-stmt (R1164), 38, 208
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>submodule, 16, 18, 21, 21, 22, 38, 39, 43, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
sync-images-stmt (R1166), 38, 209
</TD></TR>
<TR valign=top><TD colspan=2>
<B>submodule (R1416), 35, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
sync-memory-stmt (R1168), 38, 210
</TD></TR>
<TR valign=top><TD colspan=2>
<B>submodule identifier, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
sync-stat (R1165), 185, 187, 208, 208–213, 215, 216
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SUBMODULE statement, 293, 297</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
sync-team-stmt (R1169), 38, 211
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           synchronous input/output, 228, 234, 236, 239
<P>
</PRE>
submodule-name, 297
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                           SYSTEM_CLOCK, 430
<P>
</PRE>
submodule-stmt (R1417), 35, 297, 297
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subobject, 5, 9, 10, 21, 43–45, 106, 131, 315, 517, 518</B> <!-- Consumed .TP -->
<BR>
<B>subprogram, 16, 21, 38, 40, 41, 43, 118</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
T edit descriptor, 281
</TD></TR>
<TR><TD colspan=2>
<PRE>
     elemental, 13, 327, 328, 335, 336                     TAN, 430
<P>
     external, 18, 22, 38, 299                             TANH, 430
<P>
     internal, 22, 38, 40, 299, 514                        target, 12, 22, 44, 46, 61, 77–79, 84, 89, 97, 100, 101,
<P>
     module, 22, 38, 40                                              103, 105–109, 115, 129, 131, 138, 141, 142, 144,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subroutine, 22</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
162, 163, 168, 171–173, 178, 179, 237, 241, 243,
</TD></TR>
<TR><TD colspan=2>
<PRE>
     atomic, 22, 41, 207, 208, 337, 340, 342, 356–360,               309, 312, 314, 316, 318, 320, 481, 483, 484,
<P>
          377, 437, 441, 528                                         516–519, 522, 525, 527, 528
<P>
     collective, 22, 337, 341, 342, 365–368, 380, 428, 441 TARGET attribute, 6, 22, 31, 78, 108, 110, 110, 117,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subroutine reference, 324</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
124, 126, 142, 143, 172, 183, 192, 193, 200, 301,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>SUBROUTINE statement, 12, 170, 293, 327, 330, 331,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
307, 315, 316, 318, 321–323, 367, 407, 418, 481,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          332                                                        484, 504, 505, 517–519, 527, 543, 584, 585
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subroutine-name, 303, 330, 511</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
TARGET statement, 117, 298
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subroutine-stmt (R1535), 35, 302, 303, 327, 328, 330,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
target-decl (R860), 117, 117
</TD></TR>
<TR><TD colspan=2>
<PRE>
          330, 511, 514                                    target-stmt (R859), 37, 117, 514
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subroutine-subprogram (R1534), 21, 35, 36, 294, 330,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
team, 14, 22, 22, 40, 45, 46, 137, 138, 144, 186, 208,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          330                                                        209, 211, 213, 215, 337, 341, 390, 412, 428,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subroutines</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
431, 432
</TD></TR>
<TR><TD colspan=2>
<PRE>
     intrinsic, 337                                             current, 341
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>subscript, 133</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
team number, 22, 137, 213
</TD></TR>
<TR><TD colspan=2>
<PRE>
     section, 135                                          team variable, 25, 186, 441, 525
<P>
</PRE>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>642</B> <!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<PRE>
                                                                   c ISO/IEC 2017 – All rights reserved
<P>
<P>
                                                                               ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>team-construct-name, 185</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
integer, 61–62
</TD></TR>
<TR valign=top><TD colspan=2>
<B>team-number (R1176), 212, 212, 213</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
intrinsic, 9, 23, 42, 43, 57, 61–68
</TD></TR>
<TR valign=top><TD colspan=2>
<B>team-value (R1115), 137, 185, 185, 186, 211</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
logical, 68
</TD></TR>
<TR valign=top><TD colspan=2>
<B>team-variable (R1177), 212, 212, 213, 215, 528</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
numeric, 23, 61–65, 154–156, 158, 162, 169, 373,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TEAM= specifier, 137, 137</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
374, 400, 415, 429
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TEAM_NUMBER, 431</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
operation, 163
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TEAM_NUMBER= specifier, 137, 137</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
parent, 9, 23, 70, 73, 80, 84–86, 307, 552
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TEAM_TYPE, 25, 74, 99, 131, 139, 140, 170, 185, 212,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
primary, 162
</TD></TR>
<TR><TD colspan=2>
<PRE>
          380, 385, 390, 412, 428, 431, 441, 527                 real, 62–64, 64
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>THEN, 195</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type compatible, 23, 60, 77, 139, 167, 171, 307, 315,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>THIS_IMAGE, 166, 431</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
407
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TINY, 427, 432</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type conformance, 167
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TKR compatible, 307</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type declaration statement, 40, 59, 60, 78, 95, 95–97,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TL edit descriptor, 281</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
105, 118, 123, 126, 165, 294, 298, 329, 331,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>totally associated, 521</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
333, 523
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TR edit descriptor, 281</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type equality, 71
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TRAILZ, 432</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type guard statement, 66, 202
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TRANSFER, 166, 432</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
TYPE IS statement, 202, 421
</TD></TR>
<TR valign=top><TD colspan=2>
<B>transfer of control, 181, 204, 261</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type parameter, 5, 7, 15, 16, 23, 31, 42, 58, 60, 61, 68,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>transformational function, 22, 166, 333, 337, 337, 338,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
71, 73, 77, 89, 93, 95–97, 116, 126, 162, 165,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          342, 361, 362, 437, 450                                     167, 183, 185, 300, 315, 336, 403, 407, 433,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TRANSPOSE, 433</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
481, 487, 511, 513
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TRIM, 433</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type parameter definition statement, 73
</TD></TR>
<TR valign=top><TD colspan=2>
<B>truncation, 339, 391, 418</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type parameter inquiry, 24, 132, 162, 164
</TD></TR>
<TR valign=top><TD colspan=2>
<B>TYPE, 59</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type parameter keyword, 16, 47, 88
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type, 23, 42, 57–93</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
type parameter order, 24, 73
</TD></TR>
<TR><TD colspan=2>
<PRE>
     abstract, 23, 59, 82, 85, 85, 88, 131, 139             type specifier, 59
<P>
     character, 65–68                                            CHARACTER, 65
<P>
     complex, 64–65                                              CLASS, 60
<P>
     declared, 23, 60, 61, 77, 89, 90, 93, 95, 130, 132,         COMPLEX, 64
<P>
          139, 140, 142, 160, 162, 167, 170–173, 182, 202,       derived type, 59
<P>
          203, 249, 306, 311, 314, 317, 326, 333, 379, 403,      DOUBLE PRECISION, 63
<P>
          407, 421, 438, 440, 513                                INTEGER, 61
<P>
     derived, 11, 21, 23, 42, 43, 46, 57, 68–90, 93, 486,        LOGICAL, 68
<P>
          487                                                    REAL, 63
<P>
     dynamic, 17, 23, 24, 60, 61, 84, 85, 87, 90, 93, 110,       TYPE, 59
<P>
          140, 142, 144, 160, 162, 168, 170, 171, 173,      TYPE statement, 69, 73, 98, 514
<P>
          183, 201, 202, 207, 210, 249, 311, 317, 326,      type-attr-spec (R728), 69, 69, 85
<P>
          347, 379, 403, 407, 421, 429, 513, 517, 522,      type-bound procedure, 7, 15, 17, 18, 68, 70, 77, 82, 82–
<P>
          552, 601                                                    86, 170, 249, 295, 305, 311, 313, 315, 326, 510,
<P>
     expression, 162                                                  511
<P>
     extended, 6, 9, 15, 23, 23, 73, 80, 84–86, 522, 544,   type-bound procedure statement, 81, 82
<P>
          549                                               type-bound-generic-stmt (R751), 81, 81, 305
<P>
     extensible, 23, 59, 70, 77, 85, 243, 379, 421, 552,    type-bound-proc-binding (R748), 81, 81
<P>
          590                                               type-bound-proc-decl (R750), 81, 81
<P>
     extension, 23, 60, 85, 87, 202, 317, 379, 590          type-bound-procedure-part (R746), 69, 71, 81, 83, 487
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>⃝c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
643
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ISO/IEC DIS 1539-1:2017 (E)
<TABLE width=100% cellpadding=3><!-- tsb: ISO/IEC DIS 1539-1:2017 (E)
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>type-bound-procedure-stmt (R749), 81, 81</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
until-spec (R1174), 212, 212
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-declaration-stmt (R801), 36, 66, 95, 95, 334, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
UNTIL_COUNT= specifier, 212, 377
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-guard-stmt (R1154), 201, 202, 202</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
upper-bound (R818), 102, 102, 103
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-name, 69, 70, 72, 82, 87</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
upper-bound-expr (R935), 138, 138, 172
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-param-attr-spec (R734), 73, 73</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
upper-cobound (R813), 100, 101, 101
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-param-decl (R733), 73, 73</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
use association, 6, 6, 17, 31, 39, 47, 60, 66, 86, 98, 109,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-param-def-stmt (R732), 69, 73, 73</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
111, 112, 118, 123–125, 164, 165, 172, 294,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-param-inquiry (R916), 24, 132, 132, 147, 511</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
293–297, 303, 331, 334, 511–514, 517
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-param-name, 69, 73, 75, 132, 147, 511, 514</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
use path, 296
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-param-spec (R755), 87, 87, 88</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
USE statement, 6, 19, 40, 72, 111, 294, 298, 324–326,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-param-value (R701), xix, 24, 58, 58, 59, 65, 66, 75,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
510, 512, 513, 516, 570–572, 577
</TD></TR>
<TR><TD colspan=2>
<PRE>
          87, 88, 139, 140, 327, 542                        use-defined-operator (R1415), 295, 295, 296
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>type-spec (R702), 59, 59, 66, 93, 138–141, 202</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
use-name, 295, 296, 510
</TD></TR>
<TR></TR></TABLE><!-- .nf -->
<PRE>
                                                            use-stmt (R1409), 36, 184, 295, 295, 514
<P>
</PRE>
</TD></TR>
<TR></TR></TABLE><A name=0>

     <H3>U</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>UBOUND, 60, 200, 434</B> <!-- Consumed .TP -->
<BR>
<B>UCOBOUND, 434</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
v (R1312), 246, 267, 267, 280
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ultimate argument, 24, 140, 144, 314, 318, 319, 321,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
VALUE attribute, 60, 77, 83, 105, 110, 110, 118, 192,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          322, 341                                                    240, 300, 301, 303, 305, 306, 314–318, 328, 334,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ultimate component, 9, 31, 68–70, 75, 99, 101, 104, 105,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
336, 367, 418, 489, 490, 507, 519, 543, 596, 598
</TD></TR>
<TR><TD colspan=2>
<PRE>
          110, 111, 124, 125, 139, 142, 166, 167, 243, 315, value separator, 283
<P>
          316, 334, 520                                     VALUE statement, 117, 184
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>ultimate entity, 296</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
value-stmt (R861), 37, 117
</TD></TR>
<TR valign=top><TD colspan=2>
<B>undefined, 12, 24, 44, 143, 517, 518, 523, 524</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
variable, 10, 21, 25, 43, 44, 46, 50, 108
</TD></TR>
<TR valign=top><TD colspan=2>
<B>undefinition of variables, 523</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
definition & undefinition, 523
</TD></TR>
<TR valign=top><TD colspan=2>
<B>underflow mode, 447, 448, 451, 455, 467, 474, 475, 536</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
variable (R902), 89, 113, 114, 129, 129, 137, 167–169,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>underscore (R602), 49, 49</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
171, 172, 177, 178, 182, 201, 211–213, 237, 311,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>UNFORMATTED, 243, 244, 302</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
321, 475, 528
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unformatted data transfer, 242</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
variable-name (R903), 123–125, 129, 129, 130, 138, 142,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unformatted input/output statement, 218, 233</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
171, 172, 189, 514, 528
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unformatted record, 217</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
vector subscript, 25, 45, 78, 101, 131, 135, 136, 182,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>UNFORMATTED= specifier, 254, 259</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
201, 223, 287, 315, 316, 321, 322, 516, 519,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>Unicode file, 228</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
584
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unit, 9, 18, 24, 218–220, 223, 223–226, 228–231, 235,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
vector-subscript (R923), 133, 133–135
</TD></TR>
<TR><TD colspan=2>
<PRE>
          236, 239–241, 245, 250, 251, 253–260, 262, 280,   VERIFY, 436
<P>
          286, 438, 439, 524, 526, 563, 565–568             VOLATILE attribute, 31, 110, 110, 111, 118, 172, 173,
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>UNIT= specifier, 226, 231, 232, 250, 251, 253, 254</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
183, 192, 294, 296, 300, 301, 316–318, 334, 514,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unlimited polymorphic, 24, 60, 60, 93, 125, 139, 171,</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
519, 525, 528, 550
</TD></TR>
<TR><TD colspan=2>
<PRE>
          172, 202, 317, 379, 421, 428, 601                 VOLATILE statement, 118, 184, 298, 512, 514
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unlimited-format-item (R1305), 265, 266, 266, 269</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
volatile-stmt (R862), 37, 118
</TD></TR>
<TR><TD colspan=2>
UNLOCK statement, 206, 207, 213, 216, 440, 441, 525,
</TD></TR>
<TR><TD colspan=2>
<PRE>
          528                                               W
<P>
</PRE>
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unlock-stmt (R1181), 38, 213</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
w (R1308), 267, 267, 271–280, 284, 286, 289
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unordered segments, 207, 207, 340, 348, 377, 416</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
wait operation, 226, 230, 236, 239, 240, 250, 250–251,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>UNPACK, 435</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
253, 257, 258, 260, 261
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unsaved, 24, 141, 143, 330, 518, 519, 525–527</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
WAIT statement, 225, 235, 250, 250, 567, 568
</TD></TR>
<TR valign=top><TD colspan=2>
<B>unspecified storage unit, 21, 21, 520, 524, 526</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
wait-spec (R1223), 250, 250
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>644</B> </TD><TD valign=bottom>
⃝c ISO/IEC 2017 – All rights reserved
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<PRE>
                                                                       ISO/IEC DIS 1539-1:2017 (E)
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
<B>wait-stmt (R1222), 38, 250, 335</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
WRITE (UNFORMATTED), 243, 244, 302
</TD></TR>
<TR valign=top><TD colspan=2>
<B>WHERE construct, 17, 175</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
WRITE statement, 219, 224, 228, 231, 240, 245, 246,
</TD></TR>
<TR valign=top><TD colspan=2>
<B>WHERE statement, 17, 153, 175</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
250, 262, 524, 563, 564, 566, 567
</TD></TR>
<TR><TD colspan=2>
where-assignment-stmt (R1045), 153, 175, 175, 177, write-stmt (R1211), 38, 231, 232, 335, 528
</TD></TR>
<TR><TD colspan=2>
<PRE>
         178                                         WRITE= specifier, 254, 260
<P>
</PRE>
where-body-construct (R1044), 175, 175–177
</TD></TR>
<TR valign=top><TD colspan=2>
<B>where-construct (R1042), 37, 175, 175, 177, 178</B> <!-- Consumed .TP -->
<BR>
<B>where-construct-name, 175</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
X edit descriptor, 281
</TD></TR>
<TR><TD colspan=2>
where-construct-stmt (R1043), 7, 175, 175, 176, 178, xyz-list (R401), 28
</TD></TR>
<TR><TD colspan=2>
<PRE>
         204                                         xyz-name (R402), 28
<P>
</PRE>
where-stmt (R1041), 38, 175, 175, 177, 178
</TD></TR>
<TR valign=top><TD colspan=2>
<B>WHILE, 188, 190, 191</B> <!-- Consumed .TP -->
<BR>
<B>whole array, 25, 133, 133, 134, 395, 434</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Z edit descriptor, 277
</TD></TR>
<TR valign=top><TD colspan=2>
<B>WRITE (FORMATTED), 243, 244, 302</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
zero-size array, 45, 103, 114
</TD></TR>
<TR><TD colspan=2>
⃝
</TD></TR>
<TR valign=top><TD colspan=2>
<B>c ISO/IEC 2017 – All rights reserved</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
645
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<P>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I>Nemo Release 3.1</I></TD> <TD width=33% align=center>untitled ()</TD> <TD align=right width=33%><I>October 30, 2022</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from f2018.7fortran.txt using man macros.</FONT>
</BODY></HTML>
