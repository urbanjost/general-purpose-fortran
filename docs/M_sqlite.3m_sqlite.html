<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="index.html">[UP]</a></h5>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>M_sqlite (3)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>M_sqlite</B>(3fm) - [M_sqlite] Fortran interface to SQLite3 API
<P>
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Description</A><BR>
<A HREF=#3>Data Types</A><BR>
<A HREF=#4>Routines</A><BR>
<A HREF=#5>Example</A><BR>
<A HREF=#6>Limitations</A><BR>
<A HREF=#7>Implementation Notes</A><BR>
<A HREF=#8>Author</A><BR>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
<B>Types</B>
<P>
<PRE>
   type(SQLITE_DATABASE)
   type(SQLITE_STATEMENT)
   type(SQLITE_COLUMN)
<P>
</PRE>
<B><A HREF=#4>Routines</A></B>
<P>
<PRE>
  Extensions
   call sqlite3_create_table(db)
   call sqlite3_delete_table(db)
   call sqlite3_column_query(column,name,type,length,function)
   call sqlite3_prepare_select(db,tablename,columns,stmt,extra_clause)
   call sqlite3_get_column(column,value)
<P>
  SQLite API
   call sqlite3_begin(db)
   call sqlite3_close(db)
   call sqlite3_column_props(column,name,type,length)
   call sqlite3_commit(db)
   call sqlite3_do(db,command)
   call sqlite3_finalize(stmt)
   call sqlite3_get_table(db,command,result,errmsg)
   call sqlite3_insert(db,tablename,columns)
   call sqlite3_next_row(stmt,columns,finished)
   call sqlite3_open(filename,db)
   call sqlite3_prepare(db,command,stmt,columns)
   call sqlite3_query_table(db,tablename,columns)
   call sqlite3_reset(stmt)
   call sqlite3_rollback(db)
   call sqlite3_set_column(column,value)
   call sqlite3_step(stmt,completion)
<P>
   err = sqlite3_error(db)
   errmsg = sqlite3_errmsg(db)
<P>
  Direct SQLite API (new)
   message = sqlite3_libversion()
   message = sqlite3_sourceid()
   ivalue  = sqlite3_libversion_number()
<P>
   iresult = sqlite3_threadsafe()
   iresult = sqlite3_initialize()
   iresult = sqlite3_shutdown()
   iresult = sqlite3_os_init()
   iresult = sqlite3_os_end()
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
THIS IS AN EXPERIMENTAL ATTEMPT TO BEGIN A FORTRAN SQLITE3 INTERFACE.
<P>
The <B>M_sqlite</B>(3f) module provides a high-level means for
Fortran programmers to use the SQLite3 library by Richard Hipp
(<A HREF="http://www.sqlite.org">http://www.sqlite.org</A>)
<P>
The interface has been implemented in such a way that you can use a
few high-level routines for common tasks, such as inserting data into
a database and querying the contents. To this end the module defines
a set of routines and functions as well as several derived types to
hide the low-level details.
<P>
The remaining majority of the routines merely prepare SQL statements
or are a simple interface to the original C functions. Therefore, when
in doubt consult the SQLite documentation at <A HREF="http://www.sqlite.org">http://www.sqlite.org</A>.
<P>
In its current form, <B>M_sqlite</B>(3f) does not provide a full Fortran
API to all the functionality offered by SQLite, but it should be
quite useable.
</BLOCKQUOTE>
<A name=3>

     <H3>DATA TYPES</H3>

</A>
<BLOCKQUOTE>
<P>
The following derived types are defined:
<TABLE cellpadding=3><!-- tsb: The following derived types are defined:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B></B><B>type</B>(SQLITE_DATABASE) </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Variables of this type are used to hold the connection to the database or
databases. They are created by the subroutine <B>sqlite3_open</B>(3f)
<P>
The contents are valid until the database is closed (via <B>sqlite3_close</B>(3f)).
</TD></TR>
<TR valign=top><TD colspan=2>
<B></B><B>type</B>(SQLITE_STATEMENT) </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
Variables of this type hold prepared statements, the common method for
database management systems to efficiently execute SQL statements.
</TD></TR>
<TR valign=top><TD colspan=2>
<B></B><B>type</B>(SQLITE_COLUMN) </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
To provide easy communication with the database, SQLITE_COLUMN can hold
values of different types. This means you can use a single routine and
variable to transfer strings, integers or reals to and from the database.
</TD></TR>
<TR></TR></TABLE>The first two derived types are "opaque", that is they are used only to
communicate between the application and the database library and there is
information of interest to be gotten from them.
<P>
The third type is rather crucial to the working of the implementation: By
setting the properties of an SQLITE_COLUMN variable you put data into the
database or you can retrieve data from the database. See the example below for
how this works.
<P>
There are a number of convenience routines that are meant to make this easier,
which are marked below (with **). The remaining routines are calls to the C
API for SQLite3.
</BLOCKQUOTE>
<A name=4>

     <H3>ROUTINES</H3>

</A>
<BLOCKQUOTE>
<P>
The <B>M_sqlite</B>(3fm) module currently provides the following functions:
</BLOCKQUOTE>
<P>
General
<P>
<PRE>
   call sqlite3_open(filename, db)
                                   -- Open a database file and store the
                                      connection for later use.
   call sqlite3_close(db)
                                   -- Close the database connection. Simply an
                                      interface to the corresponding C function.
   err = sqlite3_error(db)
                                   -- Retrieve whether the previous command
                                      resulted in an error or not. Returns
                                      true if so, otherwise false.
</PRE>
Transactions
<P>
<PRE>
   call sqlite3_begin(db)
                                   -- Start a transaction.
   call sqlite3_commit(db)
                                   -- Commit the changes made since the start
                                      of a transaction.
   call sqlite3_rollback(db)
                                   -- Undo changes made since the start of a
                                      transaction.
</PRE>
Create tables
<P>
<PRE>
   **call sqlite3_column_props(column, name, type, length)
                                   -- Set the properties of a column
   **call sqlite3_set_column(column, value)
                                   -- Set the value of a column
   call sqlite3_insert(db, tablename, columns)
                                   -- Insert a complete new row into the table.
   **call sqlite3_create_table(db)
                                   -- Create a new table, based on the
                                      properties of the columns.
   **call sqlite3_delete_table(db)
                                   -- Delete an existing table by name.
<P>
</PRE>
<BLOCKQUOTE>
Query
<P>
<PRE>
   **call sqlite3_column_query(column, name, type, length, function)
                                   -- Set properties of a column when
                                      constructing a SELECT query. The
                                      optional "function" is a string
                                      representing an SQL function
                                      like count or max.
   **call sqlite3_prepare_select(db,tablename,columns,stmt,extra_clause)
                                   -- Prepare a SELECT query.
   call sqlite3_next_row(stmt, columns, finished)
                                   -- Retrieve the next row of a SELECT query.
   **call sqlite3_get_column(column, value)
                                   -- Get the value of a column
   call sqlite3_get_table(db, command, result, errmsg)
                                   -- Get the result of a query in a
                                      single two-dimensional array
   call sqlite3_query_table(db, tablename, columns)
                                   -- Query the structure of the table
<P>
</PRE>
General SQL command
<P>
<PRE>
   call sqlite3_do(db, command)
                                   -- Run a single SQL command
   call sqlite3_prepare(db, command, stmt, columns)
                                   -- Prepare a general SQL statement
                                      for later actual execution.
   call sqlite3_step(stmt, completion)
                                   -- Run the prepared SQL statement
   call sqlite3_reset(stmt)
                                   -- Reset the prepared statement i
                                      so that it can be used again.
   call sqlite3_finalize(stmt)
                                   -- Free all resources associated with the
                                      prepared statement.
<P>
</PRE>
Description
<P>
<PRE>
   message=sqlite3_version()
                                   -- Get version number string
   message=sqlite3_sourceid()
                                   -- Get build identification string
   ival=sqlite3_libversion_number()
                                   -- Get library version number
</PRE>
</BLOCKQUOTE>
<A name=5>

     <H3>EXAMPLE</H3>

</A>
<BLOCKQUOTE>
<P>
To illustrate the usage of the library, here is a small example that is
essentially the FLIBS example:
<P>
<PRE>
   !--------------------------------------------------------------------
   ! csvtable.f90 --
   !    Program to read a simple CSV file and put it into a
   !    SQLite database, just to demonstrate how the Fortran
   !    interface works.
   program demo_csvtable
   use M_sqlite
   implicit none
   type(SQLITE_DATABASE)             :: db
   type(SQLITE_STATEMENT)            :: stmt
   type(SQLITE_COLUMN), pointer      :: column(:)
   integer                           :: lun = 10
   integer                           :: ierr
   character(len=40), dimension(4)   :: name
   real                              :: salin
   real                              :: temp
   character(len=40)                 :: station
   character(len=40)                 :: date
   logical                           :: finished
   integer                           :: j
   character(len=40), pointer        :: result(:,:)
   character(len=:),allocatable      :: errmsg
   !--------------------------------------------------------------------
      call sqlite3_open(&#146;somedata.db&#146;, db)
   !--------------------------------------------------------------------
   ! The first part of the program simply defines the table:
      allocate(column(4))
      call sqlite3_column_props(column(1), name(1), SQLITE_CHAR, 10)
      call sqlite3_column_props(column(2), name(2), SQLITE_CHAR, 10)
      call sqlite3_column_props(column(3), name(3), SQLITE_REAL)
      call sqlite3_column_props(column(4), name(4), SQLITE_REAL)
      call sqlite3_create_table(db, &#146;measurements&#146;, column)
   !--------------------------------------------------------------------
   ! The second part reads a data file and stores the data in a table:
      call csvdata() ! create CSV file for demonstration
      ! Open a CSV file to feed data into the database
      open(lun, file = &#146;somedata.csv&#146;)
      !    To keep it simple:
      !    - The first line contains the names of the four columns
      read(lun, *) name
      !    - All lines after this contain the name of the station,
      !      the date and the two values.
   !--------------------------------------------------------------------
   ! Insert the values into the table.
   !
   ! Note that a transaction (via calls to sqlite3_begin and
   ! sqlite3_commit pair) is used, so that all the inserts can be
   ! done in one go. Inserting with autocommit is much slower,
   ! as the database file needs to be flushed every time.
   !
      call sqlite3_begin(db)
      do
         read(lun,*,iostat=ierr) station, date, salin, temp
         if(ierr .ne. 0) exit
         call sqlite3_set_column(column(1), station)
         call sqlite3_set_column(column(2), date   )
         call sqlite3_set_column(column(3), salin  )
         call sqlite3_set_column(column(4), temp   )
         call sqlite3_insert(db, &#146;measurements&#146;, column)
      enddo
      call sqlite3_commit(db)
      close(lun)
   !--------------------------------------------------------------------
   ! To check that it works, retrieve the average salinity and average
   ! temperature per station and print them sorted by station name
   !
   ! Retrieve the data by constructing an SQL query that will
   ! actually look like:
   !
   !  SELECT station, AVG(salinity), AVG(temperature) FROM measurements
   !         GROUP BY station ORDER BY station;
   !
   ! The routine sqlite3_prepare_select takes care of the actual
   ! construction of the above SQL query:
      !
      ! We want a simple report, the mean of salinity and temperature
      ! sorted by the station
      !
      deallocate(column)
<P>
      allocate(column(3))
      call sqlite3_column_query &
         & (column(1), &#146;station&#146;, SQLITE_CHAR)
      call sqlite3_column_query &
         & (column(2), name(3), SQLITE_REAL, function=&#146;avg&#146;)
      call sqlite3_column_query &
         & (column(3), name(4), SQLITE_REAL, function=&#146;avg&#146;)
<P>
      call sqlite3_prepare_select(db, &#146;measurements&#146;, column, stmt, &
         & &#146;group by station order by station&#146;)
   !--------------------------------------------------------------------
      write(*, &#146;(3a20)&#146;)&#146;Station&#146;, &#146;Mean salinity&#146;, &#146;Mean temperature&#146;
      do
         call sqlite3_next_row(stmt, column, finished)
         if(finished) exit
         call sqlite3_get_column(column(1), station)
         call sqlite3_get_column(column(2), salin  )
         call sqlite3_get_column(column(3), temp   )
         write(*, &#146;(a20,2f20.3)&#146;) station, salin, temp
      enddo
      !
      ! Get the entire table
      !
      call sqlite3_get_table(db, "select * from measurements", result, errmsg)
<P>
      if(associated(result))then
         write(*,*) &#146;Number of columns: &#146;, size(result,1)
         write(*,*) &#146;Number of rows:    &#146;, size(result,2)
         do j = 1,size(result,2)
            write(*,&#146;(10a20)&#146;) result(:,j)
         enddo
         deallocate(result)
      else
         write(*,*) &#146;Error: result table not allocated&#146;
         write(*,*) &#146;Error: &#146;, trim(errmsg)
      endif
<P>
      call sqlite3_close(db)
   !--------------------------------------------------------------------
   contains
   !--------------------------------------------------------------------
   subroutine csvdata()
   ! create fake datafile
   implicit none
   integer                         :: lun = 10
   real, dimension(5)              :: r
   character(len=100)              :: line
   character(len=40)               :: string
   character(len=20),dimension(6)  :: station = &
   & [character(len=20) :: &#146;NW1&#146;,&#146;NW2&#146;,&#146;OS30_LONGER_NAME&#146;,&#146;DH&#146;,&#146;DO&#146;,&#146;Ah111&#146; ]
   integer                         :: i
   open(lun, file=&#146;somedata.csv&#146;)
   write(lun, &#146;(a)&#146;) &#146;station,date,salinity,temperature&#146;
   do i = 1,100
      call random_number(r)
      line = station(1+int(5.0*r(1)))
      write(string, &#146;(i0,a,i0,a,i0)&#146;) &
      & 2005, &#146;-&#146;, 1+int(12.0*r(2)), &#146;-&#146;, 1+int(28.0*r(3))
      line = trim(line) // &#146;,&#146; // string
      write(string, &#146;(f10.2)&#146;) 28.0+6.0*r(4)
      line = trim(line) // &#146;,&#146; // adjustl(string)
      write(string, &#146;(f10.2)&#146;) 15.0+5.0*r(5)
      line = trim(line) // &#146;,&#146; // adjustl(string)
      write(lun, &#146;(a)&#146;) trim(line)
   enddo
   close(lun)
   end subroutine csvdata
   !--------------------------------------------------------------------
   end program demo_csvtable
   !--------------------------------------------------------------------
<P>
</PRE>
</BLOCKQUOTE>
<A name=6>

     <H3>LIMITATIONS</H3>

</A>
<BLOCKQUOTE>
<P>
The module is not complete yet:
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: The module is not complete yet:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
There is no support for blobs
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
There is no support for NULL values or for DATE values.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The SQLite API is not completely covered, though the subset should be
useful for many applications.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<A name=7>

     <H3>IMPLEMENTATION NOTES</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
The library has been designed with 64-bits platforms in mind: it should run
on these platforms without any difficulties.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=8>

     <H3>AUTHOR</H3>

</A>
<BLOCKQUOTE>
<P>
This version (20180311), by John Urban, uses the ISO_C_BINDING
interface to provide portability between PEs (Programming
Environments). The extensions are modeled on modules by Arjen Markus
&lt;<A HREF="mailto:arjenmarkus@sourceforge.net">arjenmarkus@sourceforge.net</A>&gt; and the associated C code is inspired
by work by Al Danial (<A HREF="http://danial.org">http://danial.org</A>).
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>M_sqlite (3)</TD> <TD align=right width=33%><I>August 30, 2021</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from ec259106-ca6a-47c6-a5f0-aae3b793906f using man macros.</FONT>
<br><br><center><img src="images/M_sqlite.3m_sqlite.gif"></center>
</div>
</div>
</body>
</HTML>
