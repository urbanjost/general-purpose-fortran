<html>
<head>
<title></title>
<meta name="keywords" content="Fortran, Fortran code, Fortran source code repository, Fortran library, Fortran archive,         " />
<meta name="keywords" content="General Purpose Fortran, Fortran modules, Fortran examples                                       " />
<meta name="keywords" content="Fortran Repository" />
<meta name="keywords" content="Fortran Collection" />
<link  rel="stylesheet"            href="StyleSheets/man.css"          type="text/css"  title="man"          />
<style>
body { background-color:#FFF; color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }

a,li span { color:#000; }
a:visited { color:#666; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }

h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:200%; line-height: 1.1em;color:#F33}
h2 { font-size:173%; }
h3 { font-size:144%; }
h4 { font-size:120%; }
h5,h6 { font-size:100% }

dt { font-size:108%; color:#00F;line-height: 2em;font-width:boldest;}

table { border:double #000; border-collapse:collapse; }
td { border:thin solid #888; margin: auto; padding: auto; border: auto;}
td { padding-left: 1em; padding-right: 1em;}
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:90%; line-height:1.5em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:90%; overflow:auto; padding:1em; }
xmp { background-color:#DCC; font-size:80%; display: block; font-family: monospace; white-space: pre; margin: 1em 0; }

#Container { margin:0 10px; text-align:center; }
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; }
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:80%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:.8em; font-style:italic; margin-bottom:1em; padding-top:1px; }
</style>
</head>
<body>
<a href="http://www.urbanjost.altervista.org/LIBRARY/libGPF/GPF.html">[GPF Home Page]</a>
<div id="Container">
<div id="Content">
<!-- =========================================================================================================================== -->
<div class="manpage">

<dl>
<dt> NAME </dt>
<dd>
     M_time(3fm) - [M_time::INTRO] Fortran module for manipulating and
     presenting time and date values as defined in ISO 8601:1988
     (LICENSE:MIT)
</dd>

<dt> DESCRIPTION </dt>
<dd>
<p>
   The M_time(3f) Fortran module and associated utility programs
   provide date and time-related procedures. Both a procedural and OOP
   (Object Oriented Programming) interface are provided.
   The primary conversion procedures are provided as both a simple function
   and a subroutine returning error flags and finer-grained control.

   Each routine is accompanied by a man-page which includes a sample
   program for that procedure. This is also provided in HTML format
   both in individual pages and a book format.

   The man-page example programs, unit tests and additional examples
   are all provided in the distribution package.
</p>

<p>
   The M_time(3f) module
</p>

<ul>
   <li> provides for formatting dates. </li>
   <li> facilitates simple computations using time and date values in the recent era. </li>
   <li> allows for macro-level timing of code. </li>
</ul>

<p>
   The M_TIME(3f) module complements the DATE_AND_TIME(3f) procedure, which is
   the standard intrinsic subroutine that returns the current date and time in
   the   Gregorian   calendar. That is, the primary way this module represents
   dates is as an integer array with the same meaning for elements as defined
   by the DATE_AND_TIME(3f) routine. In addition it can calculate or read many
   other date representations such as ...
</p>

<ul>
   <li> Julian Dates               </li>
   <li> Unix Epoch Dates           </li>
   <li> High-level date formatting </li>
   <li> Ordinal days of the year   </li>
   <li> days of the week           </li>
   <li> ISO-8601 week numbers      </li>
   <li> month and weekday names    </li>
</ul>

<p>
   Julian and Unix Epoch Dates are particularly useful for manipulating dates
   in simple numeric expressions.
</p>

<p>
   The extensive formatting options include showing SYSTEM_CLOCK(3f) and
   CPU_USAGE(3f) information along with Gregorian date information, allowing
   for the easy incorporation of timing information into program messages. In
   addition to conventional Civilian Calendar dates, the module
   supports the ISO-8601 standard methods of displaying dates.
</p>

<p>
   A Fortran-callable sleep(3c)/usleep(3c) procedure is also provided.
</p>

</dd>
<dt> SYNOPSIS </dt> <dd></dd>
<dt>&nbsp;Summary of functions</dt>
<dd>
<br/>
<br/>
<table BORDER="1">

<tr><th colspan="3">UNIX EPOCH                </th></tr>

<tr> <td><a href="date_to_unix.3m_time.html"> date_to_unix(dat,UNIXTIME,IERR) </a>
     </br>or</br>
     <a href="d2u.3m_time.html"> d2u(dat)&nbsp;result(UNIXTIME) </a>
     </td>
     <td>%epoch()  </td>
     <td> Convert date array to Unix Time</td>
</tr>

<tr><td><a href="unix_to_date.3m_time.html"> unix_to_date(unixtime,DAT,IERR)    </a>
    </br>or</br>
    <a href="u2d.3m_time.html"> u2d(unixtime)&nbsp;result(DAT)  </a>
    </td>
    <td>&nbsp;   </td>
    <td> Convert Unix Time to date array</td>
</tr>

<tr><th colspan="3">JULIAN                    </th></tr>

<tr>
   <td><a href="julian_to_date.3m_time.html"> julian_to_date(julian,DAT,IERR)      </a>
   </br>or</br>
   <a href="j2d.3m_time.html"> j2d(julian)&nbsp;result(DAT)    </a>
   </td>
   <td>&nbsp;   </td>
   <td> Convert Julian Date to date array</td>
</tr>

<tr>
   <td><a href="date_to_julian.3m_time.html"> date_to_julian(dat,JULIAN,IERR)      </a>
   </br>or</br>
   <a href="d2j.3m_time.html"> d2j(dat)&nbsp;result(JULIAN)    </a>
   </td>
   <td>%julian() </td>
   <td> Converts date array to Julian Date </td>
</tr>
<tr><th colspan="3">WEEK OF YEAR              </th></tr>
<tr>
   <td><a href="d2w.3m_time.html"> d2w(dat,ISO_YEAR,ISO_WEEK,ISO_WEEKDAY,ISO_NAME) </a></td>
   <td>&nbsp;  </td>
   <td> calculate iso-8601 Week- numerically and as string yyyy-Www-d</td>
</tr>
<tr>
   <td><a href="w2d.3m_time.html"> w2d(iso_year,iso_week,iso_weekday,DAT) </a>
   </br>or</br>
   <a href="w2d.3m_time.html"> w2d(iso_string,DAT,[IERR]) </a>
   </td>
   <td>&nbsp;  </td>
   <td> calculate date DAT given iso-8601 Week date (numerically or as a string yyyy-Www-d)</td>
`</tr>

<tr><th colspan="3">ORDINAL DAY               </th></tr>
<tr><td><a href="d2o.3m_time.html"> d2o(dat) result(ORDINAL)                  </a></td><td>%ordinal() </td><td> given date array return ordinal day of year, Jan 1st=1</td></tr>


<tr>
   <td><a href="ordinal_to_date.3m_time.html"> ordinal_to_date(ordinal,year,DAT)  </a>
   </br>or</br>
   <a href="o2d.3m_time.html"> o2d(ordinal,[year]) result(DAT) </a>
   </td>
   <td>&nbsp;   </td>
   <td> given ordinal day of year return date array, Jan 1st=1 </td>
</tr>

<tr><td><a href="ordinal_seconds.3m_time.html"> ordinal_seconds()  </a></td><td> </td><td> return seconds since beginning of year</td></tr>

<tr><th colspan="3">PRINTING DATES            </th></tr>
<tr><td><a href="fmtdate.3m_time.html"> fmtdate(dat,format)  result(TIMESTR) </a></d><td>%format([string]) </td><td> Convert date array to string using format</td></tr>
<tr><td><a href="fmtdate_usage.3m_time.html"> fmtdate_usage(indent)           </a></td><td>&nbsp;            </td><td> display macros recognized by fmtdate(3f)</td></tr>
<tr><td><a href="now.3m_time.html"> now(format)        result(TIMESTR)        </a></td><td>&nbsp;            </td><td> return string representing current time given format</td></tr>
<tr><td><a href="box_month.3m_time.html"> box_month(dat,CALEN)                </a></td><td>&nbsp;            </td><td> print specified month into character array</td></tr>

<tr><th colspan="3">MONTH NAME                    </th></tr>
<tr><td><a href="mo2v.3m_time.html"> mo2v(month_name)   result(MONTH_NUMBER) </a></td><td>&nbsp;      </td><td> given month name return month number</td></tr>
<tr><td><a href="v2mo.3m_time.html"> v2mo(month_number) result(MONTH_NAME)   </a></td><td>&nbsp;      </td><td> given month number return month name</td></tr>
<tr><td><a href="mo2d.3m_time.html"> mo2d(month_name,year)   result(DAT)          </a></td><td>&nbsp;      </td><td> return date array for
first day of given month name in specified year</td></tr>

<tr><th colspan="3">DAY OF WEEK               </th></tr>
<tr><td><a href="dow.3m_time.html"> dow(dat,[WEEKDAY],[DAY],IERR)  </a></td><td>%weekday() </td><td> Convert date array to day of the week as number(Mon=1) and name</td></tr>

<tr><th colspan="3">LOCALE                    </th></tr>
<tr><td><a href="locale.3m_time.html"> locale(name,month_names,weekday_names,month_names_abbr,weekday_names_abbr,IERR)  </a></td><td>&nbsp; </td><td> basic ASCII locale definition</td></tr>


<tr><th colspan="3">ASTROLOGICAL                        </th></tr>
<tr><td><a href="easter.3m_time.html"> easter(year,dat) </a></td><td>&nbsp; </td><td> calculate month and day Easter falls on for given year </td></tr>
<!--
<tr><td><a href="ephemeris.3m_time.html"> ephemeris(dat,planet,DEC_D,DEC,M,DEC_C,ASCENT_H,ASCENT_M) </a></td><td>&nbsp; </td><td> ephemeris position of planets for adjusting an equatorial telescope </td></tr>
-->

<tr><td><a href="moon_fullness.3m_time.html"> moon_fullness(dat) result(FULLNESS)</a></td><td>&nbsp; </td><td> percentage of moon phase from new to full </td></tr>
<tr><td><a href="phase_of_moon.3m_time.html"> phase_of_moon(dat) result(PHASE)</a></td><td>&nbsp; </td><td> return name for phase of moon for given date </td></tr>

<tr><th colspan="3">DURATION                  </th></tr>
<tr><td><a href="sec2days.3m_time.html">  sec2days(seconds)  result(DHMS)     </a></td><td>&nbsp;       </td><td> converts seconds to string D-HH:MM:SS</td></tr>
<tr><td><a href="days2sec.3m_time.html"> days2sec(string)   result(SECONDS)   </a></td><td>&nbsp;       </td><td> converts string D-HH:MM:SS to seconds</td></tr>

<tr><th colspan="3">READING DATES             </th></tr>
<tr><td><a href="guessdate.3m_time.html">    guessdate(anot,DAT)                </a></td><td>&nbsp;       </td><td> Converts a date string to a date array, in various formats</td></tr>

<tr><th colspan="3">C INTERFACE               </th></tr>
<tr><td><a href="system_sleep.3m_time.html">   system_sleep(wait_seconds)     </a></td><td>&nbsp;       </td><td> Call sleep(3c) or usleep(3c)</td></tr>
</table>
</dd>

<dt> FORMATTING OPTIONS IN <code>FMTDATE</code></dt>
<dd>

<p>
   You can easily use Julian Dates and Unix Epoch Times to add
   and subtract times from dates or to calculate the interval
   between dates. But JEDs and UETs and even the Gregorian Calendar
   arrays in the DAT arrays are not the way we typically describe a
   date on the Civilian Calendar. So the fmtdate(3f) routine lets us
   print a DAT array in a variety of familiar styles.
</p>

<p>
   The fmtdate(3f) and now(3f) procedures let you display a Gregorian date using
   either keywords for standard formats or using macros in a user-specified
   formatting string. A formatting string may contain the following macros:
</p>
<pre>

Description                                        Example

 Base time array:
  (1) %Y -- year, yyyy                                2016
  (2) %M -- month of year, 01 to 12                   07
  (3) %D -- day of month, 01 to 31                    27
      %d -- day of month, with suffix (1st, 2nd,...)  27th
  (4) %Z -- minutes from UTC                          -0240m
      %z -- -+hh:mm from UTC                          -04:00
      %T -- -+hhmm  from UTC                          -0400
  (5) %h -- hours, 00 to 23                           21
      %H -- hour (1 to 12, or twelve-hour clock)      09
      %N -- midnight&lt; AM &lt;=noon; noon&lt;= PM &lt;midnight  PM
  (6) %m -- minutes, 00 to 59                         24
  (7) %s -- sec, 00 to 59                             22
  (8) %x -- milliseconds 000 to 999                   512
 Conversions:
      %E -- Unix Epoch time                           1469669062.5129952
      %e -- integer value of Unix Epoch time          1469669063
      %J -- Julian date                               2457597.559
      %j -- integer value of Julian Date(Julian Day)  2457597
      %O -- Ordinal day (day of year)                 209
      %o -- whole days since Unix Epoch date          17009
      %U -- day of week, 1..7 Sunday=1                4
      %u -- day of week, 1..7 Monday=1                3
      %i -- ISO week of year 1..53                    30
      %I -- iso-8601 week-numbering date(yyyy-Www-d)  2016-W30-3
  Names:
      %l -- abbreviated month name                    Jul
      %L -- full month name                           July
      %w -- first three characters of weekday         Wed
      %W -- weekday name                              Wednesday
      %p -- phase of moon                             New
      %P -- percent of way from new to full moon      -1%
  Literals:
      %% -- a literal %                               %
      %t -- tab character
      %b -- blank character
      %B -- exclamation(bang) character
      %n -- new line (system dependent)
      %q -- single quote (apostrophe)
      %Q -- double quote
  Duration:
      %a -- Time since now (age) as d-hh:mm:ss       1-20:14:40
      %A -- Time since now (age) as seconds          123456.890
  Program timing:
      %c -- CPU_TIME(3f) output                      .78125000000000000E-001
      %C -- number of times this routine is used     1
      %S -- seconds since last use of this format    .0000000000000000
      %k -- time in seconds from SYSTEM_CLOCK(3f)    588272.750
      %K -- time in clicks from SYSTEM_CLOCK(3f)     588272750
  Help:
      %? -- call fmtdate_usage

If no percent (%) is found in the format one of several
alternate substitutions occurs.

If the format is composed entirely of one of the following
keywords the following substitution occurs:

  "iso-8601",
  "iso"        ==&gt; %Y-%M-%DT%h:%m:%s%z
                      Ex: 2017-08-26T18:56:33,510912700-04:00
  "iso-8601W",
  "isoweek"    ==&gt; %I
                      Ex: 2024-W26-6
  "sql"        ==&gt; "%Y-%M-%D %h:%m:%s.%x"
                      Ex: "2024-06-29 08:42:14.311"
  "sqlday"     ==&gt; "%Y-%M-%D"
                      Ex: "2024-06-29"
  "sqltime"    ==&gt; "%h:%m:%s.%x"
                      Ex: "08:42:31.528"
  "dash"       ==&gt; %Y-%M-%D
                      Ex: 2024-06-29
  "rfc-2822"   ==&gt; %w, %D %l %Y %h:%m:%s %T
                      Ex: Mon, 14 Aug 2006 02:34:56 -0600
  "rfc-3339"   ==&gt; %Y-%M-%DT%h:%m:%s%z
                      Ex: 2006-08-14 02:34:56-06:00
  "date"       ==&gt; %w %l %D %h:%m:%s UTC%z %Y
                      Ex: Sat Jun 29 08:43:14 UTC-04:00 2024
  "short"      ==&gt; %w, %l %d, %Y %H:%m:%s %N UTC%z
                      Ex: Sat, Jun 29th, 2024 8:43:18 AM UTC-04:00
  "long"," "   ==&gt; %W, %L %d, %Y %H:%m:%s %N UTC%z
                      Ex: Saturday, June 29th, 2024 8:43:23 AM UTC-04:00
  "suffix"     ==&gt; %Y%D%M%h%m%s
                      Ex: 20242906084327
  "formal"     ==&gt; The %d of %L %Y
                      Ex: The 29th of June 2024
  "lord"       ==&gt; the %d day of %L in the year of our Lord %Y
                      Ex: the 29th day of June in the year of our Lord 2024
  "easter"     ==&gt; Easter day: the %d day of %L in the year of our Lord %Y
                      Ex: Easter day: ...
                      the 31st day of March in the year of our Lord 2024
  "all"        ==&gt; A SAMPLE OF DATE FORMATS
                      Civil Calendar:   Saturday June 29th
                      Civil Date:               2024-06-29 08:44:29 -04:00
                      Julian Date:              2460491.0308968634
                      Unix Epoch Time:  1719665069.4890008
                      Day Of Year:              181
                      ISO-8601 week:            2024-W26-6

otherwise the following words are replaced with the most common
macros. For duplicate names the lowercase one is a numeric value string
and all uppercase is an alphanumeric string:

  String         Macro  Example
  year           %Y     2016

  month          %M     07
  MONTH          %L     July
  Month|Mth      %l     Jul

  day            %D     27
  DAY            %d     27th

  hour           %h     21

  HOUR           %H     11
  GOOD           %N     AM

  minute         %m     24

  second         %s     22

  weekday        %u     3
  WEEKDAY        %W     Thursday
  Weekday|wkday  %w     Thu

  timezone       %T     -0400   (+-HHMM)
  TIMEZONE       %z     -04:00  (+-HH:MM)
  Timezone       %Z     -240m   (+-MMMMm)

  epoch          %e     1469669063

  julian         %j     2457597

  ordinal        %O     209

  age            %A     100-20:30:40
  AGE            %a     20900.3030

  usage|help|?   %?     call fmtdate_usage()

If none of these keywords are found then every letter that
is a macro is assumed to have an implied percent in front
of it. For example:

  YMDhms ==&gt; %Y%M%D%h%m%s ==&gt; 20160727212422
</pre>

</dd>
<dt> OOPS INTERFACE </dt>
<dd>

<p>
    If you prefer an Object-oriented interface the M_time__oop module (included
    with the M_time module source) provides an OOP interface to the M_time
    module.
</p>
</dd>
<dt> EXAMPLES </dt>
<dd>

<p>
    The following example program demonstrates the extensive options available
    for formatting a date as well as how to use the module to calculate dates
    such as "Yesterday" and "Tomorrow".
</p>

    Sample program:
    </br>
<pre class="fortran">
! yesterday, today, tomorrow

     program demo_M_time
     use M_time, only: j2d, d2j, u2d, d2u, fmtdate, realtime
     integer :: dat(8)
     real(kind=realtime) :: julian, unixtime
     character(len=*),parameter :: iso_fmt='%Y-%M-%DT%h:%m:%s.%x%z'
     character(len=:),allocatable :: friendly

        friendly='%W, %L %d, %Y %H:%m:%s %N' ! a nice friendly format

        call date_and_time(values=dat)  ! current time is placed in array

        write(*,*)'Today'
        write(*,*)'ISO       ',fmtdate(dat,iso_fmt)
        write(*,*)'Friendly  ',fmtdate(dat,friendly)
        write(*,*)'ISO week  ',fmtdate(dat,'%I')

        julian=d2j(dat)
        unixtime=d2u(dat)

        write(*,*)'Yesterday' ! subtract a day from scalar time and print
        write(*,*)'          ',fmtdate(u2d(unixtime-86400),iso_fmt)
        write(*,*)'          ',fmtdate(j2d(julian-1.0),friendly)
        write(*,*)'          ',fmtdate(j2d(julian-1.0),'%I')

        write(*,*)'Tomorrow'  ! add a day to scalar time and print
        write(*,*)'          ',fmtdate(u2d(unixtime+86400),iso_fmt)
        write(*,*)'          ',fmtdate(j2d(julian+1.0),friendly)
        write(*,*)'          ',fmtdate(j2d(julian+1.0),'%I')

        write(*,*)'Next Week'  ! add a week to scalar time and print
        write(*,*)'          ',fmtdate(u2d(unixtime+7*86400),iso_fmt)
        write(*,*)'          ',fmtdate(j2d(julian+7.0),friendly)
        write(*,*)'          ',fmtdate(j2d(julian+7.0),'%I')

     end program demo_M_time
</pre>

<h3> Sample output ...</h3>

<pre>

 Today
 ISO       2015-12-22T08:07:34.025-0300
 Friendly  Tuesday, December 22nd, 2015 08:07:34 AM
 ISO week  2015-W52-2
 Yesterday
           2015-12-21T08:07:34.025-0300
           Monday, December 21st, 2015 08:07:34 AM
           2015-W52-1
 Tomorrow
           2015-12-23T08:07:34.025-0300
           Wednesday, December 23rd, 2015 08:07:34 AM
           2015-W52-3
 Next Week
           2015-12-29T08:07:34.025-0300
           Tuesday, December 29th, 2015 08:07:34 AM
           2015-W53-2
</pre>

<dt>DEFINITIONS</dt>
<dd>

<p>
   A "date_and_time" array <b>"DAT"</b> has the same format as the array of
   values generated by the Fortran intrinsic DATE_AND_TIME(3f). That is, it is
   an 8-element integer array containing year, month, day, Time zone
   difference from UTC in minutes, hour, minutes, seconds, and milliseconds of
   the second. This array represents a date on the Proleptic Gregorian
   Calendar.
</p>

<p>
   The <b>Proleptic Gregorian Calendar</b> assumes the Gregorian Calendar
   existed back to the beginning of the Julian Day calendar (4713 BC). This
   means historic dates will often be confused, as the Julian Calendar was
   used in the USA until 1752-09-03, for example. The Gregorian Calendar was
   formally decreed on 1582-10-15 but was not adapted in many countries. The
   Julian Calendar was first used around 45 BC.
</p>

<p>
   Note that the Proleptic Gregorian Calendar includes a year zero (0). It is
   frequently used in computer software to simplify the handling of older
   dates. For example, it is the calendar used by MySQL, SQLite, PHP, CIM,
   Delphi, Python and COBOL. The Proleptic Gregorian Calendar is explicitly
   required for all dates before 1582 by ISO 8601:2004 (clause 4.3.2.1 The
   Gregorian calendar) if the partners to information exchange agree.
</p>

<p>
   <b>Unix Epoch Time (UET)</b>  is defined as the number of seconds since
   00:00:00  on January 1st. 1970, UTC.
</p>

<p>
   A  <b>JD</b>  is defined as a <b>Julian Date</b>. JD days start
   at noon (not at midnight). 4713-01-01 BC at noon is defined as JD 0.0.
</p>

<p>
   If you are not familiar with them, in this context Julian Dates and
   Unix Epoch Times are scalar numbers that allow for easy computations
   using dates (to go back one day just subtract one from a Julian
   Date, for example). Since these values are generally not considered
   intelligible, routines are included to convert between these scalar
   values and the date array so human-readable results can be obtained.
</p>

<p>
   <b>Coordinated Universal Time</b>  (French:  Temps universel coordonn'e),
   abbreviated as <b>UTC</b>, is the primary time standard by which the world
   regulates clocks and time. It is within about 1 second of mean solar time
   at 0o longitude;[1] it does not observe daylight saving time. It is one of
   several closely related successors to Greenwich Mean Time (GMT). For most
   purposes, UTC is considered interchangeable with GMT, but GMT is no longer
   precisely defined by the scientific community.
</p>
</dd>

<dt> LIMITATIONS </dt>
<dd>

<p>
   Like most collections of date and time procedures M_time is
   <em>not</em> a high-precision library that accounts internally
   for leap seconds and relativistic effects.
</p>

<p>
   M_time(3f) is intended for use in the recent era and is not
   appropriate for use with historical dates that used some other
   calendar scheme such as the Julian Calendar. That is, you have to
   remember to account for conversions to other calendar systems when
   using historical dates.
</p>

<p>
   When Daylight Savings is in effect calculations will generally be
   correct,  as the date model includes a timezone value; but you are
   responsible for ensuring dates you create use the correct timezone
   value or otherwise account for Daylight Savings Time as needed.
</p>

<p>
   Currently, dates are manipulated using the current system timezone,
   which can typically be set using the environment variable TZ. So if
   you desire to set the default timezone you generally set the
   environment variable <em>before</em> executing your program. This
   is compatible with current observed behavior for the intrinsic
   procedure DATE_AND_TIME(3f) with compilers I have tested with, but
   does not seem to be a specified behavior as far as the standard is
   concerned. That is, DATE_AND_TIME(3f) returns a vector that contains
   a current time zone, but does not specify how a current time zone
   can be explicitly set. Since this library is intentionally designed
   to complement DATE_AND_TIME(3f) it adopts the same behavior. A routine
   to let you set a default time zone could be added in the future.
</p>

<p>
   Note the environment variable can be set using
   put_environment_variable(3f) from the libGPF library:
</p>

<pre>
     use M_system, only : put_environment_variable
     call put_environment_variable('TZ','America/New_York',ierr)
</pre>

</dd>

<dt> SEE ALSO </dt>
<dd>
<h3>Utility programs that use the M_time(3f) module:</h3>

<ul>
   <li> <a href="now.1.html">      now(1)      </a> prints a date in many formats                         </li>
   <li> <a href="ttee.1.html">     ttee(1)     </a> a filter which timestamps stdout from another command </li>
   <li> <a href="month.1.html">    month(1)    </a> which lets you print simple calendars                 </li>
   <li> <a href="days2sec.1.html"> days2sec(1) </a> converts dd-hh:mm:ss to seconds                       </li>
   <li> <a href="sec2days.1.html"> sec2days(1) </a> converts seconds to dd-hh:mm:ss                       </li>
   <li> <a href="paws.1.html">     paws(1)     </a> pause until specified time or for specified interval  </li>
</ul>

<p>
   The ISO-8601 standard is often used for business-related transactions.
</p>

<p>
   There are C/C++ intrinsics which provide much of the same
   functionality that should be bindable to Fortran via the ISO_C_BINDING
   module.
</p>

<p>
   The Fortran Wiki <a href="http://fortranwiki.org"> fortranwiki.org
   </a> contains information on other libraries and modules that provide
   date-time procedures.
</p>

<p>
   If you care about Leap Seconds, Orbital Mechanics, GPS/Satellite
   communications, and Astronomy the high-precision NASA SPICElib
   Fortran library is worth a look. It is well tested for manipulating
   high-precision dates.
</p>

</dd>

</dl>

</div>
<!-- =========================================================================================================================== -->
</div>
</div>
</body>
</html>
