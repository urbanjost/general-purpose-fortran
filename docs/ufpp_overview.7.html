<html>
<head>
   <title> ufpp </title>
   <link rel="stylesheet" type="text/css" href="StyleSheets/man.css" title="Local" />
   <meta name="description" content="Fortran module containing library of date and time procedures">
   <meta name="keywords" content="date_and_time,date,time,gregorian,julian,epoch time,day of week, ordinal day">
   <meta name="keywords" content="week of year">
   <meta name="keywords" content="Fortran,module,library,repository,collection">
   <script src="../../../javascript/toggleHidden.js" type="text/javascript"></script>
</head>
<body>
<!-- =========================================================================================================================== -->
<a href="../../../GPF.html">
   <img alt=" " src="images/compass.png" xstyle="position:absolute;left:0;top:0" width="64" height="64" />
</a>
<!-- =========================================================================================================================== -->
<!--
       @(#)ufpp_overview(7f): use of ufpp(1), a Fortran source code pre-processor
  -->
<!-- =========================================================================================================================== -->
<h1>NAME</h1>
<h2>ufpp(1f) -  [DEVELOPER] a Fortran source code pre-processor (LICENSE:PD)</h2>
<!-- =========================================================================================================================== -->
<h1>SYNOPSIS</h1>
<pre>
   ufpp  [[ -D] define_list]
         [ -I include_directories]
         [ -i input_file(s)]
         [ -o output_file]
         [ -html]
         [ -system]
         [ -q
         [ -header text_for_first_line]
         [ -ident]
         [ -prefix character_ADE]
         [ -keeptabs]
         [ -noenv]
         [ -width n]
         [ -cstyle default|doxygen]
         [ -allow_links]
         [ -verbose]
         [ -debug]
         [ -d ignore|remove|blank]
         [ -version]
         [ -help [ -html]]
</pre>
<!-- =========================================================================================================================== -->
<h2>DESCRIPTION</h2>
<p>
   The ufpp(1) command is a basic file pre-processor in the style of
   fpp(1) and cpp(1) that allows simple embedded directives to be used
   to conditionally select source code lines.
</p>

<p>
   Additional features allow ufpp(1) to easily support single files
   that contain documentation, source code, and unit testing materials
   and commands.
</p>

<p>
   A detailed description of command options can be generated by using
   the "-help" switch , which was used to generate
   <a href="ufpp.1.html">ufpp.1.html</a>.
</p>

<p>
   ufpp(1) is relatively language-agnostic, but is particularly
   designed with Fortran in mind. It is in fact written in Fortran.
   You will therefore find ufpp(1) particularly useful if you desire a
   Fortran-based pre-processor that is simple enough that you can easily
   customize it.
</p>

<p>
   More specifically source file lines can be selected conditionally using
   basic directives ($IF, $ELSE, $ELSEIF, $ENDIF, $DEFINE, $UNDEFINE, ...)
   The syntax for numeric expressions in the directives is very similar
   to FORTRAN 77 INTEGER and LOGICAL expressions.
</p>

<p>
   Additionally ufpp(1) supports
</p>

<ul>
<li> generating multiple files from a single input file </li>
<li> embedded system commands                           </li>
<li> incorporation of input into simple HTML documents  </li>
<li> conversion of flat text to a help/version routine or Fortran comments. </li>

<li> Output is filtered to generate files that are "Fortran-friendly". By default:
   <ul>
   <li> tab characters are expanded. </li>
   <li> DOS line terminators are removed in GNU/Linux and Unix environments. </li>
   <li> For fixed-format files
      <ul>
         <li> Common Fortran source-code extensions such as "dee'd"
              conditional lines are conditionally expanded in a compiler-independent fashion
              ("dee'd" lines are ones where a 'D' in column 1 designates lines that are only compiled to create a debug version,
              often found in fixed-format Fortran).
         </li>
          <li> optionally data past column 72 can be ignored as comments or "idents" </li>
      </ul>
   </li>

   </ul>
</li>
</ul>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h2>EXAMPLES</h2>
<h3> a basic input file ...</h3>
<p>
   Assuming you are familiar with the basic behavior of preprocessors
   such as cpp(1), fpp(1), coco(1), or more powerful macro processors
   such as m4(1) let us start with a basic input file example:
</p>
<blockquote>
<pre>

 $! Compile this program and one of the following versions of subroutine SUB1 depending on the value of A
 $! NOTE: This Fortran source file contains ufpp(1) directives beginning with a dollar("$") character.
 $!------------------
 $! set default values for variables tested
 $IF .NOT.DEFINED(A)
 $  DEFINE A=1
 $ENDIF
 $!------------------
    program conditional_compile
       call sub1
    end program conditional_compile
 $IF A .EQ. 1        ! If A=1 output this version of subroutine sub1
    subroutine sub1
       print*, "This is the first SUB1"
    end subroutine sub1
 $ELSEIF A .EQ. 2    ! If A=2 output this version of subroutine sub1
    subroutine sub1
       print*, "This is the second SUB1"
    end subroutine sub1
 $ELSE               ! If A was not 1 or 2 output this version of subroutine sub1
    subroutine sub1
       print*, "This is the third SUB1"
    end subroutine sub1
 $ENDIF
</pre>
</blockquote>

<p>
   Assuming this example is in the file "basic.ff" the output of the command
</p>

<pre>

   ufpp a=2 -i basic.ff -o basic.f90
</pre>

<p>
   would be
</p>

<blockquote>
<pre>

   program conditional_compile
      call sub1
   end program conditional_compile
   subroutine sub1
      print*, "This is the second SUB1"
   end subroutine sub1
</pre>
</blockquote>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<p>
   The next example shows how regions of flat text can be processed by ufpp(1):
      o The $BLOCK HELP directive can be used to produce a routine to display help text
        and the help text can also be written to a file to produce further document
        formats.
      o The $BLOCK VERSION directive can be used a to produce a routine that
        displays a version in a way that is compatible with the metadata display program what(1).
      o The $BLOCK NULL directive can be used for text that is otherwise ignored.
      o The $BLOCK SHELL directive can be used for text that is the output of a shell.
        This can be very system-dependent but allows code to be built dynamically.
      o The VARIABLE option is used to rewrite the text as a string declaration
   <blockquote>
   <xmp>
   $BLOCK NULL -file notes.txt !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
      This section uses $BLOCK NULL to let a block of text be included
      in the source that is essentially ignored. The difference between
      this and a $IFDEF .FALSE. ... $ENDIF or $OUTPUT /dev/null .. $OUTPUT
      END section is that the -file switch lets this section get written to a
      file optionally when the $UFPP_DOCUMENT_DIR variable is set. This text
      could be markdown text, HTML, RTF, LaTex or some other format to be
      post-processed independently.

      The following $BLOCK HELP section directives is converted into the
      HELP_USAGE() subroutine by ufpp. Optionally if the environment variable
      $UFPP_DOCUMENT_DIR is set the text is additionally written as-is into

         $UFPP_DOCUMENT_DIR/doc/cf.1.man

      because the optional "-file cf.1.man" switch was specified.

      This additional file would then typically be run thru txt2man(1) to
      create a man(1) page.
   $BLOCK END !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   $IFDEF F90
   $BLOCK HELP -file cf.1.man
   NAME
      cf - Convert between Fahrenheit and Celsius temperature values

   SYNOPSIS
      cf [ -C val1 val2 val3 ...] [ -F val1 val2 val3 ...]|[ --help| --version]

   DESCRIPTION
      -C [ val(1) val(2) val(3) ... ]
         Display the given Celsius values as both Celsius and Fahrenheit values
      -F [ val(1) val(2) val(3) ... ]
         Display the given Fahrenheit values as both Celsius and Fahrenheit values

         If no values are given a small table of common temperatures is displayed

      --help display this help and exit

      --version
         output version information and exit

    At the physically impossible-to-reach temperature of zero Kelvin, or
    minus 459.67 degrees Fahrenheit (minus 273.15 Celsius), atoms would
    stop moving. As such, nothing can be colder than absolute zero on the
    Kelvin scale.

    $BLOCK END
   $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   $! this text is converted into the help_version subroutine by ufpp ...
   $! in a format that works with what(1), do not use ",>,\ characters in the labels
   $BLOCK VERSION
   PRODUCT:        GPF (General Purpose Fortran) utilities and examples
   PROGRAM:        cf(1f)
   DESCRIPTI0N:    convert multiple values between Celsius and Fahrenheit
   VERSION:        1.0, 2016-04-09
   AUTHOR:         John S. Urban
   REPORTING BUGS: http://www.urbanjost.altervista.org/
   HOME PAGE:      http://www.urbanjost.altervista.org/index.html
   LICENSE:        Public Domain. This is free software: you are free
                   to change and redistribute it. There is NO WARRANTY,
                   to the extent permitted by law.
   $BLOCK END
   $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   $! use output of a bash(1) shell here document to build some comments
   $BLOCK SHELL
   cat <<EOF
   !! date ....... $(date)
   !! userid ..... $(logname)
   !! hostname ... $(hostname)
   EOF
   $BLOCK END
   $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   $BLOCK COMMENT
      This block of text becomes Fortran comment lines by having exclamations
      placed in front of each line, but is otherwise left as-is.

      The next section is just as-is Fortran
   $BLOCK END
   $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   program cf
   use M_kracken, only: kracken, rgets, lget
   implicit none
   $IDENT cf(1f): convert multiple values between Celsius and Fahrenheit
   real,allocatable                :: val(:)
   integer                         :: i, isum=0
     call kracken('cf','-F -C -help .F. -version .F.' ) ! define and crack command line arguments
     call help_usage(lget('cf_help'))                   ! display help information and stop if true
     call help_version(lget('cf_version'))         ! display version information and stop if true
     isum=0                                        ! running tally of values found on -C and -F options
     val=rgets('cf_C')                             ! get any values specified on -C option

     if(size(val).gt.0)then                        ! have something to print in C ==> F table
        isum=isum+size(val)
        write(*,'(a,t14,a)')'Celsius','Fahrenheit'
        write(*,'(f8.2,"C",t14,f8.2,"F")')&
        & ( val(i),(val(i)+40.0)*9.0/5.0 - 40.0,i=1,size(val))    ! print the requested values
     endif

     val=rgets('cf_F')       ! check for values on -F

     if(size(val).gt.0)then
        isum=isum+size(val)
        write(*,'(a,t14,a)') 'Fahrenheit', 'Celsius'
        write(*,'(f8.2,"F",t14,f8.2,"C")')(val(i),(val(i)+40.0)*5.0/9.0 - 40.0,i=1,size(val))
     endif

     if(isum.eq.0)then       ! if no values given on -C and -F switches show default table
       val=[ &
          &-459.67,                               &
          & -20.0,  -15.0,  -10.0,   -5.0,   0.0, &
          &   5.0,   10.0,   15.0,   20.0,  25.0, &
          &  30.0,   32.0,   35.0,   40.0,  45.0, &
          &  50.0,   55.0,   60.0,   65.0,  70.0, &
          &  75.0,   80.0,   85.0,   90.0,  95.0, &
          &  98.6,  100.0,  105.0,  110.0, 115.0  ]
        write(*,'(a,t14,a)') 'Fahrenheit', 'Celsius'
        write(*,'(f8.2,"F",t14,f8.2,"C")')(val(i),(val(i)+40.0)*5.0/9.0 - 40.0,i=1,size(val))
     endif

   end program cf
   and the output file
   $ENDIF
   $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   $IFDEF PREP_TEST
      Normally you would not just put text here,
      but $SYSTEM and $OUTPUT sections to unit test
      your commands. Then you would call
         ufpp PREP_TEST -system ...
      to run your tests, and
         ufpp F90 ...
      to generate the expanded source code when compiling

   $ENDIF
   $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   </xmp>
   </blockquote>
   The output from "ufpp F90 -i FILE -system" is:
<blockquote>
<xmp>
   subroutine help_usage(l_help)
   implicit none
   character(len=*),parameter     :: ident="@ (#)help_usage(3f): prints help information"
   logical,intent(in)             :: l_help
   character(len=:),allocatable :: help_text(:)
   integer                        :: i
   if(l_help)then
   help_text=[ CHARACTER(LEN=128) :: &
   'NAME                                                                            ',&
   '   cf - Convert between Fahrenheit and Celsius temperature values               ',&
   '                                                                                ',&
   'SYNOPSIS                                                                        ',&
   '   cf [-C val1 val2 val3 ...] [-F val1 val2 val3 ...][--help][--version]        ',&
   '                                                                                ',&
   'DESCRIPTION                                                                     ',&
   '   -C [ val(1) val(2) val(3) ... ]                                              ',&
   '      Display the given Celsius values as both Celsius and Fahrenheit values    ',&
   '   -F [ val(1) val(2) val(3) ... ]                                              ',&
   '      Display the given Fahrenheit values as both Celsius and Fahrenheit values ',&
   '                                                                                ',&
   '      If no values are given a small table of common temperatures is displayed  ',&
   '                                                                                ',&
   '   --help display this help and exit                                            ',&
   '                                                                                ',&
   '   --version                                                                    ',&
   '      output version information and exit                                       ',&
   '                                                                                ',&
   ' At the physically impossible-to-reach temperature of zero Kelvin, or           ',&
   ' minus 459.67 degrees Fahrenheit (minus 273.15 Celsius), atoms would            ',&
   ' stop moving. As such, nothing can be colder than absolute zero on the          ',&
   ' Kelvin scale.                                                                  ',&
   '                                                                                ',&
   '']
      WRITE(*,'(a)')(trim(help_text(i)),i=1,size(help_text))
      stop ! if -help was specified, stop
   endif
   end subroutine help_usage
   !-----------------------------------------------------------------------------------------------------------------------------------
   subroutine help_version(l_version)
   implicit none
   character(len=*),parameter     :: ident="@(#)help_version(3f): prints version information"
   logical,intent(in)             :: l_version
   character(len=:),allocatable   :: help_text(:)
   integer                        :: i
   if(l_version)then
   help_text=[ CHARACTER(LEN=128) :: &
   '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>',&
   '@(#)PROGRAM:        cf(1f)>',&
   '@(#)DESCRIPTION:    convert multiple values between Celsius and Fahrenheit>',&
   '@(#)VERSION:        1.0, 2016-04-09>',&
   '@(#)AUTHOR:         John S. Urban>',&
   '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>',&
   '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>',&
   '@(#)LICENSE:        Public Domain. This is free software: you are free>',&
   '@(#)                to change and redistribute it. There is NO WARRANTY,>',&
   '@(#)                to the extent permitted by law.>',&
   '@(#)COMPILED:       Mon, Dec 18th, 2017 2:55:24 AM>',&
   '']
      WRITE(*,'(a)')(trim(help_text(i)(5:len_trim(help_text(i))-1),kind=kind(1)),i=1,size(help_text))
      stop ! if -version was specified, stop
   endif
   end subroutine help_version
   !-----------------------------------------------------------------------------------------------------------------------------------
   !! date ....... Mon, Dec 18, 2017  2:55:25 AM
   !! userid ..... JSU
   !! hostname ... buzz
   !    This block of text becomes Fortran comment lines by having exclamations
   !    placed in front of each line, but is otherwise left as-is.
   !
   !    The next section is just as-is Fortran
   !===================================================================================================================================
   program cf
   use M_kracken, only: kracken, rgets, lget
   implicit none
   character(len=*),parameter::ident="@ (#)cf(1f): convert multiple values between Celsius and Fahrenheit"
   real,allocatable                :: val(:)
   integer                         :: i, isum=0
     call kracken('cf','-F -C -help .F. -version .F.' ) ! define and crack command line arguments
     call help_usage(lget('cf_help'))                   ! display help information and stop if true
     call help_version(lget('cf_version'))         ! display version information and stop if true
     isum=0                                        ! running tally of values found on -C and -F options
     val=rgets('cf_C')                             ! get any values specified on -C option

     if(size(val).gt.0)then                        ! have something to print in C ==> F table
        isum=isum+size(val)
        write(*,'(a,t14,a)')'Celsius','Fahrenheit'
        write(*,'(f8.2,"C",t14,f8.2,"F")')&
        & ( val(i),(val(i)+40.0)*9.0/5.0 - 40.0,i=1,size(val))    ! print the requested values
     endif

     val=rgets('cf_F')       ! check for values on -F

     if(size(val).gt.0)then
        isum=isum+size(val)
        write(*,'(a,t14,a)') 'Fahrenheit', 'Celsius'
        write(*,'(f8.2,"F",t14,f8.2,"C")')(val(i),(val(i)+40.0)*5.0/9.0 - 40.0,i=1,size(val))
     endif

     if(isum.eq.0)then       ! if no values given on -C and -F switches show default table
       val=[ &
          &-459.67,                               &
          & -20.0,  -15.0,  -10.0,   -5.0,   0.0, &
          &   5.0,   10.0,   15.0,   20.0,  25.0, &
          &  30.0,   32.0,   35.0,   40.0,  45.0, &
          &  50.0,   55.0,   60.0,   65.0,  70.0, &
          &  75.0,   80.0,   85.0,   90.0,  95.0, &
          &  98.6,  100.0,  105.0,  110.0, 115.0  ]
        write(*,'(a,t14,a)') 'Fahrenheit', 'Celsius'
        write(*,'(f8.2,"F",t14,f8.2,"C")')(val(i),(val(i)+40.0)*5.0/9.0 - 40.0,i=1,size(val))
     endif

   end program cf
</xmp>
</blockquote>

<p>
   This small example shows an easy way to maintain help and version
   options easily for programs. Note that the M_kracken module was used
   to provide the example with command line argument parsing; but that
   is not required.
</p>

<p>
   A more complicated example follows where code is contained in an
   HTML document. When the ufpp(1) switch "-html" is used or the input
   filename ends in ".html" , all lines outside of the lines delimited
   with the XMP directive are ignored, <em>allowing documentation and
   code to be contained in one file that can be viewed via a browser</em>.
</p>

<blockquote>
<pre>

    &lt;html&gt;
    &lt;head&gt;
       &lt;title&gt; Simple HTML template for use with ufpp(1) &lt;/title&gt;
       &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.w3.org/StyleSheets/Core/OldStyle&quot; type=&quot;text/css&quot; /&gt;
       &lt;!-- Chocolate Midnight Modernist Oldstyle Steely Swiss Traditional Ultramarine --&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h1&gt; This is an HTML document that can be used as input to ufpp(1)&lt;/h1&gt;
    &lt;p&gt;
        If you are comfortable writing simple HTML documents, a simple
        feature of ufpp(1) allows you to easily maintain documentation,
        source, and links to external files all together. If you run the
        ufpp(1) Fortran Preprocessor on this file with the command
        &lt;pre&gt;
        ufpp -html -i THISFILE.html -o THISFILE.f90
        &lt;/pre&gt;
        the Fortran source is extracted using very simple rules: If lines
        begin with &amp;lt;xmp&amp;gt; start writing out the lines; quit if
        &amp;lt;/xmp&amp;gt; is encountered.
    &lt;/p&gt;
    &lt;h2&gt; TEST PROGRAM &lt;/h2&gt;
    &lt;!-- =============================================================== --&gt;
    &lt;xmp&gt;
    $if .not.defined(WHICH_VERSION)
    $define WHICH_VERSION=1 ! Will only compile the first version of subroutine ONE
    $endif
          program testit
             write(*,*)'hello world'
             call one()
             call two()
          end program testit
    &lt;/xmp&gt;
    &lt;!-- =============================================================== --&gt;
    &lt;h2&gt; ROUTINE ONE &lt;/h2&gt;
    &lt;p&gt;
         There are three versions of subroutine ONE(). If WHICH_VERSION
         is not defined, the &quot;third&quot; version is written to output.
         If WHICH_VERSION = 1, version &quot;first&quot; is used.
         If WHICH_VERSION =2 , version &quot;second&quot; is used.
    &lt;/p&gt;
    &lt;xmp&gt;
    $IF WHICH_VERSION .EQ. 1
         subroutine one()
            write(*,*)'called one, first version'
         end subroutine one
    $ELSEIF WHICH_VERSION .eq. 2
         subroutine one()
            write(*,*)'called one, second version'
         end subroutine one
    $ELSE
         subroutine one()
            write(*,*)'called one, third version'
         end subroutine one
    $ENDIF
    &lt;/xmp&gt;
    &lt;!-- =============================================================== --&gt;
    &lt;h2&gt; ROUTINE TWO&lt;/h2&gt;
    &lt;xmp&gt;
          subroutine two()
             write(*,*)'called two'
          end subroutine two
    &lt;/xmp&gt;
    &lt;!-- =============================================================== --&gt;
    &lt;/body&gt;
</pre>
</blockquote>
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h3> History: </h3>
<p>
   This customized pre-processor is derived from the public-domain
   Lahey pre-processor. Parsing of expressions remains significantly
   unchanged from the Lahey version; but the rest is essentially
   a re-write. ufpp(1) compiles with all the Fortran 90+ compilers
   I have needed it for; including the freely available gfortran(1)
   compiler (version 4.5.3+).
</p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

<h3>Notes on Fortran source code pre-processing with ufpp(1)</h3>
<p>
   In practice Fortran codes rarely need traditional pre-processing.
   In the past the most common reason for passing Fortran files through
   a pre-processor was when the code was calling C code or other
   languages where there was no standard calling interface defined. The
   ISO_C_BINDING standard now defines a C-Fortran interface; so there is
   now generally less need to pre-process Fortran source. The second-most
   common need for pre-processing was to easily use different Fortran
   extensions in different environments. Since the most common extensions
   are now standardized (accessing command line arguments, getting
   date/time information, passing a system command to the operating
   system, ...) the need for traditional pre-processing has diminished
   even more. On the other hand dealing with differences between
   compilers that only partially implement newer Fortran versions has
   brought back a new need for pre-processing; but that is hopefully a
   temporary issue.
</p>

<p>
   That being said, pre-processing is occasionally still required.
   I strongly recommend that you isolate such code by putting the code
   sections that require pre-processing into small procedures that perform
   just the non-standard operations, and keep this in the smallest number
   of files possible.
</p>

<p>
   If I try to avoid the need for traditional pre-processing of Fortran
   source code whenever possible why not just use cpp(1) instead of making
   ufpp(1)? Even if traditional pre-processing is not required I find
   the ufpp(1) filtering capabilities useful as a way to keep related
   text files (documentation, test files, test programs, test scripts,
   ...) together in an easily maintained form.
</p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h3>Notes on alternatives to ufpp(1)</h3>

<p>
   If you just want traditional pre-processing capabilities and use a
   major Linux or Unix distribution you may find existing tools already
   meet your needs.
</p>

<p>
   Some Fortran compilers provide their own "Fortran-safe" pre-processors. The
   compiler documentation often describes their features; which are
   usually a subset of the Unix utility cpp(1). They often intentionally
   do not provide macro expansion or C-style comments (block or in-line);
   but otherwise look very much like cpp(1). They are often called "fpp"
   if they can be called as a stand-alone utility.
   <em>
   Sun has an open-source version on netlib of their flavor of fpp(1).
   </em>
</p>

<p>
   The  <em>cpp(1)  program</em>  is designed for C/C++ and is not totally "Fortran-
   safe". It is, however, a  de-facto  standard  for  code  pre-processing.
   Different  versions  often  have  switches  to  reduce  the  chances  of
   generating unexpected Fortran code. The most common version of cpp(1) works
   with most Fortran using the following form:
   <pre>

   cpp -P -C -traditional MYFILE.F90
   </pre>
</p>

<p>
   The  Fortran  95  standard  provided  an  optional standard pre-processor
   definition. Currently, it seems to rarely be provided  with  compilers.
   <a href="http://www.daniellnagle.com/coco.html">Dan Nagle has an open-source version with macro expansion called "coco"</a>.
</p>

<p>
   The Lahey Fortran site has a pre-processor code in a public-domain repository at
   <a href="http://www.lahey.com/code.htm"> http://www.lahey.com/code.htm</a>.
   It is written in Fortran 77. This is what ufpp(1) was originally derived from.
   Typically you need to create a small wrapper script to call it from make(1)/cmake(1)/...
</p>

<p>
  Other pre-processors that are Fortran-friendly or relatively language-agnostic are
    <ul>
    <li>"f90ppr" by Michel Olganon</li>
    <li>"fpx3" (Joerg Behren version is popular) </li>
    <li>"mp4" ( commonly available on Unix/GNU platforms. It is a powerful general macro pre-processor.)</li>
    <li>"tradcpp" ("traditional" cpp from GNU; which has less problems with Fortran than modern C-standard cpp(1) versions)</li>
    <li>"filepp" at <a href="http://www.cabaret.demon.co.uk/filepp"> http://www.cabaret.demon.co.uk/filepp</a></li>
    <li>"forpedo"</li>
    </ul>
</p>
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h3> Using alternate Fortran sources and/or INCLUDE files </h3>

<p>
   Simply put, instead of pre-processors you can conditionally compile
   different files.
</p>

<p>
   If you have a directory for each programming environment with
   identically named procedures in them that are specific to a system
   you can often avoid  pre-processing altogether. Isolate the
   system-dependent code into small procedures to minimize duplicate
   code. Usually, the files are of the same name but in different
   directories, one per platform. You can often additionally reduce the
   amount of duplicate code by judicious use of Fortran INCLUDE files.
   The most common problem with this method is making sure you keep any
   changes to the procedure parameters consistent across all the versions
   of the same routine.
</p>
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h3> "INCLUDE" method </h3>

<p>
   A variation on the previous approach is to have different
   directories with the same filenames in them that are INCLUDE files.
   You compile for different environments with the -I switch commonly
   available on Fortran compilers. So if you had directories CRAY and
   HP that both had the same files in them you could build different
   versions by entering "f90 -ICRAY ..." or "f90 -IHP ...".
</p>
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h3> Using dead code </h3>

<p>
   If the system-dependent code is all "standard" code that will compile
   on all platforms some people recommend placing all the code in a
   procedure and setting a variable with an INCLUDE to select the proper code
   (assuming the selection does not cause major performance overhead).
</p>

<p>
   This will make some branches into "dead code"; which many compilers
   will remove while optimizing the code.
</p>

<pre>

     subroutine system_dependent()
     character(len=10) :: system
     include "system.h"
     if(system.eq.'hp')then
       write(*,*)'do hp stuff'
     elseif(system.eq.'cray')then
       write(*,*)'do cray stuff'
     else
       write(*,*)'error: unknown system'
     endif
     end subroutine system_dependent
</pre>

<p>
   Assuming you have multiple "system.h" files that include a line like

     <pre>

     system='hp'
     </pre>
or
     <pre>

     system='cray'
     </pre>

   You can build different versions using the -I parameter once again
   to point to the different INCLUDE files.
</p>

<p>
   I personally do not use this "dead code" method, but have seen it
   used to good effect.
</p>
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h3> Run-time selection</h3>

<p>
   Of course when all the code can be compiled on all platforms you can
   write the code without any preprocessing or use of alternate INCLUDE
   files and provide input at run-time to select the correct branch as
   well. The difference is that the compiler cannot optimize out the
   unused branches in that case.
</p>
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<h3> Procedure pointers</h3>

<p>
   When all the code is standard a good method can be to use pointers
   to procedures, as is often used to select between different graphics
   drivers or various mathematical "solvers".
</p>
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<!-- =========================================================================================================================== -->
<footer>
<script language="JavaScript" type="text/javascript" src="../../../javascript/doc.js"> </script>
<script language="JavaScript" > footer("2015-09-13"); </script>
</footer>
<!-- =========================================================================================================================== -->
</body>
</html>
