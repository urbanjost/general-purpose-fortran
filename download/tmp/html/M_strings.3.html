<html> 
<head> 
<title> </title>
<style> 
p {font-family: "Lucida Console", Monaco, monospace}
body {xfont-style: italic}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
p{ padding: 0;margin: 0]
p{ padding-right:1.4em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:90%; font-style:italic; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:99%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:80%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:.8em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="download.html">[UP]</a></h5> 
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>M_strings (3)</NOBR><HR></H1>
</CENTER>
<P>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>M_strings </B>- [M_strings]Fortran string module
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Description</A><BR>
<A HREF=#3>Examples</A><BR>
</BLOCKQUOTE>
<A name=4>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<PRE>
<B>public</B> entities:
<P>
   use m_strings, only : split,delim,chomp
   use m_strings, only : substitute,change,modif,transliterate,reverse
   use M_strings, only : upper,lower
   use M_strings, only : adjustc,compact,nospace,indent,crop
   use M_strings, only : len_white,lenset,merge_str
   use M_strings, only : switch,s2c,c2s
   use M_strings, only : noesc,notabs,expand
   use M_strings, only : string_to_value,string_to_values,s2v,s2vs,value_to_string,v2s
   use M_strings, only : matchw
   use M_strings, only : isalnum, isalpha, iscntrl, isdigit, isgraph, islower,
                         isprint, ispunct, isspace, isupper, isascii, isblank, isxdigit
<P>
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; TOKENS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
split
subroutine parses string using specified delimiter characters and stores tokens into an array
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
delim
subroutine parses string using specified delimiter characters and store tokens into an array
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
chomp
function consumes input line as it returns next token in a string using specified delimiters
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; EDITING</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
substitute
subroutine non-recursively globally replaces old substring
with new substring
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
change
subroutine non-recursively globally replaces old substring
with new substring with a directive like line editor
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
modif
subroutine modifies a string with a directive like the XEDIT
line editor MODIFY command
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
transliterate
replace characters found in set one with characters from set two
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
reverse
reverse character order in a string
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CASE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
upper
function converts string to uppercase
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
lower
function converts string to miniscule
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; WHITE SPACE</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
adjustc
elemental function centers text within the length of the input string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
compact
left justify string and replace duplicate whitespace with single characters or nothing
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
nospace
function replaces whitespace with nothing
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
indent
find number of leading spaces
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
crop
function trims leading and trailing spaces
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; STRING LENGTH</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
len_white
find location of last non-whitespace character
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
lenset
return a string of specified length
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
merge_str
make strings of equal length and then call <B>MERGE</B>(3f) intrinsic
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CHARACTER ARRAY VERSUS STRING</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
switch
switch between a string and an array of single characters
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
s2c
convert string to array of single characters and add null terminator for passing to C
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
c2s
convert null-terminated array of single characters to string for converting strings returned from C
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; NONALPHA</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
noesc
convert non-printable ASCII8 characters to a space
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
notabs
convert tabs to spaces while maintaining columns, assuming tabs are set every 8 characters
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
expand
expand escape sequences in a string
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; NUMERIC STRINGS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
string_to_value
generic subroutine returns numeric value (REAL, DOUBLEPRECISION, INTEGER)  from string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
string_to_values
subroutine reads an array of numbers from a string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
s2v
function returns DOUBLEPRECISION numeric value from string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
s2vs
function returns a DOUBLEPRECISION array of numbers from a string
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
value_to_string
generic subroutine returns string given numeric value (REAL, DOUBLEPRECISION, INTEGER )
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
v2s
generic function returns string from numeric value (REAL, DOUBLEPRECISION, INTEGER )
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; LOGICAL TESTS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
matchw
compares given string for match to pattern which may contain wildcard characters
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; CHARACTER TESTS</H4>
</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isalnum
returns .true. if character is a letter or digit
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isalpha
returns .true. if character is a letter and .false. otherwise
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o iscntrl
returns .true. if character is a delete character or ordinary control character
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isdigit
returns .true. if character is a digit (0,1,&#46;&#46;&#46;,9) and .false. otherwise
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isgraph
returns .true. if character is a printable character except a space is considered non-printable
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o islower
returns .true. if character is a miniscule letter (a-z)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isprint
returns .true. if character is an ASCII printable character
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o ispunct
returns .true. if character is a printable punctuation character
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isspace
returns .true. if character is a null, space, tab, carriage return, new line, vertical tab, or formfeed
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isupper
returns .true. if character is an uppercase letter (A-Z)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isascii
returns .true. if the character is in the range <B>char</B>(0) to <B>char</B>(127)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isblank
returns .true. if character is a blank character (space or horizontal tab.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
o isxdigit
returns .true. if character is a hexadecimal digit (0-9, a-f, or A-F).
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
The M_strings module is a collection of Fortran procedures that process
character strings. Routines for parsing, tokenizing, changing case,
substituting new strings for substrings, locating strings with simple
wildcard expressions, removing tabs and line terminators and other
string manipulations are included.
<P>
M_strings_oop is a companion module that provides an OOP interface
to the M_strings module.
<P>
As newer Fortran features become more widely available a significant
amount of the code (much of which originated as pre-Fortran90 routines)
is subject to updating so new versions of this module are not expected
to be compatible with older versions.
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; OOPS INTERFACE</H4>
</A>
<BLOCKQUOTE>
<P>
If you prefer an Object-oriented interface the M_strings_oop
module (included with the M_strings module source) provides an OOP
interface to the M_strings module; as described in the example
program OBJECT_ORIENTED shown in the example program found below.
</BLOCKQUOTE>
<A name=3>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Each of the procedural functions includes an example program in the corresponding <B>man</B>(1) page for the function.
The object-oriented interface does not have individual <B>man</B>(1) pages, but is instead demonstrated using the following
example program:
<P>
<PRE>
 program  object_oriented
 !
 ! This is an example using the object-oriented class/type model defined in M_strings_oop
 ! This is essentially the same functionality as the procedures combined with several Fortran intrinsics and overloaded operators
 !
 use M_strings_oop,only : string, p
 implicit none
 TYPE(string) :: str1
 TYPE(string) :: str2
 TYPE(string) :: str3
 !==============================================================================
   write(*,*)&#146;exercise the M_STRING_OOP module interface&#146;
   ! draw a break line in the output
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;Call methods of type(STRING)&#146;
   ! define TYPE(STRING) with constructor
   str2=string(&#146;   This  is  a  String!       &#146;)
   write(*,*)repeat(&#146;=&#146;,78)
   ! print members of type
   write(*,101)&#146;str2%str is &#46;&#46;&#46;............. &#146;,str2%str
   ! same as intrinsic LEN()
   write(*,202)&#146;len &#46;&#46;&#46;..................... &#146;,str2%len()
   ! same as intrinsic INDEX()
   write(*,202)&#146;len_trim &#46;&#46;&#46;................ &#146;,str2%len_trim()
   ! same as intrinsic INDEX()
   write(*,202)&#146;index("is")&#46;&#46;&#46;.............. &#146;,str2%index("is")
   ! same as intrinsic INDEX()
   write(*,202)&#146;index("is",back=.T.) &#46;&#46;&#46;.... &#146;,str2%index("is",back=.TRUE.)
   ! output TYPE(STRING) with %str all uppercase
   write(*,101)&#146;upper &#46;&#46;&#46;................... &#146;,p(str2%upper())
   ! output TYPE(STRING) with %str all miniscule
   write(*,101)&#146;lower &#46;&#46;&#46;................... &#146;,p(str2%lower())
   ! output TYPE(STRING) with %str reversed
   write(*,101)&#146;reverse &#46;&#46;&#46;................. &#146;,p(str2%reverse())
   ! same as intrinsic ADJUSTL()
   write(*,101)&#146;adjustl &#46;&#46;&#46;................. &#146;,p(str2%adjustl())
   ! same as intrinsic ADJUSTR()
   write(*,101)&#146;adjustr &#46;&#46;&#46;................. &#146;,p(str2%adjustr())
   ! center string in current string length
   write(*,101)&#146;adjustc &#46;&#46;&#46;................. &#146;,p(str2%adjustc())
   ! center string in string length of NN
   write(*,101)&#146;adjustc(49) &#46;&#46;&#46;............. &#146;,p(str2%adjustc(49))
   ! force %str to be NN characters long
   write(*,101)&#146;lenset(49) &#46;&#46;&#46;.............. &#146;,p(str2%lenset(49))
   ! same as intrinsic TRIM()
   write(*,101)&#146;trim &#46;&#46;&#46;.................... &#146;,p(str2%trim())
   ! trim leading and trailing spaces
   write(*,101)&#146;crop &#46;&#46;&#46;.................... &#146;,p(str2%crop())
   ! calls M_strings procedure SUBSTITUTE()
   write(*,101)&#146;substitute("This","Here") .. &#146;,p(str2%substitute("This","Here"))
   ! calls M_strings procedure COMPACT()
   write(*,101)&#146;compact &#46;&#46;&#46;................. &#146;,p(str2%compact())
   write(*,101)&#146;compact("") &#46;&#46;&#46;............. &#146;,p(str2%compact(""))
   write(*,101)&#146;compact(":") &#46;&#46;&#46;............ &#146;,p(str2%compact(":"))
   ! calls M_strings procedure TRANSLITERATE()
   write(*,101)&#146;transliterate("aei","VWX") . &#146;,p(str2%transliterate("aei","VWX"))
   write(*,101)&#146;transliterate("aeiou"," ") . &#146;,p(str2%transliterate("aeiou"," "))
   write(*,101)&#146;transliterate("aeiou","") .. &#146;,p(str2%transliterate("aeiou",""))
   write(*,101)&#146;transliterate(" aeiou","") . &#146;,p(str2%transliterate(" aeiou",""))
   ! calls M_strings procedure SWITCH()
   write(*,404)&#146;chars &#46;&#46;&#46;................. . &#146;,str2%chars()
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   str2%str=&#146;\t\tSome tabs\t   x\bX &#146;
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,101)&#146;expand &#46;&#46;&#46;.................. &#146;,p(str2%expand())
   str2=str2%expand()
   ! calls M_strings procedure NOTABS()
   write(*,101)&#146;notabs &#46;&#46;&#46;.................. &#146;,p(str2%notabs())
   ! calls M_strings procedure NOESC()
   write(*,101)&#146;noesc &#46;&#46;&#46;................... &#146;,p(str2%noesc())
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;Casting to numeric variables&#146;
   str3=string(&#146;   12.345678901234567e1        &#146;)
   write(*,101)&#146;str3%str &#46;&#46;&#46;................ &#146;,str3%str
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)&#146;int  &#46;&#46;&#46;.................... &#146;, str3%int()
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)&#146;real &#46;&#46;&#46;.................... &#146;, str3%real()
   ! calls M_strings procedure STRING_TO_VALUE()
   write(*,*)&#146;dble &#46;&#46;&#46;.................... &#146;, str3%dble()
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;Matching simple globbing patterns&#146;
   str3=string(&#146;   12.345678901234567e1        &#146;)
   str3=string(&#146;Four score and seven years ago&#146;)
   write(*,101)&#146;str3%str &#46;&#46;&#46;................ &#146;,str3%str
   ! calls M_strings procedure MATCHW
   write(*,*)&#146;match("Fo*") &#46;&#46;&#46;............ &#146;, str3%match("Fo*")
   ! calls M_strings procedure MATCHW
   write(*,*)&#146;match("and") &#46;&#46;&#46;............ &#146;, str3%match("and")
   ! calls M_strings procedure MATCHW
   write(*,*)&#146;match("*and*") &#46;&#46;&#46;.......... &#146;, str3%match("*and*")
<P>
   101 format(1x,a,"[",a,"]")
   202 format(1x,a,i0)
   303 format(1x,*(l3))
   404 format(1x,a,*("[",a1,"]":))
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (add and subtract,return TYPE(STRING))&#146;
   str1%str=&#146;123.456&#146;
   str2%str=&#146;AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,*)&#146;str1 + str2 &#46;&#46;&#46;............. &#146;,p(str1 + str2)
   ! a string that looks like a numeric value can have a value added
   write(*,*)&#146;str1 + 20000 &#46;&#46;&#46;............ &#146;,p(str1 +20000)
   write(*,*)&#146;str1 - 20.0 &#46;&#46;&#46;............. &#146;,p(str1 -20.0)
   write(*,*)&#146;str2 - "Aa" (removes ALL) .. &#146;,p(str2 - &#146;Aa&#146;)
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (multiply,return TYPE(STRING))&#146;
   str1%str=&#146;AaBbCcDdEeFfGgHhIiJj&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,*)&#146;str1 * 3 &#46;&#46;&#46;................ &#146;,p(str1 * 3)
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (//,return TYPE(STRING))&#146;
   str1%str=&#146;String one:&#146;
   str2%str=&#146;String two:&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,*)&#146;str1 // str2 &#46;&#46;&#46;............. &#146;,p(str1 // str2)
   ! numeric values are converted to strings
   write(*,*)&#146;str1 // 20000 &#46;&#46;&#46;............ &#146;,p(str1 // 20000)
   write(*,*)&#146;str1 // 20.0 &#46;&#46;&#46;............. &#146;,p(str1 // 20.0)
<P>
   write(*,*)repeat(&#146;=&#146;,78)
   write(*,*)&#146;OVERLOADED OPERATORS (logical comparisons,return logical)&#146;
   ! NOTE: comparisons are performed on the character variable members
   !       of the type(string)
   str1%str=&#146;abcdefghij&#146;
   str2%str=&#146;klmnopqrst&#146;
   write(*,101)&#146;str1%str &#46;&#46;&#46;................ &#146;,str1%str
   write(*,101)&#146;str2%str &#46;&#46;&#46;................ &#146;,str2%str
   write(*,*)&#146;: EQ LT GT LE GE NE&#146;
   write(*,*)&#146;compare str1 to str1&#146;
   write(*,303)str1.eq.str1  ,str1.lt.str1  ,str1.gt.str1  ,str1.le.str1 &
              & ,str1.ge.str1  ,str1.ne.str1
   write(*,*)&#146;compare str1 to str2&#146;
   write(*,303)str1.eq.str2  ,str1.lt.str2  ,str1.gt.str2  ,str1.le.str2 &
              & ,str1.ge.str2  ,str1.ne.str2
   write(*,*)&#146;compare str2 to str1&#146;
   write(*,303)str2.eq.str1  ,str2.lt.str1  ,str2.gt.str1  ,str2.le.str1 &
              & ,str2.ge.str1  ,str2.ne.str1
<P>
   write(*,*)repeat(&#146;=&#146;,78)
<P>
 end program object_oriented
<P>
<P>
 Expected output
<P>
  exercise the M_STRING_OOP module interface
  =============================================================================
  Call methods of type(STRING)
  =============================================================================
  str2%str is &#46;&#46;&#46;............. [   This  is  a  String!             ]
  len &#46;&#46;&#46;..................... 36
  len_trim &#46;&#46;&#46;................ 23
  index("is")&#46;&#46;&#46;.............. 6
  index("is",back=.T.) &#46;&#46;&#46;.... 10
  upper &#46;&#46;&#46;................... [   THIS  IS  A  STRING!             ]
  lower &#46;&#46;&#46;................... [   this  is  a  string!             ]
  reverse &#46;&#46;&#46;................. [             !gnirtS  a  si  sihT   ]
  adjustl &#46;&#46;&#46;................. [This  is  a  String!                ]
  adjustr &#46;&#46;&#46;................. [                This  is  a  String!]
  adjustc &#46;&#46;&#46;................. [        This  is  a  String!        ]
  adjustc(49) &#46;&#46;&#46;............. [              This  is  a  String!               ]
  lenset(49) &#46;&#46;&#46;.............. [   This  is  a  String!                          ]
  trim &#46;&#46;&#46;.................... [   This  is  a  String!]
  crop &#46;&#46;&#46;.................... [This  is  a  String!]
  substitute("This","Here") .. [   Here  is  a  String!             ]
  compact &#46;&#46;&#46;................. [This is a String!]
  compact("") &#46;&#46;&#46;............. [ThisisaString!]
  compact(":") &#46;&#46;&#46;............ [This:is:a:String!]
  transliterate("aei","VWX") . [   ThXs  Xs  V  StrXng!             ]
  transliterate("aeiou"," ") . [   Th s   s     Str ng!             ]
  transliterate("aeiou","") .. [   Ths  s    Strng!                 ]
  transliterate(" aeiou","") . [ThssStrng!                          ]
  chars &#46;&#46;&#46;................. . [ ][ ][ ][T][h][i][s][ ][ ][i][s][ ][ ][a][ ][ ][S][t][r][i][n][g][!][ ][ ][ ][ ][ ][ ][ ]
  =============================================================================
  str2%str &#46;&#46;&#46;................ [\t\tSome tabs\t   x\bX ]
  expand &#46;&#46;&#46;.................. [         Some tabs          xX]
  notabs &#46;&#46;&#46;.................. [                Some tabs          xX]
  noesc &#46;&#46;&#46;................... [  Some tabs    x X]
  =============================================================================
  Casting to numeric variables
  str3%str &#46;&#46;&#46;................ [   12.345678901234567e1        ]
  int  &#46;&#46;&#46;....................          123
  real &#46;&#46;&#46;....................    123.456787
  dble &#46;&#46;&#46;....................    123.45678901234567
  =============================================================================
  Matching simple globbing patterns
  str3%str &#46;&#46;&#46;................ [Four score and seven years ago]
  match("Fo*") &#46;&#46;&#46;............  T
  match("and") &#46;&#46;&#46;............  F
  match("*and*") &#46;&#46;&#46;..........  T
  ==============================================================================
  OVERLOADED OPERATORS (add and subtract, return TYPE(STRING))
  str1%str &#46;&#46;&#46;................ [123.456]
  str2%str &#46;&#46;&#46;................ [AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj]
  str1 + str2 &#46;&#46;&#46;............. 123.456 AaBbCcDdEeFfGgHhIiJj AaBbCcDdEeFfGgHhIiJj
  str1 + 20000 &#46;&#46;&#46;............ 20123.455999999998
  str1 - 20.0 &#46;&#46;&#46;............. -103.456
  str2 - "Aa" (removes ALL) .. BbCcDdEeFfGgHhIiJj BbCcDdEeFfGgHhIiJj
  =============================================================================
  OVERLOADED OPERATORS (multiply, return TYPE(STRING))
  str1%str &#46;&#46;&#46;................ [AaBbCcDdEeFfGgHhIiJj]
  str1 * 3 &#46;&#46;&#46;................ AaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJjAaBbCcDdEeFfGgHhIiJj
  =============================================================================
  OVERLOADED OPERATORS (//, return TYPE(STRING))
  str1%str &#46;&#46;&#46;................ [String one:]
  str2%str &#46;&#46;&#46;................ [String two:]
  str1 // str2 &#46;&#46;&#46;............. String one:String two:
  str1 // 20000 &#46;&#46;&#46;............ String one:20000
  str1 // 20.0 &#46;&#46;&#46;............. String one:20.0
  =============================================================================
  OVERLOADED OPERATORS (logical comparisons, return logical)
  str1%str &#46;&#46;&#46;................ [abcdefghij]
  str2%str &#46;&#46;&#46;................ [klmnopqrst]
  : EQ LT GT LE GE NE
  compare str1 to str1
  :  T  F  F  T  T  F
  compare str1 to str2
  :  F  T  F  T  F  T
  compare str2 to str1
  :  F  F  T  F  T  T
  =============================================================================
</PRE>
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>M_strings (3)</TD> <TD align=right width=33%><I>July 02, 2017</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from a5701843-00f4-467d-9853-29c28d2a8921 using man macros.</FONT>
</div>
</div>
<center><img src="images/M_strings.3.gif"></center> 
</body>
</HTML>
