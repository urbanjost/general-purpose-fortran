!>
!!##NAME
!!    INTRINSIC(3f) - intrinsic man(1) pages
!!
!!##DESCRIPTION
!!
!!    This is a project to provide a standard set of man(1) pages for Fortran
!!    and the Fortran intrinsics, ultimately with a working example program
!!    for each intrinsic.
!!
!!    The source is maintained as a single file (intrinsics.ff) which is
!!    run thru ufpp(1) and txt2man(1) to create the program intrinsics(1f)
!!    that will generate all the text as plain text as well as the man(1)
!!    pages. The program is very useful for scanning for keywords.
!!
!!    Note that the vim(1) editor will call up a man(1) page for a word if
!!    the letter "K" is pressed over the word.
!!
!!    Integration with the editor is a powerful tool when inspecting code
!!    that uses unfamiliar procedures and to verify correct usage when
!!    creating code.
!!
!!    *Note*: In many cases the descriptions of these intrinsics were
!!    originally taken from the [[GFortran|GNU Fortran]] manual to make
!!    descriptions on the Fortran Wiki by Jason Blevins (which were then
!!    used to start this collection). Like the Fortran Wiki itself, the
!!    [[GFortran|GNU Fortran]] manual is licensed under the [[GNU Free
!!    Documentation License]].
!!
!!    These documents are at the state of "good enough considering the
!!    alternative is nothing", but are still actively being completed.
!===================================================================================================================================
subroutine help_version(l_version)
implicit none
character(len=*),parameter     :: ident="@(#)help_version(3f): prints version information"
logical,intent(in)             :: l_version
character(len=:),allocatable   :: help_text(:)
integer                        :: i
logical                        :: stopit=.false.
stopit=.false.
if(l_version)then
help_text=[ CHARACTER(LEN=128) :: &
'@(#)PRODUCT:        CLI library utilities and examples>',&
'@(#)PROGRAM:        intrinsics(1)>',&
'@(#)DESCRIPTION:    output source for man(1) pages of Fortran intrinisics>',&
'@(#)VERSION:        2.0, 20170305>',&
'@(#)AUTHOR:         John S. Urban>',&
'@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>',&
'@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>',&
'@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>',&
'@(#)                There is NO WARRANTY, to the extent permitted by law.>',&
'@(#)COMPILED:       Sat, Jul 1st, 2017 10:44:37 PM>',&
'']
   WRITE(*,'(a)')(trim(help_text(i)(5:len_trim(help_text(i))-1)),i=1,size(help_text))
   stop ! if -version was specified, stop
endif
end subroutine help_version
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine help_usage(l_help)
implicit none
character(len=*),parameter     :: ident="@(#)help_usage(3f): prints help information"
logical,intent(in)             :: l_help
character(len=:),allocatable :: help_text(:)
integer                        :: i
logical                        :: stopit=.false.
stopit=.false.
if(l_help)then
help_text=[ CHARACTER(LEN=128) :: &
'NAME                                                                            ',&
'    intrinsics(1f) - [FUNIX]output text versions of Fortran intrinsic man(1) pages',&
'                                                                                ',&
'SYNOPSIS                                                                        ',&
'    intrinsics [--help|--version]                                               ',&
'                                                                                ',&
'DESCRIPTION                                                                     ',&
'    This program outputs all the source of the man(1) pages of the Fortran intrinsics procedures.',&
'                                                                                ',&
'OPTIONS                                                                         ',&
'    --help     display this help and exit                                       ',&
'    --version  output version information and exit                              ',&
'                                                                                ',&
'EXAMPLES                                                                        ',&
'    Sample commands                                                             ',&
'                                                                                ',&
'       intrinsics >x;vi x                                                       ',&
'                                                                                ',&
'']
   WRITE(*,'(a)')(trim(help_text(i)),i=1,size(help_text))
   stop ! if -help was specified, stop
endif
end subroutine help_usage
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!     intrinsics(1f) - [FUNIX]output text versions of Fortran intrinsic man(1) pages
!!
!!##SYNOPSIS
!!
!!     intrinsics [--help|--version]
!!
!!##DESCRIPTION
!!     This program outputs all the source of the man(1) pages of the Fortran intrinsics procedures.
!!
!!##OPTIONS
!!     --help     display this help and exit
!!     --version  output version information and exit
!!
!!##EXAMPLES
!!
!!     Sample commands
!!
!!        intrinsics >x;vi x
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
program intrinsics_man_pages
use ISO_FORTRAN_ENV, only : io => OUTPUT_UNIT
use M_kracken,only : kracken, lget                                   ! add command-line parser module
implicit none
                                                               ! define command arguments, default values and crack command line
   call kracken('intrinsics','-help .false. -version .false.')
   call help_usage(lget('intrinsics_help'))                    ! if -help option is present, display help text and exit
   call help_version(lget('intrinsics_version'))               ! if -version option is present, display version text and exit
!-----------------------------------------------------------------------------------------------------------------------------------
write(io,'(a)')'NAME'
write(io,'(a)')'   intrinsics(7f) - intrinsic man(1) pages'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Got tired of not having the Fortran intrinsics available as man(1) pages,'
write(io,'(a)')'   especially when looking at code in the vim(1) editor and wanting to use the'
write(io,'(a)')'   "K" command to evoke the man(1) page.'
write(io,'(a)')''
write(io,'(a)')'   So, as a start I took the closest thing I knew, which was descriptions on the'
write(io,'(a)')'   Fortran Wiki, and am slowly turning them into man(1) pages and sometimes'
write(io,'(a)')'   altering them.'
write(io,'(a)')''
write(io,'(a)')'   *Note*: In many cases the descriptions of these intrinsics were originally'
write(io,'(a)')'   taken from the [[GFortran|GNU Fortran]] manual to make descriptions'
write(io,'(a)')'   on the Fortran Wiki by Jason Blevins (which were then used to start this'
write(io,'(a)')'   collection). Like the Fortran Wiki itself, the [[GFortran|GNU Fortran]]'
write(io,'(a)')'   manual is licensed under the [[GNU Free Documentation License]].'
write(io,'(a)')''
write(io,'(a)')'   These are at the state of "good enough considering the alternative is nothing",'
write(io,'(a)')'   but are still actively being completed.'
write(io,'(a)')''
write(io,'(a)')'CONTENTS'
write(io,'(a)')''
write(io,'(a)')'Inquiry intrinsic functions'
write(io,'(a)')''
write(io,'(a)')'The result of an inquiry function depends on the properties of its'
write(io,'(a)')'principal argument, not on the value of the argument. The value of the'
write(io,'(a)')'argument does not have to be defined.'
write(io,'(a)')''
write(io,'(a)')'   * [[allocated]]--Status of an allocatable entity'
write(io,'(a)')'   * [[associated]]--Status of a pointer or pointer/target pair'
write(io,'(a)')'   * [[bit_size]]--Bit size inquiry function'
write(io,'(a)')'   * [[command_argument_count]]--Get number of command line arguments'
write(io,'(a)')'   * [[digits]]--Significant digits function'
write(io,'(a)')'   * [[epsilon]]--Epsilon function'
write(io,'(a)')'   * [[extends_type_of]]--Type extension inquiry'
write(io,'(a)')'   * [[huge]]--Largest number of a kind'
write(io,'(a)')'   * [[is_contiguous]]--True if and only if an object is contigous'
write(io,'(a)')'   * [[kind]]--Kind of an entity'
write(io,'(a)')'   * [[lbound]]--Lower dimension bounds of an array'
write(io,'(a)')'   * [[len]]--Length of a character entity'
write(io,'(a)')'   * [[maxexponent]]--Maximum exponent of a real kind'
write(io,'(a)')'   * [[minexponent]]--Minimum exponent of a real kind'
write(io,'(a)')'   * [[new_line]]--New line character'
write(io,'(a)')'   * [[precision]]--Decimal precision of a real kind'
write(io,'(a)')'   * [[present]]--Determine whether an optional dummy argument is specified'
write(io,'(a)')'   * [[radix]]--Base of a model number'
write(io,'(a)')'   * [[range]]--Decimal exponent range of a real kind'
write(io,'(a)')'   * [[same_type_as]]--Query dynamic types for equality'
write(io,'(a)')'   * [[shape]]--Determine the shape of an array'
write(io,'(a)')'   * [[size]]--Determine the size of an array'
write(io,'(a)')'   * [[tiny]]--Smallest positive number of a real kind'
write(io,'(a)')'   * [[ubound]]--Upper dimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'Math functions'
write(io,'(a)')''
write(io,'(a)')'   * [[abs]]--Absolute value'
write(io,'(a)')'   * [[acos]]--Arccosine function'
write(io,'(a)')'   * [[acosh]]--Inverse hyperbolic cosine function'
write(io,'(a)')'   * [[asin]]--Arcsine function'
write(io,'(a)')'   * [[asinh]]--Inverse hyperbolic sine function'
write(io,'(a)')'   * [[atan]]--Arctangent function'
write(io,'(a)')'   * [[atan2]]--Arctangent function'
write(io,'(a)')'   * [[atanh]]--Inverse hyperbolic tangent function'
write(io,'(a)')'   * [[bessel_j0]]--Bessel function of the first kind of order 0'
write(io,'(a)')'   * [[bessel_j1]]--Bessel function of the first kind of order 1'
write(io,'(a)')'   * [[bessel_jn]]--Bessel function of the first kind'
write(io,'(a)')'   * [[bessel_y0]]--Bessel function of the second kind of order 0'
write(io,'(a)')'   * [[bessel_y1]]--Bessel function of the second kind of order 1'
write(io,'(a)')'   * [[bessel_yn]]--Bessel function of the second kind'
write(io,'(a)')'   * [[cos]]--Cosine function'
write(io,'(a)')'   * [[cosh]]--Hyperbolic cosine function'
write(io,'(a)')'   * [[erf]]--Error function'
write(io,'(a)')'   * [[erfc]]--Complementary error function'
write(io,'(a)')'   * [[erfc_scaled]]--Error function'
write(io,'(a)')'   * [[gamma]]--Gamma function'
write(io,'(a)')'   * [[hypot]]--Euclidean distance function'
write(io,'(a)')'   * [[log]]--Logarithm function'
write(io,'(a)')'   * [[log10]]--Base 10 logarithm function'
write(io,'(a)')'   * [[log_gamma]]--Logarithm of the Gamma function'
write(io,'(a)')'   * [[sin]]--Sine function'
write(io,'(a)')'   * [[sinh]]--Hyperbolic sine function'
write(io,'(a)')'   * [[sqrt]]--Square-root function'
write(io,'(a)')'   * [[tan]]--Tangent function'
write(io,'(a)')'   * [[tanh]]--Hyperbolic tangent function'
write(io,'(a)')''
write(io,'(a)')'   * [[aimag]]--Imaginary part of complex number'
write(io,'(a)')'   * [[aint]]--Truncate to a whole number'
write(io,'(a)')'   * [[anint]]--Nearest whole number'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   * [[achar]]--Character in ASCII collating sequence'
write(io,'(a)')'   * [[adjustl]]--Left adjust a string'
write(io,'(a)')'   * [[adjustr]]--Right adjust a string'
write(io,'(a)')'   * [[all]]--All values in MASK along DIM are true'
write(io,'(a)')'   * [[any]]--Any value in MASK along DIM is true'
write(io,'(a)')'   * [[atomic_add]]--Atomic ADD operation'
write(io,'(a)')'   * [[atomic_and]]--Atomic bitwise AND operation'
write(io,'(a)')'   * [[atomic_cas]]--Atomic compare and swap'
write(io,'(a)')'   * [[atomic_define]]--Setting a variable atomically'
write(io,'(a)')'   * [[atomic_fetch_add]]--Atomic ADD operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_and]]--Atomic bitwise AND operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_or]]--Atomic bitwise OR operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_xor]]--Atomic bitwise XOR operation with prior fetch'
write(io,'(a)')'   * [[atomic_or]]--Atomic bitwise OR operation'
write(io,'(a)')'   * [[atomic_ref]]--Obtaining the value of a variable atomically'
write(io,'(a)')'   * [[atomic_xor]]--Atomic bitwise OR operation'
write(io,'(a)')'   * [[bge]]--Bitwise greater than or equal to'
write(io,'(a)')'   * [[bgt]]--Bitwise greater than'
write(io,'(a)')'   * [[ble]]--Bitwise less than or equal to'
write(io,'(a)')'   * [[blt]]--Bitwise less than'
write(io,'(a)')'   * [[btest]]--Bit test function'
write(io,'(a)')'   * [[c_associated]]--Status of a C pointer'
write(io,'(a)')'   * [[c_funloc]]--Obtain the C address of a procedure'
write(io,'(a)')'   * [[c_f_procpointer]]--Convert C into Fortran procedure pointer'
write(io,'(a)')'   * [[c_f_pointer]]--Convert C into Fortran pointer'
write(io,'(a)')'   * [[c_loc]]--Obtain the C address of an object'
write(io,'(a)')'   * [[c_sizeof]]--Size in bytes of an expression'
write(io,'(a)')'   * [[ceiling]]--Integer ceiling function'
write(io,'(a)')'   * [[char]]--Character conversion function'
write(io,'(a)')'   * [[cmplx]]--Complex conversion function'
write(io,'(a)')'   * [[co_broadcast]]--Copy a value to all images the current set of images'
write(io,'(a)')'   * [[co_max]]--Maximal value on the current set of images'
write(io,'(a)')'   * [[co_min]]--Minimal value on the current set of images'
write(io,'(a)')'   * [[co_reduce]]--Reduction of values on the current set of images'
write(io,'(a)')'   * [[co_sum]]--Sum of values on the current set of images'
write(io,'(a)')'   * [[compiler_options]]--Options passed to the compiler'
write(io,'(a)')'   * [[compiler_version]]--Compiler version string'
write(io,'(a)')'   * [[conjg]]--Complex conjugate function'
write(io,'(a)')'   * [[count]]--Count function'
write(io,'(a)')'   * [[cpu_time]]--CPU elapsed time in seconds'
write(io,'(a)')'   * [[cshift]]--Circular shift elements of an array'
write(io,'(a)')'   * [[date_and_time]]--Date and time subroutine'
write(io,'(a)')'   * [[dble]]--Double conversion function'
write(io,'(a)')'   * [[dim]]--Positive difference'
write(io,'(a)')'   * [[dot_product]]--Dot product function'
write(io,'(a)')'   * [[dprod]]--Double product function'
write(io,'(a)')'   * [[dshiftl]]--Combined left shift'
write(io,'(a)')'   * [[dshiftr]]--Combined right shift'
write(io,'(a)')'   * [[eoshift]]--End-off shift elements of an array'
write(io,'(a)')'   * [[event_query]]--Query whether a coarray event has occurred'
write(io,'(a)')'   * [[execute_command_line]]--Execute a shell command'
write(io,'(a)')'   * [[exp]]--Exponential function'
write(io,'(a)')'   * [[exponent]]--Exponent function'
write(io,'(a)')'   * [[float]]--Convert integer to default real'
write(io,'(a)')'   * [[floor]]--Integer floor function'
write(io,'(a)')'   * [[fraction]]--Fractional part of the model representation'
write(io,'(a)')'   * [[get_command]]--Get the entire command line'
write(io,'(a)')'   * [[get_command_argument]]--Get command line arguments'
write(io,'(a)')'   * [[get_environment_variable]]--Get an environmental variable'
write(io,'(a)')'   * [[iachar]]--Code in ASCII collating sequence'
write(io,'(a)')'   * [[iall]]--Bitwise and of array elements'
write(io,'(a)')'   * [[iand]]--Bitwise logical and'
write(io,'(a)')'   * [[iany]]--Bitwise or of array elements'
write(io,'(a)')'   * [[ibclr]]--Clear bit'
write(io,'(a)')'   * [[ibits]]--Bit extraction'
write(io,'(a)')'   * [[ibset]]--Set bit'
write(io,'(a)')'   * [[ichar]]--Character-to-integer conversion function'
write(io,'(a)')'   * [[ieor]]--Bitwise logical exclusive or'
write(io,'(a)')'   * [[image_index]]--Cosubscript to image index conversion'
write(io,'(a)')'   * [[index]]--Position of a substring within a string'
write(io,'(a)')'   * [[int]]--Convert to integer type'
write(io,'(a)')'   * [[ior]]--Bitwise logical inclusive or'
write(io,'(a)')'   * [[iparity]]--Bitwise exclusive or of array elements'
write(io,'(a)')'   * [[is_iostat_end]]--Test for end-of-file value'
write(io,'(a)')'   * [[is_iostat_eor]]--Test for end-of-record value'
write(io,'(a)')'   * [[ishft]]--Shift bits'
write(io,'(a)')'   * [[ishftc]]--Shift bits circularly'
write(io,'(a)')'   * [[lcobound]]--Lower codimension bounds of an array'
write(io,'(a)')'   * [[leadz]]--Number of leading zero bits of an integer'
write(io,'(a)')'   * [[len_trim]]--Length of a character entity without trailing blank characters'
write(io,'(a)')'   * [[lge]]--Lexical greater than or equal'
write(io,'(a)')'   * [[lgt]]--Lexical greater than'
write(io,'(a)')'   * [[lle]]--Lexical less than or equal'
write(io,'(a)')'   * [[llt]]--Lexical less than'
write(io,'(a)')'   * [[logical]]--Convert to logical type'
write(io,'(a)')'   * [[maskl]]--Left justified mask'
write(io,'(a)')'   * [[maskr]]--Right justified mask'
write(io,'(a)')'   * [[matmul]]--matrix multiplication'
write(io,'(a)')'   * [[max]]--Maximum value of an argument list'
write(io,'(a)')'   * [[maxloc]]--Location of the maximum value within an array'
write(io,'(a)')'   * [[maxval]]--Maximum value of an array'
write(io,'(a)')'   * [[merge]]--Merge variables'
write(io,'(a)')'   * [[merge_bits]]--Merge of bits under mask'
write(io,'(a)')'   * [[min]]--Minimum value of an argument list'
write(io,'(a)')'   * [[minloc]]--Location of the minimum value within an array'
write(io,'(a)')'   * [[minval]]--Minimum value of an array'
write(io,'(a)')'   * [[mod]]--Remainder function'
write(io,'(a)')'   * [[modulo]]--Modulo function'
write(io,'(a)')'   * [[move_alloc]]--Move allocation from one object to another'
write(io,'(a)')'   * [[mvbits]]--Move bits from one integer to another'
write(io,'(a)')'   * [[nearest]]--Nearest representable number'
write(io,'(a)')'   * [[nint]]--Nearest whole number'
write(io,'(a)')'   * [[not]]--Logical negation'
write(io,'(a)')'   * [[norm2]]--Euclidean vector norm'
write(io,'(a)')'   * [[null]]--Function that returns an disassociated pointer'
write(io,'(a)')'   * [[num_images]]--Number of images'
write(io,'(a)')'   * [[pack]]--Pack an array into an array of rank one'
write(io,'(a)')'   * [[parity]]--Reduction with exclusive or'
write(io,'(a)')'   * [[popcnt]]--Number of bits set'
write(io,'(a)')'   * [[poppar]]--Parity of the number of bits set'
write(io,'(a)')'   * [[product]]--Product of array elements'
write(io,'(a)')'   * [[random_number]]--Pseudo-random number'
write(io,'(a)')'   * [[random_seed]]--Initialize a pseudo-random number sequence'
write(io,'(a)')'   * [[rank]]--Rank of a data object'
write(io,'(a)')'   * [[real]]--Convert to real type'
write(io,'(a)')'   * [[repeat]]--Repeated string concatenation'
write(io,'(a)')'   * [[reshape]]--Function to reshape an array'
write(io,'(a)')'   * [[rrspacing]]--Reciprocal of the relative spacing'
write(io,'(a)')'   * [[scale]]--Scale a real value'
write(io,'(a)')'   * [[scan]]--Scan a string for the presence of a set of characters'
write(io,'(a)')'   * [[selected_char_kind]]--Choose character kind'
write(io,'(a)')'   * [[selected_int_kind]]--Choose integer kind'
write(io,'(a)')'   * [[selected_real_kind]]--Choose real kind'
write(io,'(a)')'   * [[set_exponent]]--Set the exponent of the model'
write(io,'(a)')'   * [[shifta]]--Right shift with fill'
write(io,'(a)')'   * [[shiftl]]--Left shift'
write(io,'(a)')'   * [[shiftr]]--Right shift'
write(io,'(a)')'   * [[sign]]--Sign copying function'
write(io,'(a)')'   * [[sngl]]--Convert double precision real to default real'
write(io,'(a)')'   * [[spacing]]--Smallest distance between two numbers of a given type'
write(io,'(a)')'   * [[spread]]--Add a dimension to an array'
write(io,'(a)')'   * [[storage_size]]--Storage size in bits'
write(io,'(a)')'   * [[sum]]--Sum of array elements'
write(io,'(a)')'   * [[system_clock]]--Time function'
write(io,'(a)')'   * [[this_image]]--Cosubscript index of this image'
write(io,'(a)')'   * [[trailz]]--Number of trailing zero bits of an integer'
write(io,'(a)')'   * [[transfer]]--Transfer bit patterns'
write(io,'(a)')'   * [[transpose]]--Transpose an array of rank two'
write(io,'(a)')'   * [[trim]]--Remove trailing blank characters of a string'
write(io,'(a)')'   * [[ucobound]]--Upper codimension bounds of an array'
write(io,'(a)')'   * [[unpack]]--Store the elements of a vector in an array of higher rank'
write(io,'(a)')'   * [[verify]]--Scan a string for the absence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'INTRINSICS SECTION'
write(io,'(a)')''
write(io,'(a)')'  XXXXX  XX  XXX XXXXXXX XXXXXX   XXXXX  XX  XXX  XXXXX   XXXXX    XXXX   XXXXX'
write(io,'(a)')'    X     X   X  X  X  X  X    X    X     X   X  X     X    X     X    X X     X'
write(io,'(a)')'    X     XX  X     X     X    X    X     XX  X  X          X    X       X'
write(io,'(a)')'    X     XX  X     X     X    X    X     XX  X  X          X    X       X'
write(io,'(a)')'    X     X X X     X     XXXXX     X     X X X   XXXXX     X    X        XXXXX'
write(io,'(a)')'    X     X  XX     X     X  X      X     X  XX        X    X    X             X'
write(io,'(a)')'    X     X  XX     X     X  X      X     X  XX        X    X    X             X'
write(io,'(a)')'    X     X   X     X     X   X     X     X   X  X     X    X     X    X X     X'
write(io,'(a)')'  XXXXX  XXX  X    XXX   XXX  XX  XXXXX  XXX  X   XXXXX   XXXXX    XXXX   XXXXX'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ABS(3f) - [INTRINSIC:NUMERIC] Absolute value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = ABS(A)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   ABS(A) computes the absolute value of A.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'  A  - the type of the argument shall be an INTEGER, REAL, or'
write(io,'(a)')'       COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of the same type and kind as the argument except'
write(io,'(a)')'   the return value is REAL for a COMPLEX argument.'
write(io,'(a)')''
write(io,'(a)')'   If A is of type INTEGER or REAL, the value of the result is |A|; if A is'
write(io,'(a)')'   COMPLEX with value (X, Y), the result is equal to a processor-dependent'
write(io,'(a)')'   approximation to SQRT(X**2 + Y**2) computed without undue overflow'
write(io,'(a)')'   or underflow.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'     program test_abs'
write(io,'(a)')'     integer :: i = -1, iout'
write(io,'(a)')'     real :: x = -1.e0, xout, zout'
write(io,'(a)')'     complex :: z = (-3.e0,4.e0)'
write(io,'(a)')'        write(*,*)''INPUTS:'',i,x,z'
write(io,'(a)')'        iout = abs(i)'
write(io,'(a)')'        xout = abs(x)'
write(io,'(a)')'        zout = abs(z)'
write(io,'(a)')'        write(*,*)''OUTPUTS:'',iout,xout,zout'
write(io,'(a)')'        ! 3 - 4 -5 right triangle test :'
write(io,'(a)')'        write(*,*)''The abs() of (3.0,4.0) should be 5.0'',abs((3.0,4.0))'
write(io,'(a)')'     end program test_abs'
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    INPUTS:   -1  -1.00000000    (-3.00000000,4.00000000)'
write(io,'(a)')'    OUTPUTS:   1   1.00000000      5.00000000'
write(io,'(a)')'    The abs() of (3.0,4.0) should be 5.0   5.00000000'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ACHAR(3f) - [INTRINSIC:CHARACTER] returns a character in a specified position in the ASCII collating sequence'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = ACHAR(I [, KIND])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   ACHAR(I) returns the character located at position I in the ASCII'
write(io,'(a)')'   collating sequence.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I     - the type shall be INTEGER.'
write(io,'(a)')'   KIND  - (optional) an INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type CHARACTER with a length of one. If the'
write(io,'(a)')'   KIND argument is present, the return value is of the specified kind'
write(io,'(a)')'   and of the default kind otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_achar'
write(io,'(a)')'      character c'
write(io,'(a)')'      c = achar(32)'
write(io,'(a)')'    end program test_achar'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   see [[ichar]] for a discussion of converting between numerical'
write(io,'(a)')'   values and formatted string representations.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument Fortran 2003 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[char]], [[iachar]], [[ichar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ACOS(3f) - [INTRINSIC:TRIGONOMETRIC] Arccosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = ACOS(X)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   ACOS(X) computes the arccosine of X (inverse of cos(x)).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL with a magnitude that is'
write(io,'(a)')'        less than one.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The real part of the result is in radians and lies in the range'
write(io,'(a)')''
write(io,'(a)')'   0 <= ACOS(X) <= PI.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_acos'
write(io,'(a)')'      real(8) :: x = 0.866_8'
write(io,'(a)')'      x = acos(x)'
write(io,'(a)')'    end program test_acos'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[cos]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ACOSH(3f) - [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic cosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = acosh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ACOSH(X) computes the inverse hyperbolic cosine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - the type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has the same type and kind as X.'
write(io,'(a)')'   If X is complex, the imaginary part of the result is in radians and lies between'
write(io,'(a)')''
write(io,'(a)')'      0 <= AIMAG(ACOSH(X)) <= PI.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_acosh'
write(io,'(a)')'      real(8), dimension(3) :: x = (/ 1.0, 2.0, 3.0 /)'
write(io,'(a)')'      write (*,*) acosh(x)'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[cosh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ADJUSTL(3f) - [INTRINSIC:CHARACTER] Left adjust a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ADJUSTL(STRING)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ADJUSTL(STRING) will left adjust a string by removing leading spaces.'
write(io,'(a)')'   Spaces are inserted at the end of the string as needed.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - the type shall be CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type CHARACTER and of the same kind as'
write(io,'(a)')'   STRING where leading spaces are removed and the same number of'
write(io,'(a)')'   spaces are inserted on the end of STRING.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_adjustl'
write(io,'(a)')'      character(len=20) :: str = ''   gfortran'''
write(io,'(a)')'      str = adjustl(str)'
write(io,'(a)')'      print *, str'
write(io,'(a)')'    end program test_adjustl'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[adjustr]], [[trim]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ADJUSTR(3f) - [INTRINSIC:CHARACTER] Right adjust a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ADJUSTR(STRING)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ADJUSTR(STRING) will right adjust a string by removing trailing spaces.'
write(io,'(a)')'   Spaces are inserted at the start of the string as needed.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - the type shall be CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type CHARACTER and of the same kind as'
write(io,'(a)')'   STRING where trailing spaces are removed and the same number of'
write(io,'(a)')'   spaces are inserted at the start of STRING.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_adjustr'
write(io,'(a)')'      character(len=20) :: str = ''gfortran'''
write(io,'(a)')'      str = adjustr(str)'
write(io,'(a)')'      print *, str'
write(io,'(a)')'    end program test_adjustr'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[adjustl]], [[trim]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     AIMAG(3f) - [INTRINSIC:NUMERIC] Imaginary part of complex number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = AIMAG(Z)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   AIMAG(Z) yields the imaginary part of complex argument Z.'
write(io,'(a)')'   The IMAG(Z) and IMAGPART(Z) intrinsic functions are provided'
write(io,'(a)')'   for compatibility with G77, and their use in new code is'
write(io,'(a)')'   strongly discouraged.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   Z  - The type of the argument shall be COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL with the'
write(io,'(a)')'   kind type parameter of the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_aimag'
write(io,'(a)')'      complex(4) z4'
write(io,'(a)')'      complex(8) z8'
write(io,'(a)')'      z4 = cmplx(1.e0_4, 0.e0_4)'
write(io,'(a)')'      z8 = cmplx(0.e0_8, 1.e0_8)'
write(io,'(a)')'      print *, aimag(z4), dimag(z8)'
write(io,'(a)')'    end program test_aimag'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     AINT(3f) - [INTRINSIC:NUMERIC] Truncate to a whole number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = AINT(A [, KIND])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   AINT(A [, KIND]) truncates its argument to a whole number.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A     - the type of the argument shall be REAL.'
write(io,'(a)')'   KIND  - (optional) an INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL with the kind type parameter of the'
write(io,'(a)')'   argument if the optional KIND is absent; otherwise, the kind type'
write(io,'(a)')'   parameter will be given by KIND. If the magnitude of X is less'
write(io,'(a)')'   than one, aint(x) returns zero. If the magnitude is equal to or'
write(io,'(a)')'   greater than one then it returns the largest whole number that does'
write(io,'(a)')'   not exceed its magnitude. The sign is the same as the sign of X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_aint'
write(io,'(a)')'      real(4) x4'
write(io,'(a)')'      real(8) x8'
write(io,'(a)')'      x4 = 1.234E0_4'
write(io,'(a)')'      x8 = 4.321_8'
write(io,'(a)')'      print *, aint(x4), dint(x8)'
write(io,'(a)')'      x8 = aint(x4,8)'
write(io,'(a)')'    end program test_aint'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ALL(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] determines if all the values are true'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ALL(MASK [, DIM])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Logical conjunction of elements of MASK along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'   "ALL(MASK [, DIM])" determines if all the values are true in MASK'
write(io,'(a)')'   in the array along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - shall be a logical array. That is,'
write(io,'(a)')'           the type of the argument shall be LOGICAL and it shall'
write(io,'(a)')'           not be scalar.'
write(io,'(a)')'   DIM   - (optional) DIM shall be a scalar integer with a value'
write(io,'(a)')'           that lies between one and the rank of MASK.'
write(io,'(a)')'           The corresponding actual argument shall not be an optional'
write(io,'(a)')'           dummy argument.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   "ALL(MASK)" returns a scalar value of type LOGICAL where the kind'
write(io,'(a)')'   type parameter is the same as the kind type parameter of MASK. If'
write(io,'(a)')'   DIM is present, then ALL(MASK, DIM) returns an array with the rank'
write(io,'(a)')'   of MASK minus 1. The shape is determined from the shape of MASK'
write(io,'(a)')'   where the DIM dimension is elided.'
write(io,'(a)')''
write(io,'(a)')'    1. ALL(MASK) is true if all elements of MASK are true.'
write(io,'(a)')'       It also is true if MASK has zero size; otherwise, it is false.'
write(io,'(a)')''
write(io,'(a)')'    2. If the rank of MASK is one, then ALL(MASK, DIM) is equivalent'
write(io,'(a)')'       to ALL(MASK). If the rank is greater than one, then ALL(MASK,'
write(io,'(a)')'       DIM) is determined by applying ALL to the array sections.'
write(io,'(a)')''
write(io,'(a)')'    4. Result Characteristics. The result is of type logical with the same'
write(io,'(a)')'       kind type parameter as MASK. It is scalar'
write(io,'(a)')'       if DIM is absent or n = 1; otherwise, the result has rank n - 1 and'
write(io,'(a)')'       shape [d1 , d2 , . . . , dDIM-1 , dDIM+1 , . . . , dn ] where [d1 ,'
write(io,'(a)')'       d2 , . . . , dn ] is the shape of MASK.'
write(io,'(a)')''
write(io,'(a)')'    5. Result Value.'
write(io,'(a)')''
write(io,'(a)')'       Case (i):     The result of ALL (MASK) has the value true if all'
write(io,'(a)')'                     elements of MASK are true or if MASK has'
write(io,'(a)')'                     size zero, and the result has value false if any element'
write(io,'(a)')'                     of MASK is false.'
write(io,'(a)')''
write(io,'(a)')'       Case (ii):    If MASK has rank one, ALL(MASK,DIM) is equal to'
write(io,'(a)')'                     ALL(MASK). Otherwise, the value of element'
write(io,'(a)')'                     (s1 , s2 , . . . , sDIM-1 , sDIM+1 , . . . , sn ) of ALL'
write(io,'(a)')'                     (MASK, DIM) is equal to ALL (MASK (s1 , s2 , . . . ,'
write(io,'(a)')'                     sDIM-1 , :, sDIM+1 , . . . , sn )).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_all'
write(io,'(a)')'      logical l'
write(io,'(a)')'      l = all((/.true., .true., .true./))'
write(io,'(a)')'      print *, l'
write(io,'(a)')'      call section'
write(io,'(a)')'    contains'
write(io,'(a)')'       subroutine section'
write(io,'(a)')'          integer a(2,3), b(2,3)'
write(io,'(a)')'          a = 1'
write(io,'(a)')'          b = 1'
write(io,'(a)')'          b(2,2) = 2'
write(io,'(a)')'          print *, all(a .eq. b, 1)'
write(io,'(a)')'          print *, all(a .eq. b, 2)'
write(io,'(a)')'       end subroutine section'
write(io,'(a)')'    end program test_all'
write(io,'(a)')''
write(io,'(a)')'  Case (i):'
write(io,'(a)')''
write(io,'(a)')'     The value of ALL ([.TRUE., .FALSE., .TRUE.]) is false.'
write(io,'(a)')''
write(io,'(a)')'  Case (ii):'
write(io,'(a)')'                            1|3|5'
write(io,'(a)')'     If B is the array      -+-+-'
write(io,'(a)')'                            2|4|6'
write(io,'(a)')''
write(io,'(a)')'                            0|3|5'
write(io,'(a)')'     and C is the array     -+-+-'
write(io,'(a)')'                            7|4|8'
write(io,'(a)')''
write(io,'(a)')'     then ALL (B /= C, DIM = 1) is'
write(io,'(a)')'        [true, false, false]'
write(io,'(a)')'     and ALL (B /= C, DIM = 2) is'
write(io,'(a)')'        [false, false].'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   Transformational function.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ALLOCATED(3f) - [INTRINSIC:ARRAY INQUIRY] Status of an allocatable entity'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   * result = ALLOCATED(ARRAY)'
write(io,'(a)')'   * result = ALLOCATED(SCALAR)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ALLOCATED(ARRAY) and ALLOCATED(SCALAR) check the allocation status of'
write(io,'(a)')'   ARRAY and SCALAR, respectively.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY   - the argument shall be an ALLOCATABLE array.'
write(io,'(a)')'   SCALAR  - the argument shall be an ALLOCATABLE scalar.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a scalar LOGICAL with the default logical'
write(io,'(a)')'   kind type parameter. If the argument is allocated then the result'
write(io,'(a)')'   is .true.; otherwise, it returns .false..'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_allocated'
write(io,'(a)')'      integer :: i = 4'
write(io,'(a)')'      real(4), allocatable :: x(:)'
write(io,'(a)')'      if (allocated(x) .eqv. .false.) allocate(x(i))'
write(io,'(a)')'    end program test_allocated'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later. Note, the scalar= keyword and allocatable'
write(io,'(a)')'   scalar entities are available in Fortran 2003 and later.'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[move_alloc]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     anint(3f) - [INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = anint(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   anint(a [, kind]) rounds its argument to the nearest whole number.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A     - the type of the argument shall be REAL.'
write(io,'(a)')'   KIND  - (optional) an INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type real with the kind type parameter of the'
write(io,'(a)')'   argument if the optional KIND is absent; otherwise, the kind type'
write(io,'(a)')'   parameter will be given by KIND. If A is greater than zero,'
write(io,'(a)')'   anint(a) returns aint(x + 0.5). If A is less than or equal to'
write(io,'(a)')'   zero then it returns aint(x - 0.5).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_anint'
write(io,'(a)')'      real(4) x4'
write(io,'(a)')'      real(8) x8'
write(io,'(a)')'      x4 = 1.234E0_4'
write(io,'(a)')'      x8 = 4.321_8'
write(io,'(a)')'      print *, anint(x4), dnint(x8)'
write(io,'(a)')'      x8 = anint(x4,8)'
write(io,'(a)')'    end program test_anint'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     any(3f) - [INTRINSIC] determines if any of the values in the logical array are true.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = any(mask [, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ANY(MASK [, DIM]) determines if any of the values in the logical'
write(io,'(a)')'   array MASK along dimension DIM are .TRUE..'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - the type of the argument shall be LOGICAL and'
write(io,'(a)')'           it shall not be scalar.'
write(io,'(a)')'   DIM   - (optional) DIM shall be a scalar integer with a value'
write(io,'(a)')'           that lies between one and the rank of MASK.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   ANY(MASK) returns a scalar value of type LOGICAL where the kind'
write(io,'(a)')'   type parameter is the same as the kind type parameter of MASK. If'
write(io,'(a)')'   DIM is present, then ANY(MASK, DIM) returns an array with the rank'
write(io,'(a)')'   of MASK minus 1. The shape is determined from the shape of MASK'
write(io,'(a)')'   where the DIM dimension is elided.'
write(io,'(a)')''
write(io,'(a)')'1. ANY(MASK) is true if any element of MASK is true; otherwise, it'
write(io,'(a)')'   is false. It also is false if MASK has zero size.'
write(io,'(a)')''
write(io,'(a)')'2. If the rank of MASK is one, then ANY(MASK, DIM) is equivalent'
write(io,'(a)')'   to ANY(MASK). If the rank is greater than one, then ANY(MASK,'
write(io,'(a)')'   DIM) is determined by applying ANY to the array sections.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_any'
write(io,'(a)')'      logical l'
write(io,'(a)')'      l = any((/.true., .true., .true./))'
write(io,'(a)')'      print *, l'
write(io,'(a)')'      call section'
write(io,'(a)')'      contains'
write(io,'(a)')'        subroutine section'
write(io,'(a)')'          integer a(2,3), b(2,3)'
write(io,'(a)')'          a = 1'
write(io,'(a)')'          b = 1'
write(io,'(a)')'          b(2,2) = 2'
write(io,'(a)')'          print *, any(a .eq. b, 1)'
write(io,'(a)')'          print *, any(a .eq. b, 2)'
write(io,'(a)')'        end subroutine section'
write(io,'(a)')'    end program test_any'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     asin(3f) - [INTRINSIC:TRIGONOMETRIC] Arcsine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = asin(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   asin(x) computes the arcsine of its X (inverse of sin(x)).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be either REAL and a magnitude that is less'
write(io,'(a)')'        than or equal to one or be COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The real part of the result is in radians and lies in the'
write(io,'(a)')'   range -PI/2 <= asin(x) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_asin'
write(io,'(a)')'      real(8) :: x = 0.866_8'
write(io,'(a)')'      x = asin(x)'
write(io,'(a)')'    end program test_asin'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   Inverse function: [[sin]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     asinh(3f) - [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic sine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = asinh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   asinh(x) computes the inverse hyperbolic sine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X. If X is complex,'
write(io,'(a)')'   the imaginary part of the result is in radians and lies between -PI/2'
write(io,'(a)')'   <= AIMAG(ASINH(X)) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_asinh'
write(io,'(a)')'     real(8), dimension(3) :: x = (/ -1.0, 0.0, 1.0 /)'
write(io,'(a)')'     write (*,*) asinh(x)'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[sinh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     associated(3f) - [INTRINSIC] Status of a pointer or pointer/target pair'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = associated(pointer [, target])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   associated(pointer [, target]) determines the status of the pointer'
write(io,'(a)')'   POINTER or if POINTER is associated with the target TARGET.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   POINTER  - POINTER shall have the POINTER attribute'
write(io,'(a)')'              and it can be of any type.'
write(io,'(a)')'   TARGET   - (Optional) TARGET shall be a pointer or'
write(io,'(a)')'              a target. It must have the same type, kind type parameter, and'
write(io,'(a)')'              array rank as POINTER.'
write(io,'(a)')''
write(io,'(a)')'   The association status of neither POINTER nor TARGET shall be'
write(io,'(a)')'   undefined.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   associated(pointer) returns a scalar value of type logical(4).'
write(io,'(a)')'   There are several cases:'
write(io,'(a)')''
write(io,'(a)')' 1. When the optional TARGET is not present then'
write(io,'(a)')'    associated(pointer) is true if POINTER is associated with a'
write(io,'(a)')'    target; otherwise, it returns false.'
write(io,'(a)')''
write(io,'(a)')' 2. If TARGET is present and a scalar target, the result is true if'
write(io,'(a)')'    TARGET is not a zero-sized storage sequence and the target'
write(io,'(a)')'    associated with POINTER occupies the same storage units. If'
write(io,'(a)')'    POINTER is disassociated, the result is false.'
write(io,'(a)')''
write(io,'(a)')' 3. If TARGET is present and an array target, the result is true if'
write(io,'(a)')'    TARGET and POINTER have the same shape, are not zero-sized'
write(io,'(a)')'    arrays, are arrays whose elements are not zero-sized storage'
write(io,'(a)')'    sequences, and TARGET and POINTER occupy the same storage'
write(io,'(a)')'    units in array element order.'
write(io,'(a)')''
write(io,'(a)')'    As in case 2, the result is false, if POINTER is disassociated.'
write(io,'(a)')''
write(io,'(a)')' 4. If TARGET is present and an scalar pointer, the result is true'
write(io,'(a)')'    if TARGET is associated with POINTER, the target associated'
write(io,'(a)')'    with TARGET are not zero-sized storage sequences and occupy the'
write(io,'(a)')'    same storage units.'
write(io,'(a)')''
write(io,'(a)')'    The result is false, if either TARGET or POINTER is'
write(io,'(a)')'    disassociated.'
write(io,'(a)')''
write(io,'(a)')' 5. If TARGET is present and an array pointer, the result is true if'
write(io,'(a)')'    target associated with POINTER and the target associated with'
write(io,'(a)')'    TARGET have the same shape, are not zero-sized arrays, are'
write(io,'(a)')'    arrays whose elements are not zero-sized storage sequences, and'
write(io,'(a)')'    TARGET and POINTER occupy the same storage units in array'
write(io,'(a)')'    element order. The result is false, if either TARGET or'
write(io,'(a)')'    POINTER is disassociated.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_associated'
write(io,'(a)')'       implicit none'
write(io,'(a)')'       real, target  :: tgt(2) = (/1., 2./)'
write(io,'(a)')'       real, pointer :: ptr(:)'
write(io,'(a)')'       ptr => tgt'
write(io,'(a)')'       if (associated(ptr)     .eqv. .false.) call abort'
write(io,'(a)')'       if (associated(ptr,tgt) .eqv. .false.) call abort'
write(io,'(a)')'    end program test_associated'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[null]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atan(3f) - [INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   * result = atan(x)'
write(io,'(a)')'   * result = atan(y, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atan(x) computes the arctangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL or COMPLEX; if Y is present, X'
write(io,'(a)')'       shall be REAL.'
write(io,'(a)')'  Y  - Shall be of the same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   If Y is present, the result is identical to atan2(y,x).'
write(io,'(a)')'   Otherwise, it the arcus tangent of X, where the real part of'
write(io,'(a)')'   the result is in radians and lies in the range'
write(io,'(a)')''
write(io,'(a)')'   -PI/2 <= atan(x) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_atan'
write(io,'(a)')'     real(8) :: x = 2.866_8'
write(io,'(a)')'     x = atan(x)'
write(io,'(a)')'   end program test_atan'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later; for a complex argument and for two arguments [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atan2]], [[tan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atan2(3f) - [INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = atan2(y, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atan2(y, x) computes the arctangent of the complex number'
write(io,'(a)')''
write(io,'(a)')'      X + i Y.'
write(io,'(a)')''
write(io,'(a)')'   This function can be used to transform from Cartesian into polar'
write(io,'(a)')'   coordinates and allows to determine the angle in the correct quadrant.'
write(io,'(a)')'   To convert from Cartesian Coordinates (x,y) to polar coordinates'
write(io,'(a)')''
write(io,'(a)')'   (r,theta):'
write(io,'(a)')'   $$'
write(io,'(a)')'   \begin{aligned}'
write(io,'(a)')'   r &= \sqrt{x**2 + y**2} \\'
write(io,'(a)')'   \theta &= \tan**{-1}(y / x)'
write(io,'(a)')'   \end{aligned}'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   Y  - The type shall be REAL.'
write(io,'(a)')'   X  - The type and kind type parameter shall be the same as Y.'
write(io,'(a)')'If Y is zero, then X must be nonzero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has the same type and kind type parameter as Y.'
write(io,'(a)')'   It is the principal value of the complex number (X + i, Y). If'
write(io,'(a)')'   X is nonzero, then it lies in the range -PI <= atan(x) <= PI.'
write(io,'(a)')'   The sign is positive if Y is positive. If Y is zero, then'
write(io,'(a)')'   the return value is zero if X is strictly positive, PI if'
write(io,'(a)')'   X is negative and Y is positive zero (or the processor does'
write(io,'(a)')'   not handle signed zeros), and -PI if X is negative and'
write(io,'(a)')'   Y is negative zero. Finally, if X is zero, then the'
write(io,'(a)')'   magnitude of the result is PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_atan2'
write(io,'(a)')'     real(4) :: x = 1.e0_4, y = 0.5e0_4'
write(io,'(a)')'     x = atan2(y,x)'
write(io,'(a)')'   end program test_atan2'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atanh(3f) - [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic tangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = atanh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atanh(x) computes the inverse hyperbolic tangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X. If X is'
write(io,'(a)')'   complex, the imaginary part of the result is in radians and lies between'
write(io,'(a)')''
write(io,'(a)')'   -PI/2 <= AIMAG(ATANH(X)) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_atanh'
write(io,'(a)')'      real, dimension(3) :: x = (/ -1.0, 0.0, 1.0 /)'
write(io,'(a)')'      write (*,*) atanh(x)'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[tanh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_add(3f) - [INTRINSIC] Atomic ADD operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_add (atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_add(atom, value) atomically adds the value of VAR to the'
write(io,'(a)')'   variable ATOM. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'  type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'  is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_add (atom[1], this_image())'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_add]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_and]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_and(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_and(atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_and(atom, value) atomically defines ATOM with the bitwise'
write(io,'(a)')'   AND between the values of ATOM and VALUE. When STAT is present'
write(io,'(a)')'   and the invocation was successful, it is assigned the value 0. If it'
write(io,'(a)')'   is present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT  - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_and(atom[1], int(b''10100011101''))'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_and]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_cas(3f) - [INTRINSIC] Atomic compare and swap'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_cas (atom, old, compare, new [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_cas compares the variable ATOM with the value of COMPARE;'
write(io,'(a)')'   if the value is the same, ATOM is set to the value of'
write(io,'(a)')'   NEW. Additionally, OLD is set to the value of ATOM that was used'
write(io,'(a)')'   for the comparison. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM     - Scalar coarray or coindexed variable of either integer type'
write(io,'(a)')'             with atomic_int_kind kind or logical type with'
write(io,'(a)')'             atomic_logical_kind kind.'
write(io,'(a)')'  OLD      - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  COMPARE  - Scalar variable of the same type and kind as ATOM.'
write(io,'(a)')'  NEW      - Scalar variable of the same type as ATOM. If kind is'
write(io,'(a)')'             different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT     - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     logical(atomic_logical_kind) :: atom[*], prev'
write(io,'(a)')'     call atomic_cas(atom[1], prev, .false., .true.))'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_ref]], [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_define(3f) - [INTRINSIC] Setting a variable atomically'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_define (atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_define(atom, value) defines the variable ATOM with the'
write(io,'(a)')'   value VALUE atomically. When STAT is present and the invocation'
write(io,'(a)')'   was successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of either integer type'
write(io,'(a)')'           with atomic_int_kind kind or logical type with'
write(io,'(a)')'           atomic_logical_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_define(atom[1], this_image())'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later; with STAT, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_ref]], [[atomic_cas]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_and]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_add(3f) - [INTRINSIC] Atomic ADD operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_add(atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_add(atom, value, old) atomically stores the value of'
write(io,'(a)')'   ATOM in OLD and adds the value of VAR to the variable'
write(io,'(a)')'   ATOM. When STAT is present and the invocation was successful, it'
write(io,'(a)')'   is assigned the value 0. If it is present and the invocation has'
write(io,'(a)')'   failed, it is assigned a positive value; in particular, for a'
write(io,'(a)')'   coindexed ATOM, if the remote image has stopped, it is assigned the'
write(io,'(a)')'   value of iso_fortran_env''s stat_stopped_image and if the remote'
write(io,'(a)')'   image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind. atomic_logical_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_add(atom[1], this_image(), old)'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_add]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_and]], [[atomic_fetch_or]], [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_and(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_and(atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_and(atom, value, old) atomically stores the value of'
write(io,'(a)')'   ATOM in OLD and defines ATOM with the bitwise AND between the'
write(io,'(a)')'   values of ATOM and VALUE. When STAT is present and the'
write(io,'(a)')'   invocation was successful, it is assigned the value 0. If it is'
write(io,'(a)')'   present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_fetch_and (atom[1], int(b''10100011101''), old)'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_and]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_or]], [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_or(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_or(atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_or(atom, value, old) atomically stores the value of ATOM in'
write(io,'(a)')'   OLD and defines ATOM with the bitwise OR between the values of'
write(io,'(a)')'   ATOM and VALUE. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the invocation has'
write(io,'(a)')'   failed, it is assigned a positive value; in particular, for a coindexed'
write(io,'(a)')'   ATOM, if the remote image has stopped, it is assigned the value of'
write(io,'(a)')'   iso_fortran_env''s stat_stopped_image and if the remote image has'
write(io,'(a)')'   failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'           type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_fetch_or(atom[1], int(b''10100011101''), old)'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_or]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_and]], [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_xor(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise XOR operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_xor (atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_xor(atom, value, old) atomically stores the value of'
write(io,'(a)')'   ATOM in OLD and defines ATOM with the bitwise XOR between the'
write(io,'(a)')'   values of ATOM and VALUE. When STAT is present and the'
write(io,'(a)')'   invocation was successful, it is assigned the value 0. If it is'
write(io,'(a)')'   present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'           type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_fetch_xor (atom[1], int(b''10100011101''), old)'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_xor]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_and]], [[atomic_fetch_or]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_or(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_or(atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_or(atom, value) atomically defines ATOM with the bitwise'
write(io,'(a)')'   OR between the values of ATOM and VALUE. When STAT is present'
write(io,'(a)')'   and the invocation was successful, it is assigned the value 0. If it'
write(io,'(a)')'   is present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'           type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_or(atom[1], int(b''10100011101''))'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_or]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_ref(3f) - [INTRINSIC] Obtaining the value of a variable atomically'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_ref(value, atom [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_ref(atom, value) atomically assigns the value of the variable'
write(io,'(a)')'   ATOM to VALUE. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of either integer type'
write(io,'(a)')'          with atomic_int_kind kind or logical type with'
write(io,'(a)')'          atomic_logical_kind kind.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     logical(atomic_logical_kind) :: atom[*]'
write(io,'(a)')'     logical :: val'
write(io,'(a)')'     call atomic_ref(atom, .false.)'
write(io,'(a)')'     ! ...'
write(io,'(a)')'     call atomic_ref(atom, val)'
write(io,'(a)')'     if (val) then'
write(io,'(a)')'       print *, "Obtained"'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later; with STAT, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_cas]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_and]], [[atomic_fetch_or]],'
write(io,'(a)')'   [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_xor(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_xor(atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_xor(atom, value) atomically defines ATOM with the bitwise'
write(io,'(a)')'   XOR between the values of ATOM and VALUE. When STAT is present'
write(io,'(a)')'   and the invocation was successful, it is assigned the value 0. If it'
write(io,'(a)')'   is present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_xor(atom[1], int(b''10100011101''))'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_xor]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_j0(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 0'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_j0(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_j0(x) computes the [[Bessel function]] of the first kind of'
write(io,'(a)')'   order 0 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and lies in the range -0.4027 <= Bessel(0,x) <= 1.'
write(io,'(a)')'   It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_besj0'
write(io,'(a)')'     real(8) :: x = 0.0_8'
write(io,'(a)')'     x = bessel_j0(x)'
write(io,'(a)')'   end program test_besj0'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j1]], [[bessel_jn]], [[bessel_y0]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_j1(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 1'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_j1(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_j1(x) computes the [[Bessel function]] of the first kind of'
write(io,'(a)')'   order 1 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and lies in the'
write(io,'(a)')'   range -0.5818 <= Bessel(0,x) <= 0.5818 . It has the same'
write(io,'(a)')'   kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_besj1'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_j1(x)'
write(io,'(a)')'   end program test_besj1'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_jn]], [[bessel_y0]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_jn(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the first kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = bessel_jn(n, x)'
write(io,'(a)')'* result = bessel_jn(n1, n2, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_jn(n, x) computes the [[Bessel function]] of the first kind of'
write(io,'(a)')'   order N of X.'
write(io,'(a)')'   If N and X are arrays, their ranks and shapes shall conform.'
write(io,'(a)')''
write(io,'(a)')'   bessel_jn(n1, n2, x) returns an array with the [[Bessel function|Bessel'
write(io,'(a)')'   functions]] of the first kind of the orders N1 to N2.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   N  - Shall be a scalar or an array of type INTEGER.'
write(io,'(a)')'   N1  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'   N2  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'   X  - Shall be a scalar or an array of type REAL. For bessel_jn(n1, n2, x) it shall be scalar.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is a scalar of type REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_besjn'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_jn(5,x)'
write(io,'(a)')'   end program test_besjn'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]], except for the transformational variant bessel_jn(n1, n2, x).'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_y0]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_y0(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 0'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_y0(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_y0(x) computes the [[Bessel function]] of the second kind of'
write(io,'(a)')'   order 0 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_besy0'
write(io,'(a)')'     real(8) :: x = 0.0_8'
write(io,'(a)')'     x = bessel_y0(x)'
write(io,'(a)')'   end program test_besy0'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_jn]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_y1(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 1'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_y1(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_y1(x) computes the [[Bessel function]] of the second kind of'
write(io,'(a)')'   order 1 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_besy1'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_y1(x)'
write(io,'(a)')'   end program test_besy1'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_jn]], [[bessel_y0]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_yn(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the second kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = bessel_yn(n, x)'
write(io,'(a)')'* result = bessel_yn(n1, n2, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_yn(n, x) computes the [[Bessel function]] of the second kind'
write(io,'(a)')'   of order N of X. If N and X are arrays, their ranks and'
write(io,'(a)')'   shapes shall conform.'
write(io,'(a)')''
write(io,'(a)')'   bessel_yn(n1, n2, x) returns an array with the'
write(io,'(a)')'   [[Bessel function|Bessel functions]] of the first kind of the orders'
write(io,'(a)')'   N1 to N2.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  N   - Shall be a scalar or an array of type INTEGER.'
write(io,'(a)')'  N1  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'  N2  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'  X   - Shall be a scalar or an array of type REAL;'
write(io,'(a)')'        for bessel_yn(n1, n2, x) it shall be scalar.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_besyn'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_yn(5,x)'
write(io,'(a)')'   end program test_besyn'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]], except for the transformational function bessel_yn(n1, n2, x)'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_jn]], [[bessel_y0]], [[bessel_y1]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bge(3f) - [INTRINSIC:BIT COMPARE] Bitwise greater than or equal to'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is a bitwise greater than or equal to another.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bge(i, j)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of INTEGER type.'
write(io,'(a)')'   J  - Shall be of INTEGER type, and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bgt]], [[ble]], [[blt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bgt(3f) - [INTRINSIC:BIT COMPARE] Bitwise greater than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bgt(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is bitwise greater than another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of INTEGER type.'
write(io,'(a)')'  J  - Shall be of INTEGER type, and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bge]], [[ble]], [[blt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bit_size(3f) - [INTRINSIC:BIT INQUIRY] Bit size inquiry function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bit_size(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bit_size(i) returns the number of bits (integer precision plus sign bit)'
write(io,'(a)')'   represented by the type of I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type INTEGER'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_bit_size'
write(io,'(a)')'        integer :: i = 123'
write(io,'(a)')'        integer :: size'
write(io,'(a)')'        size = bit_size(i)'
write(io,'(a)')'        print *, size'
write(io,'(a)')'    end program test_bit_size'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ble(3f) - [INTRINSIC:BIT COMPARE] Bitwise less than or equal to'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is bitwise less than or equal to another.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ble(i, j)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of INTEGER type.'
write(io,'(a)')'  J  - Shall be of INTEGER type, and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bge]], [[bgt]], [[blt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     blt(3f) - [INTRINSIC:BIT COMPARE] Bitwise less than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = blt(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is bitwise less than another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of INTEGER type.'
write(io,'(a)')'  J  - Shall be of INTEGER type, and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bge]], [[bgt]], [[ble]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     btest(3f) - [INTRINSIC:BIT MANIPULATION] Bit test function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = btest(i, pos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   btest(i,pos) returns logical .true. if the bit at POS'
write(io,'(a)')'   in I is set.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER. A value of zero refers to the least significant bit.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type LOGICAL'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_btest'
write(io,'(a)')'        integer :: i = 32768 + 1024 + 64'
write(io,'(a)')'        integer :: pos'
write(io,'(a)')'        logical :: bool'
write(io,'(a)')'        do pos=0,16'
write(io,'(a)')'            bool = btest(i, pos)'
write(io,'(a)')'            print *, pos, bool'
write(io,'(a)')'        end do'
write(io,'(a)')'    end program test_btest'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ibclr]], [[ibits]], [[ibset]], [[iand]], [[ior]], [[ieor]],'
write(io,'(a)')'   [[mvbits]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_associated(3f) - [INTRINSIC:ISO_C_BINDING] Status of a C pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = c_associated(c_prt_1[, c_ptr_2])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_associated(c_prt_1[, c_ptr_2]) determines the status of the C pointer'
write(io,'(a)')'   c_ptr_1 or if c_ptr_1 is associated with the target c_ptr_2.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   c_ptr_1  - Scalar of the type c_ptr or c_funptr.'
write(io,'(a)')'   c_ptr_2  - (Optional) Scalar of the same type as c_ptr_1.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type LOGICAL; it is .false. if either'
write(io,'(a)')'   c_ptr_1 is a C NULL pointer or if c_ptr1 and c_ptr_2'
write(io,'(a)')'   point to different addresses.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    subroutine association_test(a,b)'
write(io,'(a)')'      use iso_c_binding, only: c_associated, c_loc, c_ptr'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      real, pointer :: a'
write(io,'(a)')'      type(c_ptr) :: b'
write(io,'(a)')'      if(c_associated(b, c_loc(a))) &'
write(io,'(a)')'         stop ''b and a do not point to same target'''
write(io,'(a)')'    end subroutine association_test'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_loc]], [[c_funloc]], [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_f_pointer(3f) - [INTRINSIC:ISO_C_BINDING] Convert C into Fortran pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    call c_f_pointer(cptr, fptr[, shape])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_f_pointer(cptr, fptr[, shape]) Assign the target, the C pointer,'
write(io,'(a)')'   CPTR to the Fortran pointer FPTR and specify its'
write(io,'(a)')'   shape.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   CPTR  - scalar of the type c_ptr. It is'
write(io,'(a)')'           intent(in).'
write(io,'(a)')'   FPTR  - pointer interoperable with CPTR. It is'
write(io,'(a)')'           intent(out).'
write(io,'(a)')'   SHAPE  - (Optional) Rank-one array of type INTEGER'
write(io,'(a)')'            with intent(in). It shall be present'
write(io,'(a)')'            if and only if FPTR is an array. The size'
write(io,'(a)')'            must be equal to the rank of FPTR.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program main'
write(io,'(a)')'      use iso_c_binding'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      interface'
write(io,'(a)')'        subroutine my_routine(p) bind(c,name=''myC_func'')'
write(io,'(a)')'          import :: c_ptr'
write(io,'(a)')'          type(c_ptr), intent(out) :: p'
write(io,'(a)')'        end subroutine'
write(io,'(a)')'      end interface'
write(io,'(a)')'      type(c_ptr) :: cptr'
write(io,'(a)')'      real,pointer :: a(:)'
write(io,'(a)')'      call my_routine(cptr)'
write(io,'(a)')'      call c_f_pointer(cptr, a, [12])'
write(io,'(a)')'    end program main'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_loc]], [[c_f_procpointer]], [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_f_procpointer(3f) - [INTRINSIC:ISO_C_BINDING] Convert C into Fortran procedure pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call c_f_procpointer(cptr, fptr)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_f_procpointer(cptr, fptr) assigns the target of the C'
write(io,'(a)')'   function pointer CPTR to the Fortran procedure pointer'
write(io,'(a)')'   FPTR.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  CPTR  - scalar of the type c_funptr.'
write(io,'(a)')'          It is intent(in).'
write(io,'(a)')'  FPTR  - procedure pointer interoperable with CPTR.'
write(io,'(a)')'          It is intent(out).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program main'
write(io,'(a)')'      use iso_c_binding'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      abstract interface'
write(io,'(a)')'        function func(a)'
write(io,'(a)')'          import :: c_float'
write(io,'(a)')'          real(c_float), intent(in) :: a'
write(io,'(a)')'          real(c_float) :: func'
write(io,'(a)')'        end function'
write(io,'(a)')'      end interface'
write(io,'(a)')'      interface'
write(io,'(a)')'         function getIterFunc() bind(c,name="getIterFunc")'
write(io,'(a)')'           import :: c_funptr'
write(io,'(a)')'           type(c_funptr) :: getIterFunc'
write(io,'(a)')'         end function'
write(io,'(a)')'      end interface'
write(io,'(a)')'      type(c_funptr) :: cfunptr'
write(io,'(a)')'      procedure(func), pointer :: myFunc'
write(io,'(a)')'      cfunptr = getIterFunc()'
write(io,'(a)')'      call c_f_procpointer(cfunptr, myFunc)'
write(io,'(a)')'    end program main'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_loc]], [[c_f_pointer]], [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_funloc(3f) - [INTRINSIC:ISO_C_BINDING] Obtain the C address of a procedure'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = c_funloc(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_funloc(x) determines the C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Interoperable function or pointer to such function.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type c_funptr and contains the C address'
write(io,'(a)')'   of the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    module x'
write(io,'(a)')'      use iso_c_binding'
write(io,'(a)')'      implicit none'
write(io,'(a)')'    contains'
write(io,'(a)')'      subroutine sub(a) bind(c)'
write(io,'(a)')'        real(c_float) :: a'
write(io,'(a)')'        a = sqrt(a)+5.0'
write(io,'(a)')'      end subroutine sub'
write(io,'(a)')'    end module x'
write(io,'(a)')''
write(io,'(a)')'    program main'
write(io,'(a)')'      use iso_c_binding'
write(io,'(a)')'      use x'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      interface'
write(io,'(a)')'        subroutine my_routine(p) bind(c,name=''myC_func'')'
write(io,'(a)')'          import :: c_funptr'
write(io,'(a)')'          type(c_funptr), intent(in) :: p'
write(io,'(a)')'        end subroutine'
write(io,'(a)')'      end interface'
write(io,'(a)')'      call my_routine(c_funloc(sub))'
write(io,'(a)')'    end program main'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_associated]], [[c_loc]],'
write(io,'(a)')'   [[c_f_pointer]], [[c_f_procpointer]],'
write(io,'(a)')'   [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_loc(3f) - [INTRINSIC:ISO_C_BINDING] Obtain the C address of an object'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = c_loc(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_loc(x) determines the C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall have either the POINTER or TARGET attribute. It'
write(io,'(a)')'         shall not be a coindexed object. It shall either be a variable'
write(io,'(a)')'         with interoperable type and kind type parameters, or be a scalar,'
write(io,'(a)')'         nonpolymorphic variable with no length type parameters.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type c_ptr and contains the C address'
write(io,'(a)')'   of the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   subroutine association_test(a,b)'
write(io,'(a)')'     use iso_c_binding, only: c_associated, c_loc, c_ptr'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     real, pointer :: a'
write(io,'(a)')'     type(c_ptr) :: b'
write(io,'(a)')'     if(c_associated(b, c_loc(a))) &'
write(io,'(a)')'        stop ''b and a do not point to same target'''
write(io,'(a)')'   end subroutine association_test'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_associated]], [[c_funloc]],'
write(io,'(a)')'   [[c_f_pointer]], [[c_f_procpointer]],'
write(io,'(a)')'   [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_sizeof(3f) - [INTRINSIC:ISO_C_BINDING] Size in bytes of an expression'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'n = c_sizeof(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_sizeof(x) calculates the number of bytes of storage the'
write(io,'(a)')'   expression X occupies.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The argument shall be an interoperable data entity.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer and of the system-dependent kind'
write(io,'(a)')'   c_size_t (from the [[iso_c_binding]] module). Its value is the'
write(io,'(a)')'   number of bytes occupied by the argument. If the argument has the'
write(io,'(a)')'   POINTER attribute, the number of bytes of the storage area pointed'
write(io,'(a)')'   to is returned. If the argument is of a derived type with POINTER'
write(io,'(a)')'   or ALLOCATABLE components, the return value does not account for'
write(io,'(a)')'   the sizes of the data pointed to by these components.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   use iso_c_binding'
write(io,'(a)')'   integer(c_int) :: i'
write(io,'(a)')'   real(c_float) :: r, s(5)'
write(io,'(a)')'   print *, (c_sizeof(s)/c_sizeof(r) == 5)'
write(io,'(a)')'   end'
write(io,'(a)')''
write(io,'(a)')'   The example will print .true. unless you are using a platform'
write(io,'(a)')'   where default REAL variables are unusually padded.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Intrinsic function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[storage_size]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ceiling(3f) - [INTRINSIC:NUMERIC] Integer ceiling function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ceiling(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ceiling(a) returns the least integer greater than or equal to A.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer(kind) if KIND is present'
write(io,'(a)')'   and a default-kind INTEGER otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_ceiling'
write(io,'(a)')'        real :: x = 63.29'
write(io,'(a)')'        real :: y = -63.59'
write(io,'(a)')'        print *, ceiling(x) ! returns 64'
write(io,'(a)')'        print *, ceiling(y) ! returns -63'
write(io,'(a)')'    end program test_ceiling'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[floor]], [[nint]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     char(3f) - [INTRINSIC:CHARACTER] Character conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = char(i [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   char(i [, kind]) returns the character represented by the integer I.'
write(io,'(a)')'   ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type character(1)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_char'
write(io,'(a)')'        integer :: i = 74'
write(io,'(a)')'        character(1) :: c'
write(io,'(a)')'        c = char(i)'
write(io,'(a)')'        print *, i, c ! returns ''J'''
write(io,'(a)')'    end program test_char'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   See [[ichar]] for a discussion of converting between numerical values'
write(io,'(a)')'   and formatted string representations.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[achar]], [[iachar]], [[ichar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cmplx(3f) - [INTRINSIC:NUMERIC] Complex conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = cmplx(x [, y [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cmplx(x [, y [, kind]]) returns a complex number where X is converted to'
write(io,'(a)')'   the real component. If Y is present it is converted to the imaginary'
write(io,'(a)')'   component. If Y is not present then the imaginary component is set to'
write(io,'(a)')'   0.0. If X is complex then Y must not be present.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X     - The type may be INTEGER, REAL, or COMPLEX.'
write(io,'(a)')'   Y     - (Optional; only allowed if X is not COMPLEX.).'
write(io,'(a)')'           May be INTEGER or REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of COMPLEX type, with a kind equal to'
write(io,'(a)')'   KIND if it is specified. If KIND is not specified, the'
write(io,'(a)')'   result is of the default COMPLEX kind, regardless of the kinds of'
write(io,'(a)')'   X and Y.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_cmplx'
write(io,'(a)')'        integer :: i = 42'
write(io,'(a)')'        real :: x = 3.14'
write(io,'(a)')'        complex :: z'
write(io,'(a)')'        z = cmplx(i, x)'
write(io,'(a)')'        print *, z, cmplx(x)'
write(io,'(a)')'    end program test_cmplx'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_broadcast(3f) - [INTRINSIC] Copy a value to all images the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_broadcast(A, SOURCE_IMAGE [, STAT, ERRMSG])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_broadcast copies the value of argument A on the image with'
write(io,'(a)')'   image index source_image to all images in the current team. A'
write(io,'(a)')'   becomes defined as if by intrinsic assignment. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If the'
write(io,'(a)')'   execution failed, STAT gets assigned a nonzero value and, if present,'
write(io,'(a)')'   ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - intent(inout) argument; shall have the same dynamic type and'
write(io,'(a)')'       type parameters on all images of the current team. If it is an array,'
write(io,'(a)')'       it shall have the same shape on all images.'
write(io,'(a)')''
write(io,'(a)')'  SOURCE_IMAGE  - a scalar integer expression. It shall have the'
write(io,'(a)')'                  same the same value on all images and refer to an image of the'
write(io,'(a)')'                  current team.'
write(io,'(a)')''
write(io,'(a)')'   STAT  - (optional) a scalar integer variable'
write(io,'(a)')''
write(io,'(a)')'   ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test'
write(io,'(a)')'     integer :: val(3)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       val = [1, 5, 3]'
write(io,'(a)')'     end if'
write(io,'(a)')'     call co_broadcast (val, source_image=1)'
write(io,'(a)')'     print *, this_image, ":", val'
write(io,'(a)')'   end program test'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_max]], [[co_min]], [[co_sum]], [[co_reduce]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_max(3f) - [INTRINSIC] Maximal value on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_max(a [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_max determines element-wise the maximal value of A on all'
write(io,'(a)')'   images of the current team. If result_image is present, the maximum'
write(io,'(a)')'   values are returned in A on the specified image only and the value'
write(io,'(a)')'   of A on the other images become undefined. If result_image is not'
write(io,'(a)')'   present, the value is returned on all images. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If'
write(io,'(a)')'   the execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - shall be an integer, real or character variable, which has the'
write(io,'(a)')'       same type and type parameters on all images of the team.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'                  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'                  image of the current team.'
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_max(val, result_image=1)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "Maximal value", val  ! prints num_images()'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program test'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_min]], [[co_sum]], [[co_reduce]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_min(3f) - [INTRINSIC] Minimal value on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call co_min(a [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_min determines element-wise the minimal value of A on all'
write(io,'(a)')'   images of the current team. If result_image is present, the minimal'
write(io,'(a)')'   values are returned in A on the specified image only and the value'
write(io,'(a)')'   of A on the other images become undefined. If result_image is not'
write(io,'(a)')'   present, the value is returned on all images. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If'
write(io,'(a)')'   the execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - shall be an integer, real or character variable, which has the'
write(io,'(a)')'       same type and type parameters on all images of the team.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'                  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'                  image of the current team.'
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_min(val, result_image=1)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "Minimal value", val  ! prints 1'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program test'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_max]], [[co_sum]], [[co_reduce]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_reduce(3f) - [INTRINSIC] Reduction of values on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_reduce(a, operator, [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_reduce determines element-wise the reduction of the value of A'
write(io,'(a)')'   on all images of the current team. The pure function passed as'
write(io,'(a)')'   OPERATOR is used to pairwise reduce the values of A by passing'
write(io,'(a)')'   either the value of A of different images or the result values of'
write(io,'(a)')'   such a reduction as argument. If A is an array, the deduction is'
write(io,'(a)')'   done element wise. If result_image is present, the result values are'
write(io,'(a)')'   returned in A on the specified image only and the value of A on'
write(io,'(a)')'   the other images become undefined. If result_image is not present,'
write(io,'(a)')'   the value is returned on all images. If the execution was successful'
write(io,'(a)')'   and STAT is present, it is assigned the value zero. If the'
write(io,'(a)')'   execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - is an intent(inout) argument and shall be nonpolymorphic. If'
write(io,'(a)')'  it is allocatable, it shall be allocated; if it is a pointer, it'
write(io,'(a)')'  shall be associated. A shall have the same type and type'
write(io,'(a)')'  parameters on all images of the team; if it is an array, it shall'
write(io,'(a)')'  have the same shape on all images.'
write(io,'(a)')''
write(io,'(a)')'  OPERATOR  - pure function with two scalar nonallocatable arguments,'
write(io,'(a)')'  which shall be nonpolymorphic and have the same type and type'
write(io,'(a)')'  parameters as A. The function shall return a nonallocatable'
write(io,'(a)')'  scalar of the same type and type parameters as A. The function'
write(io,'(a)')'  shall be the same on all images and with regards to the arguments'
write(io,'(a)')'  mathematically commutative and associative. Note that OPERATOR'
write(io,'(a)')'  may not be an elemental function, unless it is an intrinsic function.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'  image of the current team.'
write(io,'(a)')''
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')''
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_reduce(val, result_image=1, operator=myprod)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "Product value", val  ! prints num_images() factorial'
write(io,'(a)')'     end if'
write(io,'(a)')'   contains'
write(io,'(a)')'     pure function myprod(a, b)'
write(io,'(a)')'       integer, value :: a, b'
write(io,'(a)')'       integer :: myprod'
write(io,'(a)')'       myprod = a * b'
write(io,'(a)')'     end function myprod'
write(io,'(a)')'   end program test'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   While the rules permit in principle an intrinsic function, none of the'
write(io,'(a)')'   intrinsics in the standard fulfill the criteria of having a specific'
write(io,'(a)')'   function, which takes two arguments of the same type and returning'
write(io,'(a)')'   that type as result.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_min]], [[co_max]], [[co_sum]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_sum(3f) - [INTRINSIC] Sum of values on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_sum(a [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_sum sums up the values of each element of A on all images of'
write(io,'(a)')'   the current team. If result_image is present, the summed-up values'
write(io,'(a)')'   are returned in A on the specified image only and the value of A'
write(io,'(a)')'   on the other images become undefined. If result_image is not'
write(io,'(a)')'   present, the value is returned on all images. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If'
write(io,'(a)')'   the execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - shall be an integer, real or complex variable, which has the'
write(io,'(a)')'  same type and type parameters on all images of the team.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'  image of the current team.'
write(io,'(a)')''
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')''
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_sum(val, result_image=1)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "The sum is ", val ! prints (n**2 + n)/2, with n = num_images()'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program test'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_max]], [[co_min]], [[co_reduce]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     command_argument_count(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get number of command line arguments'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = command_argument_count()'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   command_argument_count returns the number of arguments passed on the'
write(io,'(a)')'   command line when the containing program was invoked.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'None'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer(4)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_command_argument_count'
write(io,'(a)')'       integer :: count'
write(io,'(a)')'       count = command_argument_count()'
write(io,'(a)')'       print *, count'
write(io,'(a)')'   end program test_command_argument_count'
write(io,'(a)')''
write(io,'(a)')'  Sample output:'
write(io,'(a)')''
write(io,'(a)')'   # the command verb does not count'
write(io,'(a)')'   ./test_command_argument_count'
write(io,'(a)')'           0'
write(io,'(a)')'   # quoted strings may count as one argument'
write(io,'(a)')'   ./test_command_argument_count count arguments'
write(io,'(a)')'           2'
write(io,'(a)')'   ./test_command_argument_count ''count arguments'''
write(io,'(a)')'           1'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[get_command]],'
write(io,'(a)')'   [[get_command_argument]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     compiler_options(3f) - [INTRINSIC] Options passed to the compiler'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   str = compiler_options()'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   compiler_options returns a string with the options used for'
write(io,'(a)')'   compiling.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'None.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a default-kind string with system-dependent'
write(io,'(a)')'   length. It contains the compiler flags used to compile the file,'
write(io,'(a)')'   which called the compiler_options intrinsic.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_compiler_version'
write(io,'(a)')'   use iso_fortran_env'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   print ''(4a)'', &'
write(io,'(a)')'      ''This file was compiled by '', &'
write(io,'(a)')'      compiler_version(),           &'
write(io,'(a)')'      '' using the options '',        &'
write(io,'(a)')'      compiler_options()'
write(io,'(a)')'   end program demo_compiler_version'
write(io,'(a)')''
write(io,'(a)')'  Example results:'
write(io,'(a)')''
write(io,'(a)')'   This file was compiled by GCC version 5.4.0 using the options'
write(io,'(a)')'   -I /usr/include/w32api -I /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')'   -mtune=generic -march=x86-64 -g -Wunused -Wuninitialized -Wall'
write(io,'(a)')'   -std=f2008 -fbounds-check -fbacktrace -finit-real=nan'
write(io,'(a)')'   -fno-range-check -frecord-marker=4'
write(io,'(a)')'   -J /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function of the module [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[compiler_version]], [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     compiler_version(3f) - [INTRINSIC] Compiler version string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'str = compiler_version()'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   compiler_version returns a string with the name and the'
write(io,'(a)')'   version of the compiler.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'None.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a default-kind string with system-dependent'
write(io,'(a)')'   length. It contains the name of the compiler and its version number.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_compiler_version'
write(io,'(a)')'   use iso_fortran_env'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   print ''(4a)'', &'
write(io,'(a)')'      ''This file was compiled by '', &'
write(io,'(a)')'      compiler_version(),           &'
write(io,'(a)')'      '' using the options '',        &'
write(io,'(a)')'      compiler_options()'
write(io,'(a)')'   end program demo_compiler_version'
write(io,'(a)')''
write(io,'(a)')'  Example results:'
write(io,'(a)')''
write(io,'(a)')'   This file was compiled by GCC version 5.4.0 using the options'
write(io,'(a)')'   -I /usr/include/w32api -I /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')'   -mtune=generic -march=x86-64 -g -Wunused -Wuninitialized -Wall'
write(io,'(a)')'   -std=f2008 -fbounds-check -fbacktrace -finit-real=nan'
write(io,'(a)')'   -fno-range-check -frecord-marker=4'
write(io,'(a)')'   -J /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function of the module [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[compiler_options]], [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     conjg(3f) - [INTRINSIC:NUMERIC] Complex conjugate function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   z = conjg(z)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   conjg(z) returns the conjugate of Z. If Z is (x, y)'
write(io,'(a)')'   then the result is (x, -y)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   Z  - The type shall be COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_conjg'
write(io,'(a)')'        complex :: z = (2.0, 3.0)'
write(io,'(a)')'        complex(8) :: dz = (2.71_8, -3.14_8)'
write(io,'(a)')'        z= conjg(z)'
write(io,'(a)')'        print *, z'
write(io,'(a)')'        dz = dconjg(dz)'
write(io,'(a)')'        print *, dz'
write(io,'(a)')'    end program test_conjg'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cos(3f) - [INTRINSIC:TRIGONOMETRIC] Cosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = cos(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cos(x) computes the cosine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X. The real part'
write(io,'(a)')'   of the result is in radians. If X is of the type REAL, the return'
write(io,'(a)')'   value lies in the range -1 <= \cos (x) <= 1.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_cos'
write(io,'(a)')'     real :: x = 0.0'
write(io,'(a)')'     x = cos(x)'
write(io,'(a)')'   end program test_cos'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[acos]], [[sin]], [[tan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cosh(3f) - [INTRINSIC:TRIGONOMETRIC] Hyperbolic cosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   x = cosh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cosh(x) computes the hyperbolic cosine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X. If X is complex, the'
write(io,'(a)')'   imaginary part of the result is in radians. If X is REAL, the'
write(io,'(a)')'   return value has a lower bound of one, cosh(x) >= 1.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_cosh'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = cosh(x)'
write(io,'(a)')'   end program test_cosh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   Inverse function: [[acosh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   count(3f) - [INTRINSIC] Count function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = count(mask [, dim, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Counts the number of .true. elements in a logical MASK,'
write(io,'(a)')'   or, if the DIM argument is supplied, counts the number of'
write(io,'(a)')'   elements along each row of the array in the DIM direction.'
write(io,'(a)')'   If the array has zero size, or all of the elements of MASK are'
write(io,'(a)')'   .false., then the result is 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - The type shall be LOGICAL.'
write(io,'(a)')'   DIM   - (Optional) The type shall be INTEGER.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')'   If DIM is present, the result is an array with a rank one less'
write(io,'(a)')'   than the rank of ARRAY, and a size corresponding to the shape'
write(io,'(a)')'   of ARRAY with the DIM dimension removed.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_count'
write(io,'(a)')'       integer, dimension(2,3) :: a, b'
write(io,'(a)')'       logical, dimension(2,3) :: mask'
write(io,'(a)')'       a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))'
write(io,'(a)')'       b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))'
write(io,'(a)')'       print ''(3i3)'', a(1,:)'
write(io,'(a)')'       print ''(3i3)'', a(2,:)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', b(1,:)'
write(io,'(a)')'       print ''(3i3)'', b(2,:)'
write(io,'(a)')'       print *'
write(io,'(a)')'       mask = a.ne.b'
write(io,'(a)')'       print ''(3l3)'', mask(1,:)'
write(io,'(a)')'       print ''(3l3)'', mask(2,:)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', count(mask)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', count(mask, 1)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', count(mask, 2)'
write(io,'(a)')'   end program test_count'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cpu_time(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] CPU elapsed time in seconds'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call cpu_time(time)'
write(io,'(a)')''
write(io,'(a)')'      real,intent(out) :: time'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a REAL value representing the elapsed CPU time in'
write(io,'(a)')'   seconds. This is useful for testing segments of code to determine'
write(io,'(a)')'   execution time.'
write(io,'(a)')''
write(io,'(a)')'   If a time source is available, time will be reported with microsecond'
write(io,'(a)')'   resolution. If no time source is available, TIME is set to'
write(io,'(a)')'   -1.0.'
write(io,'(a)')''
write(io,'(a)')'   Note that TIME may contain a, system dependent, arbitrary offset'
write(io,'(a)')'   and may not start with 0.0. For cpu_time, the absolute'
write(io,'(a)')'   value is meaningless, only differences between subsequent calls to'
write(io,'(a)')'   this subroutine, as shown in the example below, should be used.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   TIME  - The type shall be REAL with intent(out).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_cpu_time'
write(io,'(a)')'        real :: start, finish'
write(io,'(a)')'        call cpu_time(start)'
write(io,'(a)')'            ! put code to test here'
write(io,'(a)')'        call cpu_time(finish)'
write(io,'(a)')'        print ''("Time = ",f6.3," seconds.")'',finish-start'
write(io,'(a)')'    end program test_cpu_time'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[system_clock]], [[date_and_time]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cshift(3f) - [INTRINSIC:ARRAY MANIPULATION] Circular shift elements of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = cshift(array, shift [, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cshift(array, shift [, dim]) performs a circular shift on elements of'
write(io,'(a)')'   ARRAY along the dimension of DIM. If DIM is omitted it is'
write(io,'(a)')'   taken to be 1. DIM is a scaler of type INTEGER in the'
write(io,'(a)')'   range of 1 <= DIM <= n, where "n" is the rank of ARRAY.'
write(io,'(a)')'   If the rank of ARRAY is one, then all elements of ARRAY are shifted'
write(io,'(a)')'   by SHIFT places. If rank is greater than one, then all complete rank one'
write(io,'(a)')'   sections of ARRAY along the given dimension are shifted. Elements'
write(io,'(a)')'   shifted out one end of each rank one section are shifted back in the other end.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of any type.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')'   DIM  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns an array of same type and rank as the ARRAY argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_cshift'
write(io,'(a)')'        integer, dimension(3,3) :: a'
write(io,'(a)')'        a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'        a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)'
write(io,'(a)')'        print *'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'    end program test_cshift'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     date_and_time(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] gets current time'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    call date_and_time([date, time, zone, values])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   date_and_time(date, time, zone, values) gets the corresponding date and'
write(io,'(a)')'   time information from the real-time system clock. DATE is intent(out)'
write(io,'(a)')'   and has form ccyymmdd. TIME is intent(out) and has form hhmmss.sss.'
write(io,'(a)')'   ZONE is intent(out) and has form (+-)hhmm, representing the difference'
write(io,'(a)')'   with respect to Coordinated Universal Time (UTC). Unavailable time and'
write(io,'(a)')'   date parameters return blanks.'
write(io,'(a)')''
write(io,'(a)')'   VALUES is intent(out) and provides the following:'
write(io,'(a)')''
write(io,'(a)')' * value(1): - The year'
write(io,'(a)')' * value(2): - The month'
write(io,'(a)')' * value(3): - The day of the month'
write(io,'(a)')' * value(4): - Time difference with UTC in minutes'
write(io,'(a)')' * value(5): - The hour of the day'
write(io,'(a)')' * value(6): - The minutes of the hour'
write(io,'(a)')' * value(7): - The seconds of the minute'
write(io,'(a)')' * value(8): - The milliseconds of the second'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   DATE    - (Optional) The type shall be character(len=8) or larger,'
write(io,'(a)')'             and of default kind.'
write(io,'(a)')'   TIME    - (Optional) The type shall be character(len=10) or'
write(io,'(a)')'             larger, and of default kind.'
write(io,'(a)')'   ZONE    - (Optional) The type shall be character(len=5) or larger,'
write(io,'(a)')'             and of default kind.'
write(io,'(a)')'   VALUES  - (Optional) The type shall be integer(8).'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'None'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'    program test_time_and_date'
write(io,'(a)')''
write(io,'(a)')'        character(8)  :: date'
write(io,'(a)')'        character(10) :: time'
write(io,'(a)')'        character(5)  :: zone'
write(io,'(a)')'        integer,dimension(8) :: values'
write(io,'(a)')'        ! using keyword arguments'
write(io,'(a)')'        call date_and_time(date,time,zone,values)'
write(io,'(a)')'        call date_and_time(DATE=date,ZONE=zone)'
write(io,'(a)')'        call date_and_time(TIME=time)'
write(io,'(a)')'        call date_and_time(VALUES=values)'
write(io,'(a)')'        print ''(a,2x,a,2x,a)'', date, time, zone'
write(io,'(a)')'        print ''(8i5)'', values'
write(io,'(a)')''
write(io,'(a)')'    end program test_time_and_date'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[cpu_time]], [[system_clock]]'
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     dble(3f) - [INTRINSIC:NUMERIC] Double conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DBLE(A)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   DBLE(A) Converts A to double precision real type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be INTEGER, REAL, or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type DOUBLEPRECISION.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_dble'
write(io,'(a)')'        real    :: x = 2.18'
write(io,'(a)')'        integer :: i = 5'
write(io,'(a)')'        complex :: z = (2.3,1.14)'
write(io,'(a)')'        print *, dble(x), dble(i), dble(z)'
write(io,'(a)')'    end program test_dble'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[float]], [[real]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     digits(3f) - [INTRINSIC] Significant digits function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = digits(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   digits(x) returns the number of significant digits of the internal model'
write(io,'(a)')'   representation of X. For example, on a system using a 32-bit'
write(io,'(a)')'   floating point representation, a default real number would likely return 24.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type may be INTEGER or REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_digits'
write(io,'(a)')'        integer :: i = 12345'
write(io,'(a)')'        real :: x = 3.143'
write(io,'(a)')'        real(8) :: y = 2.33'
write(io,'(a)')'        print *, digits(i)'
write(io,'(a)')'        print *, digits(x)'
write(io,'(a)')'        print *, digits(y)'
write(io,'(a)')'    end program test_digits'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     DIM(3f) - [INTRINSIC:NUMERIC] Positive difference'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DIM(X, Y)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   DIM(X,Y) returns the difference X-Y if the result is positive;'
write(io,'(a)')'   otherwise returns zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be INTEGER or REAL'
write(io,'(a)')'   Y  - The type shall be the same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER or REAL.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_dim'
write(io,'(a)')'        integer :: i'
write(io,'(a)')'        real(8) :: x'
write(io,'(a)')'        i = dim(4, 15)'
write(io,'(a)')'        x = dim(4.345_8, 2.111_8)'
write(io,'(a)')'        print *, i'
write(io,'(a)')'        print *, x'
write(io,'(a)')'    end program test_dim'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     dot_product(3f) - [INTRINSIC] Dot product function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = dot_product(vector_a, vector_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   dot_product(vector_a, vector_b) computes the dot product multiplication'
write(io,'(a)')'   of two vectors vector_a and vector_b. The two vectors may be'
write(io,'(a)')'   either numeric or logical and must be arrays of rank one and of equal size. If'
write(io,'(a)')'   the vectors are INTEGER or REAL, the result is'
write(io,'(a)')'   sum(vector_a*vector_b). If the vectors are COMPLEX, the result'
write(io,'(a)')'   is sum(conjg(vector_a)*vector_b). If the vectors are LOGICAL,'
write(io,'(a)')'   the result is any(vector_a .and. vector_b).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   vector_a  - The type shall be numeric or LOGICAL, rank 1.'
write(io,'(a)')'   vector_b  - The type shall be numeric if vector_a is of numeric type or LOGICAL'
write(io,'(a)')'               if vector_a is of type LOGICAL. vector_b shall be a rank-one array.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If the arguments are numeric, the return value is a scaler of numeric type,'
write(io,'(a)')'   INTEGER, REAL, or COMPLEX. If the arguments are'
write(io,'(a)')'   LOGICAL, the return value is .true. or .false..'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_dot_prod'
write(io,'(a)')'        integer, dimension(3) :: a, b'
write(io,'(a)')'        a = (/ 1, 2, 3 /)'
write(io,'(a)')'        b = (/ 4, 5, 6 /)'
write(io,'(a)')'        print ''(3i3)'', a'
write(io,'(a)')'        print *'
write(io,'(a)')'        print ''(3i3)'', b'
write(io,'(a)')'        print *'
write(io,'(a)')'        print *, dot_product(a,b)'
write(io,'(a)')'    end program test_dot_prod'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     dprod(3f) - [INTRINSIC:NUMERIC] Double product function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = dprod(x, y)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   dprod(x,y) returns the product x*y.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')'   Y  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type real(8).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_dprod'
write(io,'(a)')'        real :: x = 5.2'
write(io,'(a)')'        real :: y = 2.3'
write(io,'(a)')'        real(8) :: d'
write(io,'(a)')'        d = dprod(x,y)'
write(io,'(a)')'        print *, d'
write(io,'(a)')'    end program test_dprod'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     eoshift(3f) - [INTRINSIC:ARRAY MANIPULATION] End-off shift elements of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = eoshift(array, shift [, boundary, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   eoshift(array, shift[, boundary, dim]) performs an end-off shift on'
write(io,'(a)')'   elements of ARRAY along the dimension of DIM. If DIM is'
write(io,'(a)')'   omitted it is taken to be 1. DIM is a scaler of type'
write(io,'(a)')'   INTEGER in the range of 1 <= DIM <= n where "n" is the'
write(io,'(a)')'   rank of ARRAY. If the rank of ARRAY is one, then all elements of'
write(io,'(a)')'   ARRAY are shifted by SHIFT places. If rank is greater than one,'
write(io,'(a)')'   then all complete rank one sections of ARRAY along the given dimension are'
write(io,'(a)')'   shifted. Elements shifted out one end of each rank one section are dropped. If'
write(io,'(a)')'   BOUNDARY is present then the corresponding value of from BOUNDARY'
write(io,'(a)')'   is copied back in the other end. If BOUNDARY is not present then the'
write(io,'(a)')'   following are copied in depending on the type of ARRAY.'
write(io,'(a)')''
write(io,'(a)')'*Array Type* - *Boundary Value*'
write(io,'(a)')''
write(io,'(a)')'* Numeric  - 0 of the type and kind of ARRAY.'
write(io,'(a)')'* Logical  - .false..'
write(io,'(a)')'* Character(LEN) - LEN blanks.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - May be any type, not scaler.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')'   BOUNDARY  - Same type as ARRAY.'
write(io,'(a)')'   DIM  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns an array of same type and rank as the ARRAY argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_eoshift'
write(io,'(a)')'        integer, dimension(3,3) :: a'
write(io,'(a)')'        a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'        a = eoshift(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)'
write(io,'(a)')'        print *'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'    end program test_eoshift'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     epsilon(3f) - [INTRINSIC] Epsilon function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = epsilon(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   epsilon(x) returns a nearly negligible number relative to 1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of same type as the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_epsilon'
write(io,'(a)')'        real :: x = 3.143'
write(io,'(a)')'        real(8) :: y = 2.33'
write(io,'(a)')'        print *, epsilon(x)'
write(io,'(a)')'        print *, epsilon(y)'
write(io,'(a)')'    end program test_epsilon'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     erf(3f) - [INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   erf(x) computes the error function of X, defined as'
write(io,'(a)')'   $$'
write(io,'(a)')'   \text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0**x e**{-t**2} dt.'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = erf(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL, of the same kind as'
write(io,'(a)')'   X and lies in the range -1 <= erf(x) <= 1 .'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_erf'
write(io,'(a)')'      real(8) :: x = 0.17_8'
write(io,'(a)')'      x = erf(x)'
write(io,'(a)')'    end program test_erf'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     erfc(3f) - [INTRINSIC:MATHEMATICS] Complementary error function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = erfc(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   erfc(x) computes the complementary error function of X, defined as'
write(io,'(a)')'   $$'
write(io,'(a)')'   1 - \text{erf}(x) = 1 - \frac{2}{\sqrt{\pi}} \int_0**x e**{-t**2} dt.'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and of the same kind as X. It lies'
write(io,'(a)')'   in the range'
write(io,'(a)')''
write(io,'(a)')'     0 <= ERFC(X) <= 2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_erfc'
write(io,'(a)')'     real(8) :: x = 0.17_8'
write(io,'(a)')'     x = erfc(x)'
write(io,'(a)')'   end program test_erfc'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     erfc_scaled(3f) - [INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   erfc_scaled(x) computes the exponentially-scaled complementary'
write(io,'(a)')'   error function of X:'
write(io,'(a)')''
write(io,'(a)')'   $$'
write(io,'(a)')'   e**{x**2} \frac{2}{\sqrt{\pi}} \int_{x}**{\infty} e**{-t**2} dt.'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = erfc_scaled(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and of the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_erfc_scaled'
write(io,'(a)')'     real(kind(0.0d0)) :: x = 0.17_8'
write(io,'(a)')'     x = erfc_scaled(x)'
write(io,'(a)')'     print *, x ! prints approx. 0.83375830214998126'
write(io,'(a)')'   end program test_erfc_scaled'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     EVENT_QUERY(3f) - [INTRINSIC] Query whether a coarray event has occurred'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call EVENT_QUERY(EVENT, COUNT [, STAT])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   EVENT_QUERY assigns the number of events to COUNT which have been'
write(io,'(a)')'   posted to the EVENT variable and not yet been removed by calling'
write(io,'(a)')'   EVENT_WAIT. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value and COUNT is'
write(io,'(a)')'   assigned the value -1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  EVENT  - (intent(in)) Scalar of type event_type, defined in'
write(io,'(a)')'           iso_fortran_env; shall not be coindexed.'
write(io,'(a)')'  COUNT  - (intent(out))Scalar integer with at least the precision of'
write(io,'(a)')'           default integer.'
write(io,'(a)')'  STAT   - (OPTIONAL) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program atomic'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     type(event_type) :: event_value_has_been_set[*]'
write(io,'(a)')'     integer :: cnt'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       call event_query(event_value_has_been_set, cnt)'
write(io,'(a)')'       if (cnt > 0) write(*,*) "Value has been set"'
write(io,'(a)')'     elseif (this_image() == 2) then'
write(io,'(a)')'       event post(event_value_has_been_set[1])'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program atomic'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     execute_command_line(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Execute a shell command'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'     call execute_command_line(command [, wait, exitstat, cmdstat, cmdmsg ])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The COMMAND argument is passed to the shell and executed, using the'
write(io,'(a)')'   C library''s SYSTEM call. (The shell is SH on Unix systems, and'
write(io,'(a)')'   cmd.exe on Windows.) If WAIT is present and has the value false,'
write(io,'(a)')'   the execution of the command is asynchronous if the system supports'
write(io,'(a)')'   it; otherwise, the command is executed synchronously.'
write(io,'(a)')''
write(io,'(a)')'   The three last arguments allow the user to get status information.'
write(io,'(a)')'   After synchronous execution, EXITSTAT contains the integer exit code'
write(io,'(a)')'   of the command, as returned by SYSTEM. CMDSTAT is set to zero if'
write(io,'(a)')'   the command line was executed (whatever its exit status was).'
write(io,'(a)')'   CMDMSG is assigned an error message if an error has occurred.'
write(io,'(a)')''
write(io,'(a)')'   Note that the SYSTEM function need not be thread-safe. It is the'
write(io,'(a)')'   responsibility of the user to ensure that SYSTEM is not called'
write(io,'(a)')'   concurrently.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   COMMAND   - Shall be a default CHARACTER scalar.'
write(io,'(a)')'   WAIT      - (Optional) Shall be a default LOGICAL scalar.'
write(io,'(a)')'   EXITSTAT  - (Optional) Shall be an INTEGER of the default kind.'
write(io,'(a)')'   CMDSTAT   - (Optional) Shall be an INTEGER of  default kind.'
write(io,'(a)')'   CMDMSG    - (Optional) Shall be an CHARACTER scalar of the default kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_exec'
write(io,'(a)')'     integer :: i'
write(io,'(a)')''
write(io,'(a)')'     call execute_command_line("external_prog.exe", exitstat=i)'
write(io,'(a)')'     print *, "Exit status of external_prog.exe was ", i'
write(io,'(a)')''
write(io,'(a)')'     call execute_command_line("reindex_files.exe", wait=.false.)'
write(io,'(a)')'     print *, "Now reindexing files in the background"'
write(io,'(a)')'   end program test_exec'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   Because this intrinsic is implemented in terms of the SYSTEM'
write(io,'(a)')'   function call, its behavior with respect to signaling is processor'
write(io,'(a)')'   dependent. In particular, on POSIX-compliant systems, the SIGINT and'
write(io,'(a)')'   SIGQUIT signals will be ignored, and the SIGCHLD will be blocked. As'
write(io,'(a)')'   such, if the parent process is terminated, the child process might not'
write(io,'(a)')'   be terminated alongside.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     exp(3f) - [INTRINSIC:MATHEMATICS] Exponential function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = exp(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   exp(x) computes the base "e" exponential of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or'
write(io,'(a)')'COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_exp'
write(io,'(a)')'      real :: x = 1.0'
write(io,'(a)')'      x = exp(x)'
write(io,'(a)')'    end program test_exp'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     exponent(3f) - [INTRINSIC] Exponent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = exponent(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   exponent(x) returns the value of the exponent part of X. If X'
write(io,'(a)')'   is zero the value returned is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type default INTEGER.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_exponent'
write(io,'(a)')'      real :: x = 1.0'
write(io,'(a)')'      integer :: i'
write(io,'(a)')'      i = exponent(x)'
write(io,'(a)')'      print *, i'
write(io,'(a)')'      print *, exponent(0.0)'
write(io,'(a)')'    end program test_exponent'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     float(3f) - [INTRINSIC] Convert integer to default real'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = float(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   float(a) converts the integer A to a default real value.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type default REAL.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_float'
write(io,'(a)')'        integer :: i = 1'
write(io,'(a)')'        if (float(i) /= 1.) call abort'
write(io,'(a)')'    end program test_float'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dble]], [[real]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     floor(3f) - [INTRINSIC:NUMERIC] Integer floor function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   floor(a) returns the greatest integer less than or equal to X.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = floor(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer(kind) if KIND is present'
write(io,'(a)')'   and of default-kind INTEGER otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_floor'
write(io,'(a)')'        real :: x = 63.29'
write(io,'(a)')'        real :: y = -63.59'
write(io,'(a)')'        print *, floor(x) ! returns 63'
write(io,'(a)')'        print *, floor(y) ! returns -64'
write(io,'(a)')'    end program test_floor'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ceiling]], [[nint]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     fraction(3f) - [INTRINSIC] Fractional part of the model representation'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   fraction(x) returns the fractional part of the model'
write(io,'(a)')'   representation of X.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   y = fraction(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type of the argument shall be a REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as the argument.'
write(io,'(a)')'   The fractional part of the model representation of X is returned;'
write(io,'(a)')'   it is x * radix(x)**(-exponent(x)).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_fraction'
write(io,'(a)')'      real :: x'
write(io,'(a)')'      x = 178.1387e-4'
write(io,'(a)')'      print *, fraction(x), x * radix(x)**(-exponent(x))'
write(io,'(a)')'    end program test_fraction'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     gamma(3f) - [INTRINSIC:MATHEMATICS] Gamma function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   gamma(x) computes Gamma of X. For positive,'
write(io,'(a)')'   integer values of X the Gamma function simplifies to the factorial'
write(io,'(a)')'   function Gamma(x)=(x-1)!.'
write(io,'(a)')''
write(io,'(a)')'   $$'
write(io,'(a)')'   \Gamma(x) = \int_0**\infty t**{x-1}{\mathrm{e}}**{-t}\,{\mathrm{d}}t'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   x = gamma(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL and neither zero'
write(io,'(a)')'        nor a negative integer.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL of the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_gamma'
write(io,'(a)')'     real :: x = 1.0'
write(io,'(a)')'     x = gamma(x) ! returns 1.0'
write(io,'(a)')'   end program test_gamma'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   Logarithm of the Gamma function: [[log_gamma]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     get_command(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get the entire command line'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Retrieve the entire command line that was used to invoke the program.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call get_command([command, length, status])'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  COMMAND  - (Optional) shall be of type CHARACTER and of default kind.'
write(io,'(a)')'  LENGTH  - (Optional) Shall be of type INTEGER and of default kind.'
write(io,'(a)')'  STATUS  - (Optional) Shall be of type INTEGER and of default kind.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If COMMAND is present, stores the entire command line that was used'
write(io,'(a)')'   to invoke the program in COMMAND. If LENGTH is present, it is'
write(io,'(a)')'   assigned the length of the command line. If STATUS is present, it is'
write(io,'(a)')'   assigned 0 upon success of the command, -1 if COMMAND is too short'
write(io,'(a)')'   to store the command line, or a positive value in case of an error.'
write(io,'(a)')''
write(io,'(a)')'   Note that what is typed on the command line is often processed by'
write(io,'(a)')'   a shell. The shell often processes special characters and white'
write(io,'(a)')'   space before passing it to the program. The processing can typically'
write(io,'(a)')'   be turned off by turning off globbing or quoting the command line'
write(io,'(a)')'   arguments with quote characters and/or changing the default field'
write(io,'(a)')'   separators, but this should rarely be necessary.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_get_command'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer                      :: COMMAND_LINE_LENGTH'
write(io,'(a)')'   character(len=:),allocatable :: COMMAND_LINE'
write(io,'(a)')''
write(io,'(a)')'      ! get command line length'
write(io,'(a)')'      call get_command(length=COMMAND_LINE_LENGTH)'
write(io,'(a)')''
write(io,'(a)')'      ! allocate string big enough to hold command line'
write(io,'(a)')'      allocate(character(len=COMMAND_LINE_LENGTH) :: COMMAND_LINE)'
write(io,'(a)')''
write(io,'(a)')'      ! get command line as a string'
write(io,'(a)')'      call get_command(command=COMMAND_LINE)'
write(io,'(a)')''
write(io,'(a)')'      ! JIC:: trim leading spaces just in case'
write(io,'(a)')'      COMMAND_LINE=adjustl(COMMAND_LINE)'
write(io,'(a)')''
write(io,'(a)')'      write(*,''(a)'')COMMAND_LINE'
write(io,'(a)')''
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'  Sample execution:'
write(io,'(a)')'     ./test_get_command  arguments    on the    command   line to   echo'
write(io,'(a)')'     ./test_get_command arguments on the command line to echo'
write(io,'(a)')'     # using the bash shell'
write(io,'(a)')'     ./test_get_command  ''arguments  *><`~[]!{}?"\''| on the    command   line to   echo'''
write(io,'(a)')'     ./test_get_command arguments  *><`~[]!{}?"''| on the    command   line to   echo'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[get_command_argument]],'
write(io,'(a)')'   [[command_argument_count]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     get_command_argument(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get command line arguments'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call get_command_argument(number [, value, length, status])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Retrieve the NUMBER-th argument that was passed on the command line'
write(io,'(a)')'   when the containing program was invoked.'
write(io,'(a)')''
write(io,'(a)')'   There is not anything specifically stated about what an argument is but'
write(io,'(a)')'   in practice the arguments are split on whitespace unless the arguments'
write(io,'(a)')'   are quoted and IFS values (Internal Field Seperators) used by common'
write(io,'(a)')'   shells are ignored.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   NUMBER  - Shall be a scalar of type integer(4), NUMBER > 0.'
write(io,'(a)')'   VALUE   - Shall be a scalar of type CHARACTER and of default kind.'
write(io,'(a)')'   LENGTH  - (Optional) Shall be a scalar of type integer(4).'
write(io,'(a)')'   STATUS  - (Optional) Shall be a scalar of type integer(4).'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   After get_command_argument returns, the VALUE argument holds the'
write(io,'(a)')'   NUMBER-th command line argument. If VALUE can not hold the argument, it is'
write(io,'(a)')'   truncated to fit the length of VALUE. If there are less than NUMBER'
write(io,'(a)')'   arguments specified at the command line, VALUE will be filled with blanks.'
write(io,'(a)')'   If NUMBER = 0, VALUE is set to the name of the program (on systems'
write(io,'(a)')'   that support this feature).'
write(io,'(a)')''
write(io,'(a)')'   The LENGTH argument contains the length of the'
write(io,'(a)')'   NUMBER-th command line argument.'
write(io,'(a)')''
write(io,'(a)')'   If the argument retrieval fails, STATUS'
write(io,'(a)')'   is a positive number; if VALUE contains a truncated command line argument,'
write(io,'(a)')'   STATUS is -1; and otherwise the STATUS is zero.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_get_command_argument'
write(io,'(a)')'   implicit none'
write(io,'(a)')'     integer :: count,i, longest, argument_length'
write(io,'(a)')'     integer,allocatable  :: istat(:), ilen(:)'
write(io,'(a)')'     character(len=:),allocatable :: arguments(:)'
write(io,'(a)')''
write(io,'(a)')'     ! get number of arguments'
write(io,'(a)')'     count = command_argument_count()'
write(io,'(a)')''
write(io,'(a)')'     ! find longest argument'
write(io,'(a)')'     longest=0'
write(io,'(a)')'     do i=0,count'
write(io,'(a)')'        call get_command_argument(number=i,length=argument_length)'
write(io,'(a)')'        longest=max(longest,argument_length)'
write(io,'(a)')'      enddo'
write(io,'(a)')''
write(io,'(a)')'     ! allocate string array big enough to hold command line'
write(io,'(a)')'    allocate(character(len=longest) :: arguments(0:count))'
write(io,'(a)')'    allocate(istat(0:count))'
write(io,'(a)')'    allocate(ilen(0:count))'
write(io,'(a)')''
write(io,'(a)')'     ! read the arguments into the array'
write(io,'(a)')'     do i=0,count'
write(io,'(a)')'       call get_command_argument(i, arguments(i),status=istat(i),length=ilen(i))'
write(io,'(a)')'     enddo'
write(io,'(a)')''
write(io,'(a)')'     ! show the results'
write(io,'(a)')'     write (*,''(i3.3,1x,i0.5,1x,i0.5,1x,"[",a,"]")'') (i,istat(i),ilen(i),arguments(i)(:ilen(i)),i=0,count)'
write(io,'(a)')''
write(io,'(a)')'   end program test_get_command_argument'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')' Sample output:'
write(io,'(a)')''
write(io,'(a)')'   ./test_get_command_argument a    simple      test    ''of getting   arguments  '' "  from the command"'
write(io,'(a)')'   000 00000 00003 [./test_get_command_argument]'
write(io,'(a)')'   001 00000 00001 [a]'
write(io,'(a)')'   002 00000 00006 [simple]'
write(io,'(a)')'   003 00000 00004 [test]'
write(io,'(a)')'   004 00000 00024 [of getting   arguments  ]'
write(io,'(a)')'   005 00000 00018 [  from the command]'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[get_command]],'
write(io,'(a)')'   [[command_argument_count]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     get_environment_variable(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get an environmental variable'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call get_environment_variable(NAME[, VALUE, LENGTH, STATUS, TRIM_NAME)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Get the VALUE of the environmental variable NAME.'
write(io,'(a)')''
write(io,'(a)')'   Note that get_environment_variable need not be thread-safe. It is'
write(io,'(a)')'   the responsibility of the user to ensure that the environment is not'
write(io,'(a)')'   being updated concurrently.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   NAME       - (Optional) Shall be a scalar of type CHARACTER and of default kind.'
write(io,'(a)')'   VALUE      - (Optional) Shall be a scalar of type CHARACTER and of default kind.'
write(io,'(a)')'   LENGTH     - (Optional) Shall be a scalar of type INTEGER and of default kind.'
write(io,'(a)')'   STATUS     - (Optional) Shall be a scalar of type INTEGER and of default kind.'
write(io,'(a)')'   TRIM_NAME  - (Optional) Shall be a scalar of type LOGICAL and of default kind.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Stores the value of NAME in VALUE.'
write(io,'(a)')'   If VALUE is not large enough to hold the data, it is truncated.'
write(io,'(a)')'   If NAME is not set, VALUE will be filled with blanks.'
write(io,'(a)')''
write(io,'(a)')'   Argument LENGTH contains the length needed for storing the environment'
write(io,'(a)')'   variable NAME or zero if it is not present.'
write(io,'(a)')''
write(io,'(a)')'   STATUS is'
write(io,'(a)')'   -1 if VALUE is present but too short for the environment variable;'
write(io,'(a)')'   it is 1 if the environment variable does not exist'
write(io,'(a)')'   and 2 if the processor does not support environment variables;'
write(io,'(a)')'   in all other cases STATUS is zero.'
write(io,'(a)')''
write(io,'(a)')'   If TRIM_NAME is present with the value .FALSE.,'
write(io,'(a)')'   the trailing blanks in NAME are significant;'
write(io,'(a)')'   otherwise they are not part of the environment variable name.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_getenv'
write(io,'(a)')'     character(len=255) :: homedir'
write(io,'(a)')'     call get_environment_variable("HOME", homedir)'
write(io,'(a)')'     write (*,*) trim(homedir)'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     huge(3f) - [INTRINSIC] Largest number of a kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = huge(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   huge(x) returns the largest number that is not an infinity in'
write(io,'(a)')'   the model of the type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL or INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_huge_tiny'
write(io,'(a)')'      print *, huge(0), huge(0.0), huge(0.0d0)'
write(io,'(a)')'      print *, tiny(0.0), tiny(0.0d0)'
write(io,'(a)')'    end program test_huge_tiny'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     hypot(3f) - [INTRINSIC:MATHEMATICS] Euclidean distance function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = hypot(x, y)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'hypot(x,y) is the Euclidean distance function. It is equal to'
write(io,'(a)')''
write(io,'(a)')'   sqrt{X**2 + Y**2}, without undue underflow or overflow.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')'   Y  - The type and kind type parameter shall be the same as'
write(io,'(a)')'X.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has the same type and kind type parameter as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_hypot'
write(io,'(a)')'      real(4) :: x = 1.e0_4, y = 0.5e0_4'
write(io,'(a)')'      x = hypot(x,y)'
write(io,'(a)')'    end program test_hypot'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     iachar(3f) - [INTRINSIC:CHARACTER] Code in ASCII collating sequence'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = iachar(c [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   iachar(c) returns the code for the ASCII character'
write(io,'(a)')'   in the first character position of C.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   C  - Shall be a scalar CHARACTER, with intent(in)'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_iachar'
write(io,'(a)')'      integer i'
write(io,'(a)')'      i = iachar('' '')'
write(io,'(a)')'    end program test_iachar'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   See [[ichar]] for a discussion of converting between numerical'
write(io,'(a)')'   values and formatted string representations.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[achar]], [[char]], [[ichar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iall(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise and of array elements'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = iall(array[, mask])'
write(io,'(a)')'* result = iall(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reduces with bitwise and the elements of ARRAY along dimension DIM'
write(io,'(a)')'   if the corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ARRAY  - Shall be an array of type INTEGER'
write(io,'(a)')'  DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'  in the range from 1 to "n", where "n" equals the rank of ARRAY.'
write(io,'(a)')'  MASK  - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'  scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the bitwise ALL of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank "n-1", where "n" equals'
write(io,'(a)')'   the rank of ARRAY, and a shape similar to that of ARRAY with'
write(io,'(a)')'   dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_iall'
write(io,'(a)')'     integer(1) :: a(2)'
write(io,'(a)')''
write(io,'(a)')'     a(1) = b''00100100'''
write(io,'(a)')'     a(2) = b''01101010'''
write(io,'(a)')''
write(io,'(a)')'     ! prints 00100000'
write(io,'(a)')'     print ''(b8.8)'', iall(a)'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iany]], [[iparity]], [[iand]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iand(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = iand(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Bitwise logical AND.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   J  - The type shall be INTEGER, of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the'
write(io,'(a)')'   arguments. (If the argument kinds differ, it is of the same kind as'
write(io,'(a)')'   the larger argument.)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_iand'
write(io,'(a)')'      integer :: a, b'
write(io,'(a)')'      data a / z''f'' /, b / z''3'' /'
write(io,'(a)')'      write (*,*) iand(a, b)'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ior]], [[ieor]], [[ibits]], [[ibset]], [[ibclr]],'
write(io,'(a)')'   [[not]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iany(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise or of array elements'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = iany(array[, mask])'
write(io,'(a)')'* result = iany(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reduces with bitwise or (inclusive or) the elements of ARRAY along'
write(io,'(a)')'   dimension DIM if the corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ARRAY  - Shall be an array of type INTEGER'
write(io,'(a)')'  DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'  in the range from "1" to "n", where "n" equals the rank of ARRAY.'
write(io,'(a)')'  MASK  - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'  scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the bitwise OR of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank "n-1", where "n"'
write(io,'(a)')'   equals the rank of ARRAY, and a shape similar to that of ARRAY'
write(io,'(a)')'   with dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_iany'
write(io,'(a)')'     integer(1) :: a(2)'
write(io,'(a)')''
write(io,'(a)')'     a(1) = b''00100100'''
write(io,'(a)')'     a(2) = b''01101010'''
write(io,'(a)')''
write(io,'(a)')'     ! prints 01101110'
write(io,'(a)')'     print ''(b8.8)'', iany(a)'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iparity]], [[iall]], [[ior]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ibclr(3f) - [INTRINSIC:BIT MANIPULATION] Clear bit'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ibclr(i, pos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IBCLR returns the value of I with the bit at position'
write(io,'(a)')'   POS set to zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ibits]], [[ibset]], [[iand]], [[ior]], [[ieor]],'
write(io,'(a)')'   [[mvbits]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ibits(3f) - [INTRINSIC:BIT MANIPULATION] Bit extraction'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ibits(i, pos, len)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IBITS extracts a field of length LEN from I,'
write(io,'(a)')'   starting from bit position POS and extending left for LEN'
write(io,'(a)')'   bits. The result is right-justified and the remaining bits are'
write(io,'(a)')'   zeroed. The value of pos+len must be less than or equal to the'
write(io,'(a)')'   value bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER.'
write(io,'(a)')'   LEN  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type INTEGER and of the same kind as'
write(io,'(a)')'I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bit_size]], [[ibclr]], [[ibset]],'
write(io,'(a)')'   [[iand]], [[ior]], [[ieor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ibset(3f) - [INTRINSIC:BIT MANIPULATION] Set bit'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ibset(i, pos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IBSET returns the value of I with the bit at position'
write(io,'(a)')'   POS set to one.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as'
write(io,'(a)')'I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[btest]], [[ibclr]], [[ibits]], [[iand]], [[ior]], [[ieor]],'
write(io,'(a)')'   [[mvbits]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ichar(3f) - [INTRINSIC:CHARACTER] Character-to-integer conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ichar(c [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ichar(c) returns the code for the character in the first character'
write(io,'(a)')'   position of C in the system''s native character set.'
write(io,'(a)')'   The correspondence between characters and their codes is not necessarily'
write(io,'(a)')'   the same across different GNU Fortran implementations.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   C  - Shall be a scalar CHARACTER, with intent(in)'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_ichar'
write(io,'(a)')'      integer i'
write(io,'(a)')'      i = ichar('' '')'
write(io,'(a)')'    end program test_ichar'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   No intrinsic exists to convert between a numeric value and a formatted'
write(io,'(a)')'   character string representation -- for instance, given the'
write(io,'(a)')'   CHARACTER value ''154'', obtaining an INTEGER or'
write(io,'(a)')'   REAL value with the value 154, or vice versa. Instead, this'
write(io,'(a)')'   functionality is provided by internal-file I/O, as in the following'
write(io,'(a)')'   example:'
write(io,'(a)')''
write(io,'(a)')'    program read_val'
write(io,'(a)')'      integer value'
write(io,'(a)')'      character(len=10) string, string2'
write(io,'(a)')'      string = ''154'''
write(io,'(a)')''
write(io,'(a)')'      ! Convert a string to a numeric value'
write(io,'(a)')'      read (string,''(I10)'') value'
write(io,'(a)')'      print *, value'
write(io,'(a)')''
write(io,'(a)')'      ! Convert a value to a formatted string'
write(io,'(a)')'      write (string2,''(I10)'') value'
write(io,'(a)')'      print *, string2'
write(io,'(a)')'    end program read_val'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[achar]], [[char]], [[iachar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ieor(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical exclusive or'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ieor(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IEOR returns the bitwise Boolean exclusive-OR of I and J.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   J  - The type shall be INTEGER, of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the arguments. (If the'
write(io,'(a)')'   argument kinds differ, it is of the same kind as the larger argument.)'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ior]], [[iand]], [[ibits]], [[ibset]],'
write(io,'(a)')'   [[ibclr]], [[not]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     image_index(3f) - [INTRINSIC] Cosubscript to image index conversion'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = image_index(coarray, sub)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the image index belonging to a cosubscript.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   COARRAY  - Coarray of any type.'
write(io,'(a)')'   SUB      - default integer rank-1 array of a size equal to the corank of COARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Scalar default integer with the value of the image index which'
write(io,'(a)')'   corresponds to the cosubscripts. For invalid cosubscripts the result'
write(io,'(a)')'   is zero.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   integer :: array[2,-1:4,8,*]'
write(io,'(a)')'   ! Writes  28 (or 0 if there are fewer than 28 images)'
write(io,'(a)')'   write (*,*) image_index(array, [2,0,3,1])'
write(io,'(a)')'   end'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[this_image]], [[num_images]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     index(3f) - [INTRINSIC:CHARACTER] Position of a substring within a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = index(string, substring [, back [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the position of the start of the first occurrence of string'
write(io,'(a)')'   SUBSTRING as a substring in STRING, counting from one. If'
write(io,'(a)')'   SUBSTRING is not present in STRING, zero is returned. If the'
write(io,'(a)')'   BACK argument is present and true, the return value is the start of'
write(io,'(a)')'   the last occurrence rather than the first.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'* STRING  - Shall be a scalar CHARACTER, with intent(in)'
write(io,'(a)')'* SUBSTRING  - Shall be a scalar CHARACTER, with intent(in)'
write(io,'(a)')'* BACK  - (Optional) Shall be a scalar LOGICAL, with intent(in)'
write(io,'(a)')'* KIND  - (Optional) An INTEGER initialization expression indicating'
write(io,'(a)')'  the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND.'
write(io,'(a)')'   If KIND is absent, the return value is of default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[scan]], [[verify]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     int(3f) - [INTRINSIC:NUMERIC] Convert to integer type'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = int(a [, kind))'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'Convert to integer type'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A     - Shall be of type INTEGER,'
write(io,'(a)')'           REAL, or COMPLEX.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   These functions return a INTEGER variable or array under'
write(io,'(a)')'   the following rules:'
write(io,'(a)')''
write(io,'(a)')' 1. If A is of type INTEGER, int(a) = a'
write(io,'(a)')''
write(io,'(a)')' 2. If A is of type REAL and |a| < 1, int(a) equals 0.'
write(io,'(a)')'    If |a| >= 1, then int(a) equals the largest integer that'
write(io,'(a)')'    does not exceed the range of A and whose sign is the same as the'
write(io,'(a)')'    sign of A.'
write(io,'(a)')''
write(io,'(a)')' 3. If A is of type COMPLEX, rule 2 is applied to the real part of A.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_int'
write(io,'(a)')'      integer :: i = 42'
write(io,'(a)')'      complex :: z = (-3.7, 1.0)'
write(io,'(a)')'      print *, int(i)'
write(io,'(a)')'      print *, int(z), int(z,8)'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ior(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical inclusive or'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ior(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IOR returns the bitwise Boolean inclusive-OR of I and J.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   J  - The type shall be INTEGER, of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the arguments. (If the'
write(io,'(a)')'   argument kinds differ, it is of the same kind as the larger argument.)'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ieor]], [[iand]], [[ibits]], [[ibset]],'
write(io,'(a)')'   [[ibclr]], [[not]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iparity(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise exclusive or of array elements'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = iparity(array[, mask])'
write(io,'(a)')'* result = iparity(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reduces with bitwise XOR (exclusive OR) the elements of ARRAY'
write(io,'(a)')'   along dimension DIM if the corresponding element in MASK is'
write(io,'(a)')'   TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER'
write(io,'(a)')'   DIM    - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'            in the range from "1" to "n", where "n" equals the rank of ARRAY.'
write(io,'(a)')'   MASK   - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'            scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the bitwise XOR of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank "n-1", where "n" equals'
write(io,'(a)')'   the rank of ARRAY, and a shape similar to that of ARRAY with'
write(io,'(a)')'   dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_iparity'
write(io,'(a)')'     integer, dimension(2) :: a'
write(io,'(a)')''
write(io,'(a)')'     a(1) = b''00100100'''
write(io,'(a)')'     a(2) = b''01101010'''
write(io,'(a)')''
write(io,'(a)')'     ! prints 01001110'
write(io,'(a)')'     print ''(b8.8)'', iparity(a)'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iany]], [[iall]], [[ieor]], [[parity]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     is_contiguous(3f) - [INTRINSIC:INQUIRY] test if object is contigous'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = is_contigious(A)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   True if and only if an object is contiguous.'
write(io,'(a)')''
write(io,'(a)')'   An object is contiguous if it is'
write(io,'(a)')'      (1)     an object with the CONTIGUOUS attribute,'
write(io,'(a)')'      (2)     a nonpointer whole array that is not assumed-shape,'
write(io,'(a)')'      (3)     an assumed-shape array that is argument associated with an array that is contiguous,'
write(io,'(a)')'      (4)     an array allocated by an ALLOCATE statement,'
write(io,'(a)')'      (5)     a pointer associated with a contiguous target, or'
write(io,'(a)')'      (6)     a nonzero-sized array section provided that'
write(io,'(a)')'          (a)   its base object is contiguous,'
write(io,'(a)')'          (b)   it does not have a vector subscript,'
write(io,'(a)')'          (c)   the elements of the section, in array element order, are a subset of the base object elements'
write(io,'(a)')'                that are consecutive in array element order,'
write(io,'(a)')'          (d)   if the array is of type character and a substring-range appears, the substring-range specifies all'
write(io,'(a)')'                of the characters of the parent-string,'
write(io,'(a)')'          (e)   only its final part-ref has nonzero rank, and'
write(io,'(a)')'          (f)   it is not the real or imaginary part of an array of type complex.'
write(io,'(a)')''
write(io,'(a)')'   An object is not contiguous if it is an array subobject, and'
write(io,'(a)')''
write(io,'(a)')'      o the object has two or more elements,'
write(io,'(a)')'      o the elements of the object in array element order are not consecutive in the elements of the base object,'
write(io,'(a)')'      o the object is not of type character with length zero, and'
write(io,'(a)')'      o the object is not of a derived type that has no ultimate components other than zero-sized arrays and'
write(io,'(a)')'      o characters with length zero.'
write(io,'(a)')''
write(io,'(a)')'   It is processor-dependent whether any other object is contiguous.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'    A         may be of any type. It shall be an array. If it is a'
write(io,'(a)')'              pointer it shall be associated.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'    Result    of type Default logical scalar.'
write(io,'(a)')'              The result has the value true if A is contiguous, and false otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_is_contiguous'
write(io,'(a)')'    REAL, DIMENSION (1000, 1000), TARGET :: A'
write(io,'(a)')'    REAL, DIMENSION (:, :), POINTER       :: IN, OUT'
write(io,'(a)')'    IN => A              ! Associate IN with target A'
write(io,'(a)')'    OUT => A(1:1000:2,:) ! Associate OUT with subset of target A'
write(io,'(a)')''
write(io,'(a)')'    write(*,*)''IN is '',IS_CONTIGUOUS(IN)'
write(io,'(a)')'    write(*,*)''OUT is '',IS_CONTIGUOUS(OUT)'
write(io,'(a)')''
write(io,'(a)')'    end program test_is_contiguous'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     is_iostat_end(3f) - [INTRINSIC] Test for end-of-file value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = is_iostat_end(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   is_iostat_end tests whether an variable has the value of the I/O'
write(io,'(a)')'   status "end of file". The function is equivalent to comparing the'
write(io,'(a)')'   variable with the iostat_end parameter of the intrinsic module'
write(io,'(a)')'   [[iso_fortran_env]].'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of the type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns a LOGICAL of the default kind, which .true. if'
write(io,'(a)')'   I has the value which indicates an end of file condition for'
write(io,'(a)')'   IOSTAT= specifiers, and is .false. otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program iostat'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      integer :: stat, i'
write(io,'(a)')'      open(88, file=''test.dat'')'
write(io,'(a)')'      read(88, *, iostat=stat) i'
write(io,'(a)')'      if(is_iostat_end(stat)) stop ''end of file'''
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     is_iostat_eor(3f) - [INTRINSIC] Test for end-of-record value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = is_iostat_eor(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   is_iostat_eor tests whether an variable has the value of the I/O'
write(io,'(a)')'   status "end of record". The function is equivalent to comparing the'
write(io,'(a)')'   variable with the iostat_eor parameter of the intrinsic module'
write(io,'(a)')'   [[iso_fortran_env]].'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of the type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns a LOGICAL of the default kind, which .true. if'
write(io,'(a)')'   I has the value which indicates an end of file condition for'
write(io,'(a)')'   iostat= specifiers, and is .false. otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program iostat'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      integer :: stat, i(50)'
write(io,'(a)')'      open(88, file=''test.dat'', form=''unformatted'')'
write(io,'(a)')'      read(88, iostat=stat) i'
write(io,'(a)')'      if(is_iostat_eor(stat)) stop ''end of record'''
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'Fortran 2003 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ishft(3f) - [INTRINSIC:BIT MANIPULATION] Shift bits'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ishft(i, shift)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ISHFT returns a value corresponding to I with all of the'
write(io,'(a)')'   bits shifted SHIFT places. A value of SHIFT greater than'
write(io,'(a)')'   zero corresponds to a left shift, a value of zero corresponds to no'
write(io,'(a)')'   shift, and a value less than zero corresponds to a right shift. If the'
write(io,'(a)')'   absolute value of SHIFT is greater than bit_size(i), the'
write(io,'(a)')'   value is undefined. Bits shifted out from the left end or right end are'
write(io,'(a)')'   lost; zeros are shifted in from the opposite end.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ishftc]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ishftc(3f) - [INTRINSIC:BIT MANIPULATION] Shift bits circularly'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ishftc(i, shift [, size])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ISHFTC returns a value corresponding to I with the'
write(io,'(a)')'   rightmost SIZE bits shifted circularly SHIFT places; that'
write(io,'(a)')'   is, bits shifted out one end are shifted into the opposite end. A value'
write(io,'(a)')'   of SHIFT greater than zero corresponds to a left shift, a value of'
write(io,'(a)')'   zero corresponds to no shift, and a value less than zero corresponds to'
write(io,'(a)')'   a right shift. The absolute value of SHIFT must be less than'
write(io,'(a)')'   SIZE. If the SIZE argument is omitted, it is taken to be'
write(io,'(a)')'   equivalent to bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I      - The type shall be INTEGER.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')'   SIZE   - (Optional) The type shall be INTEGER;'
write(io,'(a)')'            the value must be greater than zero and less than or equal to'
write(io,'(a)')'            bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ishft]]'
write(io,'(a)')''
!>
!!##NAME
!!    IS_IOSTAT_END(3f) - [INTRINSIC] True if and only if a value indicates an end-of-file condition.
!!##SYNOPSIS
!!
!!     logical IS_IOSTAT_END (I)
!!     integer,intent(in) :: I
!!
!!##DESCRIPTION
!!    True if and only if a value indicates an end-of-file condition
!!
!!##ARGUMENT
!!    I     integer status value obtained from READ(3f)
!!
!!##RESULT
!!    A default logical value is returned.
!!    The result has the value true if and only if I is a value for the
!!    scalar-int-variable in an IOSTAT= specifier that would
!!    indicate an end-of-file condition.
!!
!!##CLASS
!!    Elemental function.
!===================================================================================================================================
!>
!!##NAME
!!    IS_IOSTAT_EOR(3f) - [INTRINSIC] True if and only if a value indicates an end-of-record condition.
!!##SYNOPSIS
!!
!!    logical IS_IOSTAT_EOR (I)
!!
!!     integer,intent(in) :: I
!!##DESCRIPTION
!!    True if and only if a value indicates an end-of-record condition.
!!
!!##ARGUMENT
!!    I    shall be of type integer.
!!
!!##RESULT
!!    Default logical.  The result has the value true if and only if I is
!!    a value for the scalar-int-variable in an IOSTAT= specifier
!!    that would indicate an end-of-record condition.
!!
!!##CLASS
!!    Elemental function.
!===================================================================================================================================
write(io,'(a)')'NAME'
write(io,'(a)')'     kind(3f) - [INTRINSIC] Kind of an entity'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   k = kind(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   kind(x) returns the kind value of the entity X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - Shall be of type LOGICAL, INTEGER,'
write(io,'(a)')'        REAL, COMPLEX or CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is a scalar of type INTEGER and of the default'
write(io,'(a)')'   integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_kind'
write(io,'(a)')'      integer,parameter :: kc = kind('' '')'
write(io,'(a)')'      integer,parameter :: kl = kind(.true.)'
write(io,'(a)')''
write(io,'(a)')'    print *, "The default character kind is ", kc'
write(io,'(a)')'      print *, "The default logical kind is ", kl'
write(io,'(a)')'    end program test_kind'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     lbound(3f) - [INTRINSIC:ARRAY INQUIRY] Lower dimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lbound(array [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the lower bounds of an array, or a single lower bound'
write(io,'(a)')'   along the DIM dimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   ARRAY  - Shall be an array, of any type.'
write(io,'(a)')'   DIM  - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')'   If DIM is absent, the result is an array of the lower bounds of'
write(io,'(a)')'   ARRAY. If DIM is present, the result is a scalar'
write(io,'(a)')'   corresponding to the lower bound of the array along that dimension. If'
write(io,'(a)')'   ARRAY is an expression rather than a whole array or array'
write(io,'(a)')'   structure component, or if it has a zero extent along the relevant'
write(io,'(a)')'   dimension, the lower bound is taken to be 1.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[ubound]], [[lcobound]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     lcobound(3f) - [INTRINSIC] Lower codimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lcobound(coarray [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the lower bounds of a coarray, or a single lower cobound'
write(io,'(a)')'   along the DIM codimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'  ARRAY  - Shall be an coarray, of any type.'
write(io,'(a)')'  DIM  - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'  KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'  indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If KIND is'
write(io,'(a)')'   absent, the return value is of default integer kind. If DIM is'
write(io,'(a)')'   absent, the result is an array of the lower cobounds of COARRAY. If'
write(io,'(a)')'   DIM is present, the result is a scalar corresponding to the lower'
write(io,'(a)')'   cobound of the array along that codimension.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[ucobound]], [[lbound]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     leadz(3f) - [INTRINSIC:BIT INQUIRY] Number of leading zero bits of an integer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = leadz(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   LEADZ returns the number of leading zero bits of an integer.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The type of the return value is the default INTEGER.'
write(io,'(a)')'   If all the bits of I are zero, the result value is bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_leadz'
write(io,'(a)')'      write (*,*) leadz(1)  ! prints 8 if bitsize(i) has the value 32'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[bit_size]], [[popcnt]], [[poppar]], [[trailz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     len(3f) - [INTRINSIC:CHARACTER] Length of a character entity'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   l = len(string [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the length of a character string. If STRING is an array,'
write(io,'(a)')'   the length of an element of STRING is returned. Note that'
write(io,'(a)')'   STRING need not be defined when this intrinsic is invoked, since'
write(io,'(a)')'   only the length, not the content, of STRING is needed.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   STRING  - Shall be a scalar or array of type'
write(io,'(a)')'             CHARACTER, with intent(in)'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[len_trim]], [[adjustl]], [[adjustr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     len_trim(3f) - [INTRINSIC:CHARACTER] Length of a character entity without trailing blank characters'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = len_trim(string [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the length of a character string, ignoring any trailing blanks.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   STRING  - Shall be a scalar of type CHARACTER,'
write(io,'(a)')'             with intent(in)'
write(io,'(a)')'   KIND    - (Optional) An INTEGER initialization'
write(io,'(a)')'             expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[len]], [[adjustl]], [[adjustr]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     lge(3f) - [INTRINSIC:CHARACTER] Lexical greater than or equal'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lge(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically greater than or equal to'
write(io,'(a)')'   another string, where the two strings are interpreted as containing'
write(io,'(a)')'   ASCII character codes. If the String A and String B are not the same'
write(io,'(a)')'   length, the shorter is compared as if spaces were appended to it to form'
write(io,'(a)')'   a value that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a >= string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lgt]], [[lle]], [[llt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     lgt(3f) - [INTRINSIC:CHARACTER] Lexical greater than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lgt(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically greater than another string,'
write(io,'(a)')'   where the two strings are interpreted as containing ASCII character'
write(io,'(a)')'   codes. If the String A and String B are not the same length, the'
write(io,'(a)')'   shorter is compared as if spaces were appended to it to form a value'
write(io,'(a)')'   that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a > string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lge]], [[lle]], [[llt]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     lle(3f) - [INTRINSIC:CHARACTER] Lexical less than or equal'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lle(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically less than or equal to another'
write(io,'(a)')'   string, where the two strings are interpreted as containing ASCII'
write(io,'(a)')'   character codes. If the String A and String B are not the same length,'
write(io,'(a)')'   the shorter is compared as if spaces were appended to it to form a value'
write(io,'(a)')'   that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a < string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lge]], [[lgt]], [[llt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     llt(3f) - [INTRINSIC:CHARACTER] Lexical less than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = llt(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically less than another string,'
write(io,'(a)')'   where the two strings are interpreted as containing ASCII character'
write(io,'(a)')'   codes. If the String A and String B are not the same length, the'
write(io,'(a)')'   shorter is compared as if spaces were appended to it to form a value'
write(io,'(a)')'   that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a <= string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lge]], [[lgt]], [[lle]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     LOG(3f) - [INTRINSIC:MATHEMATICS] Logarithm function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = LOG(X)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   LOG(X) computes the natural logarithm of X, i.e. the logarithm to the base "e".'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type REAL or COMPLEX.'
write(io,'(a)')'   The kind type parameter is the same as X.'
write(io,'(a)')'   If X is COMPLEX, the imaginary part OMEGA is in the range'
write(io,'(a)')''
write(io,'(a)')'   -PI < OMEGA <= PI.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_log'
write(io,'(a)')'     real :: x = 2.7182818284590451_8'
write(io,'(a)')'     complex :: z = (1.0, 2.0)'
write(io,'(a)')'     x = log(x)    ! will yield (approximately) 1'
write(io,'(a)')'     z = log(z)'
write(io,'(a)')'   end program test_log'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     LOG10(3f) - [INTRINSIC:MATHEMATICS] Base 10 logarithm function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = LOG10(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   LOG10(X) computes the base 10 logarithm of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type REAL or COMPLEX.'
write(io,'(a)')'   The kind type parameter is the same as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_log10'
write(io,'(a)')'      real(8) :: x = 10.0_8'
write(io,'(a)')'      x = log10(x)'
write(io,'(a)')'    end program test_log10'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     log_gamma(3f) - [INTRINSIC:MATHEMATICS] Logarithm of the Gamma function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'x = log_gamma(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   log_gamma(x) computes the natural logarithm of the absolute value of the [[Gamma function]].'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL and neither zero nor a negative integer.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL of the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_log_gamma'
write(io,'(a)')'     real :: x = 1.0'
write(io,'(a)')'     x = log_gamma(x) ! returns 0.0'
write(io,'(a)')'   end program test_log_gamma'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Gamma function: [[gamma]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     logical(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = logical(l [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Converts one kind of LOGICAL variable to another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   L  - The type shall be LOGICAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a LOGICAL value equal to L, with a'
write(io,'(a)')'   kind corresponding to KIND, or of the default logical kind if'
write(io,'(a)')'   KIND is not given.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[int]], [[real]], [[cmplx]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     maskl(3f) - [INTRINSIC] Left justified mask'
write(io,'(a)')''
write(io,'(a)')'   result = maskl(i[, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   maskl(i[, kind]) has its leftmost I bits set to 1, and the'
write(io,'(a)')'   remaining bits set to 0.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')'   KIND  - Shall be a scalar constant expression of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER. If KIND is present, it'
write(io,'(a)')'   specifies the kind value of the return type; otherwise, it is of the'
write(io,'(a)')'   default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[maskr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maskr(3f) - [INTRINSIC] Right justified mask'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maskr(i[, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   maskr(i[, kind]) has its rightmost I bits set to 1, and the'
write(io,'(a)')'   remaining bits set to 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')'   KIND  - Shall be a scalar constant expression of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER. If KIND is present, it'
write(io,'(a)')'   specifies the kind value of the return type; otherwise, it is of the'
write(io,'(a)')'   default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[maskl]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     matmul(3f) - [INTRINSIC] matrix multiplication'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = matmul(matrix_a, matrix_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Performs a matrix multiplication on numeric or logical arguments.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   matrix_a  - An array of INTEGER,'
write(io,'(a)')'               REAL, COMPLEX, or LOGICAL type, with a rank of'
write(io,'(a)')'               one or two.'
write(io,'(a)')'   matrix_b  - An array of INTEGER,'
write(io,'(a)')'               REAL, or COMPLEX type if matrix_a is of a numeric'
write(io,'(a)')'               type; otherwise, an array of LOGICAL type. The rank shall be one'
write(io,'(a)')'               or two, and the first (or only) dimension of matrix_b shall be'
write(io,'(a)')'               equal to the last (or only) dimension of matrix_a.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The matrix product of matrix_a and matrix_b. The type and'
write(io,'(a)')'kind of the result follow the usual type and kind promotion rules, as'
write(io,'(a)')'for the * or .and. operators.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     max(3f) - [INTRINSIC:NUMERIC] Maximum value of an argument list'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = max(a1, a2 [, a3 [, ...]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the argument with the largest (most positive) value.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A1        - The type shall be INTEGER or'
write(io,'(a)')'REAL.'
write(io,'(a)')'   A2, A3, ... - An expression of the same type and kind'
write(io,'(a)')'as A1.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value corresponds to the maximum value among the arguments,'
write(io,'(a)')'   and has the same type and kind as the first argument.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[maxloc]] [[maxval]], [[min]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maxexponent(3f) - [INTRINSIC] Maximum exponent of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maxexponent(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   maxexponent(x) returns the maximum exponent in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program exponents'
write(io,'(a)')'      real(kind=4) :: x'
write(io,'(a)')'      real(kind=8) :: y'
write(io,'(a)')''
write(io,'(a)')'      print *, minexponent(x), maxexponent(x)'
write(io,'(a)')'      print *, minexponent(y), maxexponent(y)'
write(io,'(a)')'    end program exponents'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maxloc(3f) - [INTRINSIC] Location of the maximum value within an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maxloc(array, dim [, mask])'
write(io,'(a)')'   result = maxloc(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the location of the element in the array with the maximum'
write(io,'(a)')'   value, or, if the DIM argument is supplied, determines the'
write(io,'(a)')'   locations of the maximum element along each row of the array in the'
write(io,'(a)')'   DIM direction. If MASK is present, only the elements for'
write(io,'(a)')'   which MASK is .true. are considered. If more than one'
write(io,'(a)')'   element in the array has the maximum value, the location returned is'
write(io,'(a)')'   that of the first such element in array element order. If the array has'
write(io,'(a)')'   zero size, or all of the elements of MASK are .false., then'
write(io,'(a)')'   the result is an array of zeroes. Similarly, if DIM is supplied'
write(io,'(a)')'   and all of the elements of MASK along a given row are zero, the'
write(io,'(a)')'   result value for that row is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER, REAL, or CHARACTER.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar of type'
write(io,'(a)')'            INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'            inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL, and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, the result is a rank-one array with a length'
write(io,'(a)')'   equal to the rank of ARRAY. If DIM is present, the result'
write(io,'(a)')'   is an array with a rank one less than the rank of ARRAY, and a'
write(io,'(a)')'   size corresponding to the size of ARRAY with the DIM'
write(io,'(a)')'   dimension removed. If DIM is present and ARRAY has a rank'
write(io,'(a)')'   of one, the result is a scalar. In all cases, the result is of default'
write(io,'(a)')'   INTEGER type.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[max]], [[maxval]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maxval(3f) - [INTRINSIC] determines the maximum value in an array or row'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maxval(array, dim [, mask])'
write(io,'(a)')'   result = maxval(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the maximum value of the elements in an array value, or, if'
write(io,'(a)')'   the DIM argument is supplied, determines the maximum value along'
write(io,'(a)')'   each row of the array in the DIM direction. If MASK is'
write(io,'(a)')'   present, only the elements for which MASK is .true. are'
write(io,'(a)')'   considered. If the array has zero size, or all of the elements of'
write(io,'(a)')'   MASK are .false., then the result is the most negative'
write(io,'(a)')'   number of the type and kind of ARRAY if ARRAY is numeric, or'
write(io,'(a)')'   a string of nulls if ARRAY is of character type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY - Shall be an array of type INTEGER,'
write(io,'(a)')'   REAL, or CHARACTER.'
write(io,'(a)')'   DIM - (Optional) Shall be a scalar of type'
write(io,'(a)')'   INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'   inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK  - Shall be an array of type LOGICAL,'
write(io,'(a)')'   and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, or if ARRAY has a rank of one, the result'
write(io,'(a)')'   is a scalar. If DIM is present, the result is an array with a'
write(io,'(a)')'   rank one less than the rank of ARRAY, and a size corresponding to'
write(io,'(a)')'   the size of ARRAY with the DIM dimension removed. In all'
write(io,'(a)')'   cases, the result is of the same type and kind as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[max]], [[maxloc]]'
write(io,'(a)')''
write(io,'(a)')'CATEGORY'
write(io,'(a)')''
write(io,'(a)')'   intrinsics'
write(io,'(a)')'NAME'
write(io,'(a)')'     merge(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Merge variables'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = merge(tsource, fsource, mask)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Select values from two arrays according to a logical mask. The result'
write(io,'(a)')'   is equal to TSOURCE if MASK is .true., or equal to'
write(io,'(a)')'   FSOURCE if it is .false..'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   TSOURCE  - May be of any type.'
write(io,'(a)')'   FSOURCE  - Shall be of the same type and type parameters'
write(io,'(a)')'              as TSOURCE.'
write(io,'(a)')'   MASK  - Shall be of type LOGICAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type and type parameters as TSOURCE.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     merge_bits(3f) - [INTRINSIC:BIT MANIPULATION] Merge of bits under mask'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = merge_bits(i, j, mask)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   merge_bits(i, j, mask) merges the bits of I and J as determined by'
write(io,'(a)')'   the mask. The k-th bit of the result is equal to the k-th bit of'
write(io,'(a)')'   I if the k-th bit of MASK is 1; it is equal to the k-th bit of'
write(io,'(a)')'   J otherwise.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of type INTEGER.'
write(io,'(a)')'  J  - Shall be of type INTEGER and of the same kind as I.'
write(io,'(a)')'  MASK  - Shall be of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The result is of the same type and kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     min(3f) - [INTRINSIC:NUMERIC] Minimum value of an argument list'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = min(a1, a2 [, a3, ...])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the argument with the smallest (most negative) value.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A1           - The type shall be INTEGER or REAL.'
write(io,'(a)')'   A2, A3, ...  - An expression of the same type and kind as A1.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value corresponds to the minimum value among the arguments,'
write(io,'(a)')'   and has the same type and kind as the first argument.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[max]], [[minloc]], [[minval]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     minexponent(3f) - [INTRINSIC] Minimum exponent of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = minexponent(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   minexponent(x) returns the minimum exponent in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'See [[maxexponent]] for an example.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     minloc(3f) - [INTRINSIC] Location of the minimum value within an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = minloc(array, dim [, mask])'
write(io,'(a)')'   result = minloc(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the location of the element in the array with the minimum'
write(io,'(a)')'   value, or, if the DIM argument is supplied, determines the'
write(io,'(a)')'   locations of the minimum element along each row of the array in the'
write(io,'(a)')'   DIM direction. If MASK is present, only the elements for'
write(io,'(a)')'   which MASK is .true. are considered. If more than one'
write(io,'(a)')'   element in the array has the minimum value, the location returned is'
write(io,'(a)')'   that of the first such element in array element order. If the array has'
write(io,'(a)')'   zero size, or all of the elements of MASK are .false., then'
write(io,'(a)')'   the result is an array of zeroes. Similarly, if DIM is supplied'
write(io,'(a)')'   and all of the elements of MASK along a given row are zero, the'
write(io,'(a)')'   result value for that row is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER, REAL, or CHARACTER.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar of type'
write(io,'(a)')'            INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'            inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL,'
write(io,'(a)')'            and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, the result is a rank-one array with a length'
write(io,'(a)')'   equal to the rank of ARRAY. If DIM is present, the result'
write(io,'(a)')'   is an array with a rank one less than the rank of ARRAY, and a'
write(io,'(a)')'   size corresponding to the size of ARRAY with the DIM'
write(io,'(a)')'   dimension removed. If DIM is present and ARRAY has a rank'
write(io,'(a)')'   of one, the result is a scalar. In all cases, the result is of default'
write(io,'(a)')'   INTEGER type.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[min]], [[minval]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     minval(3f) - [INTRINSIC] Minimum value of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = minval(array, dim [, mask])'
write(io,'(a)')'   result = minval(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the minimum value of the elements in an array value, or, if'
write(io,'(a)')'   the DIM argument is supplied, determines the minimum value along'
write(io,'(a)')'   each row of the array in the DIM direction. If MASK is'
write(io,'(a)')'   present, only the elements for which MASK is .true. are'
write(io,'(a)')'   considered. If the array has zero size, or all of the elements of'
write(io,'(a)')'   MASK are .false., then the result is huge(array) if'
write(io,'(a)')'   ARRAY is numeric, or a string of char(255) characters if'
write(io,'(a)')'   ARRAY is of character type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER,'
write(io,'(a)')'            REAL, or CHARACTER.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar of type'
write(io,'(a)')'            INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'            inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL,'
write(io,'(a)')'            and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, or if ARRAY has a rank of one, the result'
write(io,'(a)')'   is a scalar. If DIM is present, the result is an array with a'
write(io,'(a)')'   rank one less than the rank of ARRAY, and a size corresponding to'
write(io,'(a)')'   the size of ARRAY with the DIM dimension removed. In all'
write(io,'(a)')'   cases, the result is of the same type and kind as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[min]], [[minloc]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     mod(3f) - [INTRINSIC:NUMERIC] Remainder function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = mod(a, p)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   mod(a,p) computes the remainder of the division of A by P.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - Shall be a scalar of type INTEGER or REAL.'
write(io,'(a)')'   P  - Shall be a scalar of the same type and kind as A and not equal to zero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is the result of a - (int(a/p) * p). The type'
write(io,'(a)')'   and kind of the return value is the same as that of the arguments. The'
write(io,'(a)')'   returned value has the same sign as A and a magnitude less than the'
write(io,'(a)')'   magnitude of P.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_mod'
write(io,'(a)')'     print *, mod(17,3)         ! yields 2'
write(io,'(a)')'     print *, mod(17.5,5.5)     ! yields 1.0'
write(io,'(a)')'     print *, mod(17.5d0,5.5)   ! yields 1.0d0'
write(io,'(a)')'     print *, mod(17.5,5.5d0)   ! yields 1.0d0'
write(io,'(a)')''
write(io,'(a)')'     print *, mod(-17,3)        ! yields -2'
write(io,'(a)')'     print *, mod(-17.5,5.5)    ! yields -1.0'
write(io,'(a)')'     print *, mod(-17.5d0,5.5)  ! yields -1.0d0'
write(io,'(a)')'     print *, mod(-17.5,5.5d0)  ! yields -1.0d0'
write(io,'(a)')''
write(io,'(a)')'     print *, mod(17,-3)        ! yields 2'
write(io,'(a)')'     print *, mod(17.5,-5.5)    ! yields 1.0'
write(io,'(a)')'     print *, mod(17.5d0,-5.5)  ! yields 1.0d0'
write(io,'(a)')'     print *, mod(17.5,-5.5d0)  ! yields 1.0d0'
write(io,'(a)')'   end program test_mod'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[modulo]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     modulo(3f) - [INTRINSIC:NUMERIC] Modulo function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = modulo(a, p)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   modulo(a,p) computes the A modulo P.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - Shall be a scalar of type INTEGER or REAL.'
write(io,'(a)')'  P  - Shall be a scalar of the same type and kind as A. It shall'
write(io,'(a)')'  not be zero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The type and kind of the result are those of the arguments.'
write(io,'(a)')''
write(io,'(a)')'* If A and P are of type INTEGER:'
write(io,'(a)')'  modulo(a,p) has the value of a - floor (real(a) / real(p)) * p.'
write(io,'(a)')'* If A and P are of type REAL:'
write(io,'(a)')'  modulo(a,p) has the value of a - floor (a / p) * p.'
write(io,'(a)')''
write(io,'(a)')'   The returned value has the same sign as P and a magnitude less than'
write(io,'(a)')'   the magnitude of P.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_modulo'
write(io,'(a)')'     print *, modulo(17,3)        ! yields 2'
write(io,'(a)')'     print *, modulo(17.5,5.5)    ! yields 1.0'
write(io,'(a)')''
write(io,'(a)')'     print *, modulo(-17,3)       ! yields 1'
write(io,'(a)')'     print *, modulo(-17.5,5.5)   ! yields 4.5'
write(io,'(a)')''
write(io,'(a)')'     print *, modulo(17,-3)       ! yields -1'
write(io,'(a)')'     print *, modulo(17.5,-5.5)   ! yields -4.5'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[mod]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     move_alloc(3f) - [INTRINSIC] Move allocation from one object to another'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call move_alloc(src, dest)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   move_alloc(src, dest) moves the allocation from SRC to DEST.'
write(io,'(a)')'   SRC will become deallocated in the process.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SRC  - ALLOCATABLE, intent(inout), may be of any type and kind.'
write(io,'(a)')'   DEST  - ALLOCATABLE, intent(out), shall be of the same type, kind and rank as SRC.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_move_alloc'
write(io,'(a)')'       integer, allocatable :: a(:), b(:)'
write(io,'(a)')''
write(io,'(a)')'       allocate(a(3))'
write(io,'(a)')'       a = [ 1, 2, 3 ]'
write(io,'(a)')'       call move_alloc(a, b)'
write(io,'(a)')'       print *, allocated(a), allocated(b)'
write(io,'(a)')'       print *, b'
write(io,'(a)')'   end program test_move_alloc'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Pure subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[allocated]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     mvbits(3f) - [INTRINSIC:BIT MANIPULATION] Move bits from one integer to another'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call mvbits(from, frompos, len, to, topos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Moves LEN bits from positions FROMPOS through'
write(io,'(a)')'   frompos+len-1 of FROM to positions TOPOS through'
write(io,'(a)')'   topos+len-1 of TO. The portion of argument TO not'
write(io,'(a)')'   affected by the movement of bits is unchanged. The values of'
write(io,'(a)')'   frompos+len-1 and topos+len-1 must be less than'
write(io,'(a)')'   bit_size(from).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   FROM  - The type shall be INTEGER.'
write(io,'(a)')'   FROMPOS  - The type shall be INTEGER.'
write(io,'(a)')'   LEN   - The type shall be INTEGER.'
write(io,'(a)')'   TO    - The type shall be INTEGER, of the'
write(io,'(a)')'same kind as FROM.'
write(io,'(a)')'   TOPOS  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ibclr]], [[ibset]], [[ibits]],'
write(io,'(a)')'   [[iand]], [[ior]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     nearest(3f) - [INTRINSIC] Nearest representable number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = nearest(x, s)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   nearest(x, s) returns the processor-representable number nearest'
write(io,'(a)')'   to X in the direction indicated by the sign of S.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')'   S  - Shall be of type REAL and not equal to zero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type as X. If S is positive,'
write(io,'(a)')'   NEAREST returns the processor-representable number greater than X'
write(io,'(a)')'   and nearest to it. If S is negative, NEAREST returns the'
write(io,'(a)')'   processor-representable number smaller than X and nearest to it.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_nearest'
write(io,'(a)')'     real :: x, y'
write(io,'(a)')'     x = nearest(42.0, 1.0)'
write(io,'(a)')'     y = nearest(42.0, -1.0)'
write(io,'(a)')'     write (*,"(3(g20.15))") x, y, x - y'
write(io,'(a)')'   end program test_nearest'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     new_line(3f) - [INTRINSIC] New line character'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = new_line(c)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   new_line(c) returns the new-line character.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   C  - The argument shall be a scalar or array of the type CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns a CHARACTER scalar of length one with the new-line character of'
write(io,'(a)')'   the same kind as parameter C.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program newline'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      write(*,''(A)'') ''This is record 1.''//NEW_LINE(''A'')//''This is record 2.'''
write(io,'(a)')'    end program newline'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     nint(3f) - [INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = nint(x [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   nint(x) rounds its argument to the nearest whole number.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type of the argument shall be REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns A with the fractional portion of its magnitude eliminated by'
write(io,'(a)')'   rounding to the nearest whole number and with its sign preserved,'
write(io,'(a)')'   converted to an INTEGER of the default kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_nint'
write(io,'(a)')'      real(4) x4'
write(io,'(a)')'      real(8) x8'
write(io,'(a)')'      x4 = 1.234E0_4'
write(io,'(a)')'      x8 = 4.321_8'
write(io,'(a)')'      print *, nint(x4), idnint(x8)'
write(io,'(a)')'    end program test_nint'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument [[Fortran 90]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ceiling]], [[floor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     norm2(3f) - [INTRINSIC:MATHEMATICS] Euclidean vector norm'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = norm2(array[, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Calculates the Euclidean vector norm (L_2 norm) of ARRAY along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ARRAY  - Shall be an array of type REAL.'
write(io,'(a)')'  DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'  in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the square root of the sum of'
write(io,'(a)')'   squares of the elements of ARRAY is returned. Otherwise, an array of'
write(io,'(a)')'   rank n-1, where "n" equals the rank of ARRAY, and a shape similar'
write(io,'(a)')'   to that of ARRAY with dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_norm2'
write(io,'(a)')'     real :: x(5) = [ real :: 1, 2, 3, 4, 5 ]'
write(io,'(a)')'     print *, norm2(x)  ! = sqrt(55.) ~ 7.416'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[product]], [[sum]], [[hypot]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     not(3f) - [INTRINSIC:BIT MANIPULATION] Logical negation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = not(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   NOT returns the bitwise Boolean inverse of I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the argument.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iand]], [[ior]], [[ieor]], [[ibits]],'
write(io,'(a)')'   [[ibset]], [[ibclr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     null(3f) - [INTRINSIC] Function that returns an disassociated pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    ptr => null([mold])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a disassociated pointer.'
write(io,'(a)')''
write(io,'(a)')'   If MOLD is present, a disassociated pointer of the same type is'
write(io,'(a)')'   returned, otherwise the type is determined by context.'
write(io,'(a)')''
write(io,'(a)')'   In [[Fortran 95]], MOLD is optional. Please note that [[Fortran 2003]]'
write(io,'(a)')'   includes cases where it is required.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MOLD  - (Optional) shall be a pointer of any association'
write(io,'(a)')'           status and of any type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   A disassociated pointer.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    real, pointer, dimension(:) :: vec => null ()'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[associated]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     num_images(3f) - [INTRINSIC] Number of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = num_images(distance, failed)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the number of images.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   DISTANCE  - (optional, intent(in)) Nonnegative scalar integer'
write(io,'(a)')'   FAILED   - (optional, intent(in)) Scalar logical expression'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Scalar default-kind integer. If DISTANCE is not present or has'
write(io,'(a)')'   value 0, the number of images in the current team is returned. For'
write(io,'(a)')'   values smaller or equal distance to the initial team, it returns the'
write(io,'(a)')'   number of images index on the ancestor team which has a distance of'
write(io,'(a)')'   DISTANCE from the invoking team. If DISTANCE is larger than the'
write(io,'(a)')'   distance to the initial team, the number of images of the initial team'
write(io,'(a)')'   is returned. If FAILED is not present the total number of images is'
write(io,'(a)')'   returned; if it has the value .true., the number of failed images is'
write(io,'(a)')'   returned, otherwise, the number of images which do have not the failed'
write(io,'(a)')'   status.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   integer :: value[*]'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   value = this_image()'
write(io,'(a)')'   sync all'
write(io,'(a)')'   if (this_image() == 1) then'
write(io,'(a)')'     do i = 1, num_images()'
write(io,'(a)')'       write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]'
write(io,'(a)')'     end do'
write(io,'(a)')'   end if'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later. With DISTANCE or FAILED argument, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[this_image]], [[image_index]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     pack(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Pack an array into an array of rank one'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = pack(array, mask[,vector])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Stores the elements of ARRAY in an array of rank one.'
write(io,'(a)')''
write(io,'(a)')'   The beginning of the resulting array is made up of elements whose MASK'
write(io,'(a)')'   equals TRUE. Afterwards, positions are filled with elements taken from'
write(io,'(a)')'   VECTOR.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of any type.'
write(io,'(a)')'   MASK  - Shall be an array of type LOGICAL and of the same size'
write(io,'(a)')'           as ARRAY. Alternatively, it may be a LOGICAL scalar.'
write(io,'(a)')'   VECTOR  - (Optional) shall be an array of the same type as ARRAY'
write(io,'(a)')'             and of rank one. If present, the number of elements in VECTOR'
write(io,'(a)')'             shall be equal to or greater than the number of true elements in'
write(io,'(a)')'             MASK. If MASK is scalar, the number of elements in VECTOR'
write(io,'(a)')'             shall be equal to or greater than the number of elements in'
write(io,'(a)')'             ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is an array of rank one and the same type as that of ARRAY.'
write(io,'(a)')'   If VECTOR is present, the result size is that of VECTOR, the'
write(io,'(a)')'   number of TRUE values in MASK otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program gathering nonzero elements from an array:'
write(io,'(a)')''
write(io,'(a)')'    program test_pack_1'
write(io,'(a)')'      integer :: m(6)'
write(io,'(a)')'      m = (/ 1, 0, 0, 0, 5, 0 /)'
write(io,'(a)')'      write(*, fmt="(6(i0, '' ''))") pack(m, m /= 0)  ! "1 5"'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')' Gathering nonzero elements from an array and appending elements from VECTOR:'
write(io,'(a)')''
write(io,'(a)')'    program test_pack_2'
write(io,'(a)')'      integer :: m(4)'
write(io,'(a)')'      m = (/ 1, 0, 0, 2 /)'
write(io,'(a)')'      write(*, fmt="(4(i0, '' ''))") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! "1 2 3 4"'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[unpack]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     parity(3f) - [INTRINSIC] Reduction with exclusive or'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = parity(mask[, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Calculates the parity (i.e. the reduction using .xor.) of MASK along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - Shall be an array of type LOGICAL.'
write(io,'(a)')'   DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'          in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as MASK.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the parity of all elements in MASK'
write(io,'(a)')'   is returned: .true. if an odd number of elements are .true. and'
write(io,'(a)')'   .false. otherwise. If DIM is present, an array of rank n-1,'
write(io,'(a)')'   where "n" equals the rank of MASK, and a shape similar to that of'
write(io,'(a)')'   MASK with dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_parity'
write(io,'(a)')'     logical :: x(2) = [ .true., .false. ]'
write(io,'(a)')'     print *, parity(x) ! T'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Transformational function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     popcnt(3f) - [INTRINSIC:BIT INQUIRY] Number of bits set'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = popcnt(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the number of bits set in the binary representation of an integer.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type ''integer'' and of the default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_population'
write(io,'(a)')'     print *, popcnt(127),       poppar(127)'
write(io,'(a)')'     print *, popcnt(huge(0_4)), poppar(huge(0_4))'
write(io,'(a)')'     print *, popcnt(huge(0_8)), poppar(huge(0_8))'
write(io,'(a)')'   end program test_population'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[poppar]], [[leadz]], [[trailz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     poppar(3f) - [INTRINSIC:BIT INQUIRY] Parity of the number of bits set'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = poppar(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the parity of an integer''s binary representation (i.e., the'
write(io,'(a)')'   parity of the number of bits set).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type ''integer'' and of the default integer kind.'
write(io,'(a)')'   It is equal to 0 if I has an even number of bits set and 1 if an odd'
write(io,'(a)')'   number of bits are set.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_population'
write(io,'(a)')'     print *, popcnt(127),       poppar(127)'
write(io,'(a)')'     print *, popcnt(huge(0_4)), poppar(huge(0_4))'
write(io,'(a)')'     print *, popcnt(huge(0_8)), poppar(huge(0_8))'
write(io,'(a)')'   end program test_population'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[popcnt]], [[leadz]], [[trailz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     precision(3f) - [INTRINSIC] Decimal precision of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = precision(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   precision(x) returns the decimal precision in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program prec_and_range'
write(io,'(a)')'      real(kind=4) :: x(2)'
write(io,'(a)')'      complex(kind=8) :: y'
write(io,'(a)')''
write(io,'(a)')'      print *, precision(x), range(x)'
write(io,'(a)')'      print *, precision(y), range(y)'
write(io,'(a)')'    end program prec_and_range'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[selected_real_kind]], [[range]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     present(3f) - [INTRINSIC] Determine whether an optional dummy argument is specified'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = present(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an optional dummy argument is present.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - May be of any type and may be a pointer, scalar or array'
write(io,'(a)')'        value, or a dummy procedure. It shall be the name of an optional'
write(io,'(a)')'        dummy argument accessible within the current subroutine or'
write(io,'(a)')'        function.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'      Returns either TRUE if the optional argument A is present, or'
write(io,'(a)')'      FALSE otherwise.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'     Sample program:'
write(io,'(a)')''
write(io,'(a)')'       program test_present'
write(io,'(a)')'         write(*,*) f(), f(42)      ! "f t"'
write(io,'(a)')'       contains'
write(io,'(a)')'         logical function f(x)'
write(io,'(a)')'           integer, intent(in), optional :: x'
write(io,'(a)')'           f = present(x)'
write(io,'(a)')'         end function'
write(io,'(a)')'       end program'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   STANDARD'
write(io,'(a)')''
write(io,'(a)')'      [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'   CLASS'
write(io,'(a)')''
write(io,'(a)')'      [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'        product(3f) - [INTRINSIC] Product of array elements'
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   * result = product(array[, mask])'
write(io,'(a)')'   * result = product(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'   DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Multiplies the elements of ARRAY along dimension DIM if'
write(io,'(a)')'   the corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER, REAL or COMPLEX.'
write(io,'(a)')'   DIM    - (Optional) shall be a scalar of type INTEGER with a'
write(io,'(a)')'            value in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')'   MASK   - (Optional) shall be of type LOGICAL'
write(io,'(a)')'            and either be a scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the product of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank n-1, where n equals'
write(io,'(a)')'   the rank of ARRAY, and a shape similar to that of ARRAY with'
write(io,'(a)')'   dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_product'
write(io,'(a)')'      integer :: x(5) = (/ 1, 2, 3, 4 ,5 /)'
write(io,'(a)')'      print *, product(x)                    ! all elements, product = 120'
write(io,'(a)')'      print *, product(x, mask=mod(x, 2)==1) ! odd elements, product = 15'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[sum]], note that an element by element multiplication is done directly using the star character.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     radix(3f) - [INTRINSIC] Base of a model number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = radix(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   radix(x) returns the base of the model representing the entity X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type INTEGER or REAL'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a scalar of type INTEGER and of the default'
write(io,'(a)')'   integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_radix'
write(io,'(a)')'      print *, "The radix for the default integer kind is", radix(0)'
write(io,'(a)')'      print *, "The radix for the default real kind is", radix(0.0)'
write(io,'(a)')'    end program test_radix'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[scale]], [[selected_real_kind]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     random_number(3f) - [INTRINSIC] Pseudo-random number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   random_number(harvest)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a single pseudorandom number or an array of pseudorandom numbers'
write(io,'(a)')'   from the uniform distribution over the range 0 <= x < 1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   HARVEST  - Shall be a scalar or an array of type REAL.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_random_number'
write(io,'(a)')'      real :: r(5,5)'
write(io,'(a)')'      call random_number(r)'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[random_seed]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     random_seed(3f) - [INTRINSIC] Initialize a pseudo-random number sequence'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call random_seed([size, put, get])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Restarts or queries the state of the pseudorandom number generator'
write(io,'(a)')'   used by random_number.'
write(io,'(a)')''
write(io,'(a)')'   If random_seed is called without arguments, it is seeded with random'
write(io,'(a)')'   data retrieved from the operating system.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SIZE  - (Optional) Shall be a scalar and of type default'
write(io,'(a)')'   INTEGER, with intent(out). It specifies the minimum size of the'
write(io,'(a)')'   arrays used with the PUT and GET arguments.'
write(io,'(a)')''
write(io,'(a)')'   PUT  - (Optional) Shall be an array of type default INTEGER and'
write(io,'(a)')'   rank one. It is intent(in) and the size of the array must be'
write(io,'(a)')'   larger than or equal to the number returned by the SIZE argument.'
write(io,'(a)')''
write(io,'(a)')'   GET  - (Optional) Shall be an array of type default INTEGER and'
write(io,'(a)')'   rank one. It is intent(out) and the size of the array must be'
write(io,'(a)')'   larger than or equal to the number returned by the SIZE argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_random_seed'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     integer, allocatable :: seed(:)'
write(io,'(a)')'     integer :: n'
write(io,'(a)')''
write(io,'(a)')'     call random_seed(size = n)'
write(io,'(a)')'     allocate(seed(n))'
write(io,'(a)')'     call random_seed(get=seed)'
write(io,'(a)')'     write (*, *) seed'
write(io,'(a)')'   end program test_random_seed'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[random_number]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     range(3f) - [INTRINSIC] Decimal exponent range of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = range(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   range(x) returns the decimal exponent range in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'See [[precision]] for an example.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[selected_real_kind]], [[precision]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     rank(3f) - [INTRINSIC] Rank of a data object'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = rank(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   rank(a) returns the rank of a scalar or array data object.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - can be of any type'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind. For arrays, their rank is returned; for scalars zero is'
write(io,'(a)')'   returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_rank'
write(io,'(a)')'     integer :: a'
write(io,'(a)')'     real, allocatable :: b(:,:)'
write(io,'(a)')''
write(io,'(a)')'     print *, rank(a), rank(b) ! Prints:  0  2'
write(io,'(a)')'   end program test_rank'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 29113]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     real(3f) - [INTRINSIC:NUMERIC] Convert to real type'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = real(x [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   real(x [, kind]) converts its argument X to a real type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be INTEGER, REAL, or COMPLEX.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'   indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   These functions return a REAL variable or array under'
write(io,'(a)')'   the following rules:'
write(io,'(a)')''
write(io,'(a)')' 1. real(x) is converted to a default real type if X is an integer'
write(io,'(a)')'    or real variable.'
write(io,'(a)')''
write(io,'(a)')' 2. real(x) is converted to a real type with the kind type parameter'
write(io,'(a)')'    of X if X is a complex variable.'
write(io,'(a)')''
write(io,'(a)')' 3. real(x, kind) is converted to a real type with kind type'
write(io,'(a)')'    parameter KIND if X is a complex, integer, or real variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_real'
write(io,'(a)')'     complex :: x = (1.0, 2.0)'
write(io,'(a)')'     print *, real(x), real(x,8)'
write(io,'(a)')'   end program test_real'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dble]], [[float]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     repeat(3f) - [INTRINSIC:CHARACTER] Repeated string concatenation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = repeat(string, ncopies)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Concatenates NCOPIES copies of a string.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - Shall be scalar and of type CHARACTER.'
write(io,'(a)')'   NCOPIES  - Shall be scalar and of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   A new scalar of type CHARACTER built up from NCOPIES copies'
write(io,'(a)')'   of STRING.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_repeat'
write(io,'(a)')'      write(*,*) repeat("x", 5)   ! "xxxxx"'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     reshape(3f) - [INTRINSIC:ARRAY RESHAPE] Function to reshape an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = reshape(source, shape[, pad, order])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reshapes SOURCE to correspond to SHAPE. If necessary,'
write(io,'(a)')'   the new array may be padded with elements from PAD or permuted'
write(io,'(a)')'   as defined by ORDER.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SOURCE  - Shall be an array of any type.'
write(io,'(a)')'   SHAPE  - Shall be of type INTEGER and an array of rank one. Its'
write(io,'(a)')'            values must be positive or zero.'
write(io,'(a)')'   PAD  - (Optional) shall be an array of the same type as SOURCE.'
write(io,'(a)')'   ORDER  - (Optional) shall be of type INTEGER and an array of the'
write(io,'(a)')'            same shape as SHAPE. Its values shall be a permutation of the'
write(io,'(a)')'            numbers from 1 to n, where n is the size of SHAPE. If ORDER is'
write(io,'(a)')'            absent, the natural ordering shall be assumed.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is an array of shape SHAPE with the same type as SOURCE.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_reshape'
write(io,'(a)')'      integer, dimension(4) :: x'
write(io,'(a)')'      write(*,*) shape(x)                       ! prints "4"'
write(io,'(a)')'      write(*,*) shape(reshape(x, (/2, 2/)))    ! prints "2 2"'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shape]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     rrspacing(3f) - [INTRINSIC] Reciprocal of the relative spacing'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = rrspacing(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   rrspacing(x) returns the  reciprocal of the relative spacing of'
write(io,'(a)')'   model numbers near X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The value returned is equal to'
write(io,'(a)')'   abs(fraction(x)) * float(radix(x))**digits(x).'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[spacing]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     same_type_as(3f) - [INTRINSIC] Query dynamic types for equality'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = same_type_as(a, b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Query dynamic types for equality.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - Shall be an object of extensible declared type or unlimited polymorphic.'
write(io,'(a)')'   B  - Shall be an object of extensible declared type or unlimited polymorphic.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a scalar of type default logical. It is true if and'
write(io,'(a)')'   only if the dynamic type of A is the same as the dynamic type of B.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[extends_type_of]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     scale(3f) - [INTRINSIC] Scale a real value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = scale(x, i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   scale(x,i) returns x * radix(x)**i.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type of the argument shall be a REAL.'
write(io,'(a)')'   I  - The type of the argument shall be a INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   Its value is x * radix(x)**i.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_scale'
write(io,'(a)')'      real :: x = 178.1387e-4'
write(io,'(a)')'      integer :: i = 5'
write(io,'(a)')'      print *, scale(x,i), x*radix(x)**i'
write(io,'(a)')'    end program test_scale'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[radix]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     scan(3f) - [INTRINSIC:CHARACTER] Scan a string for the presence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = scan(string, set[, back [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Scans a STRING for any of the characters in a SET'
write(io,'(a)')'   of characters.'
write(io,'(a)')''
write(io,'(a)')'   If BACK is either absent or equals FALSE, this function'
write(io,'(a)')'   returns the position of the leftmost character of STRING that is'
write(io,'(a)')'   in SET. If BACK equals TRUE, the rightmost position'
write(io,'(a)')'   is returned. If no character of SET is found in STRING, the'
write(io,'(a)')'   result is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - Shall be of type CHARACTER.'
write(io,'(a)')'   SET  - Shall be of type CHARACTER.'
write(io,'(a)')'   BACK  - (Optional) shall be of type LOGICAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_scan'
write(io,'(a)')'      write(*,*) scan("fortran", "ao")          ! 2, found ''o'''
write(io,'(a)')'      write(*,*) scan("fortran", "ao", .true.)  ! 6, found ''a'''
write(io,'(a)')'      write(*,*) scan("fortran", "c++")         ! 0, found none'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[verify]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     selected_char_kind(3f) - [INTRINSIC] Choose character kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = selected_char_kind(name)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   selected_char_kind(name) returns the kind value for the character'
write(io,'(a)')'   set named NAME, if a character set with such a name is supported, or'
write(io,'(a)')'   -1 otherwise. Currently, supported character sets include "ASCII"'
write(io,'(a)')''
write(io,'(a)')'   and "DEFAULT", which are equivalent, and "ISO_10646" (Universal'
write(io,'(a)')'   Character Set, UCS-4) which is commonly known as Unicode.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   NAME  - Shall be a scalar and of the default character type.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program character_kind'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     integer, parameter :: ascii = selected_char_kind ("ascii")'
write(io,'(a)')'     integer, parameter :: ucs4  = selected_char_kind (''ISO_10646'')'
write(io,'(a)')''
write(io,'(a)')'     character(kind=ascii, len=26) :: alphabet'
write(io,'(a)')'     character(kind=ucs4,  len=30) :: hello_world'
write(io,'(a)')''
write(io,'(a)')'     alphabet = ascii_"abcdefghijklmnopqrstuvwxyz"'
write(io,'(a)')'     hello_world = ucs4_''Hello World and Ni Hao -- '' &'
write(io,'(a)')'                   // char (int (z''4F60''), ucs4)     &'
write(io,'(a)')'                   // char (int (z''597D''), ucs4)'
write(io,'(a)')''
write(io,'(a)')'     write (*,*) alphabet'
write(io,'(a)')''
write(io,'(a)')'     open (output_unit, encoding=''UTF-8'')'
write(io,'(a)')'     write (*,*) trim (hello_world)'
write(io,'(a)')'   end program character_kind'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     selected_int_kind(3f) - [INTRINSIC] Choose integer kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = selected_int_kind(r)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   selected_int_kind(r) return the kind value of the smallest integer'
write(io,'(a)')'   type that can represent all values ranging from -10**R (exclusive)'
write(io,'(a)')'   to 10**R (exclusive). If there is no integer kind that accommodates'
write(io,'(a)')'   this range, selected_int_kind returns -1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   R  - Shall be a scalar and of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program large_integers'
write(io,'(a)')'     integer,parameter :: k5 = selected_int_kind(5)'
write(io,'(a)')'     integer,parameter :: k15 = selected_int_kind(15)'
write(io,'(a)')'     integer(kind=k5) :: i5'
write(io,'(a)')'     integer(kind=k15) :: i15'
write(io,'(a)')''
write(io,'(a)')'     print *, huge(i5), huge(i15)'
write(io,'(a)')''
write(io,'(a)')'     ! the following inequalities are always true'
write(io,'(a)')'     print *, huge(i5) >= 10_k5**5-1'
write(io,'(a)')'     print *, huge(i15) >= 10_k15**15-1'
write(io,'(a)')'   end program large_integers'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     selected_real_kind(3f) - [INTRINSIC] Choose real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = selected_real_kind([p, r, radix])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   selected_real_kind(p, r, radix) return the kind value of a real data'
write(io,'(a)')'   type with decimal precision of at least P digits, exponent range of'
write(io,'(a)')'   at least R, and with a radix of RADIX.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   P  - (Optional) shall be a scalar and of type INTEGER.'
write(io,'(a)')'   R  - (Optional) shall be a scalar and of type INTEGER.'
write(io,'(a)')'   RADIX  - (Optional) shall be a scalar and of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'   Before [[Fortran 2008]], at least one of the arguments R or P'
write(io,'(a)')'   shall be present; since [[Fortran 2008]], they are assumed to be zero'
write(io,'(a)')'   if absent.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   selected_real_kind returns the value of the kind type parameter of'
write(io,'(a)')'   a real data type with decimal precision of at least P digits, a'
write(io,'(a)')'   decimal exponent range of at least R, and with the requested'
write(io,'(a)')'   RADIX. If the RADIX parameter is absent, real kinds with'
write(io,'(a)')'   any radix can be returned. If more than one real data type meet the'
write(io,'(a)')'   criteria, the kind of the data type with the smallest decimal precision'
write(io,'(a)')'   is returned. If no real data type matches the criteria, the result is'
write(io,'(a)')''
write(io,'(a)')'* -1 if the processor does not support a real data type with a'
write(io,'(a)')'  precision greater than or equal to P, but the R and RADIX'
write(io,'(a)')'  requirements can be fulfilled'
write(io,'(a)')'* -2 if the processor does not support a real type with an exponent'
write(io,'(a)')'  range greater than or equal to R, but P and RADIX are'
write(io,'(a)')'  fulfillable'
write(io,'(a)')'* -3 if RADIX but not P and R requirements are fulfillable'
write(io,'(a)')'* -4 if RADIX and either P or R requirements are fulfillable'
write(io,'(a)')'* -5 if there is no real type with the given RADIX'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program real_kinds'
write(io,'(a)')'     integer,parameter :: p6 = selected_real_kind(6)'
write(io,'(a)')'     integer,parameter :: p10r100 = selected_real_kind(10,100)'
write(io,'(a)')'     integer,parameter :: r400 = selected_real_kind(r=400)'
write(io,'(a)')'     real(kind=p6) :: x'
write(io,'(a)')'     real(kind=p10r100) :: y'
write(io,'(a)')'     real(kind=r400) :: z'
write(io,'(a)')''
write(io,'(a)')'     print *, precision(x), range(x)'
write(io,'(a)')'     print *, precision(y), range(y)'
write(io,'(a)')'     print *, precision(z), range(z)'
write(io,'(a)')'   end program real_kinds'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later; with RADIX [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[precision]], [[range]], [[radix]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     set_exponent(3f) - [INTRINSIC] Set the exponent of the model'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = set_exponent(x, i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   set_exponent(x, i) returns the real number whose fractional part'
write(io,'(a)')'   is that that of X and whose exponent part is I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The real number whose fractional part'
write(io,'(a)')'   is that that of X and whose exponent part if I is returned;'
write(io,'(a)')'   it is fraction(x) * radix(x)**i.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_setexp'
write(io,'(a)')'      real :: x = 178.1387e-4'
write(io,'(a)')'      integer :: i = 17'
write(io,'(a)')'      print *, set_exponent(x, i), fraction(x) * radix(x)**i'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     shape(3f) - [INTRINSIC:ARRAY INQUIRY] Determine the shape of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = shape(source[, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the shape of an array.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  SOURCE  - Shall be an array or scalar of any type. If SOURCE is'
write(io,'(a)')'  a pointer it must be associated and allocatable arrays must be'
write(io,'(a)')'  allocated.'
write(io,'(a)')'  KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   An INTEGER array of rank one with as many elements as SOURCE'
write(io,'(a)')'   has dimensions. The elements of the resulting array correspond to the extend'
write(io,'(a)')'   of SOURCE along the respective dimensions. If SOURCE is a scalar,'
write(io,'(a)')'   the result is the rank one array of size zero. If KIND is absent, the'
write(io,'(a)')'   return value has the default integer kind otherwise the specified kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_shape'
write(io,'(a)')'     integer, dimension(-1:1, -1:2) :: a'
write(io,'(a)')'     write(*,*) shape(a)             ! (/ 3, 4 /)'
write(io,'(a)')'     write(*,*) size(shape(42))      ! (/ /)'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later; with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[reshape]], [[size]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     sign(3f) - [INTRINSIC:NUMERIC] Sign copying function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = sign(a, b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   sign(a,b) returns the value of A with the sign of B.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - Shall be of type INTEGER or REAL'
write(io,'(a)')'   B  - Shall be of the same type and kind as A'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The kind of the return value is that of A and B.'
write(io,'(a)')'   If B >= 0 then the result is abs(a), else'
write(io,'(a)')'   it is -abs(a).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_sign'
write(io,'(a)')'      print *, sign(-12,1)'
write(io,'(a)')'      print *, sign(-12,0)'
write(io,'(a)')'      print *, sign(-12,-1)'
write(io,'(a)')''
write(io,'(a)')'      print *, sign(-12.,1.)'
write(io,'(a)')'      print *, sign(-12.,0.)'
write(io,'(a)')'      print *, sign(-12.,-1.)'
write(io,'(a)')'    end program test_sign'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     sin(3f) - [INTRINSIC:TRIGONOMETRIC] Sine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = sin(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   sin(x) computes the sine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_sin'
write(io,'(a)')'      real :: x = 0.0'
write(io,'(a)')'      x = sin(x)'
write(io,'(a)')'    end program test_sin'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[asin]], [[cos]], [[tan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     sinh(3f) - [INTRINSIC:TRIGONOMETRIC] Hyperbolic sine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = sinh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   sinh(x) computes the hyperbolic sine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_sinh'
write(io,'(a)')'     real(8) :: x = - 1.0_8'
write(io,'(a)')'     x = sinh(x)'
write(io,'(a)')'   end program test_sinh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[asinh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     size(3f) - [INTRINSIC:ARRAY INQUIRY] Determine the size of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = size(array[, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determine the extent of ARRAY along a specified dimension DIM,'
write(io,'(a)')'   or the total number of elements in ARRAY if DIM is absent.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of any type. If ARRAY is a pointer it'
write(io,'(a)')'            must be associated and allocatable arrays must be allocated.'
write(io,'(a)')'   DIM  - (Optional) shall be a scalar of type INTEGER and its'
write(io,'(a)')'          value shall be in the range from 1 to n, where n equals the rank of'
write(io,'(a)')'ARRAY.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_size'
write(io,'(a)')'      write(*,*) size((/ 1, 2 /))    ! 2'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shape]], [[reshape]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     sngl(3f) - [INTRINSIC] Convert double precision real to default real'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = sngl(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   sngl(a) converts the double precision real A'
write(io,'(a)')'   to a default real value. This is an archaic form of REAL'
write(io,'(a)')'   that is specific to one type for A.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be a double precision REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type default REAL.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dble]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     spacing(3f) - [INTRINSIC] Smallest distance between two numbers of a given type'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = spacing(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the distance between the argument X and the nearest'
write(io,'(a)')'   adjacent number of the same type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as the input argument X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_spacing'
write(io,'(a)')'      integer, parameter :: sgl = selected_real_kind(p=6, r=37)'
write(io,'(a)')'      integer, parameter :: dbl = selected_real_kind(p=13, r=200)'
write(io,'(a)')''
write(io,'(a)')'      write(*,*) spacing(1.0_sgl)      ! "1.1920929e-07"          on i686'
write(io,'(a)')'      write(*,*) spacing(1.0_dbl)      ! "2.220446049250313e-016" on i686'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[rrspacing]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     spread(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Add a dimension to an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = spread(source, dim, ncopies)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Replicates a SOURCE array NCOPIES times along a specified'
write(io,'(a)')'   dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SOURCE  - Shall be a scalar or an array of any type and'
write(io,'(a)')'             a rank less than seven.'
write(io,'(a)')'   DIM   - Shall be a scalar of type INTEGER with a'
write(io,'(a)')'           value in the range from 1 to n+1, where n equals the rank of SOURCE.'
write(io,'(a)')'   NCOPIES  - Shall be a scalar of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is an array of the same type as SOURCE and has rank n+1'
write(io,'(a)')'   where n equals the rank of SOURCE.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_spread'
write(io,'(a)')'      integer :: a = 1, b(2) = (/ 1, 2 /)'
write(io,'(a)')'      write(*,*) spread(a, 1, 2)            ! "1 1"'
write(io,'(a)')'      write(*,*) spread(b, 1, 2)            ! "1 1 2 2"'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[unpack]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     sqrt(3f) - [INTRINSIC:MATHEMATICS] Square-root function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = sqrt(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'sqrt(x) computes the square root of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL or COMPLEX. The kind type'
write(io,'(a)')'   parameter is the same as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_sqrt'
write(io,'(a)')'      real(8) :: x = 2.0_8'
write(io,'(a)')'      complex :: z = (1.0, 2.0)'
write(io,'(a)')'      x = sqrt(x)'
write(io,'(a)')'      z = sqrt(z)'
write(io,'(a)')'    end program test_sqrt'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     storage_size(3f) - [INTRINSIC:BIT INQUIRY] Storage size in bits'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = storage_size(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the storage size of argument A in bits.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - Shall be a scalar or array of any type.'
write(io,'(a)')'   KIND  - (Optional) shall be a scalar integer constant expression.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is a scalar integer with the kind type parameter specified'
write(io,'(a)')'   by KIND (or default integer type if KIND is missing). The result'
write(io,'(a)')'   value is the size expressed in bits for an element of an array that'
write(io,'(a)')'   has the dynamic type and type parameters of A.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_sizeof]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     sum(3f) - [INTRINSIC] sum the elements of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')' Calling sequence:'
write(io,'(a)')''
write(io,'(a)')'   result = sum(array[, mask])'
write(io,'(a)')'   result = sum(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Adds the elements of ARRAY along dimension DIM if the'
write(io,'(a)')'   corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   array   - Shall be an array of type INTEGER, REAL or COMPLEX.'
write(io,'(a)')'   dim     - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'                in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')'   mask    - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'                scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If dim(3f) is absent, a scalar with the sum of all elements in ARRAY'
write(io,'(a)')'   is returned. Otherwise, an array of rank n-1, where n equals the rank of'
write(io,'(a)')'   ARRAY, and a shape similar to that of ARRAY with dimension DIM'
write(io,'(a)')'   dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')' Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_sum'
write(io,'(a)')'      integer :: x(5) = (/ 1, 2, 3, 4 ,5 /)'
write(io,'(a)')'      print *, sum(x)                        ! all elements, sum = 15'
write(io,'(a)')'      print *, sum(x, mask=mod(x, 2)==1)     ! odd elements, sum = 9'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   intrinsics'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     system_clock(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Time function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call system_clock([count, count_rate, count_max])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   system_clock lets you measure durations of time with the precision'
write(io,'(a)')'   of the smallest time increment generally available on a system by'
write(io,'(a)')'   returning processor-dependent values based on the current value of the'
write(io,'(a)')'   processor clock. The CLOCK value is incremented by one for each clock'
write(io,'(a)')'   count until the value count_max is reached and is then reset to zero'
write(io,'(a)')'   at the next count. CLOCK therefore is a modulo value that lies in the'
write(io,'(a)')'   range 0 to count_max. count_rate and count_max are assumed constant'
write(io,'(a)')'   (even though CPU rates can vary on a single platform).'
write(io,'(a)')''
write(io,'(a)')'   count_rate is system dependent and can vary depending on the kind of'
write(io,'(a)')'   the arguments.'
write(io,'(a)')''
write(io,'(a)')'   If there is no clock, or querying the clock fails, COUNT is set to'
write(io,'(a)')'   -huge(count), and count_rate and count_max are set to zero.'
write(io,'(a)')''
write(io,'(a)')'   system_clock is typically used to measure short time intervals (system'
write(io,'(a)')'   clocks may be 24-hour clocks or measure processor clock ticks since'
write(io,'(a)')'   boot, for example). It is most often used for measuring or tracking'
write(io,'(a)')'   the time spent in code blocks in lieu of using profiling tools.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  COUNT       - (Optional) shall be a scalar of type INTEGER with'
write(io,'(a)')'                intent(out).'
write(io,'(a)')'  count_rate  - (Optional) shall be a scalar of type INTEGER or REAL'
write(io,'(a)')'                with intent(out).'
write(io,'(a)')'  count_max   - (Optional) shall be a scalar of type INTEGER with'
write(io,'(a)')'                intent(out).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_system_clock'
write(io,'(a)')'     integer :: count, count_rate, count_max'
write(io,'(a)')'     call system_clock(count, count_rate, count_max)'
write(io,'(a)')'     write(*,*) count, count_rate, count_max'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[date_and_time]], [[cpu_time]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     tan(3f) - [INTRINSIC:TRIGONOMETRIC] Tangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = tan(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   tan(x) computes the tangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_tan'
write(io,'(a)')'     real(8) :: x = 0.165_8'
write(io,'(a)')'     x = tan(x)'
write(io,'(a)')'   end program test_tan'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later. For a complex argument, [[Fortran 2008]] or later.'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atan]], [[cos]], [[sin]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     tanh(3f) - [INTRINSIC:TRIGONOMETRIC] Hyperbolic tangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'x = tanh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   tanh(x) computes the hyperbolic tangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X. If X is'
write(io,'(a)')'   complex, the imaginary part of the result is in radians. If X'
write(io,'(a)')'   is REAL, the return value lies in the range'
write(io,'(a)')''
write(io,'(a)')'      -1 <= tanh(x) <= 1.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_tanh'
write(io,'(a)')'     real(8) :: x = 2.1_8'
write(io,'(a)')'     x = tanh(x)'
write(io,'(a)')'   end program test_tanh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atanh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     this_image(3f) - [INTRINSIC] Cosubscript index of this image'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = this_image()'
write(io,'(a)')'   result = this_image(distance)'
write(io,'(a)')'   result = this_image(coarray [, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'Returns the cosubscript for this image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  DISTANCE  - (optional, intent(in)) Nonnegative scalar integer'
write(io,'(a)')'  (not permitted together with COARRAY).'
write(io,'(a)')'  COARRAY  - Coarray of any type (optional; if DIM present,'
write(io,'(a)')'  required).'
write(io,'(a)')'  DIM  - default integer scalar (optional). If present, DIM shall'
write(io,'(a)')'  be between one and the corank of COARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Default integer. If COARRAY is not present, it is scalar; if'
write(io,'(a)')'   DISTANCE is not present or has value 0, its value is the image index'
write(io,'(a)')'   on the invoking image for the current team, for values smaller or'
write(io,'(a)')'   equal distance to the initial team, it returns the image index on the'
write(io,'(a)')'   ancestor team which has a distance of DISTANCE from the invoking'
write(io,'(a)')'   team. If DISTANCE is larger than the distance to the initial team,'
write(io,'(a)')'   the image index of the initial team is returned. Otherwise when the'
write(io,'(a)')'   COARRAY is present, if DIM is not present, a rank-1 array with'
write(io,'(a)')'   corank elements is returned, containing the cosubscripts for COARRAY'
write(io,'(a)')'   specifying the invoking image. If DIM is present, a scalar is'
write(io,'(a)')'   returned, with the value of the DIM element of'
write(io,'(a)')'   this_image(coarray).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   integer :: value[*]'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   value = this_image()'
write(io,'(a)')'   sync all'
write(io,'(a)')'   if (this_image() == 1) then'
write(io,'(a)')'     do i = 1, num_images()'
write(io,'(a)')'       write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]'
write(io,'(a)')'     end do'
write(io,'(a)')'   end if'
write(io,'(a)')''
write(io,'(a)')'   ! Check whether the current image is the initial image'
write(io,'(a)')'   if (this_image(huge(1)) /= this_image())'
write(io,'(a)')'   error stop "something is rotten here"'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later. With DISTANCE argument, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[num_images]], [[image_index]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     tiny(3f) - [INTRINSIC] Smallest positive number of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = tiny(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   tiny(x) returns the smallest positive (non zero) number'
write(io,'(a)')'   in the model of the type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_huge_tiny'
write(io,'(a)')'      print *, huge(0), huge(0.0), huge(0.0d0)'
write(io,'(a)')'      print *, tiny(0.0), tiny(0.0d0)'
write(io,'(a)')'    end program test_huge_tiny'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     trailz(3f) - [INTRINSIC:BIT INQUIRY] Number of trailing zero bits of an integer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = trailz(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  TRAILZ returns the number of trailing zero bits of an integer.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The type of the return value is the default INTEGER.'
write(io,'(a)')'   If all the bits of I are zero, the result value is bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_trailz'
write(io,'(a)')'      write (*,*) trailz(8)  ! prints 3'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bit_size]], [[popcnt]], [[poppar]], [[leadz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     transfer(3f) - [INTRINSIC:BIT MANIPULATION] Transfer bit patterns'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = transfer(source, mold[, size])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Interprets the bitwise representation of SOURCE in memory as if it'
write(io,'(a)')'   is the representation of a variable or array of the same type and type'
write(io,'(a)')'   parameters as MOLD.'
write(io,'(a)')''
write(io,'(a)')'   This is approximately equivalent to the C concept of *casting* one'
write(io,'(a)')'   type to another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SOURCE  - Shall be a scalar or an array of any type.'
write(io,'(a)')'   MOLD  - Shall be a scalar or an array of any type.'
write(io,'(a)')'   SIZE  - (Optional) shall be a scalar of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result has the same type as MOLD, with the bit level'
write(io,'(a)')'   representation of SOURCE. If SIZE is present, the result is'
write(io,'(a)')'   a one-dimensional array of length SIZE. If SIZE is absent'
write(io,'(a)')'   but MOLD is an array (of any size or shape), the result is a one-'
write(io,'(a)')'   dimensional array of the minimum length needed to contain the entirety'
write(io,'(a)')'   of the bitwise representation of SOURCE. If SIZE is absent'
write(io,'(a)')'   and MOLD is a scalar, the result is a scalar.'
write(io,'(a)')''
write(io,'(a)')'   If the bitwise representation of the result is longer than that of'
write(io,'(a)')'   SOURCE, then the leading bits of the result correspond to those of'
write(io,'(a)')'   SOURCE and any trailing bits are filled arbitrarily.'
write(io,'(a)')''
write(io,'(a)')'   When the resulting bit representation does not correspond to a valid'
write(io,'(a)')'   representation of a variable of the same type as MOLD, the results'
write(io,'(a)')'   are undefined, and subsequent operations on the result cannot be'
write(io,'(a)')'   guaranteed to produce sensible behavior. For example, it is possible to'
write(io,'(a)')'   create LOGICAL variables for which VAR and'
write(io,'(a)')'   .not. var both appear to be true.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_transfer'
write(io,'(a)')'      integer :: x = 2143289344'
write(io,'(a)')'      print *, transfer(x, 1.0)    ! prints "nan" on i686'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'COMMENTS'
write(io,'(a)')''
write(io,'(a)')'   [[Joe Krahn]]: Fortran uses **molding** rather than **casting**.'
write(io,'(a)')''
write(io,'(a)')'   Casting, as in C, is an in-place reinterpretation. A cast is a device'
write(io,'(a)')'   that is built around an object to change it''s shape.'
write(io,'(a)')''
write(io,'(a)')'   Fortran TRANSFER reinterprets data out-of-place. It can be considered'
write(io,'(a)')'   **molding** rather than casting. A **mold** is a device that confers a'
write(io,'(a)')'   shape onto an object placed into it.'
write(io,'(a)')''
write(io,'(a)')'   The advantage of molding is that data is always valid in the context'
write(io,'(a)')'   of the variable that holds it. For many cases, a decent compiler should'
write(io,'(a)')'   optimize TRANSFER into a simple assignment.'
write(io,'(a)')''
write(io,'(a)')'   There are disadvantages of this approach. It is problematic to define a'
write(io,'(a)')'   union of data types because you must know the largest data object, which'
write(io,'(a)')'   can vary by compiler or compile options. In many cases, an EQUIVALENCE'
write(io,'(a)')'   would be far more effective, but Fortran Standards committees seem'
write(io,'(a)')'   oblivious to the benefits of EQUIVALENCEs when used sparingly.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 90]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     transpose(3f) - [INTRINSIC:ARRAY MANIPULATION] Transpose an array of rank two'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = transpose(matrix)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Transpose an array of rank two. Element (i, j) of the result has the value'
write(io,'(a)')'   matrix(j, i), for all i, j.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MATRIX  - Shall be an array of any type and have a rank of two.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result has the same type as MATRIX, and has shape'
write(io,'(a)')'   (/ m, n /) if MATRIX has shape (/ n, m /).'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   Fortran 95 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     trim(3f) - [INTRINSIC:CHARACTER] Remove trailing blank characters of a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = trim(string)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Removes trailing blank characters of a string.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - Shall be a scalar of type CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   A scalar of type CHARACTER which length is that of STRING'
write(io,'(a)')'   less the number of trailing blanks.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_trim'
write(io,'(a)')'      character(len=10), parameter :: s = "gfortran  "'
write(io,'(a)')'      write(*,*) len(s), len(trim(s))  ! "10 8", with/without trailing blanks'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[adjustl]], [[adjustr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     ubound(3f) - [INTRINSIC:ARRAY INQUIRY] Upper dimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ubound(array [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the upper bounds of an array, or a single upper bound'
write(io,'(a)')'   along the DIM dimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array, of any type.'
write(io,'(a)')'   DIM  - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'   KIND- (Optional) An INTEGER initialization expression'
write(io,'(a)')'         indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')'   If DIM is absent, the result is an array of the upper bounds of'
write(io,'(a)')'   ARRAY. If DIM is present, the result is a scalar'
write(io,'(a)')'   corresponding to the upper bound of the array along that dimension. If'
write(io,'(a)')'   ARRAY is an expression rather than a whole array or array'
write(io,'(a)')'   structure component, or if it has a zero extent along the relevant'
write(io,'(a)')'   dimension, the upper bound is taken to be the number of elements along'
write(io,'(a)')'   the relevant dimension.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[lbound]], [[lcobound]], [[ucobound]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     ucobound(3f) - [INTRINSIC] Upper codimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ucobound(coarray [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the upper cobounds of a coarray, or a single upper cobound'
write(io,'(a)')'   along the DIM codimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an coarray, of any type.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'   KIND   - (Optional) An INTEGER initialization expression indicating'
write(io,'(a)')'            the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If KIND is'
write(io,'(a)')'   absent, the return value is of default integer kind. If DIM is'
write(io,'(a)')'   absent, the result is an array of the lower cobounds of COARRAY. If'
write(io,'(a)')'   DIM is present, the result is a scalar corresponding to the lower'
write(io,'(a)')'   cobound of the array along that codimension.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[lcobound]], [[lbound]], [[ubound]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     unpack(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Store the elements of a vector in an array of higher rank'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = unpack(vector, mask, field)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Store the elements of VECTOR in an array of higher rank.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   VECTOR  - Shall be an array of any type and rank one. It shall'
write(io,'(a)')'   have at least as many elements as MASK has TRUE values.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL.'
write(io,'(a)')'   FIELD  - Shall be of the same type as VECTOR and have the same'
write(io,'(a)')'   shape as MASK.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The resulting array corresponds to FIELD with TRUE elements'
write(io,'(a)')'   of MASK replaced by values from VECTOR in array element order.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program test_unpack'
write(io,'(a)')'      integer :: vector(2)  = (/1,1/)'
write(io,'(a)')'      logical :: mask(4)  = (/ .true., .false., .false., .true. /)'
write(io,'(a)')'      integer :: field(2,2) = 0, unity(2,2)'
write(io,'(a)')''
write(io,'(a)')'      ! result: unity matrix'
write(io,'(a)')'      unity = unpack(vector, reshape(mask, (/2,2/)), field)'
write(io,'(a)')'    end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   Fortran 95 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[pack]], [[spread]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     verify(3f) - [INTRINSIC:CHARACTER] Scan a string for the absence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = verify(string, set[, back [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Verifies that all the characters in STRING belong to the set of'
write(io,'(a)')'   characters in SET.'
write(io,'(a)')''
write(io,'(a)')'   If BACK is either absent or equals FALSE, this function returns'
write(io,'(a)')'   the position of the leftmost character of STRING that is not in'
write(io,'(a)')'   SET. If BACK equals TRUE, the rightmost position is returned. If'
write(io,'(a)')'   all characters of STRING are found in SET, the result is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  STRING  - Shall be of type CHARACTER.'
write(io,'(a)')'  SET     - Shall be of type CHARACTER.'
write(io,'(a)')'  BACK    - (Optional) shall be of type LOGICAL.'
write(io,'(a)')'  KIND    - (Optional) An INTEGER initialization expression'
write(io,'(a)')'  indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If KIND is'
write(io,'(a)')'   absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')' Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program test_verify'
write(io,'(a)')'     write(*,*) verify("fortran", "ao")           ! 1, found ''f'''
write(io,'(a)')'     write(*,*) verify("fortran", "foo")          ! 3, found ''r'''
write(io,'(a)')'     write(*,*) verify("fortran", "c++")          ! 1, found ''f'''
write(io,'(a)')'     write(*,*) verify("fortran", "c++", .true.)  ! 7, found ''n'''
write(io,'(a)')'     write(*,*) verify("fortran", "fortran")      ! 0'' found none'
write(io,'(a)')'   end program'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[scan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'    DSHIFTL(3f) - [INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DSHIFTL(I, J, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   DSHIFTL(I, J, SHIFT) combines bits of I and J. The rightmost'
write(io,'(a)')'   SHIFT bits of the result are the leftmost SHIFT bits of J, and'
write(io,'(a)')'   the remaining bits are the rightmost bits of I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I       Shall be of type INTEGER.'
write(io,'(a)')'  J       Shall be of type INTEGER, and of the same kind as I.'
write(io,'(a)')'  SHIFT   Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dshiftr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'    DSHIFTR(3f) - [INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DSHIFTL(I, J, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   DSHIFTR(I, J, SHIFT) combines bits of I and J. The leftmost'
write(io,'(a)')'   SHIFT bits of the result are the rightmost SHIFT bits of I, and'
write(io,'(a)')'   the remaining bits are the leftmost bits of J.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I       Shall be of type INTEGER.'
write(io,'(a)')'  J       Shall be of type INTEGER, and of the same kind as I.'
write(io,'(a)')'  SHIFT   Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dshiftl]]'
write(io,'(a)')'NAME'
write(io,'(a)')'    shifta(3f) - [INTRINSIC:BIT MANIPULATION] shift bits right'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = SHIFTA(I, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns a value corresponding to I with all of the bits shifted right'
write(io,'(a)')'   by SHIFT places. If the absolute value of SHIFT is greater than'
write(io,'(a)')'   BIT_SIZE(I), the value is undefined. Bits shifted out from the'
write(io,'(a)')'   right end are lost. The fill is arithmetic: the bits shifted in from'
write(io,'(a)')'   the left end are equal to the leftmost bit, which in two''s complement'
write(io,'(a)')'   representation is the sign bit.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'  I        The type shall be INTEGER.'
write(io,'(a)')'  SHIFT    The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[shiftl]], [[shiftr]]'
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'    shiftl(3f) - [INTRINSIC:BIT MANIPULATION] shift bits left'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = SHIFTL(I, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a value corresponding to I with all of the bits shifted left'
write(io,'(a)')'   by SHIFT places. If the absolute value of SHIFT is greater than'
write(io,'(a)')'   BIT_SIZE(I), the value is undefined. Bits shifted out from the left'
write(io,'(a)')'   end are lost, and bits shifted in from the right end are set to 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I       The type shall be INTEGER.'
write(io,'(a)')'  SHIFT   The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shifta]], [[shiftr]]'
write(io,'(a)')'NAME'
write(io,'(a)')'    shiftr(3f) - [INTRINSIC:BIT MANIPULATION] shift bits right'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = SHIFTR(I, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a value corresponding to I with all of the bits shifted right'
write(io,'(a)')'   by SHIFT places. If the absolute value of SHIFT is greater than'
write(io,'(a)')'   BIT_SIZE(I), the value is undefined. Bits shifted out from the right'
write(io,'(a)')'   end are lost, and bits shifted in from the left end are set to 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   - I - The type shall be INTEGER.'
write(io,'(a)')'   - SHIFT - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shifta]], [[shiftl]]'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES SECTION'
write(io,'(a)')''
write(io,'(a)')' XXXXXXX XXX XXX   XX    XX   XX XXXXXX  XXXXX   XXXXXXX  XXXXX'
write(io,'(a)')'  X    X  X   X     X     X   X   X    X   X      X    X X     X'
write(io,'(a)')'  X        X X      X     XX XX   X    X   X      X      X'
write(io,'(a)')'  X  X     X X     X X    XX XX   X    X   X      X  X   X'
write(io,'(a)')'  XXXX      X      X X    X X X   XXXXX    X      XXXX    XXXXX'
write(io,'(a)')'  X  X     X X    X   X   X X X   X        X      X  X         X'
write(io,'(a)')'  X        X X    XXXXX   X   X   X        X      X            X'
write(io,'(a)')'  X    X  X   X   X   X   X   X   X        X   X  X    X X     X'
write(io,'(a)')' XXXXXXX XXX XXX XXX XXX XXX XXX XXXX    XXXXXXX XXXXXXX  XXXXX'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   data(7f) - [FORTRAN]DATA statement'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   data-stmt is   DATA data-stmt-set [ [ , ] data-stmt-set ] ...'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The DATA statement specifies explicit initialization.'
write(io,'(a)')''
write(io,'(a)')'   If a nonpointer object has default initialization, it shall not appear in a data-stmt-object-list.'
write(io,'(a)')''
write(io,'(a)')'   A variable that appears in a DATA statement and has not been typed previously may appear in a subsequent type'
write(io,'(a)')'   declaration only if that declaration confirms the implicit typing. An array name, array section, or array elemen'
write(io,'(a)')'   that appears in a DATA statement shall have had its array properties established by a previous specification'
write(io,'(a)')'   statement.'
write(io,'(a)')''
write(io,'(a)')'   Except for variables in named common blocks, a named variable has the SAVE attribute if any part of it is'
write(io,'(a)')'   initialized in a DATA statement, and this may be confirmed by explicit specification.'
write(io,'(a)')''
write(io,'(a)')'      R535    data-stmt-set                 is   data-stmt-object-list / data-stmt-value-list /'
write(io,'(a)')''
write(io,'(a)')'      R536    data-stmt-object              is variable'
write(io,'(a)')'                                            or data-implied-do'
write(io,'(a)')''
write(io,'(a)')'      R537    data-implied-do               is   ( data-i-do-object-list , data-i-do-variable ='
write(io,'(a)')'                                                    scalar-int-initialization-expr ,'
write(io,'(a)')'                                                    scalar-int-initialization-expr'
write(io,'(a)')'                                                    [ , scalar-int-initialization-expr ] )'
write(io,'(a)')''
write(io,'(a)')'      R538    data-i-do-object              is array-element'
write(io,'(a)')'                                            or scalar-structure-component'
write(io,'(a)')'                                            or data-implied-do'
write(io,'(a)')''
write(io,'(a)')'      R539    data-i-do-variable            is   do-variable'
write(io,'(a)')''
write(io,'(a)')'      C563    A data-stmt-object or data-i-do-object shall not be a coindexed variable.'
write(io,'(a)')''
write(io,'(a)')'      C564    (R536) In a variable that is a data-stmt-object, each subscript, section subscript, substring startin'
write(io,'(a)')'              and substring ending point shall be an initialization expression.'
write(io,'(a)')''
write(io,'(a)')'      C565    (R536) A variable whose designator appears as a data-stmt-object or a data-i-do-object shall not be a'
write(io,'(a)')'              dummy argument, accessed by use or host association, in a named common block unless the DATA'
write(io,'(a)')'              statement is in a block data program unit, in blank common, a function name, a function result name,'
write(io,'(a)')'              an automatic object, or an allocatable variable.'
write(io,'(a)')''
write(io,'(a)')'      C566    (R536) A data-i-do-object or a variable that appears as a data-stmt-object shall not be an object des'
write(io,'(a)')'              in which a pointer appears other than as the entire rightmost part-ref .'
write(io,'(a)')''
write(io,'(a)')'      C567    (R538) The array-element shall be a variable.'
write(io,'(a)')''
write(io,'(a)')'      C568    (R538) The scalar-structure-component shall be a variable.'
write(io,'(a)')''
write(io,'(a)')'      C569    (R538) The scalar-structure-component shall contain at least one part-ref that contains a subscript-l'
write(io,'(a)')''
write(io,'(a)')'      C570    (R538) In an array-element or scalar-structure-component that is a data-i-do-object, any subscript sh'
write(io,'(a)')'              be an initialization expression, and any primary within that subscript that is a data-i-do-variable s'
write(io,'(a)')'              be a DO variable of this data-implied-do or of a containing data-implied-do.'
write(io,'(a)')''
write(io,'(a)')'      R540     data-stmt-value               is   [ data-stmt-repeat * ] data-stmt-constant'
write(io,'(a)')''
write(io,'(a)')'      R541     data-stmt-repeat              is scalar-int-constant'
write(io,'(a)')'                                             or scalar-int-constant-subobject'
write(io,'(a)')''
write(io,'(a)')'      C571     (R541) The data-stmt-repeat shall be positive or zero. If the data-stmt-repeat is a named constant,'
write(io,'(a)')'               shall have been declared previously in the scoping unit or made accessible by use or host associatio'
write(io,'(a)')''
write(io,'(a)')'      R542     data-stmt-constant            is   scalar-constant'
write(io,'(a)')'                                             or   scalar-constant-subobject'
write(io,'(a)')'                                             or   signed-int-literal-constant'
write(io,'(a)')'                                             or   signed-real-literal-constant'
write(io,'(a)')'                                             or   null-init'
write(io,'(a)')'                                             or   initial-data-target'
write(io,'(a)')'                                             or   structure-constructor'
write(io,'(a)')''
write(io,'(a)')'      C572     (R542) If a DATA statement constant value is a named constant or a structure constructor, the named'
write(io,'(a)')'               constant or derived type shall have been declared previously in the scoping unit or accessed by use'
write(io,'(a)')'               host association.'
write(io,'(a)')''
write(io,'(a)')'      C573     (R542) If a data-stmt-constant is a structure-constructor , it shall be an initialization expression'
write(io,'(a)')''
write(io,'(a)')'      R543     int-constant-subobject        is   constant-subobject'
write(io,'(a)')''
write(io,'(a)')'      C574     (R543) int-constant-subobject shall be of type integer.'
write(io,'(a)')''
write(io,'(a)')'      R544     constant-subobject            is   designator'
write(io,'(a)')''
write(io,'(a)')'      C575     (R544) constant-subobject shall be a subobject of a constant.'
write(io,'(a)')''
write(io,'(a)')'      C576     (R544) Any subscript, substring starting point, or substring ending point shall be an initialization'
write(io,'(a)')''
write(io,'(a)')'   The data-stmt-object-list is expanded to form a sequence of pointers and scalar variables, referred to as "seque'
write(io,'(a)')'   of variables" in subsequent text. A nonpointer array whose unqualified name appears as a data-stmt-object or'
write(io,'(a)')'   data-i-do-object is equivalent to a complete sequence of its array elements in array element order (6.5.3.2). An'
write(io,'(a)')'   array section is equivalent to the sequence of its array elements in array element order. A data-implied-do is'
write(io,'(a)')'   expanded to form a sequence of array elements and structure components, under the control of the data-i-do-'
write(io,'(a)')'   variable, as in the DO construct (8.1.7.6).'
write(io,'(a)')''
write(io,'(a)')'   The data-stmt-value-list is expanded to form a sequence of data-stmt-constants. A data-stmt-repeat indicates the'
write(io,'(a)')'   number of times the following data-stmt-constant is to be included in the sequence; omission of a data-stmt-repe'
write(io,'(a)')'   has the effect of a repeat factor of 1.'
write(io,'(a)')''
write(io,'(a)')'   A zero-sized array or a data-implied-do with an iteration count of zero contributes no variables to the expanded'
write(io,'(a)')'   sequence of variables, but a zero-length scalar character variable does contribute a variable to the expanded'
write(io,'(a)')'   sequence. A data-stmt-constant with a repeat factor of zero contributes no data-stmt-constants to the expanded'
write(io,'(a)')'   sequence of scalar data-stmt-constants.'
write(io,'(a)')''
write(io,'(a)')'   The expanded sequences of variables and data-stmt-constants are in one-to-one correspondence. Each data-stmt-'
write(io,'(a)')'   constant specifies the initial value, initial data target, or null-init for the corresponding variable. The leng'
write(io,'(a)')'   the two expanded sequences shall be the same.'
write(io,'(a)')''
write(io,'(a)')'   A data-stmt-constant shall be null-init or initial-data-target if and only if the corresponding data-stmt-object'
write(io,'(a)')'   the POINTER attribute. If data-stmt-constant is null-init, the initial association status of the corresponding d'
write(io,'(a)')'   statement object is disassociated. If data-stmt-constant is initial-data-target the corresponding data statement'
write(io,'(a)')'   object shall be data-pointer-initialization compatible with the initial data target; the data statement object i'
write(io,'(a)')'   initially associated with the target.'
write(io,'(a)')''
write(io,'(a)')'   A data-stmt-constant other than boz-literal-constant, null-init, or initial-data-target shall be compatible with'
write(io,'(a)')'   corresponding variable according to the rules of intrinsic assignment (7.2.1.2). The variable is initially defin'
write(io,'(a)')'   with the value specified by the data-stmt-constant; if necessary, the value is converted according to the rules'
write(io,'(a)')'   intrinsic assignment (7.2.1.3) to a value that agrees in type, type parameters, and shape with the variable.'
write(io,'(a)')''
write(io,'(a)')'   If a data-stmt-constant is a boz-literal-constant, the corresponding variable shall be of type integer. The boz-'
write(io,'(a)')'   literal-constant is treated as if it were converted by the intrinsic function INT (13.7.81) to type integer with'
write(io,'(a)')'   kind type parameter of the variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')'   Examples of DATA statements are:'
write(io,'(a)')''
write(io,'(a)')'          CHARACTER (LEN = 10) NAME'
write(io,'(a)')'          INTEGER, DIMENSION (0:9) :: MILES'
write(io,'(a)')'          REAL, DIMENSION (100, 100) :: SKEW'
write(io,'(a)')'          TYPE (NODE), POINTER :: HEAD_OF_LIST'
write(io,'(a)')'          TYPE (PERSON) MYNAME, YOURNAME'
write(io,'(a)')'          DATA NAME / ''JOHN DOE'' /, MILES / 10 * 0 /'
write(io,'(a)')'          DATA ((SKEW (K, J), J = 1, K), K = 1, 100) / 5050 * 0.0 /'
write(io,'(a)')'          DATA ((SKEW (K, J), J = K + 1, 100), K = 1, 99) / 4950 * 1.0 /'
write(io,'(a)')'          DATA HEAD_OF_LIST / NULL() /'
write(io,'(a)')'          DATA MYNAME / PERSON (21, ''JOHN SMITH'') /'
write(io,'(a)')'          DATA YOURNAME % AGE, YOURNAME % NAME / 35, ''FRED BROWN'' /'
write(io,'(a)')''
write(io,'(a)')'   The character variable NAME is initialized with the value JOHN DOE with padding on the right because'
write(io,'(a)')'   the length of the constant is less than the length of the variable. All ten elements of the integer array'
write(io,'(a)')'   MILES are initialized to zero. The two-dimensional array SKEW is initialized so that the lower triangle'
write(io,'(a)')'   of SKEW is zero and the strict upper triangle is one. The structures MYNAME and YOURNAME are'
write(io,'(a)')'   declared using the derived type PERSON from Note 4.17. The pointer HEAD OF LIST is declared using'
write(io,'(a)')'   the derived type NODE from Note 4.37; it is initially disassociated. MYNAME is initialized by a structure'
write(io,'(a)')'   constructor. YOURNAME is initialized by supplying a separate value for each component.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   implied_do(7f) - [FORTRAN] documentation on usage of implied do in Fortran'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Examples using implied DO loops in Fortran code.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')' Sample Programs:'
write(io,'(a)')''
write(io,'(a)')'   program initializing'
write(io,'(a)')'   implicit none'
write(io,'(a)')'      integer :: i'
write(io,'(a)')'      ! [A-Z] [a-z] alphabet'
write(io,'(a)')'      character(len=1),parameter :: a2z(26*2)=[(char(i),i=65,90),(char(i),i=97,122)]'
write(io,'(a)')'      write(*,*)''Alphabet='',a2z'
write(io,'(a)')'   end program initializing'
write(io,'(a)')''
write(io,'(a)')' Expected output:'
write(io,'(a)')''
write(io,'(a)')'   Alphabet=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
write(io,'(a)')''
write(io,'(a)')' Examples of array constructors containing an implied DO are:'
write(io,'(a)')''
write(io,'(a)')'   (/ (I, I = 1, 1075) /)'
write(io,'(a)')''
write(io,'(a)')' and'
write(io,'(a)')''
write(io,'(a)')'   N=20'
write(io,'(a)')'   [ 3.6, (3.6 / I, I = 1, N) ]'
write(io,'(a)')''
write(io,'(a)')' For an io-implied-do, the loop initialization and execution are the same as for a DO construct.'
write(io,'(a)')' An example of an output list with an implied DO is:'
write(io,'(a)')''
write(io,'(a)')'   WRITE (LP, FMT = ''(10F8.2)'') (LOG (A (I)), I = 1, N + 9, K), G'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   fortran(7f) - [FORTRAN] Fortran Example'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample'
write(io,'(a)')''
write(io,'(a)')'     program fortran_syntax'
write(io,'(a)')'     contains'
write(io,'(a)')'        subroutine sub1(a,b,c)'
write(io,'(a)')'        integer,intent(in)                     :: a'
write(io,'(a)')'        integer,intent(out)                    :: b'
write(io,'(a)')'        character(len=:),intent(out),optional  :: c'
write(io,'(a)')'        b=2*a'
write(io,'(a)')'        end subroutine sub1'
write(io,'(a)')'     end program fortran_syntax'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   fortran_continuation_line(7f) - [FORTRAN] Fortran Continuation Lines'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'If a statement is too long to fit on a line, it can be continued with'
write(io,'(a)')'the following methods: If a line is ended with an ampersand, &, it will'
write(io,'(a)')'be continued on the next line. Continuation is normally to the first'
write(io,'(a)')'character of the next non-comment line.'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year   &'
write(io,'(a)')'       + Count / 100'
write(io,'(a)')'The above is equivalent to the following'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year  + Count / 100'
write(io,'(a)')''
write(io,'(a)')'Note that & is not part of the statement.'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year   &'
write(io,'(a)')'   !  this is a comment line'
write(io,'(a)')'       + Count / 100'
write(io,'(a)')''
write(io,'(a)')'The above is equivalent to the following, since the comment is ignored'
write(io,'(a)')'by the compiler:'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year  + Count / 100'
write(io,'(a)')''
write(io,'(a)')'If the first non-blank character of the continuation line is &,'
write(io,'(a)')'continuation is to the first character after the &:'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong&'
write(io,'(a)')'        &VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'is equivalent to'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALongVariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'In this case, there should be no spaces between the last character and'
write(io,'(a)')'the & on the first line. For example,'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong   &'
write(io,'(a)')'        &VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'is equivalent to'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong   VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'Note that there are spaces between ThisIsALong and VariableName. In this'
write(io,'(a)')'way, a token (name and number) can be split over two lines. However,'
write(io,'(a)')'this is not recommended'
write(io,'(a)')''
write(io,'(a)')'SPECIFICALLY'
write(io,'(a)')'3.3.2.4     Free form statement continuation'
write(io,'(a)')''
write(io,'(a)')'1. The character "&" is used to indicate that the current statement is'
write(io,'(a)')'   continued on the next line that is not a'
write(io,'(a)')'   comment line. Comment lines cannot be continued; an "&" in a comment'
write(io,'(a)')'   has no effect. Comments may occur within a continued statement. When'
write(io,'(a)')'   used for continuation, the "&" is not part of the statement. No line'
write(io,'(a)')'   shall contain a single "&" as the only nonblank character or as the'
write(io,'(a)')'   only nonblank character before an "!" that initiates a comment.'
write(io,'(a)')''
write(io,'(a)')'2. If a noncharacter context is to be continued, an "&" shall be the last'
write(io,'(a)')'   nonblank character on the line, or the last'
write(io,'(a)')'   nonblank character before an "!". There shall be a later line that is'
write(io,'(a)')'   not a comment; the statement is continued on the next such line. If'
write(io,'(a)')'   the first nonblank character on that line is an "&", the statement'
write(io,'(a)')'   continues at the next character position following that "&"; otherwise,'
write(io,'(a)')'   it continues with the first character position of that line.'
write(io,'(a)')''
write(io,'(a)')'3. If a lexical token is split across the end of a line, the first nonblank'
write(io,'(a)')'   character on the first following noncomment'
write(io,'(a)')'   line shall be an "&" immediately followed by the successive characters'
write(io,'(a)')'   of the split token.'
write(io,'(a)')''
write(io,'(a)')'4. If a character context is to be continued, an "&" shall be the last'
write(io,'(a)')'   nonblank character on the line and shall not be'
write(io,'(a)')'   followed by commentary. There shall be a later line that is not a'
write(io,'(a)')'   comment; an "&" shall be the first nonblank character on the next such'
write(io,'(a)')'   line and the statement continues with the next character following that'
write(io,'(a)')'  "&".'
write(io,'(a)')''
write(io,'(a)')'So this is OK:'
write(io,'(a)')''
write(io,'(a)')'   POINT=[&   ! define a Point <X,Y,Z>'
write(io,'(a)')'   & 10, &    ! the X component'
write(io,'(a)')'   & 20, &    ! the Y component'
write(io,'(a)')'   & 30  ]    ! the Z component'
write(io,'(a)')''
write(io,'(a)')'because you can have comments after the ampersand when it is not a string.'
write(io,'(a)')'But this is not OK:'
write(io,'(a)')''
write(io,'(a)')'   STRING=[''&   ! create a sentence'
write(io,'(a)')'   & This&      ! first word'
write(io,'(a)')'   & is&        ! second word'
write(io,'(a)')'   & sentence&  ! third word'
write(io,'(a)')'   & a'']        ! forth word (a comment here is OK)'
write(io,'(a)')''
write(io,'(a)')'Because when continuing a string you cannot have a comment after the ampersand.'
write(io,'(a)')'This is OK:'
write(io,'(a)')''
write(io,'(a)')'   STRING=[''&'
write(io,'(a)')'   ! create a sentence'
write(io,'(a)')'   & This&'
write(io,'(a)')'   ! first word'
write(io,'(a)')'   & is&'
write(io,'(a)')'   ! second word'
write(io,'(a)')'   & sentence&'
write(io,'(a)')'   ! third word'
write(io,'(a)')'   & a'']        ! forth word (a comment here is OK)'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Long strings:'
write(io,'(a)')''
write(io,'(a)')'   Subroutine LongString()'
write(io,'(a)')''
write(io,'(a)')'   Character (len=200) :: string1, String2'
write(io,'(a)')'   string1 = "A very long string that won''t fit on a single &'
write(io,'(a)')'              &line can be made through proper continuation."'
write(io,'(a)')''
write(io,'(a)')'   string2 = "A very long string that won''t fit on a single " // &'
write(io,'(a)')'             "line can be made through proper continuation."'
write(io,'(a)')'   if (string1 == string2) then'
write(io,'(a)')'     print *, "string1 and 2 are identical!"'
write(io,'(a)')'     print *, "string1 & 2=",string1'
write(io,'(a)')'   else'
write(io,'(a)')'     print *, "string1 and 2 don''t match!"'
write(io,'(a)')'   endif'
write(io,'(a)')''
write(io,'(a)')'   End Subroutine LongString'
write(io,'(a)')''
write(io,'(a)')'.so man7/select.7'
write(io,'(a)')'.so man7/select.7'
write(io,'(a)')'NAME'
write(io,'(a)')'   select(7f) - [FORTRAN:EXECUTION CONTROL] masked array assignment'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'1 The CASE construct selects for execution at most one of its constituent blocks. The selection is based on the'
write(io,'(a)')'  value of an expression.'
write(io,'(a)')''
write(io,'(a)')'  R810      case-construct               is   select-case-stmt'
write(io,'(a)')'                                                   [ case-stmt'
write(io,'(a)')'                                                        block ] ...'
write(io,'(a)')'                                                   end-select-stmt'
write(io,'(a)')''
write(io,'(a)')'  R811      select-case-stmt             is   [ case-construct-name : ] SELECT CASE ( case-expr )'
write(io,'(a)')''
write(io,'(a)')'  R812      case-stmt                    is   CASE case-selector [case-construct-name]'
write(io,'(a)')''
write(io,'(a)')'  R813      end-select-stmt              is   END SELECT [ case-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C809      (R810) If the select-case-stmt of a case-construct specifies'
write(io,'(a)')'            a case-construct-name, the corresponding end-'
write(io,'(a)')'            select-stmt shall specify the same case-construct-name. If'
write(io,'(a)')'            the select-case-stmt of a case-construct does not specify a'
write(io,'(a)')'            case-construct-name, the corresponding end-select-stmt shall'
write(io,'(a)')'            not specify a case-construct- name. If a case-stmt specifies'
write(io,'(a)')'            a case-construct-name, the corresponding select-case-stmt'
write(io,'(a)')'            shall specify the same case-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  R814      case-expr                    is scalar-int-expr'
write(io,'(a)')'                                         or scalar-char-expr'
write(io,'(a)')'                                         or scalar-logical-expr'
write(io,'(a)')''
write(io,'(a)')'  R815      case-selector                is ( case-value-range-list )'
write(io,'(a)')'                                         or DEFAULT'
write(io,'(a)')''
write(io,'(a)')'  C810      (R810) No more than one of the selectors of one of the CASE statements shall be DEFAULT.'
write(io,'(a)')''
write(io,'(a)')'  R816      case-value-range             is   case-value'
write(io,'(a)')'                                         or   case-value :'
write(io,'(a)')'                                         or   : case-value'
write(io,'(a)')'                                         or   case-value : case-value'
write(io,'(a)')''
write(io,'(a)')'  R817      case-value                   is scalar-int-initialization-expr'
write(io,'(a)')'                                         or scalar-char-initialization-expr'
write(io,'(a)')'                                         or scalar-logical-initialization-expr'
write(io,'(a)')''
write(io,'(a)')'  C811      (R810) For a given case-construct, each case-value shall be'
write(io,'(a)')'            of the same type as case-expr . For character'
write(io,'(a)')'            type, the kind type parameters shall be the same; character'
write(io,'(a)')'            length differences are allowed.'
write(io,'(a)')''
write(io,'(a)')'  C812      (R810) A case-value-range using a colon shall not be used'
write(io,'(a)')'            if case-expr is of type logical.'
write(io,'(a)')''
write(io,'(a)')'  C813      (R810) For a given case-construct, there shall be no possible'
write(io,'(a)')'            value of the case-expr that matches more'
write(io,'(a)')'            than one case-value-range.'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  8.1.5      CASE construct'
write(io,'(a)')'  8.1.5.1    Purpose and form of the CASE construct'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'  8.1.5.2     Execution of a CASE construct'
write(io,'(a)')''
write(io,'(a)')'   The execution of the SELECT CASE statement causes the case expression'
write(io,'(a)')'   to be evaluated. The resulting value is called the case index. For a'
write(io,'(a)')'   case value range list, a match occurs if the case index matches any'
write(io,'(a)')'   of the case value ranges in the list. For a case index with a value'
write(io,'(a)')'   of c, a match is determined as follows.'
write(io,'(a)')''
write(io,'(a)')'        1. If the case value range contains a single value v without a colon, a match occurs for type logical if'
write(io,'(a)')'           the expression c .EQV. v is true, and a match occurs for type integer or character if the expression'
write(io,'(a)')'           c == v is true.'
write(io,'(a)')'        2. If the case value range is of the form low : high, a match occurs if the expression low <= c .AND.'
write(io,'(a)')'           c <= high is true.'
write(io,'(a)')'        3. If the case value range is of the form low :, a match occurs if the expression low <= c is true.'
write(io,'(a)')'        4. If the case value range is of the form : high, a match occurs if the expression c <= high is true.'
write(io,'(a)')'        5. If no other selector matches and a DEFAULT selector appears, it matches the case index.'
write(io,'(a)')'        6. If no other selector matches and the DEFAULT selector does not appear, there is no match.'
write(io,'(a)')''
write(io,'(a)')'   The block following the CASE statement containing the matching'
write(io,'(a)')'   selector, if any, is executed. This completes execution of the'
write(io,'(a)')'   construct.'
write(io,'(a)')''
write(io,'(a)')'   It is permissible to branch to an end-select-stmt only from within'
write(io,'(a)')'   its CASE construct.'
write(io,'(a)')''
write(io,'(a)')'  8.1.5.3     Examples of CASE constructs'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.5'
write(io,'(a)')'       An integer signum function:'
write(io,'(a)')''
write(io,'(a)')'       INTEGER FUNCTION SIGNUM (N)'
write(io,'(a)')'       SELECT CASE (N)'
write(io,'(a)')'       CASE (:-1)'
write(io,'(a)')'          SIGNUM = -1'
write(io,'(a)')'       CASE (0)'
write(io,'(a)')'          SIGNUM = 0'
write(io,'(a)')'       CASE (1:)'
write(io,'(a)')'          SIGNUM = 1'
write(io,'(a)')'       END SELECT'
write(io,'(a)')'       END'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.6'
write(io,'(a)')'       A code fragment to check for balanced parentheses:'
write(io,'(a)')''
write(io,'(a)')'       CHARACTER (80) :: LINE'
write(io,'(a)')'          ...'
write(io,'(a)')'       LEVEL = 0'
write(io,'(a)')'       SCAN_LINE: DO I = 1, 80'
write(io,'(a)')'          CHECK_PARENS: SELECT CASE (LINE (I:I))'
write(io,'(a)')'          CASE (''('')'
write(io,'(a)')'             LEVEL = LEVEL + 1'
write(io,'(a)')'          CASE ('')'')'
write(io,'(a)')'             LEVEL = LEVEL - 1'
write(io,'(a)')'             IF (LEVEL < 0) THEN'
write(io,'(a)')'                PRINT *, ''UNEXPECTED RIGHT PARENTHESIS'''
write(io,'(a)')'                EXIT SCAN_LINE'
write(io,'(a)')'             END IF'
write(io,'(a)')'          CASE DEFAULT'
write(io,'(a)')'             ! Ignore all other characters'
write(io,'(a)')'           END SELECT CHECK_PARENS'
write(io,'(a)')'        END DO SCAN_LINE'
write(io,'(a)')'        IF (LEVEL > 0) THEN'
write(io,'(a)')'           PRINT *, ''MISSING RIGHT PARENTHESIS'''
write(io,'(a)')'        END IF'
write(io,'(a)')''
write(io,'(a)')'        NOTE 8.7'
write(io,'(a)')'        The following three fragments are equivalent:'
write(io,'(a)')''
write(io,'(a)')'        IF (SILLY == 1) THEN'
write(io,'(a)')'           CALL THIS'
write(io,'(a)')'        ELSE'
write(io,'(a)')'           CALL THAT'
write(io,'(a)')'        END IF'
write(io,'(a)')'        SELECT CASE (SILLY == 1)'
write(io,'(a)')'        CASE (.TRUE.)'
write(io,'(a)')'           CALL THIS'
write(io,'(a)')'        CASE (.FALSE.)'
write(io,'(a)')'           CALL THAT'
write(io,'(a)')'        END SELECT'
write(io,'(a)')'        SELECT CASE (SILLY)'
write(io,'(a)')'        CASE DEFAULT'
write(io,'(a)')'           CALL THAT'
write(io,'(a)')'        CASE (1)'
write(io,'(a)')'           CALL THIS'
write(io,'(a)')'        END SELECT'
write(io,'(a)')''
write(io,'(a)')'        NOTE 8.8'
write(io,'(a)')'        A code fragment showing several selections of one block:'
write(io,'(a)')''
write(io,'(a)')'        SELECT CASE (N)'
write(io,'(a)')'        CASE (1, 3:5, 8)        ! Selects 1, 3, 4, 5, 8'
write(io,'(a)')'           CALL SUB'
write(io,'(a)')'        CASE DEFAULT'
write(io,'(a)')'           CALL OTHER'
write(io,'(a)')'        END SELECT'
write(io,'(a)')'NAME'
write(io,'(a)')'   where(7f) - [FORTRAN:ASSIGNMENT] masked array assignment'
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'  WHERE statement:'
write(io,'(a)')''
write(io,'(a)')'   WHERE ( mask-expr ) where-assignment-stmt'
write(io,'(a)')''
write(io,'(a)')'  WHERE construct without ELSEWHERE:'
write(io,'(a)')''
write(io,'(a)')'     [where-construct-name:] WHERE ( mask-expr )'
write(io,'(a)')'     ELSEWHERE (mask-expr ) [where-construct-name]'
write(io,'(a)')''
write(io,'(a)')'  WHERE construct with ELSEWHEREs:'
write(io,'(a)')''
write(io,'(a)')'     [where-construct-name:] WHERE ( mask-expr )'
write(io,'(a)')'     [ELSEWHERE (mask-expr )'
write(io,'(a)')'        elemental-statements]'
write(io,'(a)')'     [ELSEWHERE (mask-expr )'
write(io,'(a)')'        elemental-statements]'
write(io,'(a)')'           :'
write(io,'(a)')'     [ELSEWHERE'
write(io,'(a)')'        elemental-statements'
write(io,'(a)')'     ]'
write(io,'(a)')'     END WHERE [where-construct-name]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   A masked array assignment is either a WHERE statement or a WHERE'
write(io,'(a)')'   construct. It is used to mask the evaluation of expressions and'
write(io,'(a)')'   assignment of values in array assignment statements, according to the'
write(io,'(a)')'   value of a logical array expression.'
write(io,'(a)')''
write(io,'(a)')'   where-assignment-stmt that is a defined assignment shall be elemental.'
write(io,'(a)')''
write(io,'(a)')'   A statement that is part of a where-body-construct shall not be a'
write(io,'(a)')'   branch target statement.'
write(io,'(a)')''
write(io,'(a)')'   If a where-construct contains a where-stmt, a masked-elsewhere-stmt, or'
write(io,'(a)')'   another where-construct then each mask-expr within the where-construct'
write(io,'(a)')'   shall have the same shape. In each where-assignment-stmt, the mask-expr'
write(io,'(a)')'   and the variable being defined shall be arrays of the same shape.'
write(io,'(a)')''
write(io,'(a)')'   Examples of a masked array assignment are:'
write(io,'(a)')''
write(io,'(a)')'            WHERE (TEMP > 100.0) TEMP = TEMP - REDUCE_TEMP'
write(io,'(a)')''
write(io,'(a)')'            WHERE (PRESSURE <= 1.0)'
write(io,'(a)')'               PRESSURE = PRESSURE + INC_PRESSURE'
write(io,'(a)')'               TEMP = TEMP - 5.0'
write(io,'(a)')'            ELSEWHERE'
write(io,'(a)')'               RAINING = .TRUE.'
write(io,'(a)')'            ENDWHERE'
write(io,'(a)')''
write(io,'(a)')'   Interpretation of masked array assignments'
write(io,'(a)')''
write(io,'(a)')'   When a WHERE statement or a where-construct-stmt is executed, a control'
write(io,'(a)')'   mask is established. In addition,'
write(io,'(a)')'   when a WHERE construct statement is executed, a pending control'
write(io,'(a)')'   mask is established. If the statement does not appear as part of a'
write(io,'(a)')'   where-body-construct, the mask-expr of the statement is evaluated,'
write(io,'(a)')'   and the control mask is established to be the value of mask-expr . The'
write(io,'(a)')'   pending control mask is established to have the value .NOT. mask- expr'
write(io,'(a)')'   upon execution of a WHERE construct statement that does not appear as'
write(io,'(a)')'   part of a where-body-construct.  The mask-expr is evaluated only once.'
write(io,'(a)')''
write(io,'(a)')'   Each statement in a WHERE construct is executed in sequence.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a masked-elsewhere-stmt, the following actions take place in sequence.'
write(io,'(a)')''
write(io,'(a)')'   1. The control mask mc is established to have the value of the pending control mask.'
write(io,'(a)')'   2. The pending control mask is established to have the value mc .AND. (.NOT. mask-expr ).'
write(io,'(a)')'   3. The control mask mc is established to have the value mc .AND. mask-expr .'
write(io,'(a)')''
write(io,'(a)')'   The mask-expr is evaluated at most once.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of an ELSEWHERE statement, the control mask is'
write(io,'(a)')'   established to have the value of the pending'
write(io,'(a)')'   control mask. No new pending control mask value is established.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of an ENDWHERE statement, the control mask and pending'
write(io,'(a)')'   control mask are established to have the values they had prior to the'
write(io,'(a)')'   execution of the corresponding WHERE construct statement. Following the'
write(io,'(a)')'   execution of a WHERE statement that appears as a where-body-construct,'
write(io,'(a)')'   the control mask is established to have the value it had prior to the'
write(io,'(a)')'   execution of the WHERE statement.'
write(io,'(a)')''
write(io,'(a)')'   The establishment of control masks and the pending control mask'
write(io,'(a)')'   is illustrated with the following example:'
write(io,'(a)')''
write(io,'(a)')'            WHERE(cond1)             ! Statement 1'
write(io,'(a)')'            . . .'
write(io,'(a)')'            ELSEWHERE(cond2)         ! Statement 2'
write(io,'(a)')'            . . .'
write(io,'(a)')'            ELSEWHERE                ! Statement 3'
write(io,'(a)')'            . . .'
write(io,'(a)')'            END WHERE'
write(io,'(a)')''
write(io,'(a)')'   Following execution of statement 1, the control mask has the value'
write(io,'(a)')'   cond1 and the pending control mask has the value .NOT. cond1.'
write(io,'(a)')'   Following execution of statement 2, the control mask has the value'
write(io,'(a)')'   (.NOT. cond1) .AND. cond2 and the pending control mask has the'
write(io,'(a)')'   value (.NOT. cond1) .AND. (.NOT. cond2). Following execution'
write(io,'(a)')'   of statement 3, the control mask has the value (.NOT. cond1)'
write(io,'(a)')'   .AND. (.NOT. cond2). The false condition values are propagated'
write(io,'(a)')'   through the execution of the masked ELSEWHERE statement.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a WHERE construct statement that is part of a'
write(io,'(a)')'   where-body-construct, the pending control mask is established to'
write(io,'(a)')'   have the value mc .AND. (.NOT. mask-expr ). The control mask is then'
write(io,'(a)')'   established to have the value mc .AND. mask-expr. The mask-expr is'
write(io,'(a)')'   evaluated at most once.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a WHERE statement that is part of a'
write(io,'(a)')'   where-body-construct, the control mask is established to have the'
write(io,'(a)')'   value mc .AND. mask-expr. The pending control mask is not altered.'
write(io,'(a)')''
write(io,'(a)')'   If a nonelemental function reference occurs in the expr or variable'
write(io,'(a)')'   of a where-assignment-stmt or in a mask-expr ,'
write(io,'(a)')'   the function is evaluated without any masked control; that is, all of'
write(io,'(a)')'   its argument expressions are fully evaluated and the function is fully'
write(io,'(a)')'   evaluated. If the result is an array and the reference is not within'
write(io,'(a)')'   the argument list of a nonelemental function, elements corresponding'
write(io,'(a)')'   to true values in the control mask are selected for use in evaluating'
write(io,'(a)')'   the expr, variable or mask-expr.'
write(io,'(a)')''
write(io,'(a)')'   If an elemental operation or function reference occurs in the expr'
write(io,'(a)')'   or variable of a where-assignment-stmt or in a'
write(io,'(a)')'   mask-expr , and is not within the argument list of a nonelemental'
write(io,'(a)')'   function reference, the operation is performed or the function is'
write(io,'(a)')'   evaluated only for the elements corresponding to true values of the'
write(io,'(a)')'   control mask.'
write(io,'(a)')''
write(io,'(a)')'   If an array constructor appears in a where-assignment-stmt or in a'
write(io,'(a)')'   mask-expr , the array constructor is evaluated'
write(io,'(a)')'   without any masked control and then the where-assignment-stmt is'
write(io,'(a)')'   executed or the mask-expr is evaluated.'
write(io,'(a)')''
write(io,'(a)')'   When a where-assignment-stmt is executed, the values of expr that'
write(io,'(a)')'   correspond to true values of the control mask'
write(io,'(a)')'   are assigned to the corresponding elements of the variable.'
write(io,'(a)')''
write(io,'(a)')'   The value of the control mask is established by the execution of a'
write(io,'(a)')'   WHERE statement, a WHERE construct'
write(io,'(a)')'   statement, an ELSEWHERE statement, a masked ELSEWHERE statement, or'
write(io,'(a)')'   an ENDWHERE statement.  Subsequent changes to the value of entities'
write(io,'(a)')'   in a mask-expr have no effect on the value of the control mask. The'
write(io,'(a)')'   execution of a function reference in the mask expression of a WHERE'
write(io,'(a)')'   statement is permitted to affect entities in the assignment statement.'
write(io,'(a)')''
write(io,'(a)')'   Examples of function references in masked array assignments are:'
write(io,'(a)')''
write(io,'(a)')'      WHERE (A > 0.0)'
write(io,'(a)')'         A = LOG (A)           ! LOG is invoked only for positive elements.'
write(io,'(a)')'         A = A / SUM (LOG (A)) ! LOG is invoked for all elements'
write(io,'(a)')'                               ! because SUM is transformational.'
write(io,'(a)')'      END WHERE'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample'
write(io,'(a)')''
write(io,'(a)')'   program demo_where'
write(io,'(a)')'   !  Example of WHERE, ELSE WHERE, END WHERE'
write(io,'(a)')'   parameter (nd=10, ndh=nd/2, nduh=nd-ndh-1)'
write(io,'(a)')'   real, dimension(nd):: a=[ (2*j,j=1,nd) ]'
write(io,'(a)')'   real, dimension(nd):: b ! =[ ndh*1.0, 0.0, nduh*2.0 ]'
write(io,'(a)')'   real, dimension(nd):: c ! =[ nd*-77.77 ]'
write(io,'(a)')'   integer iflag(nd)'
write(io,'(a)')'   data b/ndh*1,0.0,nduh*2./,c/nd*-77.77/'
write(io,'(a)')''
write(io,'(a)')'      where (b.ne.0) c=a/b'
write(io,'(a)')''
write(io,'(a)')'      write (*,2000) c(1:nd)'
write(io,'(a)')'   2000 format (''a/b = '',/,(10f7.2))'
write(io,'(a)')'   !'
write(io,'(a)')'   !  The above protects against divide by zero, but doesn''t actually assign'
write(io,'(a)')'   !  values to elements in c when the corresponding element in b is zero'
write(io,'(a)')'   !  The following covers that, and sets a flag when a divide by zero is'
write(io,'(a)')'   !  present'
write(io,'(a)')'   !'
write(io,'(a)')'      where (b(1:nd).ne.0.0)'
write(io,'(a)')'         c=a/b'
write(io,'(a)')'         iflag=0'
write(io,'(a)')'      else where'
write(io,'(a)')'         c=0.0'
write(io,'(a)')'         iflag=1'
write(io,'(a)')'      end where'
write(io,'(a)')''
write(io,'(a)')'      write (*,2000) c(1:nd)'
write(io,'(a)')'      write (*,1000) iflag(1:nd)'
write(io,'(a)')'    1000 format (''iflag= '',/,(10i7))'
write(io,'(a)')'   end program demo_where'
write(io,'(a)')''
write(io,'(a)')'.so man7/do.7'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH DO "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   DO(7f) - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'.nf'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'   MYLOOP: do I_MYLOOP=1,10  ! DO loop'
write(io,'(a)')'      cycle MYLOOP           ! start next pass of loop'
write(io,'(a)')'      exit  MYLOOP           ! go to next statment after corresponding ENDDO'
write(io,'(a)')'   enddo MYLOOP'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'   READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'   DO WHILE (IOS == 0)'
write(io,'(a)')'      IF (X >= 0.) THEN'
write(io,'(a)')'         CALL SUBA (X)'
write(io,'(a)')'         CALL SUBB (X)'
write(io,'(a)')'              ...'
write(io,'(a)')'         CALL SUBZ (X)'
write(io,'(a)')'      ENDIF'
write(io,'(a)')'      READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'   END DO'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  8.1.7     DO construct'
write(io,'(a)')'  8.1.7.1    Purpose and form of the DO construct'
write(io,'(a)')''
write(io,'(a)')'1 The DO construct specifies the repeated execution of a sequence of'
write(io,'(a)')'  executable constructs. Such a repeated sequence is called a loop.'
write(io,'(a)')''
write(io,'(a)')'2 The number of iterations of a loop may be determined at the beginning'
write(io,'(a)')'  of execution of the DO construct, or'
write(io,'(a)')'  may be left indefinite ("DO forever" or DO WHILE). Except in the case'
write(io,'(a)')'  of a DO CONCURRENT construct, the loop can be terminated immediately'
write(io,'(a)')'  (8.1.7.6.4). The current iteration of the loop may be curtailed by'
write(io,'(a)')'  executing a CYCLE statement (8.1.7.6.3).'
write(io,'(a)')''
write(io,'(a)')'3 There are three phases in the execution of a DO construct: initiation'
write(io,'(a)')'  of the loop, execution of the loop range,'
write(io,'(a)')'  and termination of the loop.'
write(io,'(a)')''
write(io,'(a)')'4 The DO CONCURRENT construct is a DO construct whose DO statement'
write(io,'(a)')'  contains the CONCURRENT keyword.'
write(io,'(a)')''
write(io,'(a)')'5 The DO construct may be written in either a block form or a nonblock form.'
write(io,'(a)')''
write(io,'(a)')'  R821      do-construct                     is block-do-construct'
write(io,'(a)')'                                             or nonblock-do-construct'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.2    Form of the block DO construct'
write(io,'(a)')''
write(io,'(a)')'  R822      block-do-construct               is   do-stmt'
write(io,'(a)')'                                                      do-block'
write(io,'(a)')'                                                      end-do'
write(io,'(a)')''
write(io,'(a)')'  R823      do-stmt                          is label-do-stmt'
write(io,'(a)')'                                             or nonlabel-do-stmt'
write(io,'(a)')''
write(io,'(a)')'  R824      label-do-stmt                    is   [ do-construct-name : ] DO label [ loop-control ]'
write(io,'(a)')''
write(io,'(a)')'  R825      nonlabel-do-stmt                 is   [ do-construct-name : ] DO [ loop-control ]'
write(io,'(a)')''
write(io,'(a)')'  R826      loop-control                     is [ , ] do-variable = scalar-int-expr , scalar-int-expr'
write(io,'(a)')'                                                   [ , scalar-int-expr ]'
write(io,'(a)')'                                             or [ , ] WHILE ( scalar-logical-expr )'
write(io,'(a)')'                                             or [ , ] CONCURRENT forall-header'
write(io,'(a)')''
write(io,'(a)')'  R827      do-variable                      is   scalar-int-variable-name'
write(io,'(a)')''
write(io,'(a)')'  C816      (R827) The do-variable shall be a variable of type integer.'
write(io,'(a)')''
write(io,'(a)')'  R828      do-block                         is   block'
write(io,'(a)')''
write(io,'(a)')'  R829      end-do                           is end-do-stmt'
write(io,'(a)')'                                             or continue-stmt'
write(io,'(a)')''
write(io,'(a)')'  R830      end-do-stmt                      is   END DO [ do-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C817      (R822) If the do-stmt of a block-do-construct specifies a'
write(io,'(a)')'            do-construct-name, the corresponding end-do'
write(io,'(a)')'            shall be an end-do-stmt specifying the same'
write(io,'(a)')'            do-construct-name. If the do-stmt of a block-do-construct'
write(io,'(a)')'            does not specify a do-construct-name, the corresponding'
write(io,'(a)')'            end-do shall not specify a do-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  C818      (R822) If the do-stmt is a nonlabel-do-stmt, the corresponding'
write(io,'(a)')'            end-do shall be an end-do-stmt.'
write(io,'(a)')''
write(io,'(a)')'  C819      (R822) If the do-stmt is a label-do-stmt, the corresponding'
write(io,'(a)')'             end-do shall be identified with the same label .'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.3    Form of the nonblock DO construct'
write(io,'(a)')'  R831      nonblock-do-construct            is   action-term-do-construct'
write(io,'(a)')'                                             or   outer-shared-do-construct'
write(io,'(a)')''
write(io,'(a)')'  R832      action-term-do-construct         is   label-do-stmt'
write(io,'(a)')'                                                        do-body'
write(io,'(a)')'                                                        do-term-action-stmt'
write(io,'(a)')''
write(io,'(a)')'  R833      do-body                          is   [ execution-part-construct ] ...'
write(io,'(a)')''
write(io,'(a)')'  R834      do-term-action-stmt              is   action-stmt'
write(io,'(a)')''
write(io,'(a)')'  C820      (R834) A do-term-action-stmt shall not be an allstop-stmt,'
write(io,'(a)')'             arithmetic-if-stmt,'
write(io,'(a)')'             continue-stmt, cycle-stmt, end-function-stmt,'
write(io,'(a)')'             end-mp-subprogram-stmt, end-program-stmt,'
write(io,'(a)')'             end-subroutine-stmt, exit-stmt, goto-stmt, return-stmt,'
write(io,'(a)')'             or stop-stmt.'
write(io,'(a)')''
write(io,'(a)')'    C821      (R831) The do-term-action-stmt shall be identified with'
write(io,'(a)')'              a label and the corresponding'
write(io,'(a)')'              label-do-stmt shall refer to the same label.'
write(io,'(a)')''
write(io,'(a)')'    R835      outer-shared-do-construct          is   label-do-stmt'
write(io,'(a)')'                                                            do-body'
write(io,'(a)')'                                                            shared-term-do-construct'
write(io,'(a)')''
write(io,'(a)')'    R836      shared-term-do-construct           is   outer-shared-do-construct'
write(io,'(a)')'                                                 or   inner-shared-do-construct'
write(io,'(a)')''
write(io,'(a)')'    R837      inner-shared-do-construct          is   label-do-stmt'
write(io,'(a)')'                                                            do-body'
write(io,'(a)')'                                                            do-term-shared-stmt'
write(io,'(a)')''
write(io,'(a)')'    R838      do-term-shared-stmt                is   action-stmt'
write(io,'(a)')''
write(io,'(a)')'    C822      (R838) A do-term-shared-stmt shall not be an allstop-stmt,'
write(io,'(a)')'              arithmetic-if-stmt,'
write(io,'(a)')'              cycle-stmt, end-function-stmt, end-program-stmt,'
write(io,'(a)')'              end-mp-subprogram-stmt, end-subroutine-stmt, exit-stmt,'
write(io,'(a)')'              goto-stmt, return-stmt, or stop-stmt.'
write(io,'(a)')''
write(io,'(a)')'    C823      (R836) The do-term-shared-stmt shall be identified with'
write(io,'(a)')'              a label and all of the label-do-stmts'
write(io,'(a)')'              of the inner-shared-do-construct and'
write(io,'(a)')'              outer-shared-do-construct shall refer to the same label.'
write(io,'(a)')''
write(io,'(a)')'1 The do-term-action-stmt, do-term-shared-stmt, or'
write(io,'(a)')'  shared-term-do-construct following the do-body of a nonblock DO'
write(io,'(a)')'  construct is called the DO termination of that construct.'
write(io,'(a)')''
write(io,'(a)')'2 Within a scoping unit, all DO constructs whose DO statements refer to'
write(io,'(a)')'  the same label are nonblock DO constructs, and share the'
write(io,'(a)')'  statement identified by that label.'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.4      Range of the DO construct'
write(io,'(a)')''
write(io,'(a)')'1 The range of a block DO construct is the do-block , which shall satisfy'
write(io,'(a)')'  the rules for blocks (8.1.2). In particular,'
write(io,'(a)')'  transfer of control to the interior of such a block from outside the'
write(io,'(a)')'  block is prohibited. It is permitted to branch to the end-do of a'
write(io,'(a)')'  block DO construct only from within the range of that DO construct.'
write(io,'(a)')''
write(io,'(a)')'2 The range of a nonblock DO construct consists of the do-body and the'
write(io,'(a)')'  following DO termination. The end of such a range is not'
write(io,'(a)')'  bounded by a particular statement as for the other executable'
write(io,'(a)')'  constructs (e.g., END IF); nevertheless, the range satisfies the rules'
write(io,'(a)')'  for blocks (8.1.2). Transfer of control into the do-body or to the'
write(io,'(a)')'  DO termination from outside the range is prohibited; in particular,'
write(io,'(a)')'  it is permitted to branch to a do-term-shared-stmt only from within'
write(io,'(a)')'  the range of the corresponding inner-shared-do-construct.'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.5      Active and inactive DO constructs'
write(io,'(a)')''
write(io,'(a)')'1 A DO construct is either active or inactive. Initially inactive,'
write(io,'(a)')'  a DO construct becomes active only when its'
write(io,'(a)')'  DO statement is executed.'
write(io,'(a)')''
write(io,'(a)')'2 Once active, the DO construct becomes inactive only when it terminates'
write(io,'(a)')'  (8.1.7.6.4).'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.6      Execution of a DO construct'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.6.1     Loop initiation'
write(io,'(a)')''
write(io,'(a)')'1 When the DO statement is executed, the DO construct becomes active. If loop-control is'
write(io,'(a)')''
write(io,'(a)')'2       [ , ] do-variable = scalar-int-expr 1 , scalar-int-expr 2 [ , scalar-int-expr 3 ]'
write(io,'(a)')''
write(io,'(a)')'3 the following steps are performed in sequence.'
write(io,'(a)')'          1.    The initial parameter m1 , the terminal parameter m2 ,'
write(io,'(a)')'                and the incrementation parameter m3 are'
write(io,'(a)')'                of type integer with the same kind type parameter'
write(io,'(a)')'                as the do-variable. Their values are established by'
write(io,'(a)')'                evaluating scalar-int-expr 1 , scalar-int-expr 2 , and'
write(io,'(a)')'                scalar-int-expr 3 , respectively, including, if nec-'
write(io,'(a)')'                essary, conversion to the kind type parameter of the'
write(io,'(a)')'                do-variable according to the rules for numeric conversion'
write(io,'(a)')'                (Table 7.11). If scalar-int-expr 3 does not appear,'
write(io,'(a)')'                m3 has the value 1. The value of m3'
write(io,'(a)')'                shall not be zero.'
write(io,'(a)')'          2.    The DO variable becomes defined with the value of the initial parameter m1 .'
write(io,'(a)')'          3.    The iteration count is established and is the value of'
write(io,'(a)')'                the expression (m2 - m1 + m3 )/m3 , unless that value is negative,'
write(io,'(a)')'                in which case the iteration count is 0.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 8.11'
write(io,'(a)')'        The iteration count is zero whenever:'
write(io,'(a)')''
write(io,'(a)')'              m1 > m2 and m3 > 0, or'
write(io,'(a)')'              m1 < m2 and m3 < 0.'
write(io,'(a)')''
write(io,'(a)')'4 If loop-control is omitted, no iteration count is calculated. The'
write(io,'(a)')'  effect is as if a large positive iteration count,'
write(io,'(a)')'  impossible to decrement to zero, were established. If loop-control is'
write(io,'(a)')'  [ , ] WHILE (scalar-logical-expr ), the effect is as if loop-control'
write(io,'(a)')'  were omitted and the following statement inserted as the first statement'
write(io,'(a)')'  of the do-block :'
write(io,'(a)')''
write(io,'(a)')'5 IF (.NOT. (scalar- logical-expr )) EXIT'
write(io,'(a)')''
write(io,'(a)')'6 For a DO CONCURRENT construct, the values of the index variables for'
write(io,'(a)')'  the iterations of the construct are'
write(io,'(a)')'  determined by the rules for the index variables of the FORALL construct'
write(io,'(a)')'  (7.2.4.2.2 and 7.2.4.2.3).'
write(io,'(a)')''
write(io,'(a)')'7 An index-name in a DO CONCURRENT construct has a scope of the construct'
write(io,'(a)')'  (16.4). It is a scalar variable'
write(io,'(a)')'  that has the type and type parameters that it would have if it were'
write(io,'(a)')'  the name of a variable in the scoping unit that includes the construct,'
write(io,'(a)')'  and this type shall be integer type; it has no other attributes.'
write(io,'(a)')''
write(io,'(a)')'8 At the completion of the execution of the DO statement, the execution'
write(io,'(a)')'  cycle begins.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.2     The execution cycle'
write(io,'(a)')''
write(io,'(a)')'1 The execution cycle of a DO construct that is not a DO CONCURRENT'
write(io,'(a)')'  construct consists of the following steps performed in sequence'
write(io,'(a)')'  repeatedly until termination.'
write(io,'(a)')''
write(io,'(a)')'          1.    The iteration count, if any, is tested. If it is zero,'
write(io,'(a)')'                the loop terminates and the DO construct becomes'
write(io,'(a)')'                inactive. If loop-control is [ , ] WHILE'
write(io,'(a)')'                (scalar-logical-expr ), the scalar-logical-expr is'
write(io,'(a)')'                evaluated; if the value of this expression is false, the'
write(io,'(a)')'                loop terminates and the DO construct becomes inactive. If,'
write(io,'(a)')'                as a result, all of the DO constructs sharing the'
write(io,'(a)')'                do-term-shared-stmt are inactive, the execution of all'
write(io,'(a)')'                of these constructs is complete. However, if some of the'
write(io,'(a)')'                DO constructs sharing the do-term-shared-stmt are active,'
write(io,'(a)')'                execution continues with step (3) of the execution cycle'
write(io,'(a)')'                of the active DO construct whose DO statement was most'
write(io,'(a)')'                recently executed.'
write(io,'(a)')'          2.    The range of the loop is executed.'
write(io,'(a)')'          3.    The iteration count, if any, is decremented by one. The'
write(io,'(a)')'                DO variable, if any, is incremented by the'
write(io,'(a)')'                value of the incrementation parameter m3 .'
write(io,'(a)')''
write(io,'(a)')'  Except for the incrementation of the DO variable that occurs in step'
write(io,'(a)')'  (3), the DO variable shall neither be redefined'
write(io,'(a)')'  nor become undefined while the DO construct is active.'
write(io,'(a)')''
write(io,'(a)')'  The range of a DO CONCURRENT construct is executed for all of the'
write(io,'(a)')'  active combinations of the index-name'
write(io,'(a)')'  values. Each execution of the range is an iteration. The executions'
write(io,'(a)')'  may occur in any order.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.3     CYCLE statement'
write(io,'(a)')''
write(io,'(a)')'  Execution of the range of the loop may be curtailed by executing a'
write(io,'(a)')'  CYCLE statement from within the range of the loop.'
write(io,'(a)')''
write(io,'(a)')'  R839     cycle-stmt                         is   CYCLE [ do-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C824     (R839) If a do-construct-name appears, the CYCLE statement'
write(io,'(a)')'           shall be within the range of that do-'
write(io,'(a)')'           construct; otherwise, it shall be within the range of at'
write(io,'(a)')'           least one do-construct.'
write(io,'(a)')''
write(io,'(a)')'  C825     (R839) A cycle-stmt shall not appear within the range of a'
write(io,'(a)')'           DO CONCURRENT construct if it belongs to an outer construct.'
write(io,'(a)')''
write(io,'(a)')'2 A CYCLE statement belongs to a particular DO construct. If the CYCLE'
write(io,'(a)')'  statement contains a DO construct name, it belongs to that DO construct;'
write(io,'(a)')'  otherwise, it belongs to the innermost DO construct in which it appears.'
write(io,'(a)')''
write(io,'(a)')'3 Execution of a CYCLE statement that belongs to a DO construct that is'
write(io,'(a)')'  not a DO CONCURRENT construct'
write(io,'(a)')'  causes immediate progression to step (3) of the current execution'
write(io,'(a)')'  cycle of the DO construct to which it belongs.  If this construct is a'
write(io,'(a)')'  nonblock DO construct, the do-term-action-stmt or do-term-shared-stmt'
write(io,'(a)')'  is not executed.'
write(io,'(a)')''
write(io,'(a)')'4 Execution of a CYCLE statement that belongs to a DO CONCURRENT construct'
write(io,'(a)')'  completes execution of that iteration of the construct.'
write(io,'(a)')''
write(io,'(a)')'5 In a block DO construct, a transfer of control to the end-do has the'
write(io,'(a)')'  same effect as execution of a CYCLE statement'
write(io,'(a)')'  belonging to that construct. In a nonblock DO construct, transfer'
write(io,'(a)')'  of control to the do-term-action-stmt or do-term-shared-stmt causes'
write(io,'(a)')'  that statement to be executed.  Unless a further transfer of control'
write(io,'(a)')'  results, step (3) of the current execution cycle of the DO construct'
write(io,'(a)')'  is then executed.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.4    Loop termination'
write(io,'(a)')''
write(io,'(a)')'1 For a DO construct that is not a DO CONCURRENT construct, the loop'
write(io,'(a)')'  terminates, and the DO construct becomes inactive, when any of the'
write(io,'(a)')'  following occurs.'
write(io,'(a)')''
write(io,'(a)')'       The iteration count is determined to be zero or the'
write(io,'(a)')'      scalar-logical-expr is false, when tested during step (1)'
write(io,'(a)')'        of the above execution cycle.'
write(io,'(a)')''
write(io,'(a)')'       An EXIT statement that belongs to the DO construct is executed.'
write(io,'(a)')''
write(io,'(a)')'       An EXIT or CYCLE statement that belongs to an outer construct'
write(io,'(a)')'      and is within the range of the DO'
write(io,'(a)')'        construct is executed.'
write(io,'(a)')''
write(io,'(a)')'       Control is transferred from a statement within the range of a'
write(io,'(a)')'        DO construct to a statement that is neither'
write(io,'(a)')'        the end-do nor within the range of the same DO construct.'
write(io,'(a)')''
write(io,'(a)')'       A RETURN statement within the range of the DO construct is executed.'
write(io,'(a)')''
write(io,'(a)')'2 For a DO CONCURRENT construct, the loop terminates, and the DO construct'
write(io,'(a)')'  becomes inactive when all of the iterations have completed execution.'
write(io,'(a)')''
write(io,'(a)')'3 When a DO construct becomes inactive, the DO variable, if any, of the'
write(io,'(a)')'  DO construct retains its last defined value.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.7     Restrictions on DO CONCURRENT constructs'
write(io,'(a)')''
write(io,'(a)')'  C826      A RETURN statement shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  C827      A branch (8.2) within a DO CONCURRENT construct shall not have a branch target that is outside'
write(io,'(a)')'            the construct.'
write(io,'(a)')''
write(io,'(a)')'  C828      A reference to a nonpure procedure shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  C829      A reference to the procedure IEEE GET FLAG, IEEE SET HALTING MODE, or IEEE GET HALT-'
write(io,'(a)')'            ING MODE from the intrinsic module IEEE EXCEPTIONS, shall not appear within a DO CONCUR-'
write(io,'(a)')'            RENT construct.'
write(io,'(a)')''
write(io,'(a)')'1 The following additional restrictions apply to DO CONCURRENT constructs.'
write(io,'(a)')''
write(io,'(a)')'      A variable that is referenced in an iteration shall either be'
write(io,'(a)')'      previously defined during that iteration, or shall not be defined'
write(io,'(a)')'      or become undefined during any other iteration of the current'
write(io,'(a)')'      execution of the construct. A variable that is defined or becomes'
write(io,'(a)')'      undefined by more than one iteration of the current execution of'
write(io,'(a)')'      the construct becomes undefined when the current execution of'
write(io,'(a)')'      the construct terminates.  A pointer that is referenced in an'
write(io,'(a)')'      iteration either shall be previously pointer associated during'
write(io,'(a)')'      that iteration, or shall not have its pointer association changed'
write(io,'(a)')'      during any iteration. A pointer that has its pointer association'
write(io,'(a)')'      changed in more than one iteration has an association status of'
write(io,'(a)')'      undefined when the construct terminates.'
write(io,'(a)')''
write(io,'(a)')'    An allocatable object that is allocated in more than one iteration'
write(io,'(a)')'     shall be subsequently deallocated during the same iteration in which'
write(io,'(a)')'     it was allocated. An object that is allocated or deallocated in'
write(io,'(a)')'     only one iteration shall not be deallocated, allocated, referenced,'
write(io,'(a)')'     defined, or become undefined in a different iteration.'
write(io,'(a)')'    An input/output statement shall not write data to a file record or'
write(io,'(a)')'     position in one iteration and read from the same record or position'
write(io,'(a)')'     in a different iteration of the same execution of the construct.'
write(io,'(a)')'    Records written by output statements in the loop range to a'
write(io,'(a)')'     sequential access file appear in the file in an indeterminate order.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.12'
write(io,'(a)')'      The restrictions on referencing variables defined in an iteration'
write(io,'(a)')'      of a DO CONCURRENT construct apply to any procedure invoked within'
write(io,'(a)')'      the loop.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.13'
write(io,'(a)')'      The restrictions on the statements in the loop range of a DO'
write(io,'(a)')'      CONCURRENT construct are designed to ensure there are no data'
write(io,'(a)')'      dependencies between iterations of the loop. This permits code'
write(io,'(a)')'      optimizations that might otherwise be difficult or impossible'
write(io,'(a)')'      because they would depend on properties of the program not visible'
write(io,'(a)')'      to the compiler.'
write(io,'(a)')'.fi'
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')'.nf'
write(io,'(a)')'8.1.7.8    Examples of DO constructs'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.14'
write(io,'(a)')'      The following program fragment computes a tensor product of two arrays:'
write(io,'(a)')''
write(io,'(a)')'      DO I = 1, M'
write(io,'(a)')'         DO J = 1, N'
write(io,'(a)')'            C (I, J) = DOT_PRODUCT (A (I, J, :), B(:, I, J))'
write(io,'(a)')'         END DO'
write(io,'(a)')'      END DO'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.15'
write(io,'(a)')'      The following program fragment contains a DO construct that uses the'
write(io,'(a)')'      WHILE form of loop-control . The loop will continue to execute until'
write(io,'(a)')'      an end-of-file or input/output error is encountered, at which point'
write(io,'(a)')'      the DO statement terminates the loop. When a negative value of X'
write(io,'(a)')'      is read, the program skips immediately to the next READ statement,'
write(io,'(a)')'      bypassing most of the range of the loop.'
write(io,'(a)')''
write(io,'(a)')'      READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'      DO WHILE (IOS == 0)'
write(io,'(a)')'         IF (X >= 0.) THEN'
write(io,'(a)')'            CALL SUBA (X)'
write(io,'(a)')'            CALL SUBB (X)'
write(io,'(a)')'                 ...'
write(io,'(a)')'            CALL SUBZ (X)'
write(io,'(a)')'         ENDIF'
write(io,'(a)')'         READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'      END DO'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.16'
write(io,'(a)')'      The following example behaves exactly the same as the one in Note'
write(io,'(a)')'      8.15. However, the READ statement has been moved to the interior'
write(io,'(a)')'      of the range, so that only one READ statement is needed. Also, a'
write(io,'(a)')'      CYCLE statement has been used to avoid an extra level of IF nesting.'
write(io,'(a)')''
write(io,'(a)')'      DO      ! A "DO WHILE + 1/2" loop'
write(io,'(a)')'          READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'          IF (IOS /= 0) EXIT'
write(io,'(a)')'          IF (X < 0.) CYCLE'
write(io,'(a)')'          CALL SUBA (X)'
write(io,'(a)')'          CALL SUBB (X)'
write(io,'(a)')'             . . .'
write(io,'(a)')'          CALL SUBZ (X)'
write(io,'(a)')'       END DO'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.17'
write(io,'(a)')'       The following example represents a case in which the user knows'
write(io,'(a)')'       that there are no repeated values in the index array IND. The DO'
write(io,'(a)')'       CONCURRENT construct makes it easier for the processor to generate'
write(io,'(a)')'       vector gather/scatter code, unroll the loop, or parallelize the'
write(io,'(a)')'       code for this loop, potentially improving performance.'
write(io,'(a)')''
write(io,'(a)')'       INTEGER :: A(N),IND(N)'
write(io,'(a)')''
write(io,'(a)')'       DO CONCURRENT (I=1:M)'
write(io,'(a)')'          A(IND(I)) = I'
write(io,'(a)')'       END DO'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.18'
write(io,'(a)')'       Additional examples of DO constructs are in C.5.3.'
write(io,'(a)')'.fi'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH EXIT "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   EXIT(7f) - [FORTRAN:EXECUTION CONTROL] statement'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'   EXIT [construct-name]'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  The EXIT statement provides one way of terminating a loop, or completing'
write(io,'(a)')'  execution of another construct.'
write(io,'(a)')''
write(io,'(a)')'  If a construct-name appears, the EXIT statement shall be within that'
write(io,'(a)')'  construct; otherwise, it shall be within the range of at least one'
write(io,'(a)')'  do-construct.'
write(io,'(a)')''
write(io,'(a)')'  An EXIT statement belongs to a particular construct. If a construct'
write(io,'(a)')'  name appears, the EXIT statement belongs'
write(io,'(a)')'  to that construct; otherwise, it belongs to the innermost DO construct'
write(io,'(a)')'  in which it appears.'
write(io,'(a)')''
write(io,'(a)')'  An exit-stmt shall not belong to a DO CONCURRENT construct,'
write(io,'(a)')'  nor shall it appear within the range'
write(io,'(a)')'  of a DO CONCURRENT construct if it belongs to a construct'
write(io,'(a)')'  that contains that DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  When an EXIT statement that belongs to a DO construct is executed,'
write(io,'(a)')'  it terminates the loop and'
write(io,'(a)')'  any active loops contained within the terminated loop. When an'
write(io,'(a)')'  EXIT statement that belongs to a non-DO construct is executed, it'
write(io,'(a)')'  terminates any active loops contained within that construct, and'
write(io,'(a)')'  completes execution of that construct.'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'.nf'
write(io,'(a)')'  Samples:'
write(io,'(a)')''
write(io,'(a)')'   do i=1,10'
write(io,'(a)')'      if(i.eq.4)exit ! exit loop'
write(io,'(a)')'   enddo'
write(io,'(a)')''
write(io,'(a)')'   do i=1,10'
write(io,'(a)')'      do j=100,200'
write(io,'(a)')'         if(j.eq.150)exit ! exit inner loop "j"'
write(io,'(a)')'      enddo'
write(io,'(a)')'   enddo'
write(io,'(a)')''
write(io,'(a)')'   OUTER: do i=1,10'
write(io,'(a)')'      INNER: do j=100,200'
write(io,'(a)')'         if(j.eq.150)exit OUTER ! exit named loop'
write(io,'(a)')'      enddo INNER'
write(io,'(a)')'   enddo OUTER'
write(io,'(a)')''
write(io,'(a)')'   MYBLOCK: block'
write(io,'(a)')'      big=.false.'
write(io,'(a)')'      do i=1,100'
write(io,'(a)')'        if(i=40)then'
write(io,'(a)')'          exit MYBLOCK'
write(io,'(a)')'        endif'
write(io,'(a)')'      enddo'
write(io,'(a)')'      big=.true.'
write(io,'(a)')'   endblock MYBLOCK'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH BLOCK "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   BLOCK(7f) - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'.nf'
write(io,'(a)')'  [ block-construct-name : ] BLOCK'
write(io,'(a)')'  [ specification-part ]'
write(io,'(a)')'  END[ ]BLOCK [ block-construct-name ]'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  The BLOCK construct is an executable construct which may contain'
write(io,'(a)')'  declarations, and may be exited using the EXIT statement.'
write(io,'(a)')''
write(io,'(a)')'  The specification-part of a BLOCK construct shall not contain a COMMON,'
write(io,'(a)')'  EQUIVALENCE, IMPLICIT, INTENT, NAMELIST, or OPTIONAL statement.'
write(io,'(a)')''
write(io,'(a)')'  A SAVE statement in a BLOCK construct shall not contain a'
write(io,'(a)')'  common-block-name.'
write(io,'(a)')''
write(io,'(a)')'  Except for the ASYNCHRONOUS and VOLATILE statements, specifications'
write(io,'(a)')'  in a BLOCK construct declare construct entities whose scope is that'
write(io,'(a)')'  of the BLOCK construct.'
write(io,'(a)')''
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  Sample programs:'
write(io,'(a)')''
write(io,'(a)')'.nf'
write(io,'(a)')'   program demo_block'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,parameter :: arr1(*)=[1,2,3,4,5,6,7]'
write(io,'(a)')'   integer,parameter :: arr2(*)=[0,1,2,3,4,5,6,7]'
write(io,'(a)')''
write(io,'(a)')'   call showme(arr1)'
write(io,'(a)')'   call showme(arr2)'
write(io,'(a)')''
write(io,'(a)')'   contains'
write(io,'(a)')''
write(io,'(a)')'   subroutine showme(a)'
write(io,'(a)')'   integer,intent(in) :: a(:)'
write(io,'(a)')'   integer :: i=-100'
write(io,'(a)')''
write(io,'(a)')'   TESTFORZERO: block'
write(io,'(a)')'      integer :: I  ! local block variable'
write(io,'(a)')'      do i=1,size(a)'
write(io,'(a)')'         if(a(i).eq.0) EXIT TESTFORZERO'
write(io,'(a)')'      enddo'
write(io,'(a)')'      write(*,*)''Never found a zero, tried '',i-1,'' times'''
write(io,'(a)')'      return'
write(io,'(a)')'   endblock TESTFORZERO'
write(io,'(a)')''
write(io,'(a)')'   ! note the variable I in the block is local to the block'
write(io,'(a)')'   write(*,*)''found a zero'', '' I='',i'
write(io,'(a)')'   end subroutine showme'
write(io,'(a)')''
write(io,'(a)')'   end program demo_block'
write(io,'(a)')''
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    Never found a zero, tried 7 times'
write(io,'(a)')'    found a zero I= -100'
write(io,'(a)')''
write(io,'(a)')'.fi'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH CONTINUE "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   CONTINUE(7f) - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'   continue'
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  Execution of a CONTINUE statement has no effect.  A CONTINUE statement'
write(io,'(a)')'  is most often used as a labeled line that is used in transfer control'
write(io,'(a)')'  statements to numerically labeled lines such as GOTO. It is often'
write(io,'(a)')'  very confusing to have executable statements on labeled lines; a'
write(io,'(a)')'  CONTINUE statement eliminates the ambiguities that arise in jumping'
write(io,'(a)')'  to an executable line. Preferably no target of a transfer should be an'
write(io,'(a)')'  executable statement, but should be a statement like ENDDO or CONTINUE.'
write(io,'(a)')''
write(io,'(a)')'  CONTINUE was very frequently used as the end of a DO loop; ENDDO'
write(io,'(a)')'  is now the proper way to end a DO loop.'
write(io,'(a)')'.fi'
write(io,'(a)')'.SH EXAMPLE'
write(io,'(a)')'.nf'
write(io,'(a)')'   program demo_continue'
write(io,'(a)')'         I=10'
write(io,'(a)')'         J=5'
write(io,'(a)')'         if(I.lt.5)goto 100'
write(io,'(a)')'         J=3'
write(io,'(a)')'   100   continue'
write(io,'(a)')'         write(*,*)''J='',J'
write(io,'(a)')''
write(io,'(a)')'   end program demo_continue'
write(io,'(a)')'.fi'
end program intrinsics_man_pages
